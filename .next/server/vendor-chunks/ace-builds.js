/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ace-builds";
exports.ids = ["vendor-chunks/ace-builds"];
exports.modules = {

/***/ "(ssr)/./node_modules/ace-builds/src-noconflict/ace.js":
/*!*******************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ace.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/* ***** BEGIN LICENSE BLOCK *****\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**\n * Define a module along with a payload\n * @param module a name for the payload\n * @param payload a function to call with (require, exports, module) params\n */\n\n(function() {\n\nvar ACE_NAMESPACE = \"ace\";\n\nvar global = (function() { return this; })();\nif (!global && typeof window != \"undefined\") global = window; // strict mode\n\n\nif (!ACE_NAMESPACE && typeof requirejs !== \"undefined\")\n    return;\n\n\nvar define = function(module, deps, payload) {\n    if (typeof module !== \"string\") {\n        if (define.original)\n            define.original.apply(this, arguments);\n        else {\n            console.error(\"dropping module because define wasn\\'t a string.\");\n            console.trace();\n        }\n        return;\n    }\n    if (arguments.length == 2)\n        payload = deps;\n    if (!define.modules[module]) {\n        define.payloads[module] = payload;\n        define.modules[module] = null;\n    }\n};\n\ndefine.modules = {};\ndefine.payloads = {};\n\n/**\n * Get at functionality define()ed using the function above\n */\nvar _require = function(parentId, module, callback) {\n    if (typeof module === \"string\") {\n        var payload = lookup(parentId, module);\n        if (payload != undefined) {\n            callback && callback();\n            return payload;\n        }\n    } else if (Object.prototype.toString.call(module) === \"[object Array]\") {\n        var params = [];\n        for (var i = 0, l = module.length; i < l; ++i) {\n            var dep = lookup(parentId, module[i]);\n            if (dep == undefined && require.original)\n                return;\n            params.push(dep);\n        }\n        return callback && callback.apply(null, params) || true;\n    }\n};\n\nvar require = function(module, callback) {\n    var packagedModule = _require(\"\", module, callback);\n    if (packagedModule == undefined && require.original)\n        return require.original.apply(this, arguments);\n    return packagedModule;\n};\n\nvar normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = base + \"/\" + moduleName;\n\n        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    return moduleName;\n};\n\n/**\n * Internal function to lookup moduleNames and resolve them by calling the\n * definition function if needed.\n */\nvar lookup = function(parentId, moduleName) {\n    moduleName = normalizeModule(parentId, moduleName);\n\n    var module = define.modules[moduleName];\n    if (!module) {\n        module = define.payloads[moduleName];\n        if (typeof module === 'function') {\n            var exports = {};\n            var mod = {\n                id: moduleName,\n                uri: '',\n                exports: exports,\n                packaged: true\n            };\n\n            var req = function(module, callback) {\n                return _require(moduleName, module, callback);\n            };\n\n            var returnValue = module(req, exports, mod);\n            exports = returnValue || mod.exports;\n            define.modules[moduleName] = exports;\n            delete define.payloads[moduleName];\n        }\n        module = define.modules[moduleName] = exports || module;\n    }\n    return module;\n};\n\nfunction exportAce(ns) {\n    var root = global;\n    if (ns) {\n        if (!global[ns])\n            global[ns] = {};\n        root = global[ns];\n    }\n\n    if (!root.define || !root.define.packaged) {\n        define.original = root.define;\n        root.define = define;\n        root.define.packaged = true;\n    }\n\n    if (!root.require || !root.require.packaged) {\n        require.original = root.require;\n        root.require = require;\n        root.require.packaged = true;\n    }\n}\n\nexportAce(ACE_NAMESPACE);\n\n})();\n\nace.define(\"ace/lib/es6-shim\",[\"require\",\"exports\",\"module\"], function(require, exports, module){function defineProp(obj, name, val) {\n    Object.defineProperty(obj, name, {\n        value: val,\n        enumerable: false,\n        writable: true,\n        configurable: true\n    });\n}\nif (!String.prototype.startsWith) {\n    defineProp(String.prototype, \"startsWith\", function (searchString, position) {\n        position = position || 0;\n        return this.lastIndexOf(searchString, position) === position;\n    });\n}\nif (!String.prototype.endsWith) {\n    defineProp(String.prototype, \"endsWith\", function (searchString, position) {\n        var subjectString = this;\n        if (position === undefined || position > subjectString.length) {\n            position = subjectString.length;\n        }\n        position -= searchString.length;\n        var lastIndex = subjectString.indexOf(searchString, position);\n        return lastIndex !== -1 && lastIndex === position;\n    });\n}\nif (!String.prototype.repeat) {\n    defineProp(String.prototype, \"repeat\", function (count) {\n        var result = \"\";\n        var string = this;\n        while (count > 0) {\n            if (count & 1)\n                result += string;\n            if ((count >>= 1))\n                string += string;\n        }\n        return result;\n    });\n}\nif (!String.prototype.includes) {\n    defineProp(String.prototype, \"includes\", function (str, position) {\n        return this.indexOf(str, position) != -1;\n    });\n}\nif (!Object.assign) {\n    Object.assign = function (target) {\n        if (target === undefined || target === null) {\n            throw new TypeError(\"Cannot convert undefined or null to object\");\n        }\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                Object.keys(source).forEach(function (key) {\n                    output[key] = source[key];\n                });\n            }\n        }\n        return output;\n    };\n}\nif (!Object.values) {\n    Object.values = function (o) {\n        return Object.keys(o).map(function (k) {\n            return o[k];\n        });\n    };\n}\nif (!Array.prototype.find) {\n    defineProp(Array.prototype, \"find\", function (predicate) {\n        var len = this.length;\n        var thisArg = arguments[1];\n        for (var k = 0; k < len; k++) {\n            var kValue = this[k];\n            if (predicate.call(thisArg, kValue, k, this)) {\n                return kValue;\n            }\n        }\n    });\n}\nif (!Array.prototype.findIndex) {\n    defineProp(Array.prototype, \"findIndex\", function (predicate) {\n        var len = this.length;\n        var thisArg = arguments[1];\n        for (var k = 0; k < len; k++) {\n            var kValue = this[k];\n            if (predicate.call(thisArg, kValue, k, this)) {\n                return k;\n            }\n        }\n    });\n}\nif (!Array.prototype.includes) {\n    defineProp(Array.prototype, \"includes\", function (item, position) {\n        return this.indexOf(item, position) != -1;\n    });\n}\nif (!Array.prototype.fill) {\n    defineProp(Array.prototype, \"fill\", function (value) {\n        var O = this;\n        var len = O.length >>> 0;\n        var start = arguments[1];\n        var relativeStart = start >> 0;\n        var k = relativeStart < 0\n            ? Math.max(len + relativeStart, 0)\n            : Math.min(relativeStart, len);\n        var end = arguments[2];\n        var relativeEnd = end === undefined ? len : end >> 0;\n        var final = relativeEnd < 0\n            ? Math.max(len + relativeEnd, 0)\n            : Math.min(relativeEnd, len);\n        while (k < final) {\n            O[k] = value;\n            k++;\n        }\n        return O;\n    });\n}\nif (!Array.of) {\n    defineProp(Array, \"of\", function () {\n        return Array.prototype.slice.call(arguments);\n    });\n}\n\n});\n\nace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/es6-shim\"], function(require, exports, module){// vim:set ts=4 sts=4 sw=4 st:\n\"use strict\";\nrequire(\"./es6-shim\");\n\n});\n\nace.define(\"ace/lib/deep_copy\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\n\n});\n\nace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\",\"ace/lib/deep_copy\"], function(require, exports, module){\"use strict\";\nexports.last = function (a) {\n    return a[a.length - 1];\n};\nexports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n};\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\nexports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\nexports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else\n            copy[i] = array[i];\n    }\n    return copy;\n};\nexports.deepCopy = require(\"./deep_copy\").deepCopy;\nexports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n};\nexports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n        if (value === array[i]) {\n            array.splice(i, 1);\n        }\n    }\n};\nexports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\nexports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\nexports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n        matches.push({\n            offset: arguments[arguments.length - 2],\n            length: str.length\n        });\n    });\n    return matches;\n};\nexports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var deferred = function (timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n    deferred.cancel = function () {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    deferred.isPending = function () {\n        return timer;\n    };\n    return deferred;\n};\nexports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var _self = function (timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n        this.cancel();\n        fcn();\n    };\n    _self.cancel = function () {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n    _self.isPending = function () {\n        return timer;\n    };\n    return _self;\n};\nexports.supportsLookbehind = function () {\n    try {\n        new RegExp('(?<=.)');\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\nexports.skipEmptyMatch = function (line, last, supportsUnicodeFlag) {\n    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;\n};\n\n});\n\nace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nexports.OS = {\n    LINUX: \"LINUX\",\n    MAC: \"MAC\",\n    WINDOWS: \"WINDOWS\"\n};\nexports.getOS = function () {\n    if (exports.isMac) {\n        return exports.OS.MAC;\n    }\n    else if (exports.isLinux) {\n        return exports.OS.LINUX;\n    }\n    else {\n        return exports.OS.WINDOWS;\n    }\n};\nvar _navigator = typeof navigator == \"object\" ? navigator : {};\nvar os = (/mac|win|linux/i.exec(_navigator.platform) || [\"other\"])[0].toLowerCase();\nvar ua = _navigator.userAgent || \"\";\nvar appName = _navigator.appName || \"\";\nexports.isWin = (os == \"win\");\nexports.isMac = (os == \"mac\");\nexports.isLinux = (os == \"linux\");\nexports.isIE =\n    (appName == \"Microsoft Internet Explorer\" || appName.indexOf(\"MSAppHost\") >= 0)\n        ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/) || [])[1])\n        : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/) || [])[1]); // for ie\nexports.isOldIE = exports.isIE && exports.isIE < 9;\nexports.isGecko = exports.isMozilla = ua.match(/ Gecko\\/\\d+/);\nexports.isOpera = typeof opera == \"object\" && Object.prototype.toString.call(window[\"opera\"]) == \"[object Opera]\";\nexports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\nexports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\nexports.isSafari = parseFloat(ua.split(\" Safari/\")[1]) && !exports.isChrome || undefined;\nexports.isEdge = parseFloat(ua.split(\" Edge/\")[1]) || undefined;\nexports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\nexports.isAndroid = ua.indexOf(\"Android\") >= 0;\nexports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\nexports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window[\"MSStream\"];\nif (exports.isIOS)\n    exports.isMac = true;\nexports.isMobile = exports.isIOS || exports.isAndroid;\n\n});\n\nace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar useragent = require(\"./useragent\");\nvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\nexports.buildDom = function buildDom(arr, parent, refs) {\n    if (typeof arr == \"string\" && arr) {\n        var txt = document.createTextNode(arr);\n        if (parent)\n            parent.appendChild(txt);\n        return txt;\n    }\n    if (!Array.isArray(arr)) {\n        if (arr && arr.appendChild && parent)\n            parent.appendChild(arr);\n        return arr;\n    }\n    if (typeof arr[0] != \"string\" || !arr[0]) {\n        var els = [];\n        for (var i = 0; i < arr.length; i++) {\n            var ch = buildDom(arr[i], parent, refs);\n            ch && els.push(ch);\n        }\n        return els;\n    }\n    var el = document.createElement(arr[0]);\n    var options = arr[1];\n    var childIndex = 1;\n    if (options && typeof options == \"object\" && !Array.isArray(options))\n        childIndex = 2;\n    for (var i = childIndex; i < arr.length; i++)\n        buildDom(arr[i], el, refs);\n    if (childIndex == 2) {\n        Object.keys(options).forEach(function (n) {\n            var val = options[n];\n            if (n === \"class\") {\n                el.className = Array.isArray(val) ? val.join(\" \") : val;\n            }\n            else if (typeof val == \"function\" || n == \"value\" || n[0] == \"$\") {\n                el[n] = val;\n            }\n            else if (n === \"ref\") {\n                if (refs)\n                    refs[val] = el;\n            }\n            else if (n === \"style\") {\n                if (typeof val == \"string\")\n                    el.style.cssText = val;\n            }\n            else if (val != null) {\n                el.setAttribute(n, val);\n            }\n        });\n    }\n    if (parent)\n        parent.appendChild(el);\n    return el;\n};\nexports.getDocumentHead = function (doc) {\n    if (!doc)\n        doc = document;\n    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n};\nexports.createElement = function (tag, ns) {\n    return document.createElementNS ?\n        document.createElementNS(ns || XHTML_NS, tag) :\n        document.createElement(tag);\n};\nexports.removeChildren = function (element) {\n    element.innerHTML = \"\";\n};\nexports.createTextNode = function (textContent, element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createTextNode(textContent);\n};\nexports.createFragment = function (element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createDocumentFragment();\n};\nexports.hasCssClass = function (el, name) {\n    var classes = (el.className + \"\").split(/\\s+/g);\n    return classes.indexOf(name) !== -1;\n};\nexports.addCssClass = function (el, name) {\n    if (!exports.hasCssClass(el, name)) {\n        el.className += \" \" + name;\n    }\n};\nexports.removeCssClass = function (el, name) {\n    var classes = el.className.split(/\\s+/g);\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        classes.splice(index, 1);\n    }\n    el.className = classes.join(\" \");\n};\nexports.toggleCssClass = function (el, name) {\n    var classes = el.className.split(/\\s+/g), add = true;\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        add = false;\n        classes.splice(index, 1);\n    }\n    if (add)\n        classes.push(name);\n    el.className = classes.join(\" \");\n    return add;\n};\nexports.setCssClass = function (node, className, include) {\n    if (include) {\n        exports.addCssClass(node, className);\n    }\n    else {\n        exports.removeCssClass(node, className);\n    }\n};\nexports.hasCssString = function (id, doc) {\n    var index = 0, sheets;\n    doc = doc || document;\n    if ((sheets = doc.querySelectorAll(\"style\"))) {\n        while (index < sheets.length) {\n            if (sheets[index++].id === id) {\n                return true;\n            }\n        }\n    }\n};\nexports.removeElementById = function (id, doc) {\n    doc = doc || document;\n    if (doc.getElementById(id)) {\n        doc.getElementById(id).remove();\n    }\n};\nvar strictCSP;\nvar cssCache = [];\nexports.useStrictCSP = function (value) {\n    strictCSP = value;\n    if (value == false)\n        insertPendingStyles();\n    else if (!cssCache)\n        cssCache = [];\n};\nfunction insertPendingStyles() {\n    var cache = cssCache;\n    cssCache = null;\n    cache && cache.forEach(function (item) {\n        importCssString(item[0], item[1]);\n    });\n}\nfunction importCssString(cssText, id, target) {\n    if (typeof document == \"undefined\")\n        return;\n    if (cssCache) {\n        if (target) {\n            insertPendingStyles();\n        }\n        else if (target === false) {\n            return cssCache.push([cssText, id]);\n        }\n    }\n    if (strictCSP)\n        return;\n    var container = target;\n    if (!target || !target.getRootNode) {\n        container = document;\n    }\n    else {\n        container = target.getRootNode();\n        if (!container || container == target)\n            container = document;\n    }\n    var doc = container.ownerDocument || container;\n    if (id && exports.hasCssString(id, container))\n        return null;\n    if (id)\n        cssText += \"\\n/*# sourceURL=ace/css/\" + id + \" */\";\n    var style = exports.createElement(\"style\");\n    style.appendChild(doc.createTextNode(cssText));\n    if (id)\n        style.id = id;\n    if (container == doc)\n        container = exports.getDocumentHead(doc);\n    container.insertBefore(style, container.firstChild);\n}\nexports.importCssString = importCssString;\nexports.importCssStylsheet = function (uri, doc) {\n    exports.buildDom([\"link\", { rel: \"stylesheet\", href: uri }], exports.getDocumentHead(doc));\n};\nexports.scrollbarWidth = function (doc) {\n    var inner = exports.createElement(\"ace_inner\");\n    inner.style.width = \"100%\";\n    inner.style.minWidth = \"0px\";\n    inner.style.height = \"200px\";\n    inner.style.display = \"block\";\n    var outer = exports.createElement(\"ace_outer\");\n    var style = outer.style;\n    style.position = \"absolute\";\n    style.left = \"-10000px\";\n    style.overflow = \"hidden\";\n    style.width = \"200px\";\n    style.minWidth = \"0px\";\n    style.height = \"150px\";\n    style.display = \"block\";\n    outer.appendChild(inner);\n    var body = (doc && doc.documentElement) || (document && document.documentElement);\n    if (!body)\n        return 0;\n    body.appendChild(outer);\n    var noScrollbar = inner.offsetWidth;\n    style.overflow = \"scroll\";\n    var withScrollbar = inner.offsetWidth;\n    if (noScrollbar === withScrollbar) {\n        withScrollbar = outer.clientWidth;\n    }\n    body.removeChild(outer);\n    return noScrollbar - withScrollbar;\n};\nexports.computedStyle = function (element, style) {\n    return window.getComputedStyle(element, \"\") || {};\n};\nexports.setStyle = function (styles, property, value) {\n    if (styles[property] !== value) {\n        styles[property] = value;\n    }\n};\nexports.HAS_CSS_ANIMATION = false;\nexports.HAS_CSS_TRANSFORMS = false;\nexports.HI_DPI = useragent.isWin\n    ? typeof window !== \"undefined\" && window.devicePixelRatio >= 1.5\n    : true;\nif (useragent.isChromeOS)\n    exports.HI_DPI = false;\nif (typeof document !== \"undefined\") {\n    var div = document.createElement(\"div\");\n    if (exports.HI_DPI && div.style.transform !== undefined)\n        exports.HAS_CSS_TRANSFORMS = true;\n    if (!useragent.isEdge && typeof div.style.animationName !== \"undefined\")\n        exports.HAS_CSS_ANIMATION = true;\n    div = null;\n}\nif (exports.HAS_CSS_TRANSFORMS) {\n    exports.translate = function (element, tx, ty) {\n        element.style.transform = \"translate(\" + Math.round(tx) + \"px, \" + Math.round(ty) + \"px)\";\n    };\n}\nelse {\n    exports.translate = function (element, tx, ty) {\n        element.style.top = Math.round(ty) + \"px\";\n        element.style.left = Math.round(tx) + \"px\";\n    };\n}\n\n});\n\nace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){/*\n * based on code from:\n *\n * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\"use strict\";\nvar dom = require(\"./dom\");\nexports.get = function (url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            callback(xhr.responseText);\n        }\n    };\n    xhr.send(null);\n};\nexports.loadScript = function (path, callback) {\n    var head = dom.getDocumentHead();\n    var s = document.createElement('script');\n    s.src = path;\n    head.appendChild(s);\n    s.onload = s.onreadystatechange = function (_, isAbort) {\n        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n            s = s.onload = s.onreadystatechange = null;\n            if (!isAbort)\n                callback();\n        }\n    };\n};\nexports.qualifyURL = function (url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.href;\n};\n\n});\n\nace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nexports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\nexports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\nexports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar EventEmitter = {};\nvar stopPropagation = function () { this.propagationStopped = true; };\nvar preventDefault = function () { this.defaultPrevented = true; };\nEventEmitter._emit =\n    EventEmitter._dispatchEvent = function (eventName, e) {\n        this._eventRegistry || (this._eventRegistry = {});\n        this._defaultHandlers || (this._defaultHandlers = {});\n        var listeners = this._eventRegistry[eventName] || [];\n        var defaultHandler = this._defaultHandlers[eventName];\n        if (!listeners.length && !defaultHandler)\n            return;\n        if (typeof e != \"object\" || !e)\n            e = {};\n        if (!e.type)\n            e.type = eventName;\n        if (!e.stopPropagation)\n            e.stopPropagation = stopPropagation;\n        if (!e.preventDefault)\n            e.preventDefault = preventDefault;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++) {\n            listeners[i](e, this);\n            if (e.propagationStopped)\n                break;\n        }\n        if (defaultHandler && !e.defaultPrevented)\n            return defaultHandler(e, this);\n    };\nEventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++)\n        listeners[i](e, this);\n};\nEventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n        _self.off(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function (resolve) {\n            callback = resolve;\n        });\n    }\n};\nEventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = { _disabled_: {} };\n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    }\n    else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\nEventEmitter.on =\n    EventEmitter.addEventListener = function (eventName, callback, capturing) {\n        this._eventRegistry = this._eventRegistry || {};\n        var listeners = this._eventRegistry[eventName];\n        if (!listeners)\n            listeners = this._eventRegistry[eventName] = [];\n        if (listeners.indexOf(callback) == -1)\n            listeners[capturing ? \"unshift\" : \"push\"](callback);\n        return callback;\n    };\nEventEmitter.off =\n    EventEmitter.removeListener =\n        EventEmitter.removeEventListener = function (eventName, callback) {\n            this._eventRegistry = this._eventRegistry || {};\n            var listeners = this._eventRegistry[eventName];\n            if (!listeners)\n                return;\n            var index = listeners.indexOf(callback);\n            if (index !== -1)\n                listeners.splice(index, 1);\n        };\nEventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName)\n        this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry)\n        this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers)\n        this._defaultHandlers[eventName] = undefined;\n};\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/lib/report_error\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.reportError = function reportError(msg, data) {\n    var e = new Error(msg);\n    e[\"data\"] = data;\n    if (typeof console == \"object\" && console.error)\n        console.error(e);\n    setTimeout(function () { throw e; });\n};\n\n});\n\nace.define(\"ace/lib/default_english_messages\",[\"require\",\"exports\",\"module\"], function(require, exports, module){var defaultEnglishMessages = {\n    \"autocomplete.popup.aria-roledescription\": \"Autocomplete suggestions\",\n    \"autocomplete.popup.aria-label\": \"Autocomplete suggestions\",\n    \"autocomplete.popup.item.aria-roledescription\": \"item\",\n    \"autocomplete.loading\": \"Loading...\",\n    \"editor.scroller.aria-roledescription\": \"editor\",\n    \"editor.scroller.aria-label\": \"Editor content, press Enter to start editing, press Escape to exit\",\n    \"editor.gutter.aria-roledescription\": \"editor gutter\",\n    \"editor.gutter.aria-label\": \"Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit\",\n    \"error-marker.good-state\": \"Looks good!\",\n    \"prompt.recently-used\": \"Recently used\",\n    \"prompt.other-commands\": \"Other commands\",\n    \"prompt.no-matching-commands\": \"No matching commands\",\n    \"search-box.find.placeholder\": \"Search for\",\n    \"search-box.find-all.text\": \"All\",\n    \"search-box.replace.placeholder\": \"Replace with\",\n    \"search-box.replace-next.text\": \"Replace\",\n    \"search-box.replace-all.text\": \"All\",\n    \"search-box.toggle-replace.title\": \"Toggle Replace mode\",\n    \"search-box.toggle-regexp.title\": \"RegExp Search\",\n    \"search-box.toggle-case.title\": \"CaseSensitive Search\",\n    \"search-box.toggle-whole-word.title\": \"Whole Word Search\",\n    \"search-box.toggle-in-selection.title\": \"Search In Selection\",\n    \"search-box.search-counter\": \"$0 of $1\",\n    \"text-input.aria-roledescription\": \"editor\",\n    \"text-input.aria-label\": \"Cursor at row $0\",\n    \"gutter.code-folding.range.aria-label\": \"Toggle code folding, rows $0 through $1\",\n    \"gutter.code-folding.closed.aria-label\": \"Toggle code folding, rows $0 through $1\",\n    \"gutter.code-folding.open.aria-label\": \"Toggle code folding, row $0\",\n    \"gutter.code-folding.closed.title\": \"Unfold code\",\n    \"gutter.code-folding.open.title\": \"Fold code\",\n    \"gutter.annotation.aria-label.error\": \"Error, read annotations row $0\",\n    \"gutter.annotation.aria-label.warning\": \"Warning, read annotations row $0\",\n    \"gutter.annotation.aria-label.info\": \"Info, read annotations row $0\",\n    \"inline-fold.closed.title\": \"Unfold code\",\n    \"gutter-tooltip.aria-label.error.singular\": \"error\",\n    \"gutter-tooltip.aria-label.error.plural\": \"errors\",\n    \"gutter-tooltip.aria-label.warning.singular\": \"warning\",\n    \"gutter-tooltip.aria-label.warning.plural\": \"warnings\",\n    \"gutter-tooltip.aria-label.info.singular\": \"information message\",\n    \"gutter-tooltip.aria-label.info.plural\": \"information messages\",\n    \"gutter.annotation.aria-label.security\": \"Security finding, read annotations row $0\",\n    \"gutter.annotation.aria-label.hint\": \"Suggestion, read annotations row $0\",\n    \"gutter-tooltip.aria-label.security.singular\": \"security finding\",\n    \"gutter-tooltip.aria-label.security.plural\": \"security findings\",\n    \"gutter-tooltip.aria-label.hint.singular\": \"suggestion\",\n    \"gutter-tooltip.aria-label.hint.plural\": \"suggestions\"\n};\nexports.defaultEnglishMessages = defaultEnglishMessages;\n\n});\n\nace.define(\"ace/lib/app_config\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/lib/report_error\",\"ace/lib/default_english_messages\"], function(require, exports, module){\"no use strict\";\nvar oop = require(\"./oop\");\nvar EventEmitter = require(\"./event_emitter\").EventEmitter;\nvar reportError = require(\"./report_error\").reportError;\nvar defaultEnglishMessages = require(\"./default_english_messages\").defaultEnglishMessages;\nvar optionsProvider = {\n    setOptions: function (optList) {\n        Object.keys(optList).forEach(function (key) {\n            this.setOption(key, optList[key]);\n        }, this);\n    },\n    getOptions: function (optionNames) {\n        var result = {};\n        if (!optionNames) {\n            var options = this.$options;\n            optionNames = Object.keys(options).filter(function (key) {\n                return !options[key].hidden;\n            });\n        }\n        else if (!Array.isArray(optionNames)) {\n            result = optionNames;\n            optionNames = Object.keys(result);\n        }\n        optionNames.forEach(function (key) {\n            result[key] = this.getOption(key);\n        }, this);\n        return result;\n    },\n    setOption: function (name, value) {\n        if (this[\"$\" + name] === value)\n            return;\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n        if (!opt.handlesSet)\n            this[\"$\" + name] = value;\n        if (opt && opt.set)\n            opt.set.call(this, value);\n    },\n    getOption: function (name) {\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n    }\n};\nfunction warn(message) {\n    if (typeof console != \"undefined\" && console.warn)\n        console.warn.apply(console, arguments);\n}\nvar messages;\nvar nlsPlaceholders;\nvar AppConfig = /** @class */ (function () {\n    function AppConfig() {\n        this.$defaultOptions = {};\n        messages = defaultEnglishMessages;\n        nlsPlaceholders = \"dollarSigns\";\n    }\n    AppConfig.prototype.defineOptions = function (obj, path, options) {\n        if (!obj.$options)\n            this.$defaultOptions[path] = obj.$options = {};\n        Object.keys(options).forEach(function (key) {\n            var opt = options[key];\n            if (typeof opt == \"string\")\n                opt = { forwardTo: opt };\n            opt.name || (opt.name = key);\n            obj.$options[opt.name] = opt;\n            if (\"initialValue\" in opt)\n                obj[\"$\" + opt.name] = opt.initialValue;\n        });\n        oop.implement(obj, optionsProvider);\n        return this;\n    };\n    AppConfig.prototype.resetOptions = function (obj) {\n        Object.keys(obj.$options).forEach(function (key) {\n            var opt = obj.$options[key];\n            if (\"value\" in opt)\n                obj.setOption(key, opt.value);\n        });\n    };\n    AppConfig.prototype.setDefaultValue = function (path, name, value) {\n        if (!path) {\n            for (path in this.$defaultOptions)\n                if (this.$defaultOptions[path][name])\n                    break;\n            if (!this.$defaultOptions[path][name])\n                return false;\n        }\n        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});\n        if (opts[name]) {\n            if (opts.forwardTo)\n                this.setDefaultValue(opts.forwardTo, name, value);\n            else\n                opts[name].value = value;\n        }\n    };\n    AppConfig.prototype.setDefaultValues = function (path, optionHash) {\n        Object.keys(optionHash).forEach(function (key) {\n            this.setDefaultValue(path, key, optionHash[key]);\n        }, this);\n    };\n    AppConfig.prototype.setMessages = function (value, options) {\n        messages = value;\n        if (options && options.placeholders) {\n            nlsPlaceholders = options.placeholders;\n        }\n    };\n    AppConfig.prototype.nls = function (key, defaultString, params) {\n        if (!messages[key]) {\n            warn(\"No message found for the key '\" + key + \"' in messages with id \" + messages.$id + \", trying to find a translation for the default string '\" + defaultString + \"'.\");\n            if (!messages[defaultString]) {\n                warn(\"No message found for the default string '\" + defaultString + \"' in the provided messages. Falling back to the default English message.\");\n            }\n        }\n        var translated = messages[key] || messages[defaultString] || defaultString;\n        if (params) {\n            if (nlsPlaceholders === \"dollarSigns\") {\n                translated = translated.replace(/\\$(\\$|[\\d]+)/g, function (_, dollarMatch) {\n                    if (dollarMatch == \"$\")\n                        return \"$\";\n                    return params[dollarMatch];\n                });\n            }\n            if (nlsPlaceholders === \"curlyBrackets\") {\n                translated = translated.replace(/\\{([^\\}]+)\\}/g, function (_, curlyBracketMatch) {\n                    return params[curlyBracketMatch];\n                });\n            }\n        }\n        return translated;\n    };\n    return AppConfig;\n}());\nAppConfig.prototype.warn = warn;\nAppConfig.prototype.reportError = reportError;\noop.implement(AppConfig.prototype, EventEmitter);\nexports.AppConfig = AppConfig;\n\n});\n\nace.define(\"ace/theme/textmate-css\",[\"require\",\"exports\",\"module\"], function(require, exports, module){module.exports = \".ace-tm .ace_gutter {\\n  background: #f0f0f0;\\n  color: #333;\\n}\\n\\n.ace-tm .ace_print-margin {\\n  width: 1px;\\n  background: #e8e8e8;\\n}\\n\\n.ace-tm .ace_fold {\\n    background-color: #6B72E6;\\n}\\n\\n.ace-tm {\\n  background-color: #FFFFFF;\\n  color: black;\\n}\\n\\n.ace-tm .ace_cursor {\\n  color: black;\\n}\\n        \\n.ace-tm .ace_invisible {\\n  color: rgb(191, 191, 191);\\n}\\n\\n.ace-tm .ace_storage,\\n.ace-tm .ace_keyword {\\n  color: blue;\\n}\\n\\n.ace-tm .ace_constant {\\n  color: rgb(197, 6, 11);\\n}\\n\\n.ace-tm .ace_constant.ace_buildin {\\n  color: rgb(88, 72, 246);\\n}\\n\\n.ace-tm .ace_constant.ace_language {\\n  color: rgb(88, 92, 246);\\n}\\n\\n.ace-tm .ace_constant.ace_library {\\n  color: rgb(6, 150, 14);\\n}\\n\\n.ace-tm .ace_invalid {\\n  background-color: rgba(255, 0, 0, 0.1);\\n  color: red;\\n}\\n\\n.ace-tm .ace_support.ace_function {\\n  color: rgb(60, 76, 114);\\n}\\n\\n.ace-tm .ace_support.ace_constant {\\n  color: rgb(6, 150, 14);\\n}\\n\\n.ace-tm .ace_support.ace_type,\\n.ace-tm .ace_support.ace_class {\\n  color: rgb(109, 121, 222);\\n}\\n\\n.ace-tm .ace_keyword.ace_operator {\\n  color: rgb(104, 118, 135);\\n}\\n\\n.ace-tm .ace_string {\\n  color: rgb(3, 106, 7);\\n}\\n\\n.ace-tm .ace_comment {\\n  color: rgb(76, 136, 107);\\n}\\n\\n.ace-tm .ace_comment.ace_doc {\\n  color: rgb(0, 102, 255);\\n}\\n\\n.ace-tm .ace_comment.ace_doc.ace_tag {\\n  color: rgb(128, 159, 191);\\n}\\n\\n.ace-tm .ace_constant.ace_numeric {\\n  color: rgb(0, 0, 205);\\n}\\n\\n.ace-tm .ace_variable {\\n  color: rgb(49, 132, 149);\\n}\\n\\n.ace-tm .ace_xml-pe {\\n  color: rgb(104, 104, 91);\\n}\\n\\n.ace-tm .ace_entity.ace_name.ace_function {\\n  color: #0000A2;\\n}\\n\\n\\n.ace-tm .ace_heading {\\n  color: rgb(12, 7, 255);\\n}\\n\\n.ace-tm .ace_list {\\n  color:rgb(185, 6, 144);\\n}\\n\\n.ace-tm .ace_meta.ace_tag {\\n  color:rgb(0, 22, 142);\\n}\\n\\n.ace-tm .ace_string.ace_regex {\\n  color: rgb(255, 0, 0)\\n}\\n\\n.ace-tm .ace_marker-layer .ace_selection {\\n  background: rgb(181, 213, 255);\\n}\\n.ace-tm.ace_multiselect .ace_selection.ace_start {\\n  box-shadow: 0 0 3px 0px white;\\n}\\n.ace-tm .ace_marker-layer .ace_step {\\n  background: rgb(252, 255, 0);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_stack {\\n  background: rgb(164, 229, 101);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_bracket {\\n  margin: -1px 0 0 -1px;\\n  border: 1px solid rgb(192, 192, 192);\\n}\\n\\n.ace-tm .ace_marker-layer .ace_active-line {\\n  background: rgba(0, 0, 0, 0.07);\\n}\\n\\n.ace-tm .ace_gutter-active-line {\\n    background-color : #dcdcdc;\\n}\\n\\n.ace-tm .ace_marker-layer .ace_selected-word {\\n  background: rgb(250, 250, 255);\\n  border: 1px solid rgb(200, 200, 250);\\n}\\n\\n.ace-tm .ace_indent-guide {\\n  background: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\n}\\n\\n.ace-tm .ace_indent-guide-active {\\n  background: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC\\\") right repeat-y;\\n}\\n\";\n\n});\n\nace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/theme/textmate-css\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nexports.isDark = false;\nexports.cssClass = \"ace-tm\";\nexports.cssText = require(\"./textmate-css\");\nexports.$id = \"ace/theme/textmate\";\nvar dom = require(\"../lib/dom\");\ndom.importCssString(exports.cssText, exports.cssClass, false);\n\n});\n\nace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/net\",\"ace/lib/dom\",\"ace/lib/app_config\",\"ace/theme/textmate\"], function(require, exports, module){\"no use strict\";\nvar lang = require(\"./lib/lang\");\nvar net = require(\"./lib/net\");\nvar dom = require(\"./lib/dom\");\nvar AppConfig = require(\"./lib/app_config\").AppConfig;\nmodule.exports = exports = new AppConfig();\nvar options = {\n    packaged: false,\n    workerPath: null,\n    modePath: null,\n    themePath: null,\n    basePath: \"\",\n    suffix: \".js\",\n    $moduleUrls: {},\n    loadWorkerFromBlob: true,\n    sharedPopups: false,\n    useStrictCSP: null\n};\nexports.get = function (key) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n    return options[key];\n};\nexports.set = function (key, value) {\n    if (options.hasOwnProperty(key))\n        options[key] = value;\n    else if (this.setDefaultValue(\"\", key, value) == false)\n        throw new Error(\"Unknown config key: \" + key);\n    if (key == \"useStrictCSP\")\n        dom.useStrictCSP(value);\n};\nexports.all = function () {\n    return lang.copyObject(options);\n};\nexports.$modes = {};\nexports.moduleUrl = function (name, component) {\n    if (options.$moduleUrls[name])\n        return options.$moduleUrls[name];\n    var parts = name.split(\"/\");\n    component = component || parts[parts.length - 2] || \"\";\n    var sep = component == \"snippets\" ? \"/\" : \"-\";\n    var base = parts[parts.length - 1];\n    if (component == \"worker\" && sep == \"-\") {\n        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n        base = base.replace(re, \"\");\n    }\n    if ((!base || base == component) && parts.length > 1)\n        base = parts[parts.length - 2];\n    var path = options[component + \"Path\"];\n    if (path == null) {\n        path = options.basePath;\n    }\n    else if (sep == \"/\") {\n        component = sep = \"\";\n    }\n    if (path && path.slice(-1) != \"/\")\n        path += \"/\";\n    return path + component + sep + base + this.get(\"suffix\");\n};\nexports.setModuleUrl = function (name, subst) {\n    return options.$moduleUrls[name] = subst;\n};\nvar loader = function (moduleName, cb) {\n    if (moduleName === \"ace/theme/textmate\" || moduleName === \"./theme/textmate\")\n        return cb(null, require(\"./theme/textmate\"));\n    if (customLoader)\n        return customLoader(moduleName, cb);\n    console.error(\"loader is not configured\");\n};\nvar customLoader;\nexports.setLoader = function (cb) {\n    customLoader = cb;\n};\nexports.dynamicModules = Object.create(null);\nexports.$loading = {};\nexports.$loaded = {};\nexports.loadModule = function (moduleId, onLoad) {\n    var loadedModule;\n    if (Array.isArray(moduleId)) {\n        var moduleType = moduleId[0];\n        var moduleName = moduleId[1];\n    }\n    else if (typeof moduleId == \"string\") {\n        var moduleName = moduleId;\n    }\n    var load = function (module) {\n        if (module && !exports.$loading[moduleName])\n            return onLoad && onLoad(module);\n        if (!exports.$loading[moduleName])\n            exports.$loading[moduleName] = [];\n        exports.$loading[moduleName].push(onLoad);\n        if (exports.$loading[moduleName].length > 1)\n            return;\n        var afterLoad = function () {\n            loader(moduleName, function (err, module) {\n                if (module)\n                    exports.$loaded[moduleName] = module;\n                exports._emit(\"load.module\", { name: moduleName, module: module });\n                var listeners = exports.$loading[moduleName];\n                exports.$loading[moduleName] = null;\n                listeners.forEach(function (onLoad) {\n                    onLoad && onLoad(module);\n                });\n            });\n        };\n        if (!exports.get(\"packaged\"))\n            return afterLoad();\n        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n        reportErrorIfPathIsNotConfigured();\n    };\n    if (exports.dynamicModules[moduleName]) {\n        exports.dynamicModules[moduleName]().then(function (module) {\n            if (module.default) {\n                load(module.default);\n            }\n            else {\n                load(module);\n            }\n        });\n    }\n    else {\n        try {\n            loadedModule = this.$require(moduleName);\n        }\n        catch (e) { }\n        load(loadedModule || exports.$loaded[moduleName]);\n    }\n};\nexports.$require = function (moduleName) {\n    if (typeof module[\"require\"] == \"function\") {\n        var req = \"require\";\n        return module[req](moduleName);\n    }\n};\nexports.setModuleLoader = function (moduleName, onLoad) {\n    exports.dynamicModules[moduleName] = onLoad;\n};\nvar reportErrorIfPathIsNotConfigured = function () {\n    if (!options.basePath && !options.workerPath\n        && !options.modePath && !options.themePath\n        && !Object.keys(options.$moduleUrls).length) {\n        console.error(\"Unable to infer path to ace from script src,\", \"use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes\", \"or with webpack use ace/webpack-resolver\");\n        reportErrorIfPathIsNotConfigured = function () { };\n    }\n};\nexports.version = \"1.39.0\";\n\n});\n\nace.define(\"ace/loader_build\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\nvar config = require(\"./config\");\nconfig.setLoader(function(moduleName, cb) {\n    require([moduleName], function(module) {\n        cb(null, module);\n    });\n});\n\nvar global = (function() {\n    return this || typeof window != \"undefined\" && window;\n})();\n\nmodule.exports = function(ace) {\n    config.init = init;\n    config.$require = require;\n    ace.require = require;\n\n    if (true)\n        ace.define = __webpack_require__.amdD;\n};\ninit(true);function init(packaged) {\n\n    if (!global || !global.document)\n        return;\n    \n    config.set(\"packaged\", packaged || require.packaged || module.packaged || (global.define && __webpack_require__.amdD.packaged));\n\n    var scriptOptions = {};\n    var scriptUrl = \"\";\n    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n    var currentDocument = currentScript && currentScript.ownerDocument || document;\n    \n    if (currentScript && currentScript.src) {\n        scriptUrl = currentScript.src.split(/[?#]/)[0].split(\"/\").slice(0, -1).join(\"/\") || \"\";\n    }\n    \n    var scripts = currentDocument.getElementsByTagName(\"script\");\n    for (var i=0; i<scripts.length; i++) {\n        var script = scripts[i];\n\n        var src = script.src || script.getAttribute(\"src\");\n        if (!src)\n            continue;\n\n        var attributes = script.attributes;\n        for (var j=0, l=attributes.length; j < l; j++) {\n            var attr = attributes[j];\n            if (attr.name.indexOf(\"data-ace-\") === 0) {\n                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n            }\n        }\n\n        var m = src.match(/^(.*)\\/ace([\\-.]\\w+)?\\.js(\\?|$)/);\n        if (m)\n            scriptUrl = m[1];\n    }\n\n    if (scriptUrl) {\n        scriptOptions.base = scriptOptions.base || scriptUrl;\n        scriptOptions.packaged = true;\n    }\n\n    scriptOptions.basePath = scriptOptions.base;\n    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n    delete scriptOptions.base;\n\n    for (var key in scriptOptions)\n        if (typeof scriptOptions[key] !== \"undefined\")\n            config.set(key, scriptOptions[key]);\n}\n\nfunction deHyphenate(str) {\n    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n}\n});\n\nace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar Range = /** @class */ (function () {\n    function Range(startRow, startColumn, endRow, endColumn) {\n        this.start = {\n            row: startRow,\n            column: startColumn\n        };\n        this.end = {\n            row: endRow,\n            column: endColumn\n        };\n    }\n    Range.prototype.isEqual = function (range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    Range.prototype.toString = function () {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n    Range.prototype.contains = function (row, column) {\n        return this.compare(row, column) == 0;\n    };\n    Range.prototype.compareRange = function (range) {\n        var cmp, end = range.end, start = range.start;\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            }\n            else if (cmp == 0) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (cmp == -1) {\n            return -2;\n        }\n        else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            }\n            else if (cmp == 1) {\n                return 42;\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n    Range.prototype.comparePoint = function (p) {\n        return this.compare(p.row, p.column);\n    };\n    Range.prototype.containsRange = function (range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    Range.prototype.intersects = function (range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    Range.prototype.isEnd = function (row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    Range.prototype.isStart = function (row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    Range.prototype.setStart = function (row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        }\n        else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    Range.prototype.setEnd = function (row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        }\n        else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    Range.prototype.inside = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.insideStart = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.insideEnd = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Range.prototype.compare = function (row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n        if (row < this.start.row)\n            return -1;\n        if (row > this.end.row)\n            return 1;\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n        return 0;\n    };\n    Range.prototype.compareStart = function (row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.compareEnd = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.compareInside = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    Range.prototype.clipRows = function (firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = { row: lastRow + 1, column: 0 };\n        else if (this.end.row < firstRow)\n            var end = { row: firstRow, column: 0 };\n        if (this.start.row > lastRow)\n            var start = { row: lastRow + 1, column: 0 };\n        else if (this.start.row < firstRow)\n            var start = { row: firstRow, column: 0 };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.extend = function (row, column) {\n        var cmp = this.compare(row, column);\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = { row: row, column: column };\n        else\n            var end = { row: row, column: column };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.isEmpty = function () {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    Range.prototype.isMultiLine = function () {\n        return (this.start.row !== this.end.row);\n    };\n    Range.prototype.clone = function () {\n        return Range.fromPoints(this.start, this.end);\n    };\n    Range.prototype.collapseRows = function () {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    Range.prototype.toScreenRange = function (session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    Range.prototype.moveBy = function (row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n    return Range;\n}());\nRange.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nexports.Range = Range;\n\n});\n\nace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./oop\");\nvar Keys = {\n    MODIFIER_KEYS: {\n        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',\n        91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'\n    },\n    KEY_MODS: {\n        \"ctrl\": 1, \"alt\": 2, \"option\": 2, \"shift\": 4,\n        \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8,\n        \"control\": 1\n    },\n    FUNCTION_KEYS: {\n        8: \"Backspace\",\n        9: \"Tab\",\n        13: \"Return\",\n        19: \"Pause\",\n        27: \"Esc\",\n        32: \"Space\",\n        33: \"PageUp\",\n        34: \"PageDown\",\n        35: \"End\",\n        36: \"Home\",\n        37: \"Left\",\n        38: \"Up\",\n        39: \"Right\",\n        40: \"Down\",\n        44: \"Print\",\n        45: \"Insert\",\n        46: \"Delete\",\n        '-13': \"NumpadEnter\",\n        144: \"Numlock\",\n        145: \"Scrolllock\"\n    },\n    PRINTABLE_KEYS: {\n        32: ' ', 59: ';', 61: '=', 107: '+', 109: '-', 110: '.',\n        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',\n        219: '[', 220: '\\\\', 221: ']', 222: \"'\", 111: '/', 106: '*'\n    }\n};\nvar codeToKeyCode = {\n    Command: 224,\n    Backspace: 8,\n    Tab: 9,\n    Return: 13,\n    Enter: 13,\n    Pause: 19,\n    Escape: 27,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Insert: 45,\n    Delete: 46,\n    ArrowLeft: 37,\n    ArrowUp: 38,\n    ArrowRight: 39,\n    ArrowDown: 40,\n    Backquote: 192,\n    Minus: 189,\n    Equal: 187,\n    BracketLeft: 219,\n    Backslash: 220,\n    BracketRight: 221,\n    Semicolon: 186,\n    Quote: 222,\n    Comma: 188,\n    Period: 190,\n    Slash: 191,\n    Space: 32,\n    NumpadAdd: 107,\n    NumpadDecimal: 110,\n    NumpadSubtract: 109,\n    NumpadDivide: 111,\n    NumpadMultiply: 106\n};\nfor (var i = 0; i < 10; i++) {\n    codeToKeyCode[\"Digit\" + i] = 48 + i;\n    codeToKeyCode[\"Numpad\" + i] = 96 + i;\n    Keys.PRINTABLE_KEYS[48 + i] = \"\" + i;\n    Keys.FUNCTION_KEYS[96 + i] = \"Numpad\" + i;\n}\nfor (var i = 65; i < 91; i++) {\n    var chr = String.fromCharCode(i + 32);\n    codeToKeyCode[\"Key\" + chr.toUpperCase()] = i;\n    Keys.PRINTABLE_KEYS[i] = chr;\n}\nfor (var i = 1; i < 13; i++) {\n    codeToKeyCode[\"F\" + i] = 111 + i;\n    Keys.FUNCTION_KEYS[111 + i] = \"F\" + i;\n}\nvar modifiers = {\n    Shift: 16,\n    Control: 17,\n    Alt: 18,\n    Meta: 224\n};\nfor (var mod in modifiers) {\n    codeToKeyCode[mod] = codeToKeyCode[mod + \"Left\"]\n        = codeToKeyCode[mod + \"Right\"] = modifiers[mod];\n}\nexports.$codeToKeyCode = codeToKeyCode;\nKeys.PRINTABLE_KEYS[173] = '-';\nfor (var j in Keys.FUNCTION_KEYS) {\n    var name = Keys.FUNCTION_KEYS[j].toLowerCase();\n    Keys[name] = parseInt(j, 10);\n}\nfor (var j in Keys.PRINTABLE_KEYS) {\n    var name = Keys.PRINTABLE_KEYS[j].toLowerCase();\n    Keys[name] = parseInt(j, 10);\n}\noop.mixin(Keys, Keys.MODIFIER_KEYS);\noop.mixin(Keys, Keys.PRINTABLE_KEYS);\noop.mixin(Keys, Keys.FUNCTION_KEYS);\nKeys.enter = Keys[\"return\"];\nKeys.escape = Keys.esc;\nKeys.del = Keys[\"delete\"];\n(function () {\n    var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n    for (var i = Math.pow(2, mods.length); i--;) {\n        Keys.KEY_MODS[i] = mods.filter(function (x) {\n            return i & Keys.KEY_MODS[x];\n        }).join(\"-\") + \"-\";\n    }\n})();\nKeys.KEY_MODS[0] = \"\";\nKeys.KEY_MODS[-1] = \"input-\";\noop.mixin(exports, Keys);\nexports.default = exports;\nexports.keyCodeToString = function (keyCode) {\n    var keyString = Keys[keyCode];\n    if (typeof keyString != \"string\")\n        keyString = String.fromCharCode(keyCode);\n    return keyString.toLowerCase();\n};\n\n});\n\nace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\"; var keys = require(\"./keys\");\nvar useragent = require(\"./useragent\");\nvar pressedKeys = null;\nvar ts = 0;\nvar activeListenerOptions;\nfunction detectListenerOptionsSupport() {\n    activeListenerOptions = false;\n    try {\n        document.createComment(\"\").addEventListener(\"test\", function () { }, {\n            get passive() {\n                activeListenerOptions = { passive: false };\n                return true;\n            }\n        });\n    }\n    catch (e) { }\n}\nfunction getListenerOptions() {\n    if (activeListenerOptions == undefined)\n        detectListenerOptionsSupport();\n    return activeListenerOptions;\n}\nfunction EventListener(elem, type, callback) {\n    this.elem = elem;\n    this.type = type;\n    this.callback = callback;\n}\nEventListener.prototype.destroy = function () {\n    removeListener(this.elem, this.type, this.callback);\n    this.elem = this.type = this.callback = undefined;\n};\nvar addListener = exports.addListener = function (elem, type, callback, destroyer) {\n    elem.addEventListener(type, callback, getListenerOptions());\n    if (destroyer)\n        destroyer.$toDestroy.push(new EventListener(elem, type, callback));\n};\nvar removeListener = exports.removeListener = function (elem, type, callback) {\n    elem.removeEventListener(type, callback, getListenerOptions());\n};\nexports.stopEvent = function (e) {\n    exports.stopPropagation(e);\n    exports.preventDefault(e);\n    return false;\n};\nexports.stopPropagation = function (e) {\n    if (e.stopPropagation)\n        e.stopPropagation();\n};\nexports.preventDefault = function (e) {\n    if (e.preventDefault)\n        e.preventDefault();\n};\nexports.getButton = function (e) {\n    if (e.type == \"dblclick\")\n        return 0;\n    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n        return 2;\n    return e.button;\n};\nexports.capture = function (el, eventHandler, releaseCaptureHandler) {\n    var ownerDocument = el && el.ownerDocument || document;\n    function onMouseUp(e) {\n        eventHandler && eventHandler(e);\n        releaseCaptureHandler && releaseCaptureHandler(e);\n        removeListener(ownerDocument, \"mousemove\", eventHandler);\n        removeListener(ownerDocument, \"mouseup\", onMouseUp);\n        removeListener(ownerDocument, \"dragstart\", onMouseUp);\n    }\n    addListener(ownerDocument, \"mousemove\", eventHandler);\n    addListener(ownerDocument, \"mouseup\", onMouseUp);\n    addListener(ownerDocument, \"dragstart\", onMouseUp);\n    return onMouseUp;\n};\nexports.addMouseWheelListener = function (el, callback, destroyer) {\n    addListener(el, \"wheel\", function (e) {\n        var factor = 0.15;\n        var deltaX = e.deltaX || 0;\n        var deltaY = e.deltaY || 0;\n        switch (e.deltaMode) {\n            case e.DOM_DELTA_PIXEL:\n                e.wheelX = deltaX * factor;\n                e.wheelY = deltaY * factor;\n                break;\n            case e.DOM_DELTA_LINE:\n                var linePixels = 15;\n                e.wheelX = deltaX * linePixels;\n                e.wheelY = deltaY * linePixels;\n                break;\n            case e.DOM_DELTA_PAGE:\n                var pagePixels = 150;\n                e.wheelX = deltaX * pagePixels;\n                e.wheelY = deltaY * pagePixels;\n                break;\n        }\n        callback(e);\n    }, destroyer);\n};\nexports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName, destroyer) {\n    var clicks = 0;\n    var startX, startY, timer;\n    var eventNames = {\n        2: \"dblclick\",\n        3: \"tripleclick\",\n        4: \"quadclick\"\n    };\n    function onMousedown(e) {\n        if (exports.getButton(e) !== 0) {\n            clicks = 0;\n        }\n        else if (e.detail > 1) {\n            clicks++;\n            if (clicks > 4)\n                clicks = 1;\n        }\n        else {\n            clicks = 1;\n        }\n        if (useragent.isIE) {\n            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n            if (!timer || isNewClick)\n                clicks = 1;\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);\n            if (clicks == 1) {\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        }\n        e._clicks = clicks;\n        eventHandler[callbackName](\"mousedown\", e);\n        if (clicks > 4)\n            clicks = 0;\n        else if (clicks > 1)\n            return eventHandler[callbackName](eventNames[clicks], e);\n    }\n    if (!Array.isArray(elements))\n        elements = [elements];\n    elements.forEach(function (el) {\n        addListener(el, \"mousedown\", onMousedown, destroyer);\n    });\n};\nfunction getModifierHash(e) {\n    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n}\nexports.getModifierString = function (e) {\n    return keys.KEY_MODS[getModifierHash(e)];\n};\nfunction normalizeCommandKeys(callback, e, keyCode) {\n    var hashId = getModifierHash(e);\n    if (!keyCode && e.code) {\n        keyCode = keys.$codeToKeyCode[e.code] || keyCode;\n    }\n    if (!useragent.isMac && pressedKeys) {\n        if (e.getModifierState && (e.getModifierState(\"OS\") || e.getModifierState(\"Win\")))\n            hashId |= 8;\n        if (pressedKeys.altGr) {\n            if ((3 & hashId) != 3)\n                pressedKeys.altGr = 0;\n            else\n                return;\n        }\n        if (keyCode === 18 || keyCode === 17) {\n            var location = e.location;\n            if (keyCode === 17 && location === 1) {\n                if (pressedKeys[keyCode] == 1)\n                    ts = e.timeStamp;\n            }\n            else if (keyCode === 18 && hashId === 3 && location === 2) {\n                var dt = e.timeStamp - ts;\n                if (dt < 50)\n                    pressedKeys.altGr = true;\n            }\n        }\n    }\n    if (keyCode in keys.MODIFIER_KEYS) {\n        keyCode = -1;\n    }\n    if (!hashId && keyCode === 13) {\n        if (e.location === 3) {\n            callback(e, hashId, -keyCode);\n            if (e.defaultPrevented)\n                return;\n        }\n    }\n    if (useragent.isChromeOS && hashId & 8) {\n        callback(e, hashId, keyCode);\n        if (e.defaultPrevented)\n            return;\n        else\n            hashId &= ~8;\n    }\n    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n        return false;\n    }\n    return callback(e, hashId, keyCode);\n}\nexports.addCommandKeyListener = function (el, callback, destroyer) {\n    var lastDefaultPrevented = null;\n    addListener(el, \"keydown\", function (e) {\n        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;\n        var result = normalizeCommandKeys(callback, e, e.keyCode);\n        lastDefaultPrevented = e.defaultPrevented;\n        return result;\n    }, destroyer);\n    addListener(el, \"keypress\", function (e) {\n        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n            exports.stopEvent(e);\n            lastDefaultPrevented = null;\n        }\n    }, destroyer);\n    addListener(el, \"keyup\", function (e) {\n        pressedKeys[e.keyCode] = null;\n    }, destroyer);\n    if (!pressedKeys) {\n        resetPressedKeys();\n        addListener(window, \"focus\", resetPressedKeys);\n    }\n};\nfunction resetPressedKeys() {\n    pressedKeys = Object.create(null);\n}\nif (typeof window == \"object\" && window.postMessage && !useragent.isOldIE) {\n    var postMessageId = 1;\n    exports.nextTick = function (callback, win) {\n        win = win || window;\n        var messageName = \"zero-timeout-message-\" + (postMessageId++);\n        var listener = function (e) {\n            if (e.data == messageName) {\n                exports.stopPropagation(e);\n                removeListener(win, \"message\", listener);\n                callback();\n            }\n        };\n        addListener(win, \"message\", listener);\n        win.postMessage(messageName, \"*\");\n    };\n}\nexports.$idleBlocked = false;\nexports.onIdle = function (cb, timeout) {\n    return setTimeout(function handler() {\n        if (!exports.$idleBlocked) {\n            cb();\n        }\n        else {\n            setTimeout(handler, 100);\n        }\n    }, timeout);\n};\nexports.$idleBlockId = null;\nexports.blockIdle = function (delay) {\n    if (exports.$idleBlockId)\n        clearTimeout(exports.$idleBlockId);\n    exports.$idleBlocked = true;\n    exports.$idleBlockId = setTimeout(function () {\n        exports.$idleBlocked = false;\n    }, delay || 100);\n};\nexports.nextFrame = typeof window == \"object\" && (window.requestAnimationFrame\n    || window[\"mozRequestAnimationFrame\"]\n    || window[\"webkitRequestAnimationFrame\"]\n    || window[\"msRequestAnimationFrame\"]\n    || window[\"oRequestAnimationFrame\"]);\nif (exports.nextFrame)\n    exports.nextFrame = exports.nextFrame.bind(window);\nelse\n    exports.nextFrame = function (callback) {\n        setTimeout(callback, 17);\n    };\n\n});\n\nace.define(\"ace/clipboard\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar $cancelT;\nmodule.exports = {\n    lineMode: false,\n    pasteCancelled: function () {\n        if ($cancelT && $cancelT > Date.now() - 50)\n            return true;\n        return $cancelT = false;\n    },\n    cancel: function () {\n        $cancelT = Date.now();\n    }\n};\n\n});\n\nace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/config\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/clipboard\",\"ace/lib/keys\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar nls = require(\"../config\").nls;\nvar useragent = require(\"../lib/useragent\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar clipboard = require(\"../clipboard\");\nvar BROKEN_SETDATA = useragent.isChrome < 18;\nvar USE_IE_MIME_TYPE = useragent.isIE;\nvar HAS_FOCUS_ARGS = useragent.isChrome > 63;\nvar MAX_LINE_LENGTH = 400;\nvar KEYS = require(\"../lib/keys\");\nvar MODS = KEYS.KEY_MODS;\nvar isIOS = useragent.isIOS;\nvar valueResetRegex = isIOS ? /\\s/ : /\\n/;\nvar isMobile = useragent.isMobile;\nvar TextInput;\nTextInput = function (/**@type{HTMLTextAreaElement} */ parentNode, /**@type{import(\"../editor\").Editor} */ host) {\n    var text = dom.createElement(\"textarea\");\n    text.className = \"ace_text-input\";\n    text.setAttribute(\"wrap\", \"off\");\n    text.setAttribute(\"autocorrect\", \"off\");\n    text.setAttribute(\"autocapitalize\", \"off\");\n    text.setAttribute(\"spellcheck\", \"false\");\n    text.style.opacity = \"0\";\n    parentNode.insertBefore(text, parentNode.firstChild); var copied = false;\n    var pasted = false;\n    var inComposition = false;\n    var sendingText = false;\n    var tempStyle = '';\n    if (!isMobile)\n        text.style.fontSize = \"1px\";\n    var commandMode = false;\n    var ignoreFocusEvents = false;\n    var lastValue = \"\";\n    var lastSelectionStart = 0;\n    var lastSelectionEnd = 0;\n    var lastRestoreEnd = 0;\n    var rowStart = Number.MAX_SAFE_INTEGER;\n    var rowEnd = Number.MIN_SAFE_INTEGER;\n    var numberOfExtraLines = 0;\n    try {\n        var isFocused = document.activeElement === text;\n    }\n    catch (e) { }\n    this.setNumberOfExtraLines = function (/**@type{number}*/ number) {\n        rowStart = Number.MAX_SAFE_INTEGER;\n        rowEnd = Number.MIN_SAFE_INTEGER;\n        if (number < 0) {\n            numberOfExtraLines = 0;\n            return;\n        }\n        numberOfExtraLines = number;\n    };\n    this.setAriaLabel = function () {\n        var ariaLabel = \"\";\n        if (host.$textInputAriaLabel) {\n            ariaLabel += \"\".concat(host.$textInputAriaLabel, \", \");\n        }\n        if (host.session) {\n            var row = host.session.selection.cursor.row;\n            ariaLabel += nls(\"text-input.aria-label\", \"Cursor at row $0\", [row + 1]);\n        }\n        text.setAttribute(\"aria-label\", ariaLabel);\n    };\n    this.setAriaOptions = function (options) {\n        if (options.activeDescendant) {\n            text.setAttribute(\"aria-haspopup\", \"true\");\n            text.setAttribute(\"aria-autocomplete\", options.inline ? \"both\" : \"list\");\n            text.setAttribute(\"aria-activedescendant\", options.activeDescendant);\n        }\n        else {\n            text.setAttribute(\"aria-haspopup\", \"false\");\n            text.setAttribute(\"aria-autocomplete\", \"both\");\n            text.removeAttribute(\"aria-activedescendant\");\n        }\n        if (options.role) {\n            text.setAttribute(\"role\", options.role);\n        }\n        if (options.setLabel) {\n            text.setAttribute(\"aria-roledescription\", nls(\"text-input.aria-roledescription\", \"editor\"));\n            this.setAriaLabel();\n        }\n    };\n    this.setAriaOptions({ role: \"textbox\" });\n    event.addListener(text, \"blur\", function (e) {\n        if (ignoreFocusEvents)\n            return;\n        host.onBlur(e);\n        isFocused = false;\n    }, host);\n    event.addListener(text, \"focus\", function (e) {\n        if (ignoreFocusEvents)\n            return;\n        isFocused = true;\n        if (useragent.isEdge) {\n            try {\n                if (!document.hasFocus())\n                    return;\n            }\n            catch (e) { }\n        }\n        host.onFocus(e);\n        if (useragent.isEdge)\n            setTimeout(resetSelection);\n        else\n            resetSelection();\n    }, host);\n    this.$focusScroll = false;\n    this.focus = function () {\n        this.setAriaOptions({\n            setLabel: host.renderer.enableKeyboardAccessibility\n        });\n        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == \"browser\")\n            return text.focus({ preventScroll: true });\n        var top = text.style.top;\n        text.style.position = \"fixed\";\n        text.style.top = \"0px\";\n        try {\n            var isTransformed = text.getBoundingClientRect().top != 0;\n        }\n        catch (e) {\n            return;\n        }\n        var ancestors = [];\n        if (isTransformed) {\n            var t = text.parentElement;\n            while (t && t.nodeType == 1) {\n                ancestors.push(t);\n                t.setAttribute(\"ace_nocontext\", \"true\");\n                if (!t.parentElement && t.getRootNode)\n                    t = t.getRootNode()[\"host\"];\n                else\n                    t = t.parentElement;\n            }\n        }\n        text.focus({ preventScroll: true });\n        if (isTransformed) {\n            ancestors.forEach(function (p) {\n                p.removeAttribute(\"ace_nocontext\");\n            });\n        }\n        setTimeout(function () {\n            text.style.position = \"\";\n            if (text.style.top == \"0px\")\n                text.style.top = top;\n        }, 0);\n    };\n    this.blur = function () {\n        text.blur();\n    };\n    this.isFocused = function () {\n        return isFocused;\n    };\n    host.on(\"beforeEndOperation\", function () {\n        var curOp = host.curOp;\n        var commandName = curOp && curOp.command && curOp.command.name;\n        if (commandName == \"insertstring\")\n            return;\n        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);\n        if (inComposition && isUserAction) {\n            lastValue = text.value = \"\";\n            onCompositionEnd();\n        }\n        resetSelection();\n    });\n    host.on(\"changeSelection\", this.setAriaLabel);\n    var positionToSelection = function (row, column) {\n        var selection = column;\n        for (var i = 1; i <= row - rowStart && i < 2 * numberOfExtraLines + 1; i++) {\n            selection += host.session.getLine(row - i).length + 1;\n        }\n        return selection;\n    };\n    var resetSelection = isIOS\n        ? function (value) {\n            if (!isFocused || (copied && !value) || sendingText)\n                return;\n            if (!value)\n                value = \"\";\n            var newValue = \"\\n ab\" + value + \"cde fg\\n\";\n            if (newValue != text.value)\n                text.value = lastValue = newValue;\n            var selectionStart = 4;\n            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));\n            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {\n                text.setSelectionRange(selectionStart, selectionEnd);\n            }\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n        }\n        : function () {\n            if (inComposition || sendingText)\n                return;\n            if (!isFocused && !afterContextMenu)\n                return;\n            inComposition = true;\n            var selectionStart = 0;\n            var selectionEnd = 0;\n            var line = \"\";\n            if (host.session) {\n                var selection = host.selection;\n                var range = selection.getRange();\n                var row = selection.cursor.row;\n                if (row === rowEnd + 1) {\n                    rowStart = rowEnd + 1;\n                    rowEnd = rowStart + 2 * numberOfExtraLines;\n                }\n                else if (row === rowStart - 1) {\n                    rowEnd = rowStart - 1;\n                    rowStart = rowEnd - 2 * numberOfExtraLines;\n                }\n                else if (row < rowStart - 1 || row > rowEnd + 1) {\n                    rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;\n                    rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;\n                }\n                var lines = [];\n                for (var i = rowStart; i <= rowEnd; i++) {\n                    lines.push(host.session.getLine(i));\n                }\n                line = lines.join('\\n');\n                selectionStart = positionToSelection(range.start.row, range.start.column);\n                selectionEnd = positionToSelection(range.end.row, range.end.column);\n                if (range.start.row < rowStart) {\n                    var prevLine = host.session.getLine(rowStart - 1);\n                    selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;\n                    selectionEnd += prevLine.length + 1;\n                    line = prevLine + \"\\n\" + line;\n                }\n                else if (range.end.row > rowEnd) {\n                    var nextLine = host.session.getLine(rowEnd + 1);\n                    selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;\n                    selectionEnd += line.length + 1;\n                    line = line + \"\\n\" + nextLine;\n                }\n                else if (isMobile && row > 0) {\n                    line = \"\\n\" + line;\n                    selectionEnd += 1;\n                    selectionStart += 1;\n                }\n                if (line.length > MAX_LINE_LENGTH) {\n                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {\n                        line = line.slice(0, MAX_LINE_LENGTH);\n                    }\n                    else {\n                        line = \"\\n\";\n                        if (selectionStart == selectionEnd) {\n                            selectionStart = selectionEnd = 0;\n                        }\n                        else {\n                            selectionStart = 0;\n                            selectionEnd = 1;\n                        }\n                    }\n                }\n                var newValue = line + \"\\n\\n\";\n                if (newValue != lastValue) {\n                    text.value = lastValue = newValue;\n                    lastSelectionStart = lastSelectionEnd = newValue.length;\n                }\n            }\n            if (afterContextMenu) {\n                lastSelectionStart = text.selectionStart;\n                lastSelectionEnd = text.selectionEnd;\n            }\n            if (lastSelectionEnd != selectionEnd\n                || lastSelectionStart != selectionStart\n                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization\n            ) {\n                try {\n                    text.setSelectionRange(selectionStart, selectionEnd);\n                    lastSelectionStart = selectionStart;\n                    lastSelectionEnd = selectionEnd;\n                }\n                catch (e) { }\n            }\n            inComposition = false;\n        };\n    this.resetSelection = resetSelection;\n    if (isFocused)\n        host.onFocus();\n    var isAllSelected = function (text) {\n        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length\n            && text.value === lastValue && lastValue\n            && text.selectionEnd !== lastSelectionEnd;\n    };\n    var onSelect = function (e) {\n        if (inComposition)\n            return;\n        if (copied) {\n            copied = false;\n        }\n        else if (isAllSelected(text)) {\n            host.selectAll();\n            resetSelection();\n        }\n        else if (isMobile && text.selectionStart != lastSelectionStart) {\n            resetSelection();\n        }\n    };\n    var inputHandler = null;\n    this.setInputHandler = function (cb) { inputHandler = cb; };\n    this.getInputHandler = function () { return inputHandler; };\n    var afterContextMenu = false;\n    var sendText = function (value, fromInput) {\n        if (afterContextMenu)\n            afterContextMenu = false;\n        if (pasted) {\n            resetSelection();\n            if (value)\n                host.onPaste(value);\n            pasted = false;\n            return \"\";\n        }\n        else {\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            var extendLeft = lastSelectionStart;\n            var extendRight = lastValue.length - lastSelectionEnd;\n            var inserted = value;\n            var restoreStart = value.length - selectionStart;\n            var restoreEnd = value.length - selectionEnd;\n            var i = 0;\n            while (extendLeft > 0 && lastValue[i] == value[i]) {\n                i++;\n                extendLeft--;\n            }\n            inserted = inserted.slice(i);\n            i = 1;\n            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {\n                i++;\n                extendRight--;\n            }\n            restoreStart -= i - 1;\n            restoreEnd -= i - 1;\n            var endIndex = inserted.length - i + 1;\n            if (endIndex < 0) {\n                extendLeft = -endIndex;\n                endIndex = 0;\n            }\n            inserted = inserted.slice(0, endIndex);\n            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)\n                return \"\";\n            sendingText = true;\n            var shouldReset = false;\n            if (useragent.isAndroid && inserted == \". \") {\n                inserted = \"  \";\n                shouldReset = true;\n            }\n            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {\n                host.onTextInput(inserted);\n            }\n            else {\n                host.onTextInput(inserted, {\n                    extendLeft: extendLeft,\n                    extendRight: extendRight,\n                    restoreStart: restoreStart,\n                    restoreEnd: restoreEnd\n                });\n            }\n            sendingText = false;\n            lastValue = value;\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n            lastRestoreEnd = restoreEnd;\n            return shouldReset ? \"\\n\" : inserted;\n        }\n    };\n    var onInput = function (e) {\n        if (inComposition)\n            return onCompositionUpdate();\n        if (e && e.inputType) {\n            if (e.inputType == \"historyUndo\")\n                return host.execCommand(\"undo\");\n            if (e.inputType == \"historyRedo\")\n                return host.execCommand(\"redo\");\n        }\n        var data = text.value;\n        var inserted = sendText(data, true);\n        if (data.length > MAX_LINE_LENGTH + 100\n            || valueResetRegex.test(inserted)\n            || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {\n            resetSelection();\n        }\n    };\n    var handleClipboardData = function (e, data, forceIEMime) {\n        var clipboardData = e.clipboardData || window[\"clipboardData\"];\n        if (!clipboardData || BROKEN_SETDATA)\n            return;\n        var mime = USE_IE_MIME_TYPE || forceIEMime ? \"Text\" : \"text/plain\";\n        try {\n            if (data) {\n                return clipboardData.setData(mime, data) !== false;\n            }\n            else {\n                return clipboardData.getData(mime);\n            }\n        }\n        catch (e) {\n            if (!forceIEMime)\n                return handleClipboardData(e, data, true);\n        }\n    };\n    var doCopy = function (e, isCut) {\n        var data = host.getCopyText();\n        if (!data)\n            return event.preventDefault(e);\n        if (handleClipboardData(e, data)) {\n            if (isIOS) {\n                resetSelection(data);\n                copied = data;\n                setTimeout(function () {\n                    copied = false;\n                }, 10);\n            }\n            isCut ? host.onCut() : host.onCopy();\n            event.preventDefault(e);\n        }\n        else {\n            copied = true;\n            text.value = data;\n            text.select();\n            setTimeout(function () {\n                copied = false;\n                resetSelection();\n                isCut ? host.onCut() : host.onCopy();\n            });\n        }\n    };\n    var onCut = function (e) {\n        doCopy(e, true);\n    };\n    var onCopy = function (e) {\n        doCopy(e, false);\n    };\n    var onPaste = function (e) {\n        var data = handleClipboardData(e);\n        if (clipboard.pasteCancelled())\n            return;\n        if (typeof data == \"string\") {\n            if (data)\n                host.onPaste(data, e);\n            if (useragent.isIE)\n                setTimeout(resetSelection);\n            event.preventDefault(e);\n        }\n        else {\n            text.value = \"\";\n            pasted = true;\n        }\n    };\n    event.addCommandKeyListener(text, function (e, hashId, keyCode) {\n        if (inComposition)\n            return;\n        return host.onCommandKey(e, hashId, keyCode);\n    }, host);\n    event.addListener(text, \"select\", onSelect, host);\n    event.addListener(text, \"input\", onInput, host);\n    event.addListener(text, \"cut\", onCut, host);\n    event.addListener(text, \"copy\", onCopy, host);\n    event.addListener(text, \"paste\", onPaste, host);\n    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {\n        event.addListener(parentNode, \"keydown\", function (e) {\n            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n                return;\n            switch (e.keyCode) {\n                case 67:\n                    onCopy(e);\n                    break;\n                case 86:\n                    onPaste(e);\n                    break;\n                case 88:\n                    onCut(e);\n                    break;\n            }\n        }, host);\n    }\n    var onCompositionStart = function (e) {\n        if (inComposition || !host.onCompositionStart || host.$readOnly)\n            return;\n        inComposition = {};\n        if (commandMode)\n            return;\n        if (e.data)\n            inComposition.useTextareaForIME = false;\n        setTimeout(onCompositionUpdate, 0);\n        host._signal(\"compositionStart\");\n        host.on(\"mousedown\", cancelComposition);\n        var range = host.getSelectionRange();\n        range.end.row = range.start.row;\n        range.end.column = range.start.column;\n        inComposition.markerRange = range;\n        inComposition.selectionStart = lastSelectionStart;\n        host.onCompositionStart(inComposition);\n        if (inComposition.useTextareaForIME) {\n            lastValue = text.value = \"\";\n            lastSelectionStart = 0;\n            lastSelectionEnd = 0;\n        }\n        else {\n            if (text.msGetInputContext)\n                inComposition.context = text.msGetInputContext();\n            if (text.getInputContext)\n                inComposition.context = text.getInputContext();\n        }\n    };\n    var onCompositionUpdate = function () {\n        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n            return;\n        if (commandMode)\n            return cancelComposition();\n        if (inComposition.useTextareaForIME) {\n            host.onCompositionUpdate(text.value);\n        }\n        else {\n            var data = text.value;\n            sendText(data);\n            if (inComposition.markerRange) {\n                if (inComposition.context) {\n                    inComposition.markerRange.start.column = inComposition.selectionStart\n                        = inComposition.context.compositionStartOffset;\n                }\n                inComposition.markerRange.end.column = inComposition.markerRange.start.column\n                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;\n            }\n        }\n    };\n    var onCompositionEnd = function (e) {\n        if (!host.onCompositionEnd || host.$readOnly)\n            return;\n        inComposition = false;\n        host.onCompositionEnd();\n        host.off(\"mousedown\", cancelComposition);\n        if (e)\n            onInput();\n    };\n    function cancelComposition() {\n        ignoreFocusEvents = true;\n        text.blur();\n        text.focus();\n        ignoreFocusEvents = false;\n    }\n    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);\n    function onKeyup(e) {\n        if (e.keyCode == 27 && text.value.length < text.selectionStart) {\n            if (!inComposition)\n                lastValue = text.value;\n            lastSelectionStart = lastSelectionEnd = -1;\n            resetSelection();\n        }\n        syncComposition();\n    }\n    event.addListener(text, \"compositionstart\", onCompositionStart, host);\n    event.addListener(text, \"compositionupdate\", onCompositionUpdate, host);\n    event.addListener(text, \"keyup\", onKeyup, host);\n    event.addListener(text, \"keydown\", syncComposition, host);\n    event.addListener(text, \"compositionend\", onCompositionEnd, host);\n    this.getElement = function () {\n        return text;\n    };\n    this.setCommandMode = function (value) {\n        commandMode = value;\n        text.readOnly = false;\n    };\n    this.setReadOnly = function (readOnly) {\n        if (!commandMode)\n            text.readOnly = readOnly;\n    };\n    this.setCopyWithEmptySelection = function (value) {\n    };\n    this.onContextMenu = function (e) {\n        afterContextMenu = true;\n        resetSelection();\n        host._emit(\"nativecontextmenu\", { target: host, domEvent: e });\n        this.moveToMouse(e, true);\n    };\n    this.moveToMouse = function (e, bringToFront) {\n        if (!tempStyle)\n            tempStyle = text.style.cssText;\n        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n            + (useragent.isIE ? \"opacity:0.1;\" : \"\")\n            + \"text-indent: -\" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + \"px;\";\n        var rect = host.container.getBoundingClientRect();\n        var style = dom.computedStyle(host.container);\n        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n        var left = rect.left + (parseInt(style.borderLeftWidth) || 0);\n        var maxTop = rect.bottom - top - text.clientHeight - 2;\n        var move = function (e) {\n            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));\n        };\n        move(e);\n        if (e.type != \"mousedown\")\n            return;\n        host.renderer.$isMousePressed = true;\n        clearTimeout(closeTimeout);\n        if (useragent.isWin)\n            event.capture(host.container, move, onContextMenuClose);\n    };\n    this.onContextMenuClose = onContextMenuClose;\n    var closeTimeout;\n    function onContextMenuClose() {\n        clearTimeout(closeTimeout);\n        closeTimeout = setTimeout(function () {\n            if (tempStyle) {\n                text.style.cssText = tempStyle;\n                tempStyle = '';\n            }\n            host.renderer.$isMousePressed = false;\n            if (host.renderer.$keepTextAreaAtCursor)\n                host.renderer.$moveTextAreaToCursor();\n        }, 0);\n    }\n    var onContextMenu = function (e) {\n        host.textInput.onContextMenu(e);\n        onContextMenuClose();\n    };\n    event.addListener(text, \"mouseup\", onContextMenu, host);\n    event.addListener(text, \"mousedown\", function (e) {\n        e.preventDefault();\n        onContextMenuClose();\n    }, host);\n    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu, host);\n    event.addListener(text, \"contextmenu\", onContextMenu, host);\n    if (isIOS)\n        addIosSelectionHandler(parentNode, host, text);\n    function addIosSelectionHandler(parentNode, host, text) {\n        var typingResetTimeout = null;\n        var typing = false;\n        text.addEventListener(\"keydown\", function (e) {\n            if (typingResetTimeout)\n                clearTimeout(typingResetTimeout);\n            typing = true;\n        }, true);\n        text.addEventListener(\"keyup\", function (e) {\n            typingResetTimeout = setTimeout(function () {\n                typing = false;\n            }, 100);\n        }, true);\n        var detectArrowKeys = function (e) {\n            if (document.activeElement !== text)\n                return;\n            if (typing || inComposition || host.$mouseHandler.isMousePressed)\n                return;\n            if (copied) {\n                return;\n            }\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            var key = null;\n            var modifier = 0;\n            if (selectionStart == 0) {\n                key = KEYS.up;\n            }\n            else if (selectionStart == 1) {\n                key = KEYS.home;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == \"\\n\") {\n                key = KEYS.end;\n            }\n            else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == \" \") {\n                key = KEYS.left;\n                modifier = MODS.option;\n            }\n            else if (selectionStart < lastSelectionStart\n                || (selectionStart == lastSelectionStart\n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd)) {\n                key = KEYS.left;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split(\"\\n\").length > 2) {\n                key = KEYS.down;\n            }\n            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == \" \") {\n                key = KEYS.right;\n                modifier = MODS.option;\n            }\n            else if (selectionEnd > lastSelectionEnd\n                || (selectionEnd == lastSelectionEnd\n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd)) {\n                key = KEYS.right;\n            }\n            if (selectionStart !== selectionEnd)\n                modifier |= MODS.shift;\n            if (key) {\n                var result = host.onCommandKey({}, modifier, key);\n                if (!result && host.commands) {\n                    key = KEYS.keyCodeToString(key);\n                    var command = host.commands.findKeyCommand(modifier, key);\n                    if (command)\n                        host.execCommand(command);\n                }\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n                resetSelection(\"\");\n            }\n        };\n        document.addEventListener(\"selectionchange\", detectArrowKeys);\n        host.on(\"destroy\", function () {\n            document.removeEventListener(\"selectionchange\", detectArrowKeys);\n        });\n    }\n    this.destroy = function () {\n        if (text.parentElement)\n            text.parentElement.removeChild(text);\n    };\n};\nexports.TextInput = TextInput;\nexports.$setUserAgentForTests = function (_isMobile, _isIOS) {\n    isMobile = _isMobile;\n    isIOS = _isIOS;\n};\n\n});\n\nace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar useragent = require(\"../lib/useragent\");\nvar DRAG_OFFSET = 0; // pixels\nvar SCROLL_COOLDOWN_T = 550; // milliseconds\nvar DefaultHandlers = /** @class */ (function () {\n    function DefaultHandlers(mouseHandler) {\n        mouseHandler.$clickSelection = null;\n        var editor = mouseHandler.editor;\n        editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n        editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n        editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n        var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n            \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n        exports.forEach(function (x) {\n            mouseHandler[x] = this[x];\n        }, this);\n        mouseHandler[\"selectByLines\"] = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n        mouseHandler[\"selectByWords\"] = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n    }\n    DefaultHandlers.prototype.onMouseDown = function (ev) {\n        var inSelection = ev.inSelection();\n        var pos = ev.getDocumentPosition();\n        this.mousedownEvent = ev;\n        var editor = this.editor;\n        var button = ev.getButton();\n        if (button !== 0) {\n            var selectionRange = editor.getSelectionRange();\n            var selectionEmpty = selectionRange.isEmpty();\n            if (selectionEmpty || button == 1)\n                editor.selection.moveToPosition(pos);\n            if (button == 2) {\n                editor.textInput.onContextMenu(ev.domEvent);\n                if (!useragent.isMozilla)\n                    ev.preventDefault();\n            }\n            return;\n        }\n        this.mousedownEvent.time = Date.now();\n        if (inSelection && !editor.isFocused()) {\n            editor.focus();\n            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {\n                this.setState(\"focusWait\");\n                this.captureMouse(ev);\n                return;\n            }\n        }\n        this.captureMouse(ev);\n        this.startSelect(pos, ev.domEvent._clicks > 1);\n        return ev.preventDefault();\n    };\n    DefaultHandlers.prototype.startSelect = function (pos, waitForClickSelection) {\n        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var editor = this.editor;\n        if (!this.mousedownEvent)\n            return;\n        if (this.mousedownEvent.getShiftKey())\n            editor.selection.selectToPosition(pos);\n        else if (!waitForClickSelection)\n            editor.selection.moveToPosition(pos);\n        if (!waitForClickSelection)\n            this.select();\n        editor.setStyle(\"ace_selecting\");\n        this.setState(\"select\");\n    };\n    DefaultHandlers.prototype.select = function () {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        if (this.$clickSelection) {\n            var cmp = this.$clickSelection.comparePoint(cursor);\n            if (cmp == -1) {\n                anchor = this.$clickSelection.end;\n            }\n            else if (cmp == 1) {\n                anchor = this.$clickSelection.start;\n            }\n            else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n    DefaultHandlers.prototype.extendSelectionBy = function (unitName) {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var range = editor.selection[unitName](cursor.row, cursor.column);\n        if (this.$clickSelection) {\n            var cmpStart = this.$clickSelection.comparePoint(range.start);\n            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n            if (cmpStart == -1 && cmpEnd <= 0) {\n                anchor = this.$clickSelection.end;\n                if (range.end.row != cursor.row || range.end.column != cursor.column)\n                    cursor = range.start;\n            }\n            else if (cmpEnd == 1 && cmpStart >= 0) {\n                anchor = this.$clickSelection.start;\n                if (range.start.row != cursor.row || range.start.column != cursor.column)\n                    cursor = range.end;\n            }\n            else if (cmpStart == -1 && cmpEnd == 1) {\n                cursor = range.end;\n                anchor = range.start;\n            }\n            else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n    DefaultHandlers.prototype.selectByLinesEnd = function () {\n        this.$clickSelection = null;\n        this.editor.unsetStyle(\"ace_selecting\");\n    };\n    DefaultHandlers.prototype.focusWait = function () {\n        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n        var time = Date.now();\n        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)\n            this.startSelect(this.mousedownEvent.getDocumentPosition());\n    };\n    DefaultHandlers.prototype.onDoubleClick = function (ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        var session = editor.session;\n        var range = session.getBracketRange(pos);\n        if (range) {\n            if (range.isEmpty()) {\n                range.start.column--;\n                range.end.column++;\n            }\n            this.setState(\"select\");\n        }\n        else {\n            range = editor.selection.getWordRange(pos.row, pos.column);\n            this.setState(\"selectByWords\");\n        }\n        this.$clickSelection = range;\n        this.select();\n    };\n    DefaultHandlers.prototype.onTripleClick = function (ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        this.setState(\"selectByLines\");\n        var range = editor.getSelectionRange();\n        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n        }\n        else {\n            this.$clickSelection = editor.selection.getLineRange(pos.row);\n        }\n        this.select();\n    };\n    DefaultHandlers.prototype.onQuadClick = function (ev) {\n        var editor = this.editor;\n        editor.selectAll();\n        this.$clickSelection = editor.getSelectionRange();\n        this.setState(\"selectAll\");\n    };\n    DefaultHandlers.prototype.onMouseWheel = function (ev) {\n        if (ev.getAccelKey())\n            return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n        var editor = this.editor;\n        if (!this.$lastScroll)\n            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };\n        var prevScroll = this.$lastScroll;\n        var t = ev.domEvent.timeStamp;\n        var dt = t - prevScroll.t;\n        var vx = dt ? ev.wheelX / dt : prevScroll.vx;\n        var vy = dt ? ev.wheelY / dt : prevScroll.vy;\n        if (dt < SCROLL_COOLDOWN_T) {\n            vx = (vx + prevScroll.vx) / 2;\n            vy = (vy + prevScroll.vy) / 2;\n        }\n        var direction = Math.abs(vx / vy);\n        var canScroll = false;\n        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))\n            canScroll = true;\n        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))\n            canScroll = true;\n        if (canScroll) {\n            prevScroll.allowed = t;\n        }\n        else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {\n            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)\n                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);\n            if (isSlower) {\n                canScroll = true;\n                prevScroll.allowed = t;\n            }\n            else {\n                prevScroll.allowed = 0;\n            }\n        }\n        prevScroll.t = t;\n        prevScroll.vx = vx;\n        prevScroll.vy = vy;\n        if (canScroll) {\n            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    };\n    return DefaultHandlers;\n}());\nDefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;\nDefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;\nDefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;\nexports.DefaultHandlers = DefaultHandlers;\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\nfunction calcRangeOrientation(range, cursor) {\n    if (range.start.row == range.end.row)\n        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n        var cmp = cursor.column - 4;\n    else\n        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n    if (cmp < 0)\n        return { cursor: range.start, anchor: range.end };\n    else\n        return { cursor: range.end, anchor: range.start };\n}\n\n});\n\nace.define(\"ace/lib/scroll\",[\"require\",\"exports\",\"module\"], function(require, exports, module){exports.preventParentScroll = function preventParentScroll(event) {\n    event.stopPropagation();\n    var target = event.currentTarget;\n    var contentOverflows = target.scrollHeight > target.clientHeight;\n    if (!contentOverflows) {\n        event.preventDefault();\n    }\n};\n\n});\n\nace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/range\",\"ace/lib/scroll\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar Range = require(\"./range\").Range;\nvar preventParentScroll = require(\"./lib/scroll\").preventParentScroll;\nvar CLASSNAME = \"ace_tooltip\";\nvar Tooltip = /** @class */ (function () {\n    function Tooltip(parentNode) {\n        this.isOpen = false;\n        this.$element = null;\n        this.$parentNode = parentNode;\n    }\n    Tooltip.prototype.$init = function () {\n        this.$element = dom.createElement(\"div\");\n        this.$element.className = CLASSNAME;\n        this.$element.style.display = \"none\";\n        this.$parentNode.appendChild(this.$element);\n        return this.$element;\n    };\n    Tooltip.prototype.getElement = function () {\n        return this.$element || this.$init();\n    };\n    Tooltip.prototype.setText = function (text) {\n        this.getElement().textContent = text;\n    };\n    Tooltip.prototype.setHtml = function (html) {\n        this.getElement().innerHTML = html;\n    };\n    Tooltip.prototype.setPosition = function (x, y) {\n        this.getElement().style.left = x + \"px\";\n        this.getElement().style.top = y + \"px\";\n    };\n    Tooltip.prototype.setClassName = function (className) {\n        dom.addCssClass(this.getElement(), className);\n    };\n    Tooltip.prototype.setTheme = function (theme) {\n        this.$element.className = CLASSNAME + \" \" +\n            (theme.isDark ? \"ace_dark \" : \"\") + (theme.cssClass || \"\");\n    };\n    Tooltip.prototype.show = function (text, x, y) {\n        if (text != null)\n            this.setText(text);\n        if (x != null && y != null)\n            this.setPosition(x, y);\n        if (!this.isOpen) {\n            this.getElement().style.display = \"block\";\n            this.isOpen = true;\n        }\n    };\n    Tooltip.prototype.hide = function (e) {\n        if (this.isOpen) {\n            this.getElement().style.display = \"none\";\n            this.getElement().className = CLASSNAME;\n            this.isOpen = false;\n        }\n    };\n    Tooltip.prototype.getHeight = function () {\n        return this.getElement().offsetHeight;\n    };\n    Tooltip.prototype.getWidth = function () {\n        return this.getElement().offsetWidth;\n    };\n    Tooltip.prototype.destroy = function () {\n        this.isOpen = false;\n        if (this.$element && this.$element.parentNode) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    };\n    return Tooltip;\n}());\nvar PopupManager = /** @class */ (function () {\n    function PopupManager() {\n        this.popups = [];\n    }\n    PopupManager.prototype.addPopup = function (popup) {\n        this.popups.push(popup);\n        this.updatePopups();\n    };\n    PopupManager.prototype.removePopup = function (popup) {\n        var index = this.popups.indexOf(popup);\n        if (index !== -1) {\n            this.popups.splice(index, 1);\n            this.updatePopups();\n        }\n    };\n    PopupManager.prototype.updatePopups = function () {\n        var e_1, _a, e_2, _b;\n        this.popups.sort(function (a, b) { return b.priority - a.priority; });\n        var visiblepopups = [];\n        try {\n            for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var popup = _d.value;\n                var shouldDisplay = true;\n                try {\n                    for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {\n                        var visiblePopup = visiblepopups_1_1.value;\n                        if (this.doPopupsOverlap(visiblePopup, popup)) {\n                            shouldDisplay = false;\n                            break;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                if (shouldDisplay) {\n                    visiblepopups.push(popup);\n                }\n                else {\n                    popup.hide();\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    PopupManager.prototype.doPopupsOverlap = function (popupA, popupB) {\n        var rectA = popupA.getElement().getBoundingClientRect();\n        var rectB = popupB.getElement().getBoundingClientRect();\n        return (rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom\n            > rectB.top);\n    };\n    return PopupManager;\n}());\nvar popupManager = new PopupManager();\nexports.popupManager = popupManager;\nexports.Tooltip = Tooltip;\nvar HoverTooltip = /** @class */ (function (_super) {\n    __extends(HoverTooltip, _super);\n    function HoverTooltip(parentNode) {\n        if (parentNode === void 0) { parentNode = document.body; }\n        var _this = _super.call(this, parentNode) || this;\n        _this.timeout = undefined;\n        _this.lastT = 0;\n        _this.idleTime = 350;\n        _this.lastEvent = undefined;\n        _this.onMouseOut = _this.onMouseOut.bind(_this);\n        _this.onMouseMove = _this.onMouseMove.bind(_this);\n        _this.waitForHover = _this.waitForHover.bind(_this);\n        _this.hide = _this.hide.bind(_this);\n        var el = _this.getElement();\n        el.style.whiteSpace = \"pre-wrap\";\n        el.style.pointerEvents = \"auto\";\n        el.addEventListener(\"mouseout\", _this.onMouseOut);\n        el.tabIndex = -1;\n        el.addEventListener(\"blur\", function () {\n            if (!el.contains(document.activeElement))\n                this.hide();\n        }.bind(_this));\n        el.addEventListener(\"wheel\", preventParentScroll);\n        return _this;\n    }\n    HoverTooltip.prototype.addToEditor = function (editor) {\n        editor.on(\"mousemove\", this.onMouseMove);\n        editor.on(\"mousedown\", this.hide);\n        editor.renderer.getMouseEventTarget().addEventListener(\"mouseout\", this.onMouseOut, true);\n    };\n    HoverTooltip.prototype.removeFromEditor = function (editor) {\n        editor.off(\"mousemove\", this.onMouseMove);\n        editor.off(\"mousedown\", this.hide);\n        editor.renderer.getMouseEventTarget().removeEventListener(\"mouseout\", this.onMouseOut, true);\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    };\n    HoverTooltip.prototype.onMouseMove = function (e, editor) {\n        this.lastEvent = e;\n        this.lastT = Date.now();\n        var isMousePressed = editor.$mouseHandler.isMousePressed;\n        if (this.isOpen) {\n            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();\n            if (!this.range\n                || !this.range.contains(pos.row, pos.column)\n                || isMousePressed\n                || this.isOutsideOfText(this.lastEvent)) {\n                this.hide();\n            }\n        }\n        if (this.timeout || isMousePressed)\n            return;\n        this.lastEvent = e;\n        this.timeout = setTimeout(this.waitForHover, this.idleTime);\n    };\n    HoverTooltip.prototype.waitForHover = function () {\n        if (this.timeout)\n            clearTimeout(this.timeout);\n        var dt = Date.now() - this.lastT;\n        if (this.idleTime - dt > 10) {\n            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);\n            return;\n        }\n        this.timeout = null;\n        if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {\n            this.$gatherData(this.lastEvent, this.lastEvent.editor);\n        }\n    };\n    HoverTooltip.prototype.isOutsideOfText = function (e) {\n        var editor = e.editor;\n        var docPos = e.getDocumentPosition();\n        var line = editor.session.getLine(docPos.row);\n        if (docPos.column == line.length) {\n            var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);\n            var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);\n            if (clippedPos.column != screenPos.column\n                || clippedPos.row != screenPos.row) {\n                return true;\n            }\n        }\n        return false;\n    };\n    HoverTooltip.prototype.setDataProvider = function (value) {\n        this.$gatherData = value;\n    };\n    HoverTooltip.prototype.showForRange = function (editor, range, domNode, startingEvent) {\n        var MARGIN = 10;\n        if (startingEvent && startingEvent != this.lastEvent)\n            return;\n        if (this.isOpen && document.activeElement == this.getElement())\n            return;\n        var renderer = editor.renderer;\n        if (!this.isOpen) {\n            popupManager.addPopup(this);\n            this.$registerCloseEvents();\n            this.setTheme(renderer.theme);\n        }\n        this.isOpen = true;\n        this.addMarker(range, editor.session);\n        this.range = Range.fromPoints(range.start, range.end);\n        var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);\n        var rect = renderer.scroller.getBoundingClientRect();\n        if (position.pageX < rect.left)\n            position.pageX = rect.left;\n        var element = this.getElement();\n        element.innerHTML = \"\";\n        element.appendChild(domNode);\n        element.style.maxHeight = \"\";\n        element.style.display = \"block\";\n        var labelHeight = element.clientHeight;\n        var labelWidth = element.clientWidth;\n        var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;\n        var isAbove = true;\n        if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {\n            isAbove = false;\n        }\n        element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + \"px\";\n        element.style.top = isAbove ? \"\" : position.pageY + renderer.lineHeight + \"px\";\n        element.style.bottom = isAbove ? window.innerHeight - position.pageY + \"px\" : \"\";\n        element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + \"px\";\n    };\n    HoverTooltip.prototype.addMarker = function (range, session) {\n        if (this.marker) {\n            this.$markerSession.removeMarker(this.marker);\n        }\n        this.$markerSession = session;\n        this.marker = session && session.addMarker(range, \"ace_highlight-marker\", \"text\");\n    };\n    HoverTooltip.prototype.hide = function (e) {\n        if (!e && document.activeElement == this.getElement())\n            return;\n        if (e && e.target && (e.type != \"keydown\" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))\n            return;\n        this.lastEvent = null;\n        if (this.timeout)\n            clearTimeout(this.timeout);\n        this.timeout = null;\n        this.addMarker(null);\n        if (this.isOpen) {\n            this.$removeCloseEvents();\n            this.getElement().style.display = \"none\";\n            this.isOpen = false;\n            popupManager.removePopup(this);\n        }\n    };\n    HoverTooltip.prototype.$registerCloseEvents = function () {\n        window.addEventListener(\"keydown\", this.hide, true);\n        window.addEventListener(\"wheel\", this.hide, true);\n        window.addEventListener(\"mousedown\", this.hide, true);\n    };\n    HoverTooltip.prototype.$removeCloseEvents = function () {\n        window.removeEventListener(\"keydown\", this.hide, true);\n        window.removeEventListener(\"wheel\", this.hide, true);\n        window.removeEventListener(\"mousedown\", this.hide, true);\n    };\n    HoverTooltip.prototype.onMouseOut = function (e) {\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.lastEvent = null;\n        if (!this.isOpen)\n            return;\n        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))\n            return;\n        if (e && e.currentTarget.contains(e.relatedTarget))\n            return;\n        if (!e.relatedTarget.classList.contains(\"ace_content\"))\n            this.hide();\n    };\n    return HoverTooltip;\n}(Tooltip));\nexports.HoverTooltip = HoverTooltip;\n\n});\n\nace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/tooltip\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar Tooltip = require(\"../tooltip\").Tooltip;\nvar nls = require(\"../config\").nls;\nvar GUTTER_TOOLTIP_LEFT_OFFSET = 5;\nvar GUTTER_TOOLTIP_TOP_OFFSET = 3;\nexports.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;\nexports.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;\nfunction GutterHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var gutter = editor.renderer.$gutterLayer;\n    var tooltip = new GutterTooltip(editor, true);\n    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function (e) {\n        if (!editor.isFocused() || e.getButton() != 0)\n            return;\n        var gutterRegion = gutter.getRegion(e);\n        if (gutterRegion == \"foldWidgets\")\n            return;\n        var row = e.getDocumentPosition().row;\n        var selection = editor.session.selection;\n        if (e.getShiftKey())\n            selection.selectTo(row, 0);\n        else {\n            if (e.domEvent.detail == 2) {\n                editor.selectAll();\n                return e.preventDefault();\n            }\n            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n        }\n        mouseHandler.setState(\"selectByLines\");\n        mouseHandler.captureMouse(e);\n        return e.preventDefault();\n    });\n    var tooltipTimeout, mouseEvent;\n    function showTooltip() {\n        var row = mouseEvent.getDocumentPosition().row;\n        var maxRow = editor.session.getLength();\n        if (row == maxRow) {\n            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n            var pos = mouseEvent.$pos;\n            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n                return hideTooltip();\n        }\n        tooltip.showTooltip(row);\n        if (!tooltip.isOpen)\n            return;\n        editor.on(\"mousewheel\", hideTooltip);\n        editor.on(\"changeSession\", hideTooltip);\n        window.addEventListener(\"keydown\", hideTooltip, true);\n        if (mouseHandler.$tooltipFollowsMouse) {\n            moveTooltip(mouseEvent);\n        }\n        else {\n            var gutterRow = mouseEvent.getGutterRow();\n            var gutterCell = gutter.$lines.get(gutterRow);\n            if (gutterCell) {\n                var gutterElement = gutterCell.element.querySelector(\".ace_gutter_annotation\");\n                var rect = gutterElement.getBoundingClientRect();\n                var style = tooltip.getElement().style;\n                style.left = (rect.right - GUTTER_TOOLTIP_LEFT_OFFSET) + \"px\";\n                style.top = (rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET) + \"px\";\n            }\n            else {\n                moveTooltip(mouseEvent);\n            }\n        }\n    }\n    function hideTooltip(e) {\n        if (e && e.type === \"keydown\" && (e.ctrlKey || e.metaKey))\n            return;\n        if (e && e.type === \"mouseout\" && (!e.relatedTarget || tooltip.getElement().contains(e.relatedTarget)))\n            return;\n        if (tooltipTimeout)\n            tooltipTimeout = clearTimeout(tooltipTimeout);\n        if (tooltip.isOpen) {\n            tooltip.hideTooltip();\n            editor.off(\"mousewheel\", hideTooltip);\n            editor.off(\"changeSession\", hideTooltip);\n            window.removeEventListener(\"keydown\", hideTooltip, true);\n        }\n    }\n    function moveTooltip(e) {\n        tooltip.setPosition(e.x, e.y);\n    }\n    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function (e) {\n        var target = e.domEvent.target || e.domEvent.srcElement;\n        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n            return hideTooltip();\n        if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)\n            moveTooltip(e);\n        mouseEvent = e;\n        if (tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function () {\n            tooltipTimeout = null;\n            if (mouseEvent && !mouseHandler.isMousePressed)\n                showTooltip();\n        }, 50);\n    });\n    event.addListener(editor.renderer.$gutter, \"mouseout\", function (e) {\n        mouseEvent = null;\n        if (!tooltip.isOpen)\n            return;\n        tooltipTimeout = setTimeout(function () {\n            tooltipTimeout = null;\n            hideTooltip(e);\n        }, 50);\n    }, editor);\n}\nexports.GutterHandler = GutterHandler;\nvar GutterTooltip = /** @class */ (function (_super) {\n    __extends(GutterTooltip, _super);\n    function GutterTooltip(editor, isHover) {\n        if (isHover === void 0) { isHover = false; }\n        var _this = _super.call(this, editor.container) || this;\n        _this.editor = editor;\n        _this.visibleTooltipRow;\n        var el = _this.getElement();\n        el.setAttribute(\"role\", \"tooltip\");\n        el.style.pointerEvents = \"auto\";\n        if (isHover) {\n            _this.onMouseOut = _this.onMouseOut.bind(_this);\n            el.addEventListener(\"mouseout\", _this.onMouseOut);\n        }\n        return _this;\n    }\n    GutterTooltip.prototype.onMouseOut = function (e) {\n        if (!this.isOpen)\n            return;\n        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))\n            return;\n        if (e && e.currentTarget.contains(e.relatedTarget))\n            return;\n        this.hideTooltip();\n    };\n    GutterTooltip.prototype.setPosition = function (x, y) {\n        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n        var width = this.getWidth();\n        var height = this.getHeight();\n        x += 15;\n        y += 15;\n        if (x + width > windowWidth) {\n            x -= (x + width) - windowWidth;\n        }\n        if (y + height > windowHeight) {\n            y -= 20 + height;\n        }\n        Tooltip.prototype.setPosition.call(this, x, y);\n    };\n    Object.defineProperty(GutterTooltip, \"annotationLabels\", {\n        get: function () {\n            return {\n                error: {\n                    singular: nls(\"gutter-tooltip.aria-label.error.singular\", \"error\"),\n                    plural: nls(\"gutter-tooltip.aria-label.error.plural\", \"errors\")\n                },\n                security: {\n                    singular: nls(\"gutter-tooltip.aria-label.security.singular\", \"security finding\"),\n                    plural: nls(\"gutter-tooltip.aria-label.security.plural\", \"security findings\")\n                },\n                warning: {\n                    singular: nls(\"gutter-tooltip.aria-label.warning.singular\", \"warning\"),\n                    plural: nls(\"gutter-tooltip.aria-label.warning.plural\", \"warnings\")\n                },\n                info: {\n                    singular: nls(\"gutter-tooltip.aria-label.info.singular\", \"information message\"),\n                    plural: nls(\"gutter-tooltip.aria-label.info.plural\", \"information messages\")\n                },\n                hint: {\n                    singular: nls(\"gutter-tooltip.aria-label.hint.singular\", \"suggestion\"),\n                    plural: nls(\"gutter-tooltip.aria-label.hint.plural\", \"suggestions\")\n                }\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    GutterTooltip.prototype.showTooltip = function (row) {\n        var _a;\n        var gutter = this.editor.renderer.$gutterLayer;\n        var annotationsInRow = gutter.$annotations[row];\n        var annotation;\n        if (annotationsInRow)\n            annotation = {\n                displayText: Array.from(annotationsInRow.displayText),\n                type: Array.from(annotationsInRow.type)\n            };\n        else\n            annotation = { displayText: [], type: [] };\n        var fold = gutter.session.getFoldLine(row);\n        if (fold && gutter.$showFoldedAnnotations) {\n            var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };\n            var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };\n            var mostSevereAnnotationTypeInFold;\n            for (var i = row + 1; i <= fold.end.row; i++) {\n                if (!gutter.$annotations[i])\n                    continue;\n                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {\n                    var annotationType = gutter.$annotations[i].type[j];\n                    annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);\n                    if (!mostSevereAnnotationTypeInFold ||\n                        severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {\n                        mostSevereAnnotationTypeInFold = annotationType;\n                    }\n                }\n            }\n            if ([\"error\", \"security\", \"warning\"].includes(mostSevereAnnotationTypeInFold)) {\n                var summaryFoldedAnnotations = \"\".concat(GutterTooltip.annotationsToSummaryString(annotationsInFold), \" in folded code.\");\n                annotation.displayText.push(summaryFoldedAnnotations);\n                annotation.type.push(mostSevereAnnotationTypeInFold + \"_fold\");\n            }\n        }\n        if (annotation.displayText.length === 0)\n            return this.hideTooltip();\n        var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };\n        var iconClassName = gutter.$useSvgGutterIcons ? \"ace_icon_svg\" : \"ace_icon\";\n        for (var i = 0; i < annotation.displayText.length; i++) {\n            var lineElement = dom.createElement(\"span\");\n            var iconElement = dom.createElement(\"span\");\n            (_a = iconElement.classList).add.apply(_a, [\"ace_\".concat(annotation.type[i]), iconClassName]);\n            iconElement.setAttribute(\"aria-label\", \"\".concat(GutterTooltip.annotationLabels[annotation.type[i].replace(\"_fold\", \"\")].singular));\n            iconElement.setAttribute(\"role\", \"img\");\n            iconElement.appendChild(dom.createTextNode(\" \"));\n            lineElement.appendChild(iconElement);\n            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));\n            lineElement.appendChild(dom.createElement(\"br\"));\n            annotationMessages[annotation.type[i].replace(\"_fold\", \"\")].push(lineElement);\n        }\n        var tooltipElement = this.getElement();\n        dom.removeChildren(tooltipElement);\n        annotationMessages.error.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.security.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.warning.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.info.forEach(function (el) { return tooltipElement.appendChild(el); });\n        annotationMessages.hint.forEach(function (el) { return tooltipElement.appendChild(el); });\n        tooltipElement.setAttribute(\"aria-live\", \"polite\");\n        if (!this.isOpen) {\n            this.setTheme(this.editor.renderer.theme);\n            this.setClassName(\"ace_gutter-tooltip\");\n        }\n        this.show();\n        this.visibleTooltipRow = row;\n        this.editor._signal(\"showGutterTooltip\", this);\n    };\n    GutterTooltip.prototype.hideTooltip = function () {\n        if (!this.isOpen) {\n            return;\n        }\n        this.$element.removeAttribute(\"aria-live\");\n        this.hide();\n        this.visibleTooltipRow = undefined;\n        this.editor._signal(\"hideGutterTooltip\", this);\n    };\n    GutterTooltip.annotationsToSummaryString = function (annotations) {\n        var e_1, _a;\n        var summary = [];\n        var annotationTypes = [\"error\", \"security\", \"warning\", \"info\", \"hint\"];\n        try {\n            for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {\n                var annotationType = annotationTypes_1_1.value;\n                if (!annotations[annotationType].length)\n                    continue;\n                var label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;\n                summary.push(\"\".concat(annotations[annotationType].length, \" \").concat(label));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return summary.join(\", \");\n    };\n    return GutterTooltip;\n}(Tooltip));\nexports.GutterTooltip = GutterTooltip;\n\n});\n\nace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar MouseEvent = /** @class */ (function () {\n    function MouseEvent(domEvent, editor) { this.speed; this.wheelX; this.wheelY;\n        this.domEvent = domEvent;\n        this.editor = editor;\n        this.x = this.clientX = domEvent.clientX;\n        this.y = this.clientY = domEvent.clientY;\n        this.$pos = null;\n        this.$inSelection = null;\n        this.propagationStopped = false;\n        this.defaultPrevented = false;\n    }\n    MouseEvent.prototype.stopPropagation = function () {\n        event.stopPropagation(this.domEvent);\n        this.propagationStopped = true;\n    };\n    MouseEvent.prototype.preventDefault = function () {\n        event.preventDefault(this.domEvent);\n        this.defaultPrevented = true;\n    };\n    MouseEvent.prototype.stop = function () {\n        this.stopPropagation();\n        this.preventDefault();\n    };\n    MouseEvent.prototype.getDocumentPosition = function () {\n        if (this.$pos)\n            return this.$pos;\n        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n        return this.$pos;\n    };\n    MouseEvent.prototype.getGutterRow = function () {\n        var documentRow = this.getDocumentPosition().row;\n        var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);\n        var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);\n        return screenRow - screenTopRow;\n    };\n    MouseEvent.prototype.inSelection = function () {\n        if (this.$inSelection !== null)\n            return this.$inSelection;\n        var editor = this.editor;\n        var selectionRange = editor.getSelectionRange();\n        if (selectionRange.isEmpty())\n            this.$inSelection = false;\n        else {\n            var pos = this.getDocumentPosition();\n            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n        }\n        return this.$inSelection;\n    };\n    MouseEvent.prototype.getButton = function () {\n        return event.getButton(this.domEvent);\n    };\n    MouseEvent.prototype.getShiftKey = function () {\n        return this.domEvent.shiftKey;\n    };\n    MouseEvent.prototype.getAccelKey = function () {\n        return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;\n    };\n    return MouseEvent;\n}());\nexports.MouseEvent = MouseEvent;\n\n});\n\nace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar AUTOSCROLL_DELAY = 200;\nvar SCROLL_CURSOR_DELAY = 200;\nvar SCROLL_CURSOR_HYSTERESIS = 5;\nfunction DragdropHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var dragImage = dom.createElement(\"div\");\n    dragImage.style.cssText = \"top:-100px;position:absolute;z-index:2147483647;opacity:0.5\";\n    dragImage.textContent = \"\\xa0\";\n    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n    exports.forEach(function (x) {\n        mouseHandler[x] = this[x];\n    }, this);\n    editor.on(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n    var mouseTarget = editor.container;\n    var dragSelectionMarker, x, y;\n    var timerId, range;\n    var dragCursor, counter = 0;\n    var dragOperation;\n    var isInternal;\n    var autoScrollStartTime;\n    var cursorMovedTime;\n    var cursorPointOnCaretMoved;\n    this.onDragStart = function (e) {\n        if (this.cancelDrag || !mouseTarget.draggable) {\n            var self = this;\n            setTimeout(function () {\n                self.startSelect();\n                self.captureMouse(e);\n            }, 0);\n            return e.preventDefault();\n        }\n        range = editor.getSelectionRange();\n        var dataTransfer = e.dataTransfer;\n        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n        editor.container.appendChild(dragImage);\n        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);\n        setTimeout(function () {\n            editor.container.removeChild(dragImage);\n        });\n        dataTransfer.clearData();\n        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n        isInternal = true;\n        this.setState(\"drag\");\n    };\n    this.onDragEnd = function (e) {\n        mouseTarget.draggable = false;\n        isInternal = false;\n        this.setState(null);\n        if (!editor.getReadOnly()) {\n            var dropEffect = e.dataTransfer.dropEffect;\n            if (!dragOperation && dropEffect == \"move\")\n                editor.session.remove(editor.getSelectionRange());\n            editor.$resetCursorStyle();\n        }\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n    };\n    this.onDragEnter = function (e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker)\n            addDragMarker();\n        counter++;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n    this.onDragOver = function (e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker) {\n            addDragMarker();\n            counter++;\n        }\n        if (onMouseMoveTimer !== null)\n            onMouseMoveTimer = null;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n    this.onDragLeave = function (e) {\n        counter--;\n        if (counter <= 0 && dragSelectionMarker) {\n            clearDragMarker();\n            dragOperation = null;\n            return event.preventDefault(e);\n        }\n    };\n    this.onDrop = function (e) {\n        if (!dragCursor)\n            return;\n        var dataTransfer = e.dataTransfer;\n        if (isInternal) {\n            switch (dragOperation) {\n                case \"move\":\n                    if (range.contains(dragCursor.row, dragCursor.column)) {\n                        range = {\n                            start: dragCursor,\n                            end: dragCursor\n                        };\n                    }\n                    else {\n                        range = editor.moveText(range, dragCursor);\n                    }\n                    break;\n                case \"copy\":\n                    range = editor.moveText(range, dragCursor, true);\n                    break;\n            }\n        }\n        else {\n            var dropData = dataTransfer.getData('Text');\n            range = {\n                start: dragCursor,\n                end: editor.session.insert(dragCursor, dropData)\n            };\n            editor.focus();\n            dragOperation = null;\n        }\n        clearDragMarker();\n        return event.preventDefault(e);\n    };\n    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler), editor);\n    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler), editor);\n    function scrollCursorIntoView(cursor, prevCursor) {\n        var now = Date.now();\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n        if (!cursorMovedTime || vMovement || hMovement) {\n            editor.moveCursorToPosition(cursor);\n            cursorMovedTime = now;\n            cursorPointOnCaretMoved = { x: x, y: y };\n        }\n        else {\n            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n                cursorMovedTime = null;\n            }\n            else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n                editor.renderer.scrollCursorIntoView();\n                cursorMovedTime = null;\n            }\n        }\n    }\n    function autoScroll(cursor, prevCursor) {\n        var now = Date.now();\n        var lineHeight = editor.renderer.layerConfig.lineHeight;\n        var characterWidth = editor.renderer.layerConfig.characterWidth;\n        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n        var offsets = {\n            x: {\n                left: x - editorRect.left,\n                right: editorRect.right - x\n            },\n            y: {\n                top: y - editorRect.top,\n                bottom: editorRect.bottom - y\n            }\n        };\n        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n        var scrollCursor = { row: cursor.row, column: cursor.column };\n        if (nearestXOffset / characterWidth <= 2) {\n            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n        }\n        if (nearestYOffset / lineHeight <= 1) {\n            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n        }\n        var vScroll = cursor.row != scrollCursor.row;\n        var hScroll = cursor.column != scrollCursor.column;\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        if (vScroll || (hScroll && !vMovement)) {\n            if (!autoScrollStartTime)\n                autoScrollStartTime = now;\n            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n                editor.renderer.scrollCursorIntoView(scrollCursor);\n        }\n        else {\n            autoScrollStartTime = null;\n        }\n    }\n    function onDragInterval() {\n        var prevCursor = dragCursor;\n        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n        scrollCursorIntoView(dragCursor, prevCursor);\n        autoScroll(dragCursor, prevCursor);\n    }\n    function addDragMarker() {\n        range = editor.selection.toOrientedRange();\n        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n        editor.clearSelection();\n        if (editor.isFocused())\n            editor.renderer.$cursorLayer.setBlinking(false);\n        clearInterval(timerId);\n        onDragInterval();\n        timerId = setInterval(onDragInterval, 20);\n        counter = 0;\n        event.addListener(document, \"mousemove\", onMouseMove);\n    }\n    function clearDragMarker() {\n        clearInterval(timerId);\n        editor.session.removeMarker(dragSelectionMarker);\n        dragSelectionMarker = null;\n        editor.selection.fromOrientedRange(range);\n        if (editor.isFocused() && !isInternal)\n            editor.$resetCursorStyle();\n        range = null;\n        dragCursor = null;\n        counter = 0;\n        autoScrollStartTime = null;\n        cursorMovedTime = null;\n        event.removeListener(document, \"mousemove\", onMouseMove);\n    }\n    var onMouseMoveTimer = null;\n    function onMouseMove() {\n        if (onMouseMoveTimer == null) {\n            onMouseMoveTimer = setTimeout(function () {\n                if (onMouseMoveTimer != null && dragSelectionMarker)\n                    clearDragMarker();\n            }, 20);\n        }\n    }\n    function canAccept(dataTransfer) {\n        var types = dataTransfer.types;\n        return !types || Array.prototype.some.call(types, function (type) {\n            return type == 'text/plain' || type == 'Text';\n        });\n    }\n    function getDropEffect(e) {\n        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n        var effectAllowed = \"uninitialized\";\n        try {\n            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n        }\n        catch (e) { }\n        var dropEffect = \"none\";\n        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"move\";\n        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        return dropEffect;\n    }\n}\n(function () {\n    this.dragWait = function () {\n        var interval = Date.now() - this.mousedownEvent.time;\n        if (interval > this.editor.getDragDelay())\n            this.startDrag();\n    };\n    this.dragWaitEnd = function () {\n        var target = this.editor.container;\n        target.draggable = false;\n        this.startSelect(this.mousedownEvent.getDocumentPosition());\n        this.selectEnd();\n    };\n    this.dragReadyEnd = function (e) {\n        this.editor.$resetCursorStyle();\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n        this.dragWaitEnd();\n    };\n    this.startDrag = function () {\n        this.cancelDrag = false;\n        var editor = this.editor;\n        var target = editor.container;\n        target.draggable = true;\n        editor.renderer.$cursorLayer.setBlinking(false);\n        editor.setStyle(\"ace_dragging\");\n        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n        editor.renderer.setCursorStyle(cursorStyle);\n        this.setState(\"dragReady\");\n    };\n    this.onMouseDrag = function (e) {\n        var target = this.editor.container;\n        if (useragent.isIE && this.state == \"dragReady\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 3)\n                target.dragDrop();\n        }\n        if (this.state === \"dragWait\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 0) {\n                target.draggable = false;\n                this.startSelect(this.mousedownEvent.getDocumentPosition());\n            }\n        }\n    };\n    this.onMouseDown = function (e) {\n        if (!this.$dragEnabled)\n            return;\n        this.mousedownEvent = e;\n        var editor = this.editor;\n        var inSelection = e.inSelection();\n        var button = e.getButton();\n        var clickCount = e.domEvent.detail || 1;\n        if (clickCount === 1 && button === 0 && inSelection) {\n            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n                return;\n            this.mousedownEvent.time = Date.now();\n            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n            if (\"unselectable\" in eventTarget)\n                eventTarget.unselectable = \"on\";\n            if (editor.getDragDelay()) {\n                if (useragent.isWebKit) {\n                    this.cancelDrag = true;\n                    var mouseTarget = editor.container;\n                    mouseTarget.draggable = true;\n                }\n                this.setState(\"dragWait\");\n            }\n            else {\n                this.startDrag();\n            }\n            this.captureMouse(e, this.onMouseDrag.bind(this));\n            e.defaultPrevented = true;\n        }\n    };\n}).call(DragdropHandler.prototype);\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\nexports.DragdropHandler = DragdropHandler;\n\n});\n\nace.define(\"ace/mouse/touch_handler\",[\"require\",\"exports\",\"module\",\"ace/mouse/mouse_event\",\"ace/lib/event\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar event = require(\"../lib/event\");\nvar dom = require(\"../lib/dom\");\nexports.addTouchListeners = function (el, editor) {\n    var mode = \"scroll\";\n    var startX;\n    var startY;\n    var touchStartT;\n    var lastT;\n    var longTouchTimer;\n    var animationTimer;\n    var animationSteps = 0;\n    var pos;\n    var clickCount = 0;\n    var vX = 0;\n    var vY = 0;\n    var pressed;\n    var contextMenu;\n    function createContextMenu() {\n        var clipboard = window.navigator && window.navigator.clipboard;\n        var isOpen = false;\n        var updateMenu = function () {\n            var selected = editor.getCopyText();\n            var hasUndo = editor.session.getUndoManager().hasUndo();\n            contextMenu.replaceChild(dom.buildDom(isOpen ? [\"span\",\n                !selected && canExecuteCommand(\"selectall\") && [\"span\", { class: \"ace_mobile-button\", action: \"selectall\" }, \"Select All\"],\n                selected && canExecuteCommand(\"copy\") && [\"span\", { class: \"ace_mobile-button\", action: \"copy\" }, \"Copy\"],\n                selected && canExecuteCommand(\"cut\") && [\"span\", { class: \"ace_mobile-button\", action: \"cut\" }, \"Cut\"],\n                clipboard && canExecuteCommand(\"paste\") && [\"span\", { class: \"ace_mobile-button\", action: \"paste\" }, \"Paste\"],\n                hasUndo && canExecuteCommand(\"undo\") && [\"span\", { class: \"ace_mobile-button\", action: \"undo\" }, \"Undo\"],\n                canExecuteCommand(\"find\") && [\"span\", { class: \"ace_mobile-button\", action: \"find\" }, \"Find\"],\n                canExecuteCommand(\"openCommandPalette\") && [\"span\", { class: \"ace_mobile-button\", action: \"openCommandPalette\" }, \"Palette\"]\n            ] : [\"span\"]), contextMenu.firstChild);\n        };\n        var canExecuteCommand = function (/** @type {string} */ cmd) {\n            return editor.commands.canExecute(cmd, editor);\n        };\n        var handleClick = function (e) {\n            var action = e.target.getAttribute(\"action\");\n            if (action == \"more\" || !isOpen) {\n                isOpen = !isOpen;\n                return updateMenu();\n            }\n            if (action == \"paste\") {\n                clipboard.readText().then(function (text) {\n                    editor.execCommand(action, text);\n                });\n            }\n            else if (action) {\n                if (action == \"cut\" || action == \"copy\") {\n                    if (clipboard)\n                        clipboard.writeText(editor.getCopyText());\n                    else\n                        document.execCommand(\"copy\");\n                }\n                editor.execCommand(action);\n            }\n            contextMenu.firstChild.style.display = \"none\";\n            isOpen = false;\n            if (action != \"openCommandPalette\")\n                editor.focus();\n        };\n        contextMenu = dom.buildDom([\"div\",\n            {\n                class: \"ace_mobile-menu\",\n                ontouchstart: function (e) {\n                    mode = \"menu\";\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.textInput.focus();\n                },\n                ontouchend: function (e) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    handleClick(e);\n                },\n                onclick: handleClick\n            },\n            [\"span\"],\n            [\"span\", { class: \"ace_mobile-button\", action: \"more\" }, \"...\"]\n        ], editor.container);\n    }\n    function showContextMenu() {\n        if (!editor.getOption(\"enableMobileMenu\")) {\n            if (contextMenu) {\n                hideContextMenu();\n            }\n            return;\n        }\n        if (!contextMenu)\n            createContextMenu();\n        var cursor = editor.selection.cursor;\n        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);\n        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;\n        var scrollLeft = editor.renderer.scrollLeft;\n        var rect = editor.container.getBoundingClientRect();\n        contextMenu.style.top = pagePos.pageY - rect.top - 3 + \"px\";\n        if (pagePos.pageX - rect.left < rect.width - 70) {\n            contextMenu.style.left = \"\";\n            contextMenu.style.right = \"10px\";\n        }\n        else {\n            contextMenu.style.right = \"\";\n            contextMenu.style.left = leftOffset + scrollLeft - rect.left + \"px\";\n        }\n        contextMenu.style.display = \"\";\n        contextMenu.firstChild.style.display = \"none\";\n        editor.on(\"input\", hideContextMenu);\n    }\n    function hideContextMenu(e) {\n        if (contextMenu)\n            contextMenu.style.display = \"none\";\n        editor.off(\"input\", hideContextMenu);\n    }\n    function handleLongTap() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        var range = editor.selection.getRange();\n        var inSelection = range.contains(pos.row, pos.column);\n        if (range.isEmpty() || !inSelection) {\n            editor.selection.moveToPosition(pos);\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n        showContextMenu();\n    }\n    function switchToSelectionMode() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        editor.selection.moveToPosition(pos);\n        var range = clickCount >= 2\n            ? editor.selection.getLineRange(pos.row)\n            : editor.session.getBracketRange(pos);\n        if (range && !range.isEmpty()) {\n            editor.selection.setRange(range);\n        }\n        else {\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n    }\n    event.addListener(el, \"contextmenu\", function (e) {\n        if (!pressed)\n            return;\n        var textarea = editor.textInput.getElement();\n        textarea.focus();\n    }, editor);\n    event.addListener(el, \"touchstart\", function (e) {\n        var touches = e.touches;\n        if (longTouchTimer || touches.length > 1) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n            touchStartT = -1;\n            mode = \"zoom\";\n            return;\n        }\n        pressed = editor.$mouseHandler.isMousePressed = true;\n        var h = editor.renderer.layerConfig.lineHeight;\n        var w = editor.renderer.layerConfig.lineHeight;\n        var t = e.timeStamp;\n        lastT = t;\n        var touchObj = touches[0];\n        var x = touchObj.clientX;\n        var y = touchObj.clientY;\n        if (Math.abs(startX - x) + Math.abs(startY - y) > h)\n            touchStartT = -1;\n        startX = e.clientX = x;\n        startY = e.clientY = y;\n        vX = vY = 0;\n        var ev = new MouseEvent(e, editor);\n        pos = ev.getDocumentPosition();\n        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {\n            clickCount++;\n            e.preventDefault();\n            e.button = 0;\n            switchToSelectionMode();\n        }\n        else {\n            clickCount = 0;\n            var cursor = editor.selection.cursor;\n            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;\n            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);\n            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);\n            var rect = editor.renderer.scroller.getBoundingClientRect();\n            var offsetTop = editor.renderer.layerConfig.offset;\n            var offsetLeft = editor.renderer.scrollLeft;\n            var weightedDistance = function (x, y) {\n                x = x / w;\n                y = y / h - 0.75;\n                return x * x + y * y;\n            };\n            if (e.clientX < rect.left) {\n                mode = \"zoom\";\n                return;\n            }\n            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);\n            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);\n            if (diff1 < 3.5 && diff2 < 3.5)\n                mode = diff1 > diff2 ? \"cursor\" : \"anchor\";\n            if (diff2 < 3.5)\n                mode = \"anchor\";\n            else if (diff1 < 3.5)\n                mode = \"cursor\";\n            else\n                mode = \"scroll\";\n            longTouchTimer = setTimeout(handleLongTap, 450);\n        }\n        touchStartT = t;\n    }, editor);\n    event.addListener(el, \"touchend\", function (e) {\n        pressed = editor.$mouseHandler.isMousePressed = false;\n        if (animationTimer)\n            clearInterval(animationTimer);\n        if (mode == \"zoom\") {\n            mode = \"\";\n            animationSteps = 0;\n        }\n        else if (longTouchTimer) {\n            editor.selection.moveToPosition(pos);\n            animationSteps = 0;\n            showContextMenu();\n        }\n        else if (mode == \"scroll\") {\n            animate();\n            hideContextMenu();\n        }\n        else {\n            showContextMenu();\n        }\n        clearTimeout(longTouchTimer);\n        longTouchTimer = null;\n    }, editor);\n    event.addListener(el, \"touchmove\", function (e) {\n        if (longTouchTimer) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n        }\n        var touches = e.touches;\n        if (touches.length > 1 || mode == \"zoom\")\n            return;\n        var touchObj = touches[0];\n        var wheelX = startX - touchObj.clientX;\n        var wheelY = startY - touchObj.clientY;\n        if (mode == \"wait\") {\n            if (wheelX * wheelX + wheelY * wheelY > 4)\n                mode = \"cursor\";\n            else\n                return e.preventDefault();\n        }\n        startX = touchObj.clientX;\n        startY = touchObj.clientY;\n        e.clientX = touchObj.clientX;\n        e.clientY = touchObj.clientY;\n        var t = e.timeStamp;\n        var dt = t - lastT;\n        lastT = t;\n        if (mode == \"scroll\") {\n            var mouseEvent = new MouseEvent(e, editor);\n            mouseEvent.speed = 1;\n            mouseEvent.wheelX = wheelX;\n            mouseEvent.wheelY = wheelY;\n            if (10 * Math.abs(wheelX) < Math.abs(wheelY))\n                wheelX = 0;\n            if (10 * Math.abs(wheelY) < Math.abs(wheelX))\n                wheelY = 0;\n            if (dt != 0) {\n                vX = wheelX / dt;\n                vY = wheelY / dt;\n            }\n            editor._emit(\"mousewheel\", mouseEvent);\n            if (!mouseEvent.propagationStopped) {\n                vX = vY = 0;\n            }\n        }\n        else {\n            var ev = new MouseEvent(e, editor);\n            var pos = ev.getDocumentPosition();\n            if (mode == \"cursor\")\n                editor.selection.moveCursorToPosition(pos);\n            else if (mode == \"anchor\")\n                editor.selection.setSelectionAnchor(pos.row, pos.column);\n            editor.renderer.scrollCursorIntoView(pos);\n            e.preventDefault();\n        }\n    }, editor);\n    function animate() {\n        animationSteps += 60;\n        animationTimer = setInterval(function () {\n            if (animationSteps-- <= 0) {\n                clearInterval(animationTimer);\n                animationTimer = null;\n            }\n            if (Math.abs(vX) < 0.01)\n                vX = 0;\n            if (Math.abs(vY) < 0.01)\n                vY = 0;\n            if (animationSteps < 20)\n                vX = 0.9 * vX;\n            if (animationSteps < 20)\n                vY = 0.9 * vY;\n            var oldScrollTop = editor.session.getScrollTop();\n            editor.renderer.scrollBy(10 * vX, 10 * vY);\n            if (oldScrollTop == editor.session.getScrollTop())\n                animationSteps = 0;\n        }, 10);\n    }\n};\n\n});\n\nace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/mouse/touch_handler\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar DefaultHandlers = require(\"./default_handlers\").DefaultHandlers;\nvar DefaultGutterHandler = require(\"./default_gutter_handler\").GutterHandler;\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar DragdropHandler = require(\"./dragdrop_handler\").DragdropHandler;\nvar addTouchListeners = require(\"./touch_handler\").addTouchListeners;\nvar config = require(\"../config\");\nvar MouseHandler = /** @class */ (function () {\n    function MouseHandler(editor) { this.$dragDelay; this.$dragEnabled; this.$mouseMoved; this.mouseEvent; this.$focusTimeout;\n        var _self = this;\n        this.editor = editor;\n        new DefaultHandlers(this);\n        new DefaultGutterHandler(this);\n        new DragdropHandler(this);\n        var focusEditor = function (e) {\n            var windowBlurred = !document.hasFocus || !document.hasFocus()\n                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());\n            if (windowBlurred)\n                window.focus();\n            editor.focus();\n            setTimeout(function () {\n                if (!editor.isFocused())\n                    editor.focus();\n            });\n        };\n        var mouseTarget = editor.renderer.getMouseEventTarget();\n        event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"), editor);\n        event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"), editor);\n        event.addMultiMouseDownListener([\n            mouseTarget,\n            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,\n            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,\n            editor.textInput && editor.textInput.getElement()\n        ].filter(Boolean), [400, 300, 250], this, \"onMouseEvent\", editor);\n        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"), editor);\n        addTouchListeners(editor.container, editor);\n        var gutterEl = editor.renderer.$gutter;\n        event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"), editor);\n        event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"), editor);\n        event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"), editor);\n        event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"), editor);\n        event.addListener(mouseTarget, \"mousedown\", focusEditor, editor);\n        event.addListener(gutterEl, \"mousedown\", focusEditor, editor);\n        if (useragent.isIE && editor.renderer.scrollBarV) {\n            event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor, editor);\n            event.addListener(editor.renderer.scrollBarH.element, \"mousedown\", focusEditor, editor);\n        }\n        editor.on(\"mousemove\", function (e) {\n            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n                return;\n            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);\n            var range = editor.session.selection.getRange();\n            var renderer = editor.renderer;\n            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {\n                renderer.setCursorStyle(\"default\");\n            }\n            else {\n                renderer.setCursorStyle(\"\");\n            }\n        }, //@ts-expect-error TODO: seems mistyping - should be boolean\n        editor);\n    }\n    MouseHandler.prototype.onMouseEvent = function (name, e) {\n        if (!this.editor.session)\n            return;\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n    MouseHandler.prototype.onMouseMove = function (name, e) {\n        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n        if (!listeners || !listeners.length)\n            return;\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n    MouseHandler.prototype.onMouseWheel = function (name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n        this.editor._emit(name, mouseEvent);\n    };\n    MouseHandler.prototype.setState = function (state) {\n        this.state = state;\n    };\n    MouseHandler.prototype.captureMouse = function (ev, mouseMoveHandler) {\n        this.x = ev.x;\n        this.y = ev.y;\n        this.isMousePressed = true;\n        var editor = this.editor;\n        var renderer = this.editor.renderer;\n        renderer.$isMousePressed = true;\n        var self = this;\n        var onMouseMove = function (e) {\n            if (!e)\n                return;\n            if (useragent.isWebKit && !e.which && self.releaseMouse)\n                return self.releaseMouse();\n            self.x = e.clientX;\n            self.y = e.clientY;\n            mouseMoveHandler && mouseMoveHandler(e);\n            self.mouseEvent = new MouseEvent(e, self.editor);\n            self.$mouseMoved = true;\n        };\n        var onCaptureEnd = function (e) {\n            editor.off(\"beforeEndOperation\", onOperationEnd);\n            clearInterval(timerId);\n            if (editor.session)\n                onCaptureInterval();\n            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n            self.state = \"\";\n            self.isMousePressed = renderer.$isMousePressed = false;\n            if (renderer.$keepTextAreaAtCursor)\n                renderer.$moveTextAreaToCursor();\n            self.$onCaptureMouseMove = self.releaseMouse = null;\n            e && self.onMouseEvent(\"mouseup\", e);\n            editor.endOperation();\n        };\n        var onCaptureInterval = function () {\n            self[self.state] && self[self.state]();\n            self.$mouseMoved = false;\n        };\n        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n            return setTimeout(function () { onCaptureEnd(ev); });\n        }\n        var onOperationEnd = function (e) {\n            if (!self.releaseMouse)\n                return;\n            if (editor.curOp.command.name && editor.curOp.selectionChanged) {\n                self[self.state + \"End\"] && self[self.state + \"End\"]();\n                self.state = \"\";\n                self.releaseMouse();\n            }\n        };\n        editor.on(\"beforeEndOperation\", onOperationEnd);\n        editor.startOperation({ command: { name: \"mouse\" } });\n        self.$onCaptureMouseMove = onMouseMove;\n        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n        var timerId = setInterval(onCaptureInterval, 20);\n    };\n    MouseHandler.prototype.cancelContextMenu = function () {\n        var stop = function (e) {\n            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n                return;\n            this.editor.off(\"nativecontextmenu\", stop);\n            if (e && e.domEvent)\n                event.stopEvent(e.domEvent);\n        }.bind(this);\n        setTimeout(stop, 10);\n        this.editor.on(\"nativecontextmenu\", stop);\n    };\n    MouseHandler.prototype.destroy = function () {\n        if (this.releaseMouse)\n            this.releaseMouse();\n    };\n    return MouseHandler;\n}());\nMouseHandler.prototype.releaseMouse = null;\nconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n    scrollSpeed: { initialValue: 2 },\n    dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },\n    dragEnabled: { initialValue: true },\n    focusTimeout: { initialValue: 0 },\n    tooltipFollowsMouse: { initialValue: true }\n});\nexports.MouseHandler = MouseHandler;\n\n});\n\nace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar FoldHandler = /** @class */ (function () {\n    function FoldHandler(editor) {\n        editor.on(\"click\", function (e) {\n            var position = e.getDocumentPosition();\n            var session = editor.session;\n            var fold = session.getFoldAt(position.row, position.column, 1);\n            if (fold) {\n                if (e.getAccelKey())\n                    session.removeFold(fold);\n                else\n                    session.expandFold(fold);\n                e.stop();\n            }\n            var target = e.domEvent && e.domEvent.target;\n            if (target && dom.hasCssClass(target, \"ace_inline_button\")) {\n                if (dom.hasCssClass(target, \"ace_toggle_wrap\")) {\n                    session.setOption(\"wrap\", !session.getUseWrapMode());\n                    editor.renderer.scrollCursorIntoView();\n                }\n            }\n        });\n        editor.on(\"gutterclick\", function (e) {\n            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n            if (gutterRegion == \"foldWidgets\") {\n                var row = e.getDocumentPosition().row;\n                var session = editor.session;\n                if (session.foldWidgets && session.foldWidgets[row])\n                    editor.session.onFoldWidgetClick(row, e);\n                if (!editor.isFocused())\n                    editor.focus();\n                e.stop();\n            }\n        });\n        editor.on(\"gutterdblclick\", function (e) {\n            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n            if (gutterRegion == \"foldWidgets\") {\n                var row = e.getDocumentPosition().row;\n                var session = editor.session;\n                var data = session.getParentFoldRangeData(row, true);\n                var range = data.range || data.firstRange;\n                if (range) {\n                    row = range.start.row;\n                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n                    if (fold) {\n                        session.removeFold(fold);\n                    }\n                    else {\n                        session.addFold(\"...\", range);\n                        editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });\n                    }\n                }\n                e.stop();\n            }\n        });\n    }\n    return FoldHandler;\n}());\nexports.FoldHandler = FoldHandler;\n\n});\n\nace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(require, exports, module){\"use strict\";\nvar keyUtil = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar KeyBinding = /** @class */ (function () {\n    function KeyBinding(editor) {\n        this.$editor = editor;\n        this.$data = { editor: editor };\n        this.$handlers = [];\n        this.setDefaultHandler(editor.commands);\n    }\n    KeyBinding.prototype.setDefaultHandler = function (kb) {\n        this.removeKeyboardHandler(this.$defaultHandler);\n        this.$defaultHandler = kb;\n        this.addKeyboardHandler(kb, 0);\n    };\n    KeyBinding.prototype.setKeyboardHandler = function (kb) {\n        var h = this.$handlers;\n        if (h[h.length - 1] == kb)\n            return;\n        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n            this.removeKeyboardHandler(h[h.length - 1]);\n        this.addKeyboardHandler(kb, 1);\n    };\n    KeyBinding.prototype.addKeyboardHandler = function (kb, pos) {\n        if (!kb)\n            return;\n        if (typeof kb == \"function\" && !kb.handleKeyboard)\n            kb.handleKeyboard = kb;\n        var i = this.$handlers.indexOf(kb);\n        if (i != -1)\n            this.$handlers.splice(i, 1);\n        if (pos == undefined)\n            this.$handlers.push(kb);\n        else\n            this.$handlers.splice(pos, 0, kb);\n        if (i == -1 && kb.attach)\n            kb.attach(this.$editor);\n    };\n    KeyBinding.prototype.removeKeyboardHandler = function (kb) {\n        var i = this.$handlers.indexOf(kb);\n        if (i == -1)\n            return false;\n        this.$handlers.splice(i, 1);\n        kb.detach && kb.detach(this.$editor);\n        return true;\n    };\n    KeyBinding.prototype.getKeyboardHandler = function () {\n        return this.$handlers[this.$handlers.length - 1];\n    };\n    KeyBinding.prototype.getStatusText = function () {\n        var data = this.$data;\n        var editor = data.editor;\n        return this.$handlers.map(function (h) {\n            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n        }).filter(Boolean).join(\" \");\n    };\n    KeyBinding.prototype.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {\n        var toExecute;\n        var success = false;\n        var commands = this.$editor.commands;\n        for (var i = this.$handlers.length; i--;) {\n            toExecute = this.$handlers[i].handleKeyboard(\n            this.$data, hashId, keyString, keyCode, e);\n            if (!toExecute || !toExecute.command)\n                continue;\n            if (toExecute.command == \"null\") {\n                success = true;\n            }\n            else {\n                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);\n            }\n            if (success && e && hashId != -1 &&\n                toExecute[\"passEvent\"] != true && toExecute.command[\"passEvent\"] != true) {\n                event.stopEvent(e);\n            }\n            if (success)\n                break;\n        }\n        if (!success && hashId == -1) {\n            toExecute = { command: \"insertstring\" };\n            success = commands.exec(\"insertstring\", this.$editor, keyString);\n        }\n        if (success && this.$editor._signal)\n            this.$editor._signal(\"keyboardActivity\", toExecute);\n        return success;\n    };\n    KeyBinding.prototype.onCommandKey = function (e, hashId, keyCode) {\n        var keyString = keyUtil.keyCodeToString(keyCode);\n        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n    };\n    KeyBinding.prototype.onTextInput = function (text) {\n        return this.$callKeyboardHandlers(-1, text);\n    };\n    return KeyBinding;\n}());\nexports.KeyBinding = KeyBinding;\n\n});\n\nace.define(\"ace/lib/bidiutil\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar ArabicAlefBetIntervalsBegine = ['\\u0621', '\\u0641'];\nvar ArabicAlefBetIntervalsEnd = ['\\u063A', '\\u064a'];\nvar dir = 0, hiLevel = 0;\nvar lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;\nvar impTab_LTR = [ [0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]\n];\nvar impTab_RTL = [ [2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]\n];\nvar LTR = 0, RTL = 1;\nvar L = 0;\nvar R = 1;\nvar EN = 2;\nvar AN = 3;\nvar ON = 4;\nvar B = 5;\nvar S = 6;\nvar AL = 7;\nvar WS = 8;\nvar CS = 9;\nvar ES = 10;\nvar ET = 11;\nvar NSM = 12;\nvar LRE = 13;\nvar RLE = 14;\nvar PDF = 15;\nvar LRO = 16;\nvar RLO = 17;\nvar BN = 18;\nvar UnicodeTBL00 = [\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,\n    WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,\n    EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,\n    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,\n    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,\n    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,\n    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,\n    BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,\n    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,\n    CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,\n    ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON\n];\nvar UnicodeTBL20 = [\n    WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,\n    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,\n    ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,\n    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS\n];\nfunction _computeLevels(chars, levels, len, charTypes) {\n    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];\n    if (!charTypes) {\n        for (i = 0, charTypes = []; i < len; i++) {\n            charTypes[i] = _getCharacterType(chars[i]);\n        }\n    }\n    hiLevel = dir;\n    lastArabic = false;\n    hasUBAT_AL = false;\n    hasUBAT_B = false;\n    hasUBAT_S = false;\n    for (ix = 0; ix < len; ix++) {\n        prevState = newState;\n        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);\n        newState = impTab[prevState][newClass];\n        action = newState & 0xF0;\n        newState &= 0x0F;\n        levels[ix] = newLevel = impTab[newState][5];\n        if (action > 0) {\n            if (action == 0x10) {\n                for (i = condPos; i < ix; i++) {\n                    levels[i] = 1;\n                }\n                condPos = -1;\n            }\n            else {\n                condPos = -1;\n            }\n        }\n        cond = impTab[newState][6];\n        if (cond) {\n            if (condPos == -1) {\n                condPos = ix;\n            }\n        }\n        else {\n            if (condPos > -1) {\n                for (i = condPos; i < ix; i++) {\n                    levels[i] = newLevel;\n                }\n                condPos = -1;\n            }\n        }\n        if (charTypes[ix] == B) {\n            levels[ix] = 0;\n        }\n        hiLevel |= newLevel;\n    }\n    if (hasUBAT_S) {\n        for (i = 0; i < len; i++) {\n            if (charTypes[i] == S) {\n                levels[i] = dir;\n                for (var j = i - 1; j >= 0; j--) {\n                    if (charTypes[j] == WS) {\n                        levels[j] = dir;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction _invertLevel(lev, levels, _array) {\n    if (hiLevel < lev) {\n        return;\n    }\n    if (lev == 1 && dir == RTL && !hasUBAT_B) {\n        _array.reverse();\n        return;\n    }\n    var len = _array.length, start = 0, end, lo, hi, tmp;\n    while (start < len) {\n        if (levels[start] >= lev) {\n            end = start + 1;\n            while (end < len && levels[end] >= lev) {\n                end++;\n            }\n            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {\n                tmp = _array[lo];\n                _array[lo] = _array[hi];\n                _array[hi] = tmp;\n            }\n            start = end;\n        }\n        start++;\n    }\n}\nfunction _getCharClass(chars, types, classes, ix) {\n    var cType = types[ix], wType, nType, len, i;\n    switch (cType) {\n        case L:\n        case R:\n            lastArabic = false;\n        case ON:\n        case AN:\n            return cType;\n        case EN:\n            return lastArabic ? AN : EN;\n        case AL:\n            lastArabic = true;\n            hasUBAT_AL = true;\n            return R;\n        case WS:\n            return ON;\n        case CS:\n            if (ix < 1 || (ix + 1) >= types.length ||\n                ((wType = classes[ix - 1]) != EN && wType != AN) ||\n                ((nType = types[ix + 1]) != EN && nType != AN)) {\n                return ON;\n            }\n            if (lastArabic) {\n                nType = AN;\n            }\n            return nType == wType ? nType : ON;\n        case ES:\n            wType = ix > 0 ? classes[ix - 1] : B;\n            if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN) {\n                return EN;\n            }\n            return ON;\n        case ET:\n            if (ix > 0 && classes[ix - 1] == EN) {\n                return EN;\n            }\n            if (lastArabic) {\n                return ON;\n            }\n            i = ix + 1;\n            len = types.length;\n            while (i < len && types[i] == ET) {\n                i++;\n            }\n            if (i < len && types[i] == EN) {\n                return EN;\n            }\n            return ON;\n        case NSM:\n            len = types.length;\n            i = ix + 1;\n            while (i < len && types[i] == NSM) {\n                i++;\n            }\n            if (i < len) {\n                var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;\n                wType = types[i];\n                if (rtlCandidate && (wType == R || wType == AL)) {\n                    return R;\n                }\n            }\n            if (ix < 1 || (wType = types[ix - 1]) == B) {\n                return ON;\n            }\n            return classes[ix - 1];\n        case B:\n            lastArabic = false;\n            hasUBAT_B = true;\n            return dir;\n        case S:\n            hasUBAT_S = true;\n            return ON;\n        case LRE:\n        case RLE:\n        case LRO:\n        case RLO:\n        case PDF:\n            lastArabic = false;\n        case BN:\n            return ON;\n    }\n}\nfunction _getCharacterType(ch) {\n    var uc = ch.charCodeAt(0), hi = uc >> 8;\n    if (hi == 0) {\n        return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);\n    }\n    else if (hi == 5) {\n        return (/[\\u0591-\\u05f4]/.test(ch) ? R : L);\n    }\n    else if (hi == 6) {\n        if (/[\\u0610-\\u061a\\u064b-\\u065f\\u06d6-\\u06e4\\u06e7-\\u06ed]/.test(ch))\n            return NSM;\n        else if (/[\\u0660-\\u0669\\u066b-\\u066c]/.test(ch))\n            return AN;\n        else if (uc == 0x066A)\n            return ET;\n        else if (/[\\u06f0-\\u06f9]/.test(ch))\n            return EN;\n        else\n            return AL;\n    }\n    else if (hi == 0x20 && uc <= 0x205F) {\n        return UnicodeTBL20[uc & 0xFF];\n    }\n    else if (hi == 0xFE) {\n        return (uc >= 0xFE70 ? AL : ON);\n    }\n    return ON;\n}\nfunction _isArabicDiacritics(ch) {\n    return (ch >= '\\u064b' && ch <= '\\u0655');\n}\nexports.L = L;\nexports.R = R;\nexports.EN = EN;\nexports.ON_R = 3;\nexports.AN = 4;\nexports.R_H = 5;\nexports.B = 6;\nexports.RLE = 7;\nexports.DOT = \"\\xB7\";\nexports.doBidiReorder = function (text, textCharTypes, isRtl) {\n    if (text.length < 2)\n        return {};\n    var chars = text.split(\"\"), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];\n    dir = isRtl ? RTL : LTR;\n    _computeLevels(chars, levels, chars.length, textCharTypes);\n    for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)\n        ;\n    _invertLevel(2, levels, logicalFromVisual);\n    _invertLevel(1, levels, logicalFromVisual);\n    for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width\n        if (textCharTypes[i] === AN) {\n            levels[i] = exports.AN;\n        }\n        else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)\n            || textCharTypes[i] === ON || textCharTypes[i] === BN)) {\n            levels[i] = exports.ON_R;\n        }\n        else if ((i > 0 && chars[i - 1] === '\\u0644') && /\\u0622|\\u0623|\\u0625|\\u0627/.test(chars[i])) {\n            levels[i - 1] = levels[i] = exports.R_H;\n            i++;\n        }\n    }\n    if (chars[chars.length - 1] === exports.DOT)\n        levels[chars.length - 1] = exports.B;\n    if (chars[0] === '\\u202B')\n        levels[0] = exports.RLE;\n    for (var i = 0; i < logicalFromVisual.length; i++) {\n        bidiLevels[i] = levels[logicalFromVisual[i]];\n    }\n    return { 'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels };\n};\nexports.hasBidiCharacters = function (text, textCharTypes) {\n    var ret = false;\n    for (var i = 0; i < text.length; i++) {\n        textCharTypes[i] = _getCharacterType(text.charAt(i));\n        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))\n            ret = true;\n    }\n    return ret;\n};\nexports.getVisualFromLogicalIdx = function (logIdx, rowMap) {\n    for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {\n        if (rowMap.logicalFromVisual[i] == logIdx)\n            return i;\n    }\n    return 0;\n};\n\n});\n\nace.define(\"ace/bidihandler\",[\"require\",\"exports\",\"module\",\"ace/lib/bidiutil\",\"ace/lib/lang\"], function(require, exports, module){\"use strict\";\nvar bidiUtil = require(\"./lib/bidiutil\");\nvar lang = require(\"./lib/lang\");\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\nvar BidiHandler = /** @class */ (function () {\n    function BidiHandler(session) {\n        this.session = session;\n        this.bidiMap = {};\n        this.currentRow = null;\n        this.bidiUtil = bidiUtil;\n        this.charWidths = [];\n        this.EOL = \"\\xAC\";\n        this.showInvisibles = true;\n        this.isRtlDir = false;\n        this.$isRtl = false;\n        this.line = \"\";\n        this.wrapIndent = 0;\n        this.EOF = \"\\xB6\";\n        this.RLE = \"\\u202B\";\n        this.contentWidth = 0;\n        this.fontMetrics = null;\n        this.rtlLineOffset = 0;\n        this.wrapOffset = 0;\n        this.isMoveLeftOperation = false;\n        this.seenBidi = bidiRE.test(session.getValue());\n    }\n    BidiHandler.prototype.isBidiRow = function (screenRow, docRow, splitIndex) {\n        if (!this.seenBidi)\n            return false;\n        if (screenRow !== this.currentRow) {\n            this.currentRow = screenRow;\n            this.updateRowLine(docRow, splitIndex);\n            this.updateBidiMap();\n        }\n        return this.bidiMap.bidiLevels;\n    };\n    BidiHandler.prototype.onChange = function (delta) {\n        if (!this.seenBidi) {\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\n                this.seenBidi = true;\n                this.currentRow = null;\n            }\n        }\n        else {\n            this.currentRow = null;\n        }\n    };\n    BidiHandler.prototype.getDocumentRow = function () {\n        var docRow = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            if (index >= 0)\n                docRow = this.session.$docRowCache[index];\n        }\n        return docRow;\n    };\n    BidiHandler.prototype.getSplitIndex = function () {\n        var splitIndex = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            while (this.currentRow - splitIndex > 0) {\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\n                if (currentIndex !== prevIndex)\n                    break;\n                prevIndex = currentIndex;\n                splitIndex++;\n            }\n        }\n        else {\n            splitIndex = this.currentRow;\n        }\n        return splitIndex;\n    };\n    BidiHandler.prototype.updateRowLine = function (docRow, splitIndex) {\n        if (docRow === undefined)\n            docRow = this.getDocumentRow();\n        var isLastRow = (docRow === this.session.getLength() - 1), endOfLine = isLastRow ? this.EOF : this.EOL;\n        this.wrapIndent = 0;\n        this.line = this.session.getLine(docRow);\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\n        if (this.session.$useWrapMode) {\n            var splits = this.session.$wrapData[docRow];\n            if (splits) {\n                if (splitIndex === undefined)\n                    splitIndex = this.getSplitIndex();\n                if (splitIndex > 0 && splits.length) {\n                    this.wrapIndent = splits.indent;\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\n                    this.line = (splitIndex < splits.length) ?\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\n                        this.line.substring(splits[splits.length - 1]);\n                }\n                else {\n                    this.line = this.line.substring(0, splits[splitIndex]);\n                }\n                if (splitIndex == splits.length) {\n                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\n                }\n            }\n        }\n        else {\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\n        }\n        var session = this.session, shift = 0, size;\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function (ch, i) {\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\n                shift += size - 1;\n                return lang.stringRepeat(bidiUtil.DOT, size);\n            }\n            return ch;\n        });\n        if (this.isRtlDir) {\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\n        }\n    };\n    BidiHandler.prototype.updateBidiMap = function () {\n        var textCharTypes = [];\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\n            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\n        }\n        else {\n            this.bidiMap = {};\n        }\n    };\n    BidiHandler.prototype.markAsDirty = function () {\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.updateCharacterWidths = function (fontMetrics) {\n        if (this.characterWidth === fontMetrics.$characterSize.width)\n            return;\n        this.fontMetrics = fontMetrics;\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.setShowInvisibles = function (showInvisibles) {\n        this.showInvisibles = showInvisibles;\n        this.currentRow = null;\n    };\n    BidiHandler.prototype.setEolChar = function (eolChar) {\n        this.EOL = eolChar;\n    };\n    BidiHandler.prototype.setContentWidth = function (width) {\n        this.contentWidth = width;\n    };\n    BidiHandler.prototype.isRtlLine = function (row) {\n        if (this.$isRtl)\n            return true;\n        if (row != undefined)\n            return (this.session.getLine(row).charAt(0) == this.RLE);\n        else\n            return this.isRtlDir;\n    };\n    BidiHandler.prototype.setRtlDirection = function (editor, isRtlDir) {\n        var cursor = editor.getCursorPosition();\n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\n                editor.session.doc.removeInLine(row, 0, 1);\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\n                editor.session.doc.insert({ column: 0, row: row }, editor.session.$bidiHandler.RLE);\n        }\n    };\n    BidiHandler.prototype.getPosLeft = function (col) {\n        col -= this.wrapIndent;\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\n            visualIdx++;\n        for (var i = 0; i < visualIdx; i++) {\n            left += this.charWidths[levels[i]];\n        }\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\n            left += this.charWidths[levels[visualIdx]];\n        if (this.wrapIndent)\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        if (this.isRtlDir)\n            left += this.rtlLineOffset;\n        return left;\n    };\n    BidiHandler.prototype.getSelections = function (startCol, endCol) {\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;\n        if (this.wrapIndent)\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\n            logIdx = map.logicalFromVisual[visIdx];\n            level = levels[visIdx];\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\n            if (isSelected && !isSelectedPrev) {\n                selectionStart = offset;\n            }\n            else if (!isSelected && isSelectedPrev) {\n                selections.push({ left: selectionStart, width: offset - selectionStart });\n            }\n            offset += this.charWidths[level];\n            isSelectedPrev = isSelected;\n        }\n        if (isSelected && (visIdx === levels.length)) {\n            selections.push({ left: selectionStart, width: offset - selectionStart });\n        }\n        if (this.isRtlDir) {\n            for (var i = 0; i < selections.length; i++) {\n                selections[i].left += this.rtlLineOffset;\n            }\n        }\n        return selections;\n    };\n    BidiHandler.prototype.offsetToCol = function (posX) {\n        if (this.isRtlDir)\n            posX -= this.rtlLineOffset;\n        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];\n        if (this.wrapIndent)\n            posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n        while (posX > offset + charWidth / 2) {\n            offset += charWidth;\n            if (visualIdx === levels.length - 1) {\n                charWidth = 0;\n                break;\n            }\n            charWidth = this.charWidths[levels[++visualIdx]];\n        }\n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)) {\n            if (posX < offset)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)) {\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\n                : this.bidiMap.logicalFromVisual[visualIdx - 1]);\n        }\n        else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\n            || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))) {\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        else {\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n        if (logicalIdx === 0 && this.isRtlDir)\n            logicalIdx++;\n        return (logicalIdx + this.wrapIndent);\n    };\n    return BidiHandler;\n}());\nexports.BidiHandler = BidiHandler;\n\n});\n\nace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Selection = /** @class */ (function () {\n    function Selection(session) {\n        this.session = session;\n        this.doc = session.getDocument();\n        this.clearSelection();\n        this.cursor = this.lead = this.doc.createAnchor(0, 0);\n        this.anchor = this.doc.createAnchor(0, 0);\n        this.$silent = false;\n        var self = this;\n        this.cursor.on(\"change\", function (e) {\n            self.$cursorChanged = true;\n            if (!self.$silent)\n                self._emit(\"changeCursor\");\n            if (!self.$isEmpty && !self.$silent)\n                self._emit(\"changeSelection\");\n            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n                self.$desiredColumn = null;\n        });\n        this.anchor.on(\"change\", function () {\n            self.$anchorChanged = true;\n            if (!self.$isEmpty && !self.$silent)\n                self._emit(\"changeSelection\");\n        });\n    }\n    Selection.prototype.isEmpty = function () {\n        return this.$isEmpty || (this.anchor.row == this.lead.row &&\n            this.anchor.column == this.lead.column);\n    };\n    Selection.prototype.isMultiLine = function () {\n        return !this.$isEmpty && this.anchor.row != this.cursor.row;\n    };\n    Selection.prototype.getCursor = function () {\n        return this.lead.getPosition();\n    };\n    Selection.prototype.setAnchor = function (row, column) {\n        this.$isEmpty = false;\n        this.anchor.setPosition(row, column);\n    };\n    Selection.prototype.getAnchor = function () {\n        if (this.$isEmpty)\n            return this.getSelectionLead();\n        return this.anchor.getPosition();\n    };\n    Selection.prototype.getSelectionLead = function () {\n        return this.lead.getPosition();\n    };\n    Selection.prototype.isBackwards = function () {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n    };\n    Selection.prototype.getRange = function () {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        if (this.$isEmpty)\n            return Range.fromPoints(lead, lead);\n        return this.isBackwards()\n            ? Range.fromPoints(lead, anchor)\n            : Range.fromPoints(anchor, lead);\n    };\n    Selection.prototype.clearSelection = function () {\n        if (!this.$isEmpty) {\n            this.$isEmpty = true;\n            this._emit(\"changeSelection\");\n        }\n    };\n    Selection.prototype.selectAll = function () {\n        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);\n    };\n    Selection.prototype.setRange = function (range, reverse) {\n        var start = reverse ? range.end : range.start;\n        var end = reverse ? range.start : range.end;\n        this.$setSelection(start.row, start.column, end.row, end.column);\n    };\n    Selection.prototype.$setSelection = function (anchorRow, anchorColumn, cursorRow, cursorColumn) {\n        if (this.$silent)\n            return;\n        var wasEmpty = this.$isEmpty;\n        var wasMultiselect = this.inMultiSelectMode;\n        this.$silent = true;\n        this.$cursorChanged = this.$anchorChanged = false;\n        this.anchor.setPosition(anchorRow, anchorColumn);\n        this.cursor.setPosition(cursorRow, cursorColumn);\n        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);\n        this.$silent = false;\n        if (this.$cursorChanged)\n            this._emit(\"changeCursor\");\n        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)\n            this._emit(\"changeSelection\");\n    };\n    Selection.prototype.$moveSelection = function (mover) {\n        var lead = this.lead;\n        if (this.$isEmpty)\n            this.setSelectionAnchor(lead.row, lead.column);\n        mover.call(this);\n    };\n    Selection.prototype.selectTo = function (row, column) {\n        this.$moveSelection(function () {\n            this.moveCursorTo(row, column);\n        });\n    };\n    Selection.prototype.selectToPosition = function (pos) {\n        this.$moveSelection(function () {\n            this.moveCursorToPosition(pos);\n        });\n    };\n    Selection.prototype.moveTo = function (row, column) {\n        this.clearSelection();\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveToPosition = function (pos) {\n        this.clearSelection();\n        this.moveCursorToPosition(pos);\n    };\n    Selection.prototype.selectUp = function () {\n        this.$moveSelection(this.moveCursorUp);\n    };\n    Selection.prototype.selectDown = function () {\n        this.$moveSelection(this.moveCursorDown);\n    };\n    Selection.prototype.selectRight = function () {\n        this.$moveSelection(this.moveCursorRight);\n    };\n    Selection.prototype.selectLeft = function () {\n        this.$moveSelection(this.moveCursorLeft);\n    };\n    Selection.prototype.selectLineStart = function () {\n        this.$moveSelection(this.moveCursorLineStart);\n    };\n    Selection.prototype.selectLineEnd = function () {\n        this.$moveSelection(this.moveCursorLineEnd);\n    };\n    Selection.prototype.selectFileEnd = function () {\n        this.$moveSelection(this.moveCursorFileEnd);\n    };\n    Selection.prototype.selectFileStart = function () {\n        this.$moveSelection(this.moveCursorFileStart);\n    };\n    Selection.prototype.selectWordRight = function () {\n        this.$moveSelection(this.moveCursorWordRight);\n    };\n    Selection.prototype.selectWordLeft = function () {\n        this.$moveSelection(this.moveCursorWordLeft);\n    };\n    Selection.prototype.getWordRange = function (row, column) {\n        if (typeof column == \"undefined\") {\n            var cursor = row || this.lead;\n            row = cursor.row;\n            column = cursor.column;\n        }\n        return this.session.getWordRange(row, column);\n    };\n    Selection.prototype.selectWord = function () {\n        this.setSelectionRange(this.getWordRange());\n    };\n    Selection.prototype.selectAWord = function () {\n        var cursor = this.getCursor();\n        var range = this.session.getAWordRange(cursor.row, cursor.column);\n        this.setSelectionRange(range);\n    };\n    Selection.prototype.getLineRange = function (row, excludeLastChar) {\n        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n        var rowEnd;\n        var foldLine = this.session.getFoldLine(rowStart);\n        if (foldLine) {\n            rowStart = foldLine.start.row;\n            rowEnd = foldLine.end.row;\n        }\n        else {\n            rowEnd = rowStart;\n        }\n        if (excludeLastChar === true)\n            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n        else\n            return new Range(rowStart, 0, rowEnd + 1, 0);\n    };\n    Selection.prototype.selectLine = function () {\n        this.setSelectionRange(this.getLineRange());\n    };\n    Selection.prototype.moveCursorUp = function () {\n        this.moveCursorBy(-1, 0);\n    };\n    Selection.prototype.moveCursorDown = function () {\n        this.moveCursorBy(1, 0);\n    };\n    Selection.prototype.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {\n        var start = cursor.column;\n        var end = cursor.column + tabSize;\n        if (direction < 0) {\n            start = cursor.column - tabSize;\n            end = cursor.column;\n        }\n        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(\" \").length - 1 == tabSize;\n    };\n    Selection.prototype.moveCursorLeft = function () {\n        var cursor = this.lead.getPosition(), fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n        }\n        else if (cursor.column === 0) {\n            if (cursor.row > 0) {\n                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, -tabSize);\n            }\n            else {\n                this.moveCursorBy(0, -1);\n            }\n        }\n    };\n    Selection.prototype.moveCursorRight = function () {\n        var cursor = this.lead.getPosition(), fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n        }\n        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n            if (this.lead.row < this.doc.getLength() - 1) {\n                this.moveCursorTo(this.lead.row + 1, 0);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            var cursor = this.lead;\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, tabSize);\n            }\n            else {\n                this.moveCursorBy(0, 1);\n            }\n        }\n    };\n    Selection.prototype.moveCursorLineStart = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var screenRow = this.session.documentToScreenRow(row, column);\n        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);\n        var leadingSpace = beforeCursor.match(/^\\s*/);\n        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n            firstColumnPosition.column += leadingSpace[0].length;\n        this.moveCursorToPosition(firstColumnPosition);\n    };\n    Selection.prototype.moveCursorLineEnd = function () {\n        var lead = this.lead;\n        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n        if (this.lead.column == lineEnd.column) {\n            var line = this.session.getLine(lineEnd.row);\n            if (lineEnd.column == line.length) {\n                var textEnd = line.search(/\\s+$/);\n                if (textEnd > 0)\n                    lineEnd.column = textEnd;\n            }\n        }\n        this.moveCursorTo(lineEnd.row, lineEnd.column);\n    };\n    Selection.prototype.moveCursorFileEnd = function () {\n        var row = this.doc.getLength() - 1;\n        var column = this.doc.getLine(row).length;\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveCursorFileStart = function () {\n        this.moveCursorTo(0, 0);\n    };\n    Selection.prototype.moveCursorLongWordRight = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n            return;\n        }\n        if (this.session.nonTokenRe.exec(rightOfCursor)) {\n            column += this.session.nonTokenRe.lastIndex;\n            this.session.nonTokenRe.lastIndex = 0;\n            rightOfCursor = line.substring(column);\n        }\n        if (column >= line.length) {\n            this.moveCursorTo(row, line.length);\n            this.moveCursorRight();\n            if (row < this.doc.getLength() - 1)\n                this.moveCursorWordRight();\n            return;\n        }\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            column += this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.moveCursorLongWordLeft = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n            return;\n        }\n        var str = this.session.getFoldStringAt(row, column, -1);\n        if (str == null) {\n            str = this.doc.getLine(row).substring(0, column);\n        }\n        var leftOfCursor = lang.stringReverse(str);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        if (this.session.nonTokenRe.exec(leftOfCursor)) {\n            column -= this.session.nonTokenRe.lastIndex;\n            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n            this.session.nonTokenRe.lastIndex = 0;\n        }\n        if (column <= 0) {\n            this.moveCursorTo(row, 0);\n            this.moveCursorLeft();\n            if (row > 0)\n                this.moveCursorWordLeft();\n            return;\n        }\n        if (this.session.tokenRe.exec(leftOfCursor)) {\n            column -= this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n        this.moveCursorTo(row, column);\n    };\n    Selection.prototype.$shortWordEndIndex = function (rightOfCursor) {\n        var index = 0, ch;\n        var whitespaceRe = /\\s/;\n        var tokenRe = this.session.tokenRe;\n        tokenRe.lastIndex = 0;\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            index = this.session.tokenRe.lastIndex;\n        }\n        else {\n            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                index++;\n            if (index < 1) {\n                tokenRe.lastIndex = 0;\n                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n                    tokenRe.lastIndex = 0;\n                    index++;\n                    if (whitespaceRe.test(ch)) {\n                        if (index > 2) {\n                            index--;\n                            break;\n                        }\n                        else {\n                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                                index++;\n                            if (index > 2)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        tokenRe.lastIndex = 0;\n        return index;\n    };\n    Selection.prototype.moveCursorShortWordRight = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold)\n            return this.moveCursorTo(fold.end.row, fold.end.column);\n        if (column == line.length) {\n            var l = this.doc.getLength();\n            do {\n                row++;\n                rightOfCursor = this.doc.getLine(row);\n            } while (row < l && /^\\s*$/.test(rightOfCursor));\n            if (!/^\\s+/.test(rightOfCursor))\n                rightOfCursor = \"\";\n            column = 0;\n        }\n        var index = this.$shortWordEndIndex(rightOfCursor);\n        this.moveCursorTo(row, column + index);\n    };\n    Selection.prototype.moveCursorShortWordLeft = function () {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1))\n            return this.moveCursorTo(fold.start.row, fold.start.column);\n        var line = this.session.getLine(row).substring(0, column);\n        if (column === 0) {\n            do {\n                row--;\n                line = this.doc.getLine(row);\n            } while (row > 0 && /^\\s*$/.test(line));\n            column = line.length;\n            if (!/\\s+$/.test(line))\n                line = \"\";\n        }\n        var leftOfCursor = lang.stringReverse(line);\n        var index = this.$shortWordEndIndex(leftOfCursor);\n        return this.moveCursorTo(row, column - index);\n    };\n    Selection.prototype.moveCursorWordRight = function () {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordRight();\n        else\n            this.moveCursorShortWordRight();\n    };\n    Selection.prototype.moveCursorWordLeft = function () {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordLeft();\n        else\n            this.moveCursorShortWordLeft();\n    };\n    Selection.prototype.moveCursorBy = function (rows, chars) {\n        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);\n        var offsetX;\n        if (chars === 0) {\n            if (rows !== 0) {\n                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {\n                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);\n                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);\n                }\n                else {\n                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];\n                }\n            }\n            if (this.$desiredColumn)\n                screenPos.column = this.$desiredColumn;\n            else\n                this.$desiredColumn = screenPos.column;\n        }\n        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {\n            var widget = this.session.lineWidgets[this.lead.row];\n            if (rows < 0)\n                rows -= widget.rowsAbove || 0;\n            else if (rows > 0)\n                rows += widget.rowCount - (widget.rowsAbove || 0);\n        }\n        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);\n        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n        }\n        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n    };\n    Selection.prototype.moveCursorToPosition = function (position) {\n        this.moveCursorTo(position.row, position.column);\n    };\n    Selection.prototype.moveCursorTo = function (row, column, keepDesiredColumn) {\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            row = fold.start.row;\n            column = fold.start.column;\n        }\n        this.$keepDesiredColumnOnChange = true;\n        var line = this.session.getLine(row);\n        if (/[\\uDC00-\\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {\n            if (this.lead.row == row && this.lead.column == column + 1)\n                column = column - 1;\n            else\n                column = column + 1;\n        }\n        this.lead.setPosition(row, column);\n        this.$keepDesiredColumnOnChange = false;\n        if (!keepDesiredColumn)\n            this.$desiredColumn = null;\n    };\n    Selection.prototype.moveCursorToScreen = function (row, column, keepDesiredColumn) {\n        var pos = this.session.screenToDocumentPosition(row, column);\n        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n    };\n    Selection.prototype.detach = function () {\n        this.lead.detach();\n        this.anchor.detach();\n    };\n    Selection.prototype.fromOrientedRange = function (range) {\n        this.setSelectionRange(range, range.cursor == range.start);\n        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n    };\n    Selection.prototype.toOrientedRange = function (range) {\n        var r = this.getRange();\n        if (range) {\n            range.start.column = r.start.column;\n            range.start.row = r.start.row;\n            range.end.column = r.end.column;\n            range.end.row = r.end.row;\n        }\n        else {\n            range = r;\n        }\n        range.cursor = this.isBackwards() ? range.start : range.end;\n        range.desiredColumn = this.$desiredColumn;\n        return range;\n    };\n    Selection.prototype.getRangeOfMovements = function (func) {\n        var start = this.getCursor();\n        try {\n            func(this);\n            var end = this.getCursor();\n            return Range.fromPoints(start, end);\n        }\n        catch (e) {\n            return Range.fromPoints(start, start);\n        }\n        finally {\n            this.moveCursorToPosition(start);\n        }\n    };\n    Selection.prototype.toJSON = function () {\n        if (this.rangeCount) { var data = this.ranges.map(function (r) {\n                var r1 = r.clone();\n                r1.isBackwards = r.cursor == r.start;\n                return r1;\n            });\n        }\n        else { var data = this.getRange();\n            data.isBackwards = this.isBackwards();\n        }\n        return data;\n    };\n    Selection.prototype.fromJSON = function (data) {\n        if (data.start == undefined) {\n            if (this.rangeList && data.length > 1) {\n                this.toSingleRange(data[0]);\n                for (var i = data.length; i--;) {\n                    var r = Range.fromPoints(data[i].start, data[i].end);\n                    if (data[i].isBackwards)\n                        r.cursor = r.start;\n                    this.addRange(r, true);\n                }\n                return;\n            }\n            else {\n                data = data[0];\n            }\n        }\n        if (this.rangeList)\n            this.toSingleRange(data);\n        this.setSelectionRange(data, data.isBackwards);\n    };\n    Selection.prototype.isEqual = function (data) {\n        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n            return false;\n        if (!data.length || !this.ranges)\n            return this.getRange().isEqual(data);\n        for (var i = this.ranges.length; i--;) {\n            if (!this.ranges[i].isEqual(data[i]))\n                return false;\n        }\n        return true;\n    };\n    return Selection;\n}());\nSelection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;\nSelection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;\nSelection.prototype.setSelectionRange = Selection.prototype.setRange;\noop.implement(Selection.prototype, EventEmitter);\nexports.Selection = Selection;\n\n});\n\nace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/report_error\"], function(require, exports, module){\"use strict\";\nvar reportError = require(\"./lib/report_error\").reportError;\nvar MAX_TOKEN_COUNT = 2000;\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(rules) {\n        this.splitRegex;\n        this.states = rules;\n        this.regExps = {};\n        this.matchMappings = {};\n        for (var key in this.states) {\n            var state = this.states[key];\n            var ruleRegExps = [];\n            var matchTotal = 0;\n            var mapping = this.matchMappings[key] = { defaultToken: \"text\" };\n            var flag = \"g\";\n            var splitterRurles = [];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.defaultToken)\n                    mapping.defaultToken = rule.defaultToken;\n                if (rule.caseInsensitive && flag.indexOf(\"i\") === -1)\n                    flag += \"i\";\n                if (rule.unicode && flag.indexOf(\"u\") === -1)\n                    flag += \"u\";\n                if (rule.regex == null)\n                    continue;\n                if (rule.regex instanceof RegExp)\n                    rule.regex = rule.regex.toString().slice(1, -1);\n                var adjustedregex = rule.regex;\n                var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n                if (Array.isArray(rule.token)) {\n                    if (rule.token.length == 1 || matchcount == 1) {\n                        rule.token = rule.token[0];\n                    }\n                    else if (matchcount - 1 != rule.token.length) {\n                        this.reportError(\"number of classes and regexp groups doesn't match\", {\n                            rule: rule,\n                            groupCount: matchcount - 1\n                        });\n                        rule.token = rule.token[0];\n                    }\n                    else {\n                        rule.tokenArray = rule.token;\n                        rule.token = null;\n                        rule.onMatch = this.$arrayTokens;\n                    }\n                }\n                else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                    if (matchcount > 1)\n                        rule.onMatch = this.$applyToken;\n                    else\n                        rule.onMatch = rule.token;\n                }\n                if (matchcount > 1) {\n                    if (/\\\\\\d/.test(rule.regex)) {\n                        adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function (match, digit) {\n                            return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                        });\n                    }\n                    else {\n                        matchcount = 1;\n                        adjustedregex = this.removeCapturingGroups(rule.regex);\n                    }\n                    if (!rule.splitRegex && typeof rule.token != \"string\")\n                        splitterRurles.push(rule); // flag will be known only at the very end\n                }\n                mapping[matchTotal] = i;\n                matchTotal += matchcount;\n                ruleRegExps.push(adjustedregex);\n                if (!rule.onMatch)\n                    rule.onMatch = null;\n            }\n            if (!ruleRegExps.length) {\n                mapping[0] = 0;\n                ruleRegExps.push(\"$\");\n            }\n            splitterRurles.forEach(function (rule) {\n                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n            }, this);\n            this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n        }\n    }\n    Tokenizer.prototype.$setMaxTokenCount = function (m) {\n        MAX_TOKEN_COUNT = m | 0;\n    };\n    Tokenizer.prototype.$applyToken = function (str) {\n        var values = this.splitRegex.exec(str).slice(1);\n        var types = this.token.apply(this, values);\n        if (typeof types === \"string\")\n            return [{ type: types, value: str }];\n        var tokens = [];\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i]\n                };\n        }\n        return tokens;\n    };\n    Tokenizer.prototype.$arrayTokens = function (str) {\n        if (!str)\n            return [];\n        var values = this.splitRegex.exec(str);\n        if (!values)\n            return \"text\";\n        var tokens = [];\n        var types = this.tokenArray;\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i + 1])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i + 1]\n                };\n        }\n        return tokens;\n    };\n    Tokenizer.prototype.removeCapturingGroups = function (src) {\n        var r = src.replace(/\\\\.|\\[(?:\\\\.|[^\\\\\\]])*|\\(\\?[:=!<]|(\\()/g, function (x, y) { return y ? \"(?:\" : x; });\n        return r;\n    };\n    Tokenizer.prototype.createSplitterRegexp = function (src, flag) {\n        if (src.indexOf(\"(?=\") != -1) {\n            var stack = 0;\n            var inChClass = false;\n            var lastCapture = {};\n            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function (m, esc, parenOpen, parenClose, square, index) {\n                if (inChClass) {\n                    inChClass = square != \"]\";\n                }\n                else if (square) {\n                    inChClass = true;\n                }\n                else if (parenClose) {\n                    if (stack == lastCapture.stack) {\n                        lastCapture.end = index + 1;\n                        lastCapture.stack = -1;\n                    }\n                    stack--;\n                }\n                else if (parenOpen) {\n                    stack++;\n                    if (parenOpen.length != 1) {\n                        lastCapture.stack = stack;\n                        lastCapture.start = index;\n                    }\n                }\n                return m;\n            });\n            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n        }\n        if (src.charAt(0) != \"^\")\n            src = \"^\" + src;\n        if (src.charAt(src.length - 1) != \"$\")\n            src += \"$\";\n        return new RegExp(src, (flag || \"\").replace(\"g\", \"\"));\n    };\n    Tokenizer.prototype.getLineTokens = function (line, startState) {\n        if (startState && typeof startState != \"string\") {\n            var stack = startState.slice(0);\n            startState = stack[0];\n            if (startState === \"#tmp\") {\n                stack.shift();\n                startState = stack.shift();\n            }\n        }\n        else\n            var stack = [];\n        var currentState = /**@type{string}*/ (startState) || \"start\";\n        var state = this.states[currentState];\n        if (!state) {\n            currentState = \"start\";\n            state = this.states[currentState];\n        }\n        var mapping = this.matchMappings[currentState];\n        var re = this.regExps[currentState];\n        re.lastIndex = 0;\n        var match, tokens = [];\n        var lastIndex = 0;\n        var matchAttempts = 0;\n        var token = { type: null, value: \"\" };\n        while (match = re.exec(line)) {\n            var type = mapping.defaultToken;\n            var rule = null;\n            var value = match[0];\n            var index = re.lastIndex;\n            if (index - value.length > lastIndex) {\n                var skipped = line.substring(lastIndex, index - value.length);\n                if (token.type == type) {\n                    token.value += skipped;\n                }\n                else {\n                    if (token.type)\n                        tokens.push(token);\n                    token = { type: type, value: skipped };\n                }\n            }\n            for (var i = 0; i < match.length - 2; i++) {\n                if (match[i + 1] === undefined)\n                    continue;\n                rule = state[mapping[i]];\n                if (rule.onMatch)\n                    type = rule.onMatch(value, currentState, stack, line);\n                else\n                    type = rule.token;\n                if (rule.next) {\n                    if (typeof rule.next == \"string\") {\n                        currentState = rule.next;\n                    }\n                    else {\n                        currentState = rule.next(currentState, stack);\n                    }\n                    state = this.states[currentState];\n                    if (!state) {\n                        this.reportError(\"state doesn't exist\", currentState);\n                        currentState = \"start\";\n                        state = this.states[currentState];\n                    }\n                    mapping = this.matchMappings[currentState];\n                    lastIndex = index;\n                    re = this.regExps[currentState];\n                    re.lastIndex = index;\n                }\n                if (rule.consumeLineEnd)\n                    lastIndex = index;\n                break;\n            }\n            if (value) {\n                if (typeof type === \"string\") {\n                    if ((!rule || rule.merge !== false) && token.type === type) {\n                        token.value += value;\n                    }\n                    else {\n                        if (token.type)\n                            tokens.push(token);\n                        token = { type: type, value: value };\n                    }\n                }\n                else if (type) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = { type: null, value: \"\" };\n                    for (var i = 0; i < type.length; i++)\n                        tokens.push(type[i]);\n                }\n            }\n            if (lastIndex == line.length)\n                break;\n            lastIndex = index;\n            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n                if (matchAttempts > 2 * line.length) {\n                    this.reportError(\"infinite loop with in ace tokenizer\", {\n                        startState: startState,\n                        line: line\n                    });\n                }\n                while (lastIndex < line.length) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {\n                        value: line.substring(lastIndex, lastIndex += 500),\n                        type: \"overflow\"\n                    };\n                }\n                currentState = \"start\";\n                stack = [];\n                break;\n            }\n        }\n        if (token.type)\n            tokens.push(token);\n        if (stack.length > 1) {\n            if (stack[0] !== currentState)\n                stack.unshift(\"#tmp\", currentState);\n        }\n        return {\n            tokens: tokens,\n            state: stack.length ? stack : currentState\n        };\n    };\n    return Tokenizer;\n}());\nTokenizer.prototype.reportError = reportError;\nexports.Tokenizer = Tokenizer;\n\n});\n\nace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/deep_copy\"], function(require, exports, module){\"use strict\";\nvar deepCopy = require(\"../lib/deep_copy\").deepCopy;\nvar TextHighlightRules;\nTextHighlightRules = function () {\n    this.$rules = {\n        \"start\": [{\n                token: \"empty_line\",\n                regex: '^$'\n            }, {\n                defaultToken: \"text\"\n            }]\n    };\n};\n(function () {\n    this.addRules = function (rules, prefix) {\n        if (!prefix) {\n            for (var key in rules)\n                this.$rules[key] = rules[key];\n            return;\n        }\n        for (var key in rules) {\n            var state = rules[key];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.next || rule.onMatch) {\n                    if (typeof rule.next == \"string\") {\n                        if (rule.next.indexOf(prefix) !== 0)\n                            rule.next = prefix + rule.next;\n                    }\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n                        rule.nextState = prefix + rule.nextState;\n                }\n            }\n            this.$rules[prefix + key] = state;\n        }\n    };\n    this.getRules = function () {\n        return this.$rules;\n    };\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n        var embedRules = typeof HighlightRules == \"function\"\n            ? new HighlightRules().getRules()\n            : HighlightRules;\n        if (states) {\n            for (var i = 0; i < states.length; i++)\n                states[i] = prefix + states[i];\n        }\n        else {\n            states = [];\n            for (var key in embedRules)\n                states.push(prefix + key);\n        }\n        this.addRules(embedRules, prefix);\n        if (escapeRules) {\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n            for (var i = 0; i < states.length; i++)\n                addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));\n        }\n        if (!this.$embeds)\n            this.$embeds = [];\n        this.$embeds.push(prefix);\n    };\n    this.getEmbeds = function () {\n        return this.$embeds;\n    };\n    var pushState = function (currentState, stack) {\n        if (currentState != \"start\" || stack.length)\n            stack.unshift(this.nextState, currentState);\n        return this.nextState;\n    };\n    var popState = function (currentState, stack) {\n        stack.shift();\n        return stack.shift() || \"start\";\n    };\n    this.normalizeRules = function () {\n        var id = 0;\n        var rules = this.$rules;\n        function processState(key) {\n            var state = rules[key];\n            state[\"processed\"] = true;\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                var toInsert = null;\n                if (Array.isArray(rule)) {\n                    toInsert = rule;\n                    rule = {};\n                }\n                if (!rule.regex && rule.start) {\n                    rule.regex = rule.start;\n                    if (!rule.next)\n                        rule.next = [];\n                    rule.next.push({\n                        defaultToken: rule.token\n                    }, {\n                        token: rule.token + \".end\",\n                        regex: rule.end || rule.start,\n                        next: \"pop\"\n                    });\n                    rule.token = rule.token + \".start\";\n                    rule.push = true;\n                }\n                var next = rule.next || rule.push;\n                if (next && Array.isArray(next)) {\n                    var stateName = rule.stateName;\n                    if (!stateName) {\n                        stateName = rule.token;\n                        if (typeof stateName != \"string\")\n                            stateName = stateName[0] || \"\";\n                        if (rules[stateName])\n                            stateName += id++;\n                    }\n                    rules[stateName] = next;\n                    rule.next = stateName;\n                    processState(stateName);\n                }\n                else if (next == \"pop\") {\n                    rule.next = popState;\n                }\n                if (rule.push) {\n                    rule.nextState = rule.next || rule.push;\n                    rule.next = pushState;\n                    delete rule.push;\n                }\n                if (rule.rules) {\n                    for (var r in rule.rules) {\n                        if (rules[r]) {\n                            if (rules[r].push)\n                                rules[r].push.apply(rules[r], rule.rules[r]);\n                        }\n                        else {\n                            rules[r] = rule.rules[r];\n                        }\n                    }\n                }\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\n                if (includeName) {\n                    if (includeName === \"$self\")\n                        includeName = \"start\";\n                    if (Array.isArray(includeName))\n                        toInsert = includeName.map(function (x) { return rules[x]; });\n                    else\n                        toInsert = rules[includeName];\n                }\n                if (toInsert) {\n                    var args = [i, 1].concat(toInsert);\n                    if (rule.noEscape)\n                        args = args.filter(function (x) { return !x.next; });\n                    state.splice.apply(state, args);\n                    i--;\n                }\n                if (rule.keywordMap) {\n                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive);\n                    delete rule.defaultToken;\n                }\n            }\n        }\n        Object.keys(rules).forEach(processState, this);\n    };\n    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {\n        var keywords = Object.create(null);\n        this.$keywordList = [];\n        Object.keys(map).forEach(function (className) {\n            var a = map[className];\n            var list = a.split(splitChar || \"|\");\n            for (var i = list.length; i--;) {\n                var word = list[i];\n                this.$keywordList.push(word);\n                if (ignoreCase)\n                    word = word.toLowerCase();\n                keywords[word] = className;\n            }\n        }, this);\n        map = null;\n        return ignoreCase\n            ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }\n            : function (value) { return keywords[value] || defaultToken; };\n    };\n    this.getKeywords = function () {\n        return this.$keywords;\n    };\n}).call(TextHighlightRules.prototype);\nexports.TextHighlightRules = TextHighlightRules;\n\n});\n\nace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar Behaviour;\nBehaviour = function () {\n    this.$behaviours = {};\n};\n(function () {\n    this.add = function (name, action, callback) {\n        switch (undefined) {\n            case this.$behaviours:\n                this.$behaviours = {};\n            case this.$behaviours[name]:\n                this.$behaviours[name] = {};\n        }\n        this.$behaviours[name][action] = callback;\n    };\n    this.addBehaviours = function (behaviours) {\n        for (var key in behaviours) {\n            for (var action in behaviours[key]) {\n                this.add(key, action, behaviours[key][action]);\n            }\n        }\n    };\n    this.remove = function (name) {\n        if (this.$behaviours && this.$behaviours[name]) {\n            delete this.$behaviours[name];\n        }\n    };\n    this.inherit = function (mode, filter) {\n        if (typeof mode === \"function\") {\n            var behaviours = new mode().getBehaviours(filter);\n        }\n        else {\n            var behaviours = mode.getBehaviours(filter);\n        }\n        this.addBehaviours(behaviours);\n    };\n    this.getBehaviours = function (filter) {\n        if (!filter) {\n            return this.$behaviours;\n        }\n        else {\n            var ret = {};\n            for (var i = 0; i < filter.length; i++) {\n                if (this.$behaviours[filter[i]]) {\n                    ret[filter[i]] = this.$behaviours[filter[i]];\n                }\n            }\n            return ret;\n        }\n    };\n}).call(Behaviour.prototype);\nexports.Behaviour = Behaviour;\n\n});\n\nace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar TokenIterator = /** @class */ (function () {\n    function TokenIterator(session, initialRow, initialColumn) {\n        this.$session = session;\n        this.$row = initialRow;\n        this.$rowTokens = session.getTokens(initialRow);\n        var token = session.getTokenAt(initialRow, initialColumn);\n        this.$tokenIndex = token ? token.index : -1;\n    }\n    TokenIterator.prototype.stepBackward = function () {\n        this.$tokenIndex -= 1;\n        while (this.$tokenIndex < 0) {\n            this.$row -= 1;\n            if (this.$row < 0) {\n                this.$row = 0;\n                return null;\n            }\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = this.$rowTokens.length - 1;\n        }\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.stepForward = function () {\n        this.$tokenIndex += 1;\n        var rowCount;\n        while (this.$tokenIndex >= this.$rowTokens.length) {\n            this.$row += 1;\n            if (!rowCount)\n                rowCount = this.$session.getLength();\n            if (this.$row >= rowCount) {\n                this.$row = rowCount - 1;\n                return null;\n            }\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = 0;\n        }\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.getCurrentToken = function () {\n        return this.$rowTokens[this.$tokenIndex];\n    };\n    TokenIterator.prototype.getCurrentTokenRow = function () {\n        return this.$row;\n    };\n    TokenIterator.prototype.getCurrentTokenColumn = function () {\n        var rowTokens = this.$rowTokens;\n        var tokenIndex = this.$tokenIndex;\n        var column = rowTokens[tokenIndex].start;\n        if (column !== undefined)\n            return column;\n        column = 0;\n        while (tokenIndex > 0) {\n            tokenIndex -= 1;\n            column += rowTokens[tokenIndex].value.length;\n        }\n        return column;\n    };\n    TokenIterator.prototype.getCurrentTokenPosition = function () {\n        return { row: this.$row, column: this.getCurrentTokenColumn() };\n    };\n    TokenIterator.prototype.getCurrentTokenRange = function () {\n        var token = this.$rowTokens[this.$tokenIndex];\n        var column = this.getCurrentTokenColumn();\n        return new Range(this.$row, column, this.$row, column + token.value.length);\n    };\n    return TokenIterator;\n}());\nexports.TokenIterator = TokenIterator;\n\n});\n\nace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\nvar SAFE_INSERT_IN_TOKENS = [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\"];\nvar SAFE_INSERT_BEFORE_TOKENS = [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\", \"comment\"];\nvar context;\nvar contextCache = {};\nvar defaultQuotes = { '\"': '\"', \"'\": \"'\" };\nvar initContext = function (editor) {\n    var id = -1;\n    if (editor.multiSelect) {\n        id = editor.selection.index;\n        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n            contextCache = { rangeCount: editor.multiSelect.rangeCount };\n    }\n    if (contextCache[id])\n        return context = contextCache[id];\n    context = contextCache[id] = {\n        autoInsertedBrackets: 0,\n        autoInsertedRow: -1,\n        autoInsertedLineEnd: \"\",\n        maybeInsertedBrackets: 0,\n        maybeInsertedRow: -1,\n        maybeInsertedLineStart: \"\",\n        maybeInsertedLineEnd: \"\"\n    };\n};\nvar getWrapped = function (selection, selected, opening, closing) {\n    var rowDiff = selection.end.row - selection.start.row;\n    return {\n        text: opening + selected + closing,\n        selection: [\n            0,\n            selection.start.column + 1,\n            rowDiff,\n            selection.end.column + (rowDiff ? 0 : 1)\n        ]\n    };\n};\nvar CstyleBehaviour;\nCstyleBehaviour = function (options) {\n    options = options || {};\n    this.add(\"braces\", \"insertion\", function (state, action, editor, session, text) {\n        var cursor = editor.getCursorPosition();\n        var line = session.doc.getLine(cursor.row);\n        if (text == '{') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            var token = session.getTokenAt(cursor.row, cursor.column);\n            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '{', '}');\n            }\n            else if (token && /(?:string)\\.quasi|\\.xml/.test(token.type)) {\n                var excludeTokens = [\n                    /tag\\-(?:open|name)/, /attribute\\-name/\n                ];\n                if (excludeTokens.some(function (el) { return el.test(token.type); }) || /(string)\\.quasi/.test(token.type)\n                    && token.value[cursor.column - token.start - 1] !== '$')\n                    return;\n                CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                return {\n                    text: '{}',\n                    selection: [1, 1]\n                };\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {\n                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                    return {\n                        text: '{}',\n                        selection: [1, 1]\n                    };\n                }\n                else {\n                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n                    return {\n                        text: '{',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n        else if (text == '}') {\n            initContext(editor);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == '}') {\n                var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n        else if (text == \"\\n\" || text == \"\\r\\n\") {\n            initContext(editor);\n            var closing = \"\";\n            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n                CstyleBehaviour.clearMaybeInsertedClosing();\n            }\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === '}') {\n                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');\n                if (!openBracePos)\n                    return null;\n                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n            }\n            else if (closing) {\n                var next_indent = this.$getIndent(line);\n            }\n            else {\n                CstyleBehaviour.clearMaybeInsertedClosing();\n                return;\n            }\n            var indent = next_indent + session.getTabString();\n            return {\n                text: '\\n' + indent + '\\n' + next_indent + closing,\n                selection: [1, indent.length, 1, indent.length]\n            };\n        }\n        else {\n            CstyleBehaviour.clearMaybeInsertedClosing();\n        }\n    });\n    this.add(\"braces\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '{') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.end.column, range.end.column + 1);\n            if (rightChar == '}') {\n                range.end.column++;\n                return range;\n            }\n            else {\n                context.maybeInsertedBrackets--;\n            }\n        }\n    });\n    this.add(\"parens\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '(') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '(', ')');\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n                return {\n                    text: '()',\n                    selection: [1, 1]\n                };\n            }\n        }\n        else if (text == ')') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ')') {\n                var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n    this.add(\"parens\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '(') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ')') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    this.add(\"brackets\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '[') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '[', ']');\n            }\n            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n                return {\n                    text: '[]',\n                    selection: [1, 1]\n                };\n            }\n        }\n        else if (text == ']') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ']') {\n                var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n    this.add(\"brackets\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '[') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ']') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    this.add(\"string_dquotes\", \"insertion\", function (state, action, editor, session, text) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        if (text.length == 1 && quotes[text]) {\n            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)\n                return;\n            initContext(editor);\n            var quote = text;\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, quote, quote);\n            }\n            else if (!selected) {\n                var cursor = editor.getCursorPosition();\n                var line = session.doc.getLine(cursor.row);\n                var leftChar = line.substring(cursor.column - 1, cursor.column);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                var token = session.getTokenAt(cursor.row, cursor.column);\n                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);\n                if (leftChar == \"\\\\\" && token && /escape/.test(token.type))\n                    return null;\n                var stringBefore = token && /string|escape/.test(token.type);\n                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);\n                var pair;\n                if (rightChar == quote) {\n                    pair = stringBefore !== stringAfter;\n                    if (pair && /string\\.end/.test(rightToken.type))\n                        pair = false;\n                }\n                else {\n                    if (stringBefore && !stringAfter)\n                        return null; // wrap string with different quote\n                    if (stringBefore && stringAfter)\n                        return null; // do not pair quotes inside strings\n                    var wordRe = session.$mode.tokenRe;\n                    wordRe.lastIndex = 0;\n                    var isWordBefore = wordRe.test(leftChar);\n                    wordRe.lastIndex = 0;\n                    var isWordAfter = wordRe.test(rightChar);\n                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;\n                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);\n                    if ((!shouldPairQuotes && isWordBefore) || isWordAfter)\n                        return null; // before or after alphanumeric\n                    if (rightChar && !/[\\s;,.})\\]\\\\]/.test(rightChar))\n                        return null; // there is rightChar and it isn't closing\n                    var charBefore = line[cursor.column - 2];\n                    if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))\n                        return null;\n                    pair = true;\n                }\n                return {\n                    text: pair ? quote + quote : \"\",\n                    selection: [1, 1]\n                };\n            }\n        }\n    });\n    this.add(\"string_dquotes\", \"deletion\", function (state, action, editor, session, range) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n    if (options.closeDocComment !== false) {\n        this.add(\"doc comment end\", \"insertion\", function (state, action, editor, session, text) {\n            if (state === \"doc-start\" && (text === \"\\n\" || text === \"\\r\\n\") && editor.selection.isEmpty()) {\n                var cursor = editor.getCursorPosition();\n                if (cursor.column === 0) {\n                    return;\n                }\n                var line = session.doc.getLine(cursor.row);\n                var nextLine = session.doc.getLine(cursor.row + 1);\n                var tokens = session.getTokens(cursor.row);\n                var index = 0;\n                for (var i = 0; i < tokens.length; i++) {\n                    index += tokens[i].value.length;\n                    var currentToken = tokens[i];\n                    if (index >= cursor.column) {\n                        if (index === cursor.column) {\n                            if (!/\\.doc/.test(currentToken.type)) {\n                                return;\n                            }\n                            if (/\\*\\//.test(currentToken.value)) {\n                                var nextToken = tokens[i + 1];\n                                if (!nextToken || !/\\.doc/.test(nextToken.type)) {\n                                    return;\n                                }\n                            }\n                        }\n                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);\n                        var closeDocPos = currentToken.value.indexOf(\"*/\");\n                        var openDocPos = currentToken.value.indexOf(\"/**\", closeDocPos > -1 ? closeDocPos + 2 : 0);\n                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {\n                            return;\n                        }\n                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos\n                            && cursorPosInToken <= openDocPos || !/\\.doc/.test(currentToken.type)) {\n                            return;\n                        }\n                        break;\n                    }\n                }\n                var indent = this.$getIndent(line);\n                if (/\\s*\\*/.test(nextLine)) {\n                    if (/^\\s*\\*/.test(line)) {\n                        return {\n                            text: text + indent + \"* \",\n                            selection: [1, 2 + indent.length, 1, 2 + indent.length]\n                        };\n                    }\n                    else {\n                        return {\n                            text: text + indent + \" * \",\n                            selection: [1, 3 + indent.length, 1, 3 + indent.length]\n                        };\n                    }\n                }\n                if (/\\/\\*\\*/.test(line.substring(0, cursor.column))) {\n                    return {\n                        text: text + indent + \" * \" + text + \" \" + indent + \"*/\",\n                        selection: [1, 4 + indent.length, 1, 4 + indent.length]\n                    };\n                }\n            }\n        });\n    }\n};\nCstyleBehaviour.isSaneInsertion = function (editor, session) {\n    var cursor = editor.getCursorPosition();\n    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n        if (/[)}\\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))\n            return true;\n        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n            return false;\n    }\n    iterator.stepForward();\n    return iterator.getCurrentTokenRow() !== cursor.row ||\n        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n};\nCstyleBehaviour[\"$matchTokenType\"] = function (token, types) {\n    return types.indexOf(token.type || token) > -1;\n};\nCstyleBehaviour[\"recordAutoInsert\"] = function (editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this[\"isAutoInsertedClosing\"](cursor, line, context.autoInsertedLineEnd[0]))\n        context.autoInsertedBrackets = 0;\n    context.autoInsertedRow = cursor.row;\n    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n    context.autoInsertedBrackets++;\n};\nCstyleBehaviour[\"recordMaybeInsert\"] = function (editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this[\"isMaybeInsertedClosing\"](cursor, line))\n        context.maybeInsertedBrackets = 0;\n    context.maybeInsertedRow = cursor.row;\n    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n    context.maybeInsertedLineEnd = line.substr(cursor.column);\n    context.maybeInsertedBrackets++;\n};\nCstyleBehaviour[\"isAutoInsertedClosing\"] = function (cursor, line, bracket) {\n    return context.autoInsertedBrackets > 0 &&\n        cursor.row === context.autoInsertedRow &&\n        bracket === context.autoInsertedLineEnd[0] &&\n        line.substr(cursor.column) === context.autoInsertedLineEnd;\n};\nCstyleBehaviour[\"isMaybeInsertedClosing\"] = function (cursor, line) {\n    return context.maybeInsertedBrackets > 0 &&\n        cursor.row === context.maybeInsertedRow &&\n        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n};\nCstyleBehaviour[\"popAutoInsertedClosing\"] = function () {\n    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n    context.autoInsertedBrackets--;\n};\nCstyleBehaviour[\"clearMaybeInsertedClosing\"] = function () {\n    if (context) {\n        context.maybeInsertedBrackets = 0;\n        context.maybeInsertedRow = -1;\n    }\n};\noop.inherits(CstyleBehaviour, Behaviour);\nexports.CstyleBehaviour = CstyleBehaviour;\n\n});\n\nace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];\nvar code = 0;\nvar str = [];\nfor (var i = 0; i < wordChars.length; i += 2) {\n    str.push(code += wordChars[i]);\n    if (wordChars[i + 1])\n        str.push(45, code += wordChars[i + 1]);\n}\nexports.wordChars = String.fromCharCode.apply(null, str);\n\n});\n\nace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar config = require(\"../config\");\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar unicode = require(\"../unicode\");\nvar lang = require(\"../lib/lang\");\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\nvar Mode;\nMode = function () {\n    this.HighlightRules = TextHighlightRules;\n};\n(function () {\n    this.$defaultBehaviour = new CstyleBehaviour();\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\n    this.getTokenizer = function () {\n        if (!this.$tokenizer) {\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n        }\n        return this.$tokenizer;\n    };\n    this.lineCommentStart = \"\";\n    this.blockComment = \"\";\n    this.toggleCommentLines = function (state, session, startRow, endRow) {\n        var doc = session.doc;\n        var ignoreBlankLines = true;\n        var shouldRemove = true;\n        var minIndent = Infinity;\n        var tabSize = session.getTabSize();\n        var insertAtTabStop = false;\n        if (!this.lineCommentStart) {\n            if (!this.blockComment)\n                return false;\n            var lineCommentStart = this.blockComment.start;\n            var lineCommentEnd = this.blockComment.end;\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n            var comment = function (line, i) {\n                if (testRemove(line, i))\n                    return;\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);\n                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);\n                }\n            };\n            var uncomment = function (line, i) {\n                var m;\n                if (m = line.match(regexpEnd))\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\n                if (m = line.match(regexpStart))\n                    doc.removeInLine(i, m[1].length, m[0].length);\n            };\n            var testRemove = function (line, row) {\n                if (regexpStart.test(line))\n                    return true;\n                var tokens = session.getTokens(row);\n                for (var i = 0; i < tokens.length; i++) {\n                    if (tokens[i].type === \"comment\")\n                        return true;\n                }\n            };\n        }\n        else {\n            if (Array.isArray(this.lineCommentStart)) {\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n                var lineCommentStart = this.lineCommentStart[0];\n            }\n            else {\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n                var lineCommentStart = this.lineCommentStart;\n            }\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n            insertAtTabStop = session.getUseSoftTabs();\n            var uncomment = function (line, i) {\n                var m = line.match(regexpStart);\n                if (!m)\n                    return;\n                var start = m[1].length, end = m[0].length;\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n                    end--;\n                doc.removeInLine(i, start, end);\n            };\n            var commentWithSpace = lineCommentStart + \" \";\n            var comment = function (line, i) {\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    if (shouldInsertSpace(line, minIndent, minIndent))\n                        doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);\n                    else\n                        doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);\n                }\n            };\n            var testRemove = function (line, i) {\n                return regexpStart.test(line);\n            };\n            var shouldInsertSpace = function (line, before, after) {\n                var spaces = 0;\n                while (before-- && line.charAt(before) == \" \")\n                    spaces++;\n                if (spaces % tabSize != 0)\n                    return false;\n                var spaces = 0;\n                while (line.charAt(after++) == \" \")\n                    spaces++;\n                if (tabSize > 2)\n                    return spaces % tabSize != tabSize - 1;\n                else\n                    return spaces % tabSize == 0;\n            };\n        }\n        function iter(fun) {\n            for (var i = startRow; i <= endRow; i++)\n                fun(doc.getLine(i), i);\n        }\n        var minEmptyLength = Infinity;\n        iter(function (line, i) {\n            var indent = line.search(/\\S/);\n            if (indent !== -1) {\n                if (indent < minIndent)\n                    minIndent = indent;\n                if (shouldRemove && !testRemove(line, i))\n                    shouldRemove = false;\n            }\n            else if (minEmptyLength > line.length) {\n                minEmptyLength = line.length;\n            }\n        });\n        if (minIndent == Infinity) {\n            minIndent = minEmptyLength;\n            ignoreBlankLines = false;\n            shouldRemove = false;\n        }\n        if (insertAtTabStop && minIndent % tabSize != 0)\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n        iter(shouldRemove ? uncomment : comment);\n    };\n    this.toggleBlockComment = function (state, session, range, cursor) {\n        var comment = this.blockComment;\n        if (!comment)\n            return;\n        if (!comment.start && comment[0])\n            comment = comment[0];\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n        var token = iterator.getCurrentToken();\n        var sel = session.selection;\n        var initialRange = session.selection.toOrientedRange();\n        var startRow, colDiff;\n        if (token && /comment/.test(token.type)) {\n            var startRange, endRange;\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.start);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    startRange = new Range(row, column, row, column + comment.start.length);\n                    break;\n                }\n                token = iterator.stepBackward();\n            }\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.end);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    endRange = new Range(row, column, row, column + comment.end.length);\n                    break;\n                }\n                token = iterator.stepForward();\n            }\n            if (endRange)\n                session.remove(endRange);\n            if (startRange) {\n                session.remove(startRange);\n                startRow = startRange.start.row;\n                colDiff = -comment.start.length;\n            }\n        }\n        else {\n            colDiff = comment.start.length;\n            startRow = range.start.row;\n            session.insert(range.end, comment.end);\n            session.insert(range.start, comment.start);\n        }\n        if (initialRange.start.row == startRow)\n            initialRange.start.column += colDiff;\n        if (initialRange.end.row == startRow)\n            initialRange.end.column += colDiff;\n        session.selection.fromOrientedRange(initialRange);\n    };\n    this.getNextLineIndent = function (state, line, tab) {\n        return this.$getIndent(line);\n    };\n    this.checkOutdent = function (state, line, input) {\n        return false;\n    };\n    this.autoOutdent = function (state, doc, row) {\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n    this.createWorker = function (session) {\n        return null;\n    };\n    this.createModeDelegates = function (mapping) {\n        this.$embeds = [];\n        this.$modes = {};\n        for (var i in mapping) {\n            if (mapping[i]) {\n                var Mode = mapping[i];\n                var id = Mode.prototype.$id;\n                var mode = config.$modes[id];\n                if (!mode)\n                    config.$modes[id] = mode = new Mode();\n                if (!config.$modes[i])\n                    config.$modes[i] = mode;\n                this.$embeds.push(i);\n                this.$modes[i] = mode;\n            }\n        }\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\",\n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\n        var _loop_1 = function (i) {\n            (function (scope) {\n                var functionName = delegations[i];\n                var defaultHandler = scope[functionName];\n                scope[delegations[i]] =\n                    function () {\n                        return this.$delegator(functionName, arguments, defaultHandler);\n                    };\n            }(this_1));\n        };\n        var this_1 = this;\n        for (var i = 0; i < delegations.length; i++) {\n            _loop_1(i);\n        }\n    };\n    this.$delegator = function (method, args, defaultHandler) {\n        var state = args[0] || \"start\";\n        if (typeof state != \"string\") {\n            if (Array.isArray(state[2])) {\n                var language = state[2][state[2].length - 1];\n                var mode = this.$modes[language];\n                if (mode)\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\n            }\n            state = state[0] || \"start\";\n        }\n        for (var i = 0; i < this.$embeds.length; i++) {\n            if (!this.$modes[this.$embeds[i]])\n                continue;\n            var split = state.split(this.$embeds[i]);\n            if (!split[0] && split[1]) {\n                args[0] = split[1];\n                var mode = this.$modes[this.$embeds[i]];\n                return mode[method].apply(mode, args);\n            }\n        }\n        var ret = defaultHandler.apply(this, args);\n        return defaultHandler ? ret : undefined;\n    };\n    this.transformAction = function (state, action, editor, session, param) {\n        if (this.$behaviour) {\n            var behaviours = this.$behaviour.getBehaviours();\n            for (var key in behaviours) {\n                if (behaviours[key][action]) {\n                    var ret = behaviours[key][action].apply(this, arguments);\n                    if (ret) {\n                        return ret;\n                    }\n                }\n            }\n        }\n    };\n    this.getKeywords = function (append) {\n        if (!this.completionKeywords) {\n            var rules = this.$tokenizer[\"rules\"];\n            var completionKeywords = [];\n            for (var rule in rules) {\n                var ruleItr = rules[rule];\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\n                    if (typeof ruleItr[r].token === \"string\") {\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\n                            completionKeywords.push(ruleItr[r].regex);\n                    }\n                    else if (typeof ruleItr[r].token === \"object\") {\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {\n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\n                            }\n                        }\n                    }\n                }\n            }\n            this.completionKeywords = completionKeywords;\n        }\n        if (!append)\n            return this.$keywordList;\n        return completionKeywords.concat(this.$keywordList || []);\n    };\n    this.$createKeywordList = function () {\n        if (!this.$highlightRules)\n            this.getTokenizer();\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\n    };\n    this.getCompletions = function (state, session, pos, prefix) {\n        var keywords = this.$keywordList || this.$createKeywordList();\n        return keywords.map(function (word) {\n            return {\n                name: word,\n                value: word,\n                score: 0,\n                meta: \"keyword\"\n            };\n        });\n    };\n    this.$id = \"ace/mode/text\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});\n\nace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"./lib/dom\");\nvar LineWidgets = /** @class */ (function () {\n    function LineWidgets(session) {\n        this.session = session;\n        this.session.widgetManager = this;\n        this.session.getRowLength = this.getRowLength;\n        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n        this.updateOnChange = this.updateOnChange.bind(this);\n        this.renderWidgets = this.renderWidgets.bind(this);\n        this.measureWidgets = this.measureWidgets.bind(this);\n        this.session._changedWidgets = [];\n        this.$onChangeEditor = this.$onChangeEditor.bind(this);\n        this.session.on(\"change\", this.updateOnChange);\n        this.session.on(\"changeFold\", this.updateOnFold);\n        this.session.on(\"changeEditor\", this.$onChangeEditor);\n    }\n    LineWidgets.prototype.getRowLength = function (row) {\n        var h;\n        if (this.lineWidgets)\n            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else\n            h = 0;\n        if (!this[\"$useWrapMode\"] || !this[\"$wrapData\"][row]) {\n            return 1 + h;\n        }\n        else {\n            return this[\"$wrapData\"][row].length + 1 + h;\n        }\n    };\n    LineWidgets.prototype.$getWidgetScreenLength = function () {\n        var screenRows = 0;\n        this.lineWidgets.forEach(function (w) {\n            if (w && w.rowCount && !w.hidden)\n                screenRows += w.rowCount;\n        });\n        return screenRows;\n    };\n    LineWidgets.prototype.$onChangeEditor = function (e) {\n        this.attach(e.editor);\n    };\n    LineWidgets.prototype.attach = function (editor) {\n        if (editor && editor.widgetManager && editor.widgetManager != this)\n            editor.widgetManager.detach();\n        if (this.editor == editor)\n            return;\n        this.detach();\n        this.editor = editor;\n        if (editor) {\n            editor.widgetManager = this;\n            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n            editor.renderer.on(\"afterRender\", this.renderWidgets);\n        }\n    };\n    LineWidgets.prototype.detach = function (e) {\n        var editor = this.editor;\n        if (!editor)\n            return;\n        this.editor = null;\n        editor.widgetManager = null;\n        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n        editor.renderer.off(\"afterRender\", this.renderWidgets);\n        var lineWidgets = this.session.lineWidgets;\n        lineWidgets && lineWidgets.forEach(function (w) {\n            if (w && w.el && w.el.parentNode) {\n                w._inDocument = false;\n                w.el.parentNode.removeChild(w.el);\n            }\n        });\n    };\n    LineWidgets.prototype.updateOnFold = function (e, session) {\n        var lineWidgets = session.lineWidgets;\n        if (!lineWidgets || !e.action)\n            return;\n        var fold = e.data;\n        var start = fold.start.row;\n        var end = fold.end.row;\n        var hide = e.action == \"add\";\n        for (var i = start + 1; i < end; i++) {\n            if (lineWidgets[i])\n                lineWidgets[i].hidden = hide;\n        }\n        if (lineWidgets[end]) {\n            if (hide) {\n                if (!lineWidgets[start])\n                    lineWidgets[start] = lineWidgets[end];\n                else\n                    lineWidgets[end].hidden = hide;\n            }\n            else {\n                if (lineWidgets[start] == lineWidgets[end])\n                    lineWidgets[start] = undefined;\n                lineWidgets[end].hidden = hide;\n            }\n        }\n    };\n    LineWidgets.prototype.updateOnChange = function (delta) {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n        if (len === 0) {\n        }\n        else if (delta.action == \"remove\") {\n            var removed = lineWidgets.splice(startRow + 1, len);\n            if (!lineWidgets[startRow] && removed[removed.length - 1]) {\n                lineWidgets[startRow] = removed.pop();\n            }\n            removed.forEach(function (w) {\n                w && this.removeLineWidget(w);\n            }, this);\n            this.$updateRows();\n        }\n        else {\n            var args = new Array(len);\n            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {\n                if (delta.start.column > lineWidgets[startRow].column)\n                    startRow++;\n            }\n            args.unshift(startRow, 0);\n            lineWidgets.splice.apply(lineWidgets, args);\n            this.$updateRows();\n        }\n    };\n    LineWidgets.prototype.$updateRows = function () {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var noWidgets = true;\n        lineWidgets.forEach(function (w, i) {\n            if (w) {\n                noWidgets = false;\n                w.row = i;\n                while (w.$oldWidget) {\n                    w.$oldWidget.row = i;\n                    w = w.$oldWidget;\n                }\n            }\n        });\n        if (noWidgets)\n            this.session.lineWidgets = null;\n    };\n    LineWidgets.prototype.$registerLineWidget = function (w) {\n        if (!this.session.lineWidgets)\n            this.session.lineWidgets = new Array(this.session.getLength());\n        var old = this.session.lineWidgets[w.row];\n        if (old) {\n            w.$oldWidget = old;\n            if (old.el && old.el.parentNode) {\n                old.el.parentNode.removeChild(old.el);\n                old._inDocument = false;\n            }\n        }\n        this.session.lineWidgets[w.row] = w;\n        return w;\n    };\n    LineWidgets.prototype.addLineWidget = function (w) {\n        this.$registerLineWidget(w);\n        w.session = this.session;\n        if (!this.editor)\n            return w;\n        var renderer = this.editor.renderer;\n        if (w.html && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.innerHTML = w.html;\n        }\n        if (w.text && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.textContent = w.text;\n        }\n        if (w.el) {\n            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n            if (w.className) {\n                dom.addCssClass(w.el, w.className);\n            }\n            w.el.style.position = \"absolute\";\n            w.el.style.zIndex = \"5\";\n            renderer.container.appendChild(w.el);\n            w._inDocument = true;\n            if (!w.coverGutter) {\n                w.el.style.zIndex = \"3\";\n            }\n            if (w.pixelHeight == null) {\n                w.pixelHeight = w.el.offsetHeight;\n            }\n        }\n        if (w.rowCount == null) {\n            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n        }\n        var fold = this.session.getFoldAt(w.row, 0);\n        w.$fold = fold;\n        if (fold) {\n            var lineWidgets = this.session.lineWidgets;\n            if (w.row == fold.end.row && !lineWidgets[fold.start.row])\n                lineWidgets[fold.start.row] = w;\n            else\n                w.hidden = true;\n        }\n        this.session._emit(\"changeFold\", { data: { start: { row: w.row } } });\n        this.$updateRows();\n        this.renderWidgets(null, renderer);\n        this.onWidgetChanged(w);\n        return w;\n    };\n    LineWidgets.prototype.removeLineWidget = function (w) {\n        w._inDocument = false;\n        w.session = null;\n        if (w.el && w.el.parentNode)\n            w.el.parentNode.removeChild(w.el);\n        if (w.editor && w.editor.destroy)\n            try {\n                w.editor.destroy();\n            }\n            catch (e) { }\n        if (this.session.lineWidgets) {\n            var w1 = this.session.lineWidgets[w.row];\n            if (w1 == w) {\n                this.session.lineWidgets[w.row] = w.$oldWidget;\n                if (w.$oldWidget)\n                    this.onWidgetChanged(w.$oldWidget);\n            }\n            else {\n                while (w1) {\n                    if (w1.$oldWidget == w) {\n                        w1.$oldWidget = w.$oldWidget;\n                        break;\n                    }\n                    w1 = w1.$oldWidget;\n                }\n            }\n        }\n        this.session._emit(\"changeFold\", { data: { start: { row: w.row } } });\n        this.$updateRows();\n    };\n    LineWidgets.prototype.getWidgetsAtRow = function (row) {\n        var lineWidgets = this.session.lineWidgets;\n        var w = lineWidgets && lineWidgets[row];\n        var list = [];\n        while (w) {\n            list.push(w);\n            w = w.$oldWidget;\n        }\n        return list;\n    };\n    LineWidgets.prototype.onWidgetChanged = function (w) {\n        this.session._changedWidgets.push(w);\n        this.editor && this.editor.renderer.updateFull();\n    };\n    LineWidgets.prototype.measureWidgets = function (e, renderer) {\n        var changedWidgets = this.session._changedWidgets;\n        var config = renderer.layerConfig;\n        if (!changedWidgets || !changedWidgets.length)\n            return;\n        var min = Infinity;\n        for (var i = 0; i < changedWidgets.length; i++) {\n            var w = changedWidgets[i];\n            if (!w || !w.el)\n                continue;\n            if (w.session != this.session)\n                continue;\n            if (!w._inDocument) {\n                if (this.session.lineWidgets[w.row] != w)\n                    continue;\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            w.h = w.el.offsetHeight;\n            if (!w.fixedWidth) {\n                w.w = w.el.offsetWidth;\n                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n            }\n            var rowCount = w.h / config.lineHeight;\n            if (w.coverLine) {\n                rowCount -= this.session.getRowLineCount(w.row);\n                if (rowCount < 0)\n                    rowCount = 0;\n            }\n            if (w.rowCount != rowCount) {\n                w.rowCount = rowCount;\n                if (w.row < min)\n                    min = w.row;\n            }\n        }\n        if (min != Infinity) {\n            this.session._emit(\"changeFold\", { data: { start: { row: min } } });\n            this.session.lineWidgetWidth = null;\n        }\n        this.session._changedWidgets = [];\n    };\n    LineWidgets.prototype.renderWidgets = function (e, renderer) {\n        var config = renderer.layerConfig;\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var first = Math.min(this.firstRow, config.firstRow);\n        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n        while (first > 0 && !lineWidgets[first])\n            first--;\n        this.firstRow = config.firstRow;\n        this.lastRow = config.lastRow;\n        renderer.$cursorLayer.config = config;\n        for (var i = first; i <= last; i++) {\n            var w = lineWidgets[i];\n            if (!w || !w.el)\n                continue;\n            if (w.hidden) {\n                w.el.style.top = -100 - (w.pixelHeight || 0) + \"px\";\n                continue;\n            }\n            if (!w._inDocument) {\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;\n            if (!w.coverLine)\n                top += config.lineHeight * this.session.getRowLineCount(w.row);\n            w.el.style.top = top - config.offset + \"px\";\n            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n            if (!w.fixedWidth)\n                left -= renderer.scrollLeft;\n            w.el.style.left = left + \"px\";\n            if (w.fullWidth && w.screenWidth) {\n                w.el.style.minWidth = config.width + 2 * config.padding + \"px\";\n            }\n            if (w.fixedWidth) {\n                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n            }\n            else {\n                w.el.style.right = \"\";\n            }\n        }\n    };\n    return LineWidgets;\n}());\nexports.LineWidgets = LineWidgets;\n\n});\n\nace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nfunction throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\nfunction positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length &&\n        position.column >= 0 && position.column <= docLines[position.row].length;\n}\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n        throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\nexports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            }\n            else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            }\n            else {\n                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n            }\n            break;\n    }\n};\n\n});\n\nace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Anchor = /** @class */ (function () {\n    function Anchor(doc, row, column) {\n        this.$onChange = this.onChange.bind(this);\n        this.attach(doc);\n        if (typeof row != \"number\")\n            this.setPosition(row.row, row.column);\n        else\n            this.setPosition(row, column);\n    }\n    Anchor.prototype.getPosition = function () {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    Anchor.prototype.getDocument = function () {\n        return this.document;\n    };\n    Anchor.prototype.onChange = function (delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n        if (delta.start.row > this.row)\n            return;\n        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    Anchor.prototype.setPosition = function (row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        }\n        else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    Anchor.prototype.detach = function () {\n        this.document.off(\"change\", this.$onChange);\n    };\n    Anchor.prototype.attach = function (doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    Anchor.prototype.$clipPositionToDocument = function (row, column) {\n        var pos = {};\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n        if (column < 0)\n            pos.column = 0;\n        return pos;\n    };\n    return Anchor;\n}());\nAnchor.prototype.$insertRight = false;\noop.implement(Anchor.prototype, EventEmitter);\nfunction $pointsInOrder(point1, point2, equalPointsInOrder) {\n    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n    return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n}\nfunction $getTransformedPoint(delta, point, moveIfEqual) {\n    var deltaIsInsert = delta.action == \"insert\";\n    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n    var deltaStart = delta.start;\n    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n            row: point.row,\n            column: point.column\n        };\n    }\n    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n            row: point.row + deltaRowShift,\n            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n    }\n    return {\n        row: deltaStart.row,\n        column: deltaStart.column\n    };\n}\nexports.Anchor = Anchor;\n\n});\n\nace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\nvar Document = /** @class */ (function () {\n    function Document(textOrLines) {\n        this.$lines = [\"\"];\n        if (textOrLines.length === 0) {\n            this.$lines = [\"\"];\n        }\n        else if (Array.isArray(textOrLines)) {\n            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);\n        }\n        else {\n            this.insert({ row: 0, column: 0 }, textOrLines);\n        }\n    }\n    Document.prototype.setValue = function (text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({ row: 0, column: 0 }, text || \"\");\n    };\n    Document.prototype.getValue = function () {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    Document.prototype.createAnchor = function (row, column) {\n        return new Anchor(this, row, column);\n    };\n    Document.prototype.$detectNewLine = function (text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineCharacter = function () {\n        switch (this.$newLineMode) {\n            case \"windows\":\n                return \"\\r\\n\";\n            case \"unix\":\n                return \"\\n\";\n            default:\n                return this.$autoNewLine || \"\\n\";\n        }\n    };\n    Document.prototype.setNewLineMode = function (newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineMode = function () {\n        return this.$newLineMode;\n    };\n    Document.prototype.isNewLine = function (text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    Document.prototype.getLine = function (row) {\n        return this.$lines[row] || \"\";\n    };\n    Document.prototype.getLines = function (firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    Document.prototype.getAllLines = function () {\n        return this.getLines(0, this.getLength());\n    };\n    Document.prototype.getLength = function () {\n        return this.$lines.length;\n    };\n    Document.prototype.getTextRange = function (range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    Document.prototype.getLinesForRange = function (range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        }\n        else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    Document.prototype.insertLines = function (row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    Document.prototype.removeLines = function (firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    Document.prototype.insertNewLine = function (position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    Document.prototype.insert = function (position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        return this.insertMergedLines(position, this.$split(text));\n    };\n    Document.prototype.insertInLine = function (position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        return this.clonePos(end);\n    };\n    Document.prototype.clippedPos = function (row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        }\n        else if (row < 0) {\n            row = 0;\n        }\n        else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return { row: row, column: column };\n    };\n    Document.prototype.clonePos = function (pos) {\n        return { row: pos.row, column: pos.column };\n    };\n    Document.prototype.pos = function (row, column) {\n        return { row: row, column: column };\n    };\n    Document.prototype.$clipPosition = function (position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        }\n        else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    Document.prototype.insertFullLines = function (row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        }\n        else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({ row: row, column: column }, lines);\n    };\n    Document.prototype.insertMergedLines = function (position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        return this.clonePos(end);\n    };\n    Document.prototype.remove = function (range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        });\n        return this.clonePos(start);\n    };\n    Document.prototype.removeInLine = function (row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        }, true);\n        return this.clonePos(start);\n    };\n    Document.prototype.removeFullLines = function (firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine = lastRow < this.getLength() - 1;\n        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);\n        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);\n        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);\n        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);\n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    Document.prototype.removeNewLine = function (row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    Document.prototype.replace = function (range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        return end;\n    };\n    Document.prototype.applyDeltas = function (deltas) {\n        for (var i = 0; i < deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    Document.prototype.revertDeltas = function (deltas) {\n        for (var i = deltas.length - 1; i >= 0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    Document.prototype.applyDelta = function (delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    Document.prototype.$safeApplyDelta = function (delta) {\n        var docLength = this.$lines.length;\n        if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength\n            || delta.action == \"insert\" && delta.start.row <= docLength) {\n            this.applyDelta(delta);\n        }\n    };\n    Document.prototype.$splitAndapplyLargeDelta = function (delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row;\n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    Document.prototype.revertDelta = function (delta) {\n        this.$safeApplyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    Document.prototype.indexToPosition = function (index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return { row: i, column: index + lines[i].length + newlineLength };\n        }\n        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };\n    };\n    Document.prototype.positionToIndex = function (pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n        return index + pos.column;\n    };\n    Document.prototype.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n    };\n    return Document;\n}());\nDocument.prototype.$autoNewLine = \"\";\nDocument.prototype.$newLineMode = \"auto\";\noop.implement(Document.prototype, EventEmitter);\nexports.Document = Document;\n\n});\n\nace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar BackgroundTokenizer = /** @class */ (function () {\n    function BackgroundTokenizer(tokenizer, session) {\n        this.running = false;\n        this.lines = [];\n        this.states = [];\n        this.currentLine = 0;\n        this.tokenizer = tokenizer;\n        var self = this;\n        this.$worker = function () {\n            if (!self.running) {\n                return;\n            }\n            var workerStart = new Date();\n            var currentLine = self.currentLine;\n            var endLine = -1;\n            var doc = self.doc;\n            var startLine = currentLine;\n            while (self.lines[currentLine])\n                currentLine++;\n            var len = doc.getLength();\n            var processedLines = 0;\n            self.running = false;\n            while (currentLine < len) {\n                self.$tokenizeRow(currentLine);\n                endLine = currentLine;\n                do {\n                    currentLine++;\n                } while (self.lines[currentLine]);\n                processedLines++;\n                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\n                    self.running = setTimeout(self.$worker, 20);\n                    break;\n                }\n            }\n            self.currentLine = currentLine;\n            if (endLine == -1)\n                endLine = currentLine;\n            if (startLine <= endLine)\n                self.fireUpdateEvent(startLine, endLine);\n        };\n    }\n    BackgroundTokenizer.prototype.setTokenizer = function (tokenizer) {\n        this.tokenizer = tokenizer;\n        this.lines = [];\n        this.states = [];\n        this.start(0);\n    };\n    BackgroundTokenizer.prototype.setDocument = function (doc) {\n        this.doc = doc;\n        this.lines = [];\n        this.states = [];\n        this.stop();\n    };\n    BackgroundTokenizer.prototype.fireUpdateEvent = function (firstRow, lastRow) {\n        var data = {\n            first: firstRow,\n            last: lastRow\n        };\n        this._signal(\"update\", { data: data });\n    };\n    BackgroundTokenizer.prototype.start = function (startRow) {\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n        this.lines.splice(this.currentLine, this.lines.length);\n        this.states.splice(this.currentLine, this.states.length);\n        this.stop();\n        this.running = setTimeout(this.$worker, 700);\n    };\n    BackgroundTokenizer.prototype.scheduleStart = function () {\n        if (!this.running)\n            this.running = setTimeout(this.$worker, 700);\n    };\n    BackgroundTokenizer.prototype.$updateOnChange = function (delta) {\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n        if (len === 0) {\n            this.lines[startRow] = null;\n        }\n        else if (delta.action == \"remove\") {\n            this.lines.splice(startRow, len + 1, null);\n            this.states.splice(startRow, len + 1, null);\n        }\n        else {\n            var args = Array(len + 1);\n            args.unshift(startRow, 1);\n            this.lines.splice.apply(this.lines, args);\n            this.states.splice.apply(this.states, args);\n        }\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n        this.stop();\n    };\n    BackgroundTokenizer.prototype.stop = function () {\n        if (this.running)\n            clearTimeout(this.running);\n        this.running = false;\n    };\n    BackgroundTokenizer.prototype.getTokens = function (row) {\n        return this.lines[row] || this.$tokenizeRow(row);\n    };\n    BackgroundTokenizer.prototype.getState = function (row) {\n        if (this.currentLine == row)\n            this.$tokenizeRow(row);\n        return this.states[row] || \"start\";\n    };\n    BackgroundTokenizer.prototype.$tokenizeRow = function (row) {\n        var line = this.doc.getLine(row);\n        var state = this.states[row - 1];\n        var data = this.tokenizer.getLineTokens(line, state, row);\n        if (this.states[row] + \"\" !== data.state + \"\") {\n            this.states[row] = data.state;\n            this.lines[row + 1] = null;\n            if (this.currentLine > row + 1)\n                this.currentLine = row + 1;\n        }\n        else if (this.currentLine == row) {\n            this.currentLine = row + 1;\n        }\n        return this.lines[row] = data.tokens;\n    };\n    BackgroundTokenizer.prototype.cleanup = function () {\n        this.running = false;\n        this.lines = [];\n        this.states = [];\n        this.currentLine = 0;\n        this.removeAllListeners();\n    };\n    return BackgroundTokenizer;\n}());\noop.implement(BackgroundTokenizer.prototype, EventEmitter);\nexports.BackgroundTokenizer = BackgroundTokenizer;\n\n});\n\nace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"./lib/lang\");\nvar Range = require(\"./range\").Range;\nvar SearchHighlight = /** @class */ (function () {\n    function SearchHighlight(regExp, clazz, type) {\n        if (type === void 0) { type = \"text\"; }\n        this.setRegexp(regExp);\n        this.clazz = clazz;\n        this.type = type;\n        this.docLen = 0;\n    }\n    SearchHighlight.prototype.setRegexp = function (regExp) {\n        if (this.regExp + \"\" == regExp + \"\")\n            return;\n        this.regExp = regExp;\n        this.cache = [];\n    };\n    SearchHighlight.prototype.update = function (html, markerLayer, session, config) {\n        if (!this.regExp)\n            return;\n        var start = config.firstRow;\n        var end = config.lastRow;\n        var renderedMarkerRanges = {};\n        var _search = session.$editor.$search;\n        var mtSearch = _search.$isMultilineSearch(session.$editor.getLastSearchOptions());\n        for (var i = start; i <= end; i++) {\n            var ranges = this.cache[i];\n            if (ranges == null || session.getValue().length != this.docLen) {\n                if (mtSearch) {\n                    ranges = [];\n                    var match = _search.$multiLineForward(session, this.regExp, i, end);\n                    if (match) {\n                        var end_row = match.endRow <= end ? match.endRow - 1 : end;\n                        if (end_row > i)\n                            i = end_row;\n                        ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));\n                    }\n                    if (ranges.length > this.MAX_RANGES)\n                        ranges = ranges.slice(0, this.MAX_RANGES);\n                }\n                else {\n                    ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n                    if (ranges.length > this.MAX_RANGES)\n                        ranges = ranges.slice(0, this.MAX_RANGES);\n                    ranges = ranges.map(function (match) {\n                        return new Range(i, match.offset, i, match.offset + match.length);\n                    });\n                }\n                this.cache[i] = ranges.length ? ranges : \"\";\n            }\n            if (ranges.length === 0)\n                continue;\n            for (var j = ranges.length; j--;) {\n                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);\n                var rangeAsString = rangeToAddMarkerTo.toString();\n                if (renderedMarkerRanges[rangeAsString])\n                    continue;\n                renderedMarkerRanges[rangeAsString] = true;\n                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);\n            }\n        }\n        this.docLen = session.getValue().length;\n    };\n    return SearchHighlight;\n}());\nSearchHighlight.prototype.MAX_RANGES = 500;\nexports.SearchHighlight = SearchHighlight;\n\n});\n\nace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar UndoManager = /** @class */ (function () {\n    function UndoManager() {\n        this.$keepRedoStack;\n        this.$maxRev = 0;\n        this.$fromUndo = false;\n        this.$undoDepth = Infinity;\n        this.reset();\n    }\n    UndoManager.prototype.addSession = function (session) {\n        this.$session = session;\n    };\n    UndoManager.prototype.add = function (delta, allowMerge, session) {\n        if (this.$fromUndo)\n            return;\n        if (delta == this.$lastDelta)\n            return;\n        if (!this.$keepRedoStack)\n            this.$redoStack.length = 0;\n        if (allowMerge === false || !this.lastDeltas) {\n            this.lastDeltas = [];\n            var undoStackLength = this.$undoStack.length;\n            if (undoStackLength > this.$undoDepth - 1) {\n                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);\n            }\n            this.$undoStack.push(this.lastDeltas);\n            delta.id = this.$rev = ++this.$maxRev;\n        }\n        if (delta.action == \"remove\" || delta.action == \"insert\")\n            this.$lastDelta = delta;\n        this.lastDeltas.push(delta);\n    };\n    UndoManager.prototype.addSelection = function (selection, rev) {\n        this.selections.push({\n            value: selection,\n            rev: rev || this.$rev\n        });\n    };\n    UndoManager.prototype.startNewGroup = function () {\n        this.lastDeltas = null;\n        return this.$rev;\n    };\n    UndoManager.prototype.markIgnored = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n        var stack = this.$undoStack;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id <= from)\n                break;\n            if (delta.id < to)\n                delta.ignore = true;\n        }\n        this.lastDeltas = null;\n    };\n    UndoManager.prototype.getSelection = function (rev, after) {\n        var stack = this.selections;\n        for (var i = stack.length; i--;) {\n            var selection = stack[i];\n            if (selection.rev < rev) {\n                if (after)\n                    selection = stack[i + 1];\n                return selection;\n            }\n        }\n    };\n    UndoManager.prototype.getRevision = function () {\n        return this.$rev;\n    };\n    UndoManager.prototype.getDeltas = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n        var stack = this.$undoStack;\n        var end = null, start = 0;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id < to && !end)\n                end = i + 1;\n            if (delta.id <= from) {\n                start = i + 1;\n                break;\n            }\n        }\n        return stack.slice(start, end);\n    };\n    UndoManager.prototype.getChangedRanges = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n    };\n    UndoManager.prototype.getChangedLines = function (from, to) {\n        if (to == null)\n            to = this.$rev + 1;\n    };\n    UndoManager.prototype.undo = function (session, dontSelect) {\n        this.lastDeltas = null;\n        var stack = this.$undoStack;\n        if (!rearrangeUndoStack(stack, stack.length))\n            return;\n        if (!session)\n            session = this.$session;\n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\n            this.$redoStack = [];\n        this.$fromUndo = true;\n        var deltaSet = stack.pop();\n        var undoSelectionRange = null;\n        if (deltaSet) {\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\n            this.$redoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        return undoSelectionRange;\n    };\n    UndoManager.prototype.redo = function (session, dontSelect) {\n        this.lastDeltas = null;\n        if (!session)\n            session = this.$session;\n        this.$fromUndo = true;\n        if (this.$redoStackBaseRev != this.$rev) {\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\n            rebaseRedoStack(this.$redoStack, diff);\n            this.$redoStackBaseRev = this.$rev;\n            this.$redoStack.forEach(function (x) {\n                x[0].id = ++this.$maxRev;\n            }, this);\n        }\n        var deltaSet = this.$redoStack.pop();\n        var redoSelectionRange = null;\n        if (deltaSet) {\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\n            this.$undoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        return redoSelectionRange;\n    };\n    UndoManager.prototype.$syncRev = function () {\n        var stack = this.$undoStack;\n        var nextDelta = stack[stack.length - 1];\n        var id = nextDelta && nextDelta[0].id || 0;\n        this.$redoStackBaseRev = id;\n        this.$rev = id;\n    };\n    UndoManager.prototype.reset = function () {\n        this.lastDeltas = null;\n        this.$lastDelta = null;\n        this.$undoStack = [];\n        this.$redoStack = [];\n        this.$rev = 0;\n        this.mark = 0;\n        this.$redoStackBaseRev = this.$rev;\n        this.selections = [];\n    };\n    UndoManager.prototype.canUndo = function () {\n        return this.$undoStack.length > 0;\n    };\n    UndoManager.prototype.canRedo = function () {\n        return this.$redoStack.length > 0;\n    };\n    UndoManager.prototype.bookmark = function (rev) {\n        if (rev == undefined)\n            rev = this.$rev;\n        this.mark = rev;\n    };\n    UndoManager.prototype.isAtBookmark = function () {\n        return this.$rev === this.mark;\n    };\n    UndoManager.prototype.toJSON = function () {\n        return {\n            $redoStack: this.$redoStack,\n            $undoStack: this.$undoStack\n        };\n    };\n    UndoManager.prototype.fromJSON = function (json) {\n        this.reset();\n        this.$undoStack = json.$undoStack;\n        this.$redoStack = json.$redoStack;\n    };\n    UndoManager.prototype.$prettyPrint = function (delta) {\n        if (delta)\n            return stringifyDelta(delta);\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\n    };\n    return UndoManager;\n}());\nUndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;\nUndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;\nUndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;\nUndoManager.prototype.markClean = UndoManager.prototype.bookmark;\nfunction rearrangeUndoStack(stack, pos) {\n    for (var i = pos; i--;) {\n        var deltaSet = stack[i];\n        if (deltaSet && !deltaSet[0].ignore) {\n            while (i < pos - 1) {\n                var swapped = swapGroups(stack[i], stack[i + 1]);\n                stack[i] = swapped[0];\n                stack[i + 1] = swapped[1];\n                i++;\n            }\n            return true;\n        }\n    }\n}\nvar Range = require(\"./range\").Range;\nvar cmp = Range.comparePoints;\nvar comparePoints = Range.comparePoints;\nfunction $updateMarkers(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert)\n        end = start;\n    for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = comparePoints(point, start);\n        if (cmp < 0) {\n            continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n            if (isInsert) {\n                if (point.bias == 1) {\n                    cmp = 1;\n                }\n                else {\n                    point.bias == -1;\n                    continue;\n                }\n            }\n        }\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\n        if (cmp2 > 0) {\n            point.row += rowShift;\n            point.column += point.row == end.row ? colShift : 0;\n            continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n            point.row = start.row;\n            point.column = start.column;\n            if (cmp2 === 0)\n                point.bias = 1;\n        }\n    }\n}\nfunction clonePos(pos) {\n    return { row: pos.row, column: pos.column };\n}\nfunction cloneDelta(d) {\n    return {\n        start: clonePos(d.start),\n        end: clonePos(d.end),\n        action: d.action,\n        lines: d.lines.slice()\n    };\n}\nfunction stringifyDelta(d) {\n    d = d || this;\n    if (Array.isArray(d)) {\n        return d.map(stringifyDelta).join(\"\\n\");\n    }\n    var type = \"\";\n    if (d.action) {\n        type = d.action == \"insert\" ? \"+\" : \"-\";\n        type += \"[\" + d.lines + \"]\";\n    }\n    else if (d.value) {\n        if (Array.isArray(d.value)) {\n            type = d.value.map(stringifyRange).join(\"\\n\");\n        }\n        else {\n            type = stringifyRange(d.value);\n        }\n    }\n    if (d.start) {\n        type += stringifyRange(d);\n    }\n    if (d.id || d.rev) {\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\n    }\n    return type;\n}\nfunction stringifyRange(r) {\n    return r.start.row + \":\" + r.start.column\n        + \"=>\" + r.end.row + \":\" + r.end.column;\n}\nfunction swap(d1, d2) {\n    var i1 = d1.action == \"insert\";\n    var i2 = d2.action == \"insert\";\n    if (i1 && i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        }\n        else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (i1 && !i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        }\n        else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (!i1 && i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        }\n        else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        }\n        else {\n            return null;\n        }\n    }\n    else if (!i1 && !i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        }\n        else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        }\n        else {\n            return null;\n        }\n    }\n    return [d2, d1];\n}\nfunction swapGroups(ds1, ds2) {\n    for (var i = ds1.length; i--;) {\n        for (var j = 0; j < ds2.length; j++) {\n            if (!swap(ds1[i], ds2[j])) {\n                while (i < ds1.length) {\n                    while (j--) {\n                        swap(ds2[j], ds1[i]);\n                    }\n                    j = ds2.length;\n                    i++;\n                }\n                return [ds1, ds2];\n            }\n        }\n    }\n    ds1.selectionBefore = ds2.selectionBefore =\n        ds1.selectionAfter = ds2.selectionAfter = null;\n    return [ds2, ds1];\n}\nfunction xform(d1, c1) {\n    var i1 = d1.action == \"insert\";\n    var i2 = c1.action == \"insert\";\n    if (i1 && i2) {\n        if (cmp(d1.start, c1.start) < 0) {\n            shift(c1, d1, 1);\n        }\n        else {\n            shift(d1, c1, 1);\n        }\n    }\n    else if (i1 && !i2) {\n        if (cmp(d1.start, c1.end) >= 0) {\n            shift(d1, c1, -1);\n        }\n        else if (cmp(d1.start, c1.start) <= 0) {\n            shift(c1, d1, +1);\n        }\n        else {\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\n            shift(c1, d1, +1);\n        }\n    }\n    else if (!i1 && i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        }\n        else if (cmp(c1.start, d1.start) <= 0) {\n            shift(d1, c1, +1);\n        }\n        else {\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\n            shift(d1, c1, +1);\n        }\n    }\n    else if (!i1 && !i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        }\n        else if (cmp(c1.end, d1.start) <= 0) {\n            shift(d1, c1, -1);\n        }\n        else {\n            var before, after;\n            if (cmp(d1.start, c1.start) < 0) {\n                before = d1;\n                d1 = splitDelta(d1, c1.start);\n            }\n            if (cmp(d1.end, c1.end) > 0) {\n                after = splitDelta(d1, c1.end);\n            }\n            shiftPos(c1.end, d1.start, d1.end, -1);\n            if (after && !before) {\n                d1.lines = after.lines;\n                d1.start = after.start;\n                d1.end = after.end;\n                after = d1;\n            }\n            return [c1, before, after].filter(Boolean);\n        }\n    }\n    return [c1, d1];\n}\nfunction shift(d1, d2, dir) {\n    shiftPos(d1.start, d2.start, d2.end, dir);\n    shiftPos(d1.end, d2.start, d2.end, dir);\n}\nfunction shiftPos(pos, start, end, dir) {\n    if (pos.row == (dir == 1 ? start : end).row) {\n        pos.column += dir * (end.column - start.column);\n    }\n    pos.row += dir * (end.row - start.row);\n}\nfunction splitDelta(c, pos) {\n    var lines = c.lines;\n    var end = c.end;\n    c.end = clonePos(pos);\n    var rowsBefore = c.end.row - c.start.row;\n    var otherLines = lines.splice(rowsBefore, lines.length);\n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\n    lines.push(otherLines[0].substring(0, col));\n    otherLines[0] = otherLines[0].substr(col);\n    var rest = {\n        start: clonePos(pos),\n        end: end,\n        lines: otherLines,\n        action: c.action\n    };\n    return rest;\n}\nfunction moveDeltasByOne(redoStack, d) {\n    d = cloneDelta(d);\n    for (var j = redoStack.length; j--;) {\n        var deltaSet = redoStack[j];\n        for (var i = 0; i < deltaSet.length; i++) {\n            var x = deltaSet[i];\n            var xformed = xform(x, d);\n            d = xformed[0];\n            if (xformed.length != 2) {\n                if (xformed[2]) {\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\n                    i++;\n                }\n                else if (!xformed[1]) {\n                    deltaSet.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (!deltaSet.length) {\n            redoStack.splice(j, 1);\n        }\n    }\n    return redoStack;\n}\nfunction rebaseRedoStack(redoStack, deltaSets) {\n    for (var i = 0; i < deltaSets.length; i++) {\n        var deltas = deltaSets[i];\n        for (var j = 0; j < deltas.length; j++) {\n            moveDeltasByOne(redoStack, deltas[j]);\n        }\n    }\n}\nexports.UndoManager = UndoManager;\n\n});\n\nace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar FoldLine = /** @class */ (function () {\n    function FoldLine(foldData, folds) {\n        this.foldData = foldData;\n        if (Array.isArray(folds)) {\n            this.folds = folds;\n        }\n        else {\n            folds = this.folds = [folds];\n        }\n        var last = folds[folds.length - 1];\n        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);\n        this.start = this.range.start;\n        this.end = this.range.end;\n        this.folds.forEach(function (fold) {\n            fold.setFoldLine(this);\n        }, this);\n    }\n    FoldLine.prototype.shiftRow = function (shift) {\n        this.start.row += shift;\n        this.end.row += shift;\n        this.folds.forEach(function (fold) {\n            fold.start.row += shift;\n            fold.end.row += shift;\n        });\n    };\n    FoldLine.prototype.addFold = function (fold) {\n        if (fold.sameRow) {\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n            }\n            this.folds.push(fold);\n            this.folds.sort(function (a, b) {\n                return -a.range.compareEnd(b.start.row, b.start.column);\n            });\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n                this.end.row = fold.end.row;\n                this.end.column = fold.end.column;\n            }\n            else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n                this.start.row = fold.start.row;\n                this.start.column = fold.start.column;\n            }\n        }\n        else if (fold.start.row == this.end.row) {\n            this.folds.push(fold);\n            this.end.row = fold.end.row;\n            this.end.column = fold.end.column;\n        }\n        else if (fold.end.row == this.start.row) {\n            this.folds.unshift(fold);\n            this.start.row = fold.start.row;\n            this.start.column = fold.start.column;\n        }\n        else {\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n        }\n        fold.foldLine = this;\n    };\n    FoldLine.prototype.containsRow = function (row) {\n        return row >= this.start.row && row <= this.end.row;\n    };\n    FoldLine.prototype.walk = function (callback, endRow, endColumn) {\n        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;\n        if (endRow == null) {\n            endRow = this.end.row;\n            endColumn = this.end.column;\n        }\n        for (var i = 0; i < folds.length; i++) {\n            fold = folds[i];\n            cmp = fold.range.compareStart(endRow, endColumn);\n            if (cmp == -1) {\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\n                return;\n            }\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n            if (stop || cmp === 0) {\n                return;\n            }\n            isNewRow = !fold.sameRow;\n            lastEnd = fold.end.column;\n        }\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\n    };\n    FoldLine.prototype.getNextFoldTo = function (row, column) {\n        var fold, cmp;\n        for (var i = 0; i < this.folds.length; i++) {\n            fold = this.folds[i];\n            cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                return {\n                    fold: fold,\n                    kind: \"after\"\n                };\n            }\n            else if (cmp === 0) {\n                return {\n                    fold: fold,\n                    kind: \"inside\"\n                };\n            }\n        }\n        return null;\n    };\n    FoldLine.prototype.addRemoveChars = function (row, column, len) {\n        var ret = this.getNextFoldTo(row, column), fold, folds;\n        if (ret) {\n            fold = ret.fold;\n            if (ret.kind == \"inside\"\n                && fold.start.column != column\n                && fold.start.row != row) {\n                window.console && window.console.log(row, column, fold);\n            }\n            else if (fold.start.row == row) {\n                folds = this.folds;\n                var i = folds.indexOf(fold);\n                if (i === 0) {\n                    this.start.column += len;\n                }\n                for (i; i < folds.length; i++) {\n                    fold = folds[i];\n                    fold.start.column += len;\n                    if (!fold.sameRow) {\n                        return;\n                    }\n                    fold.end.column += len;\n                }\n                this.end.column += len;\n            }\n        }\n    };\n    FoldLine.prototype.split = function (row, column) {\n        var pos = this.getNextFoldTo(row, column);\n        if (!pos || pos.kind == \"inside\")\n            return null;\n        var fold = pos.fold;\n        var folds = this.folds;\n        var foldData = this.foldData;\n        var i = folds.indexOf(fold);\n        var foldBefore = folds[i - 1];\n        this.end.row = foldBefore.end.row;\n        this.end.column = foldBefore.end.column;\n        folds = folds.splice(i, folds.length - i);\n        var newFoldLine = new FoldLine(foldData, folds);\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n        return newFoldLine;\n    };\n    FoldLine.prototype.merge = function (foldLineNext) {\n        var folds = foldLineNext.folds;\n        for (var i = 0; i < folds.length; i++) {\n            this.addFold(folds[i]);\n        }\n        var foldData = this.foldData;\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\n    };\n    FoldLine.prototype.toString = function () {\n        var ret = [this.range.toString() + \": [\"];\n        this.folds.forEach(function (fold) {\n            ret.push(\"  \" + fold.toString());\n        });\n        ret.push(\"]\");\n        return ret.join(\"\\n\");\n    };\n    FoldLine.prototype.idxToPosition = function (idx) {\n        var lastFoldEndColumn = 0;\n        for (var i = 0; i < this.folds.length; i++) {\n            var fold = this.folds[i];\n            idx -= fold.start.column - lastFoldEndColumn;\n            if (idx < 0) {\n                return {\n                    row: fold.start.row,\n                    column: fold.start.column + idx\n                };\n            }\n            idx -= fold.placeholder.length;\n            if (idx < 0) {\n                return fold.start;\n            }\n            lastFoldEndColumn = fold.end.column;\n        }\n        return {\n            row: this.end.row,\n            column: this.end.column + idx\n        };\n    };\n    return FoldLine;\n}());\nexports.FoldLine = FoldLine;\n\n});\n\nace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar comparePoints = Range.comparePoints;\nvar RangeList = /** @class */ (function () {\n    function RangeList() {\n        this.ranges = [];\n        this.$bias = 1;\n    }\n    RangeList.prototype.pointIndex = function (pos, excludeEdges, startIndex) {\n        var list = this.ranges;\n        for (var i = startIndex || 0; i < list.length; i++) {\n            var range = list[i];\n            var cmpEnd = comparePoints(pos, range.end);\n            if (cmpEnd > 0)\n                continue;\n            var cmpStart = comparePoints(pos, range.start);\n            if (cmpEnd === 0)\n                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;\n            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n                return i;\n            return -i - 1;\n        }\n        return -i - 1;\n    };\n    RangeList.prototype.add = function (range) {\n        var excludeEdges = !range.isEmpty();\n        var startIndex = this.pointIndex(range.start, excludeEdges);\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        else\n            endIndex++;\n        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n    };\n    RangeList.prototype.addList = function (list) {\n        var removed = [];\n        for (var i = list.length; i--;) {\n            removed.push.apply(removed, this.add(list[i]));\n        }\n        return removed;\n    };\n    RangeList.prototype.substractPoint = function (pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges.splice(i, 1);\n    };\n    RangeList.prototype.merge = function () {\n        var removed = [];\n        var list = this.ranges;\n        list = list.sort(function (a, b) {\n            return comparePoints(a.start, b.start);\n        });\n        var next = list[0], range;\n        for (var i = 1; i < list.length; i++) {\n            range = next;\n            next = list[i];\n            var cmp = comparePoints(range.end, next.start);\n            if (cmp < 0)\n                continue;\n            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n                continue;\n            if (comparePoints(range.end, next.end) < 0) {\n                range.end.row = next.end.row;\n                range.end.column = next.end.column;\n            }\n            list.splice(i, 1);\n            removed.push(next);\n            next = range;\n            i--;\n        }\n        this.ranges = list;\n        return removed;\n    };\n    RangeList.prototype.contains = function (row, column) {\n        return this.pointIndex({ row: row, column: column }) >= 0;\n    };\n    RangeList.prototype.containsPoint = function (pos) {\n        return this.pointIndex(pos) >= 0;\n    };\n    RangeList.prototype.rangeAtPoint = function (pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges[i];\n    };\n    RangeList.prototype.clipRows = function (startRow, endRow) {\n        var list = this.ranges;\n        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n            return [];\n        var startIndex = this.pointIndex({ row: startRow, column: 0 });\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        var clipped = [];\n        for (var i = startIndex; i < endIndex; i++) {\n            clipped.push(list[i]);\n        }\n        return clipped;\n    };\n    RangeList.prototype.removeAll = function () {\n        return this.ranges.splice(0, this.ranges.length);\n    };\n    RangeList.prototype.attach = function (session) {\n        if (this.session)\n            this.detach();\n        this.session = session;\n        this.onChange = this.$onChange.bind(this);\n        this.session.on('change', this.onChange);\n    };\n    RangeList.prototype.detach = function () {\n        if (!this.session)\n            return;\n        this.session.removeListener('change', this.onChange);\n        this.session = null;\n    };\n    RangeList.prototype.$onChange = function (delta) {\n        var start = delta.start;\n        var end = delta.end;\n        var startRow = start.row;\n        var endRow = end.row;\n        var ranges = this.ranges;\n        for (var i = 0, n = ranges.length; i < n; i++) {\n            var r = ranges[i];\n            if (r.end.row >= startRow)\n                break;\n        }\n        if (delta.action == \"insert\") {\n            var lineDif = endRow - startRow;\n            var colDiff = -start.column + end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > startRow)\n                    break;\n                if (r.start.row == startRow && r.start.column >= start.column) {\n                    if (r.start.column == start.column && this.$bias <= 0) {\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                if (r.end.row == startRow && r.end.column >= start.column) {\n                    if (r.end.column == start.column && this.$bias < 0) {\n                        continue;\n                    }\n                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {\n                        if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)\n                            r.end.column -= colDiff;\n                    }\n                    r.end.column += colDiff;\n                    r.end.row += lineDif;\n                }\n            }\n        }\n        else {\n            var lineDif = startRow - endRow;\n            var colDiff = start.column - end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > endRow)\n                    break;\n                if (r.end.row < endRow\n                    && (startRow < r.end.row\n                        || startRow == r.end.row && start.column < r.end.column)) {\n                    r.end.row = startRow;\n                    r.end.column = start.column;\n                }\n                else if (r.end.row == endRow) {\n                    if (r.end.column <= end.column) {\n                        if (lineDif || r.end.column > start.column) {\n                            r.end.column = start.column;\n                            r.end.row = start.row;\n                        }\n                    }\n                    else {\n                        r.end.column += colDiff;\n                        r.end.row += lineDif;\n                    }\n                }\n                else if (r.end.row > endRow) {\n                    r.end.row += lineDif;\n                }\n                if (r.start.row < endRow\n                    && (startRow < r.start.row\n                        || startRow == r.start.row && start.column < r.start.column)) {\n                    r.start.row = startRow;\n                    r.start.column = start.column;\n                }\n                else if (r.start.row == endRow) {\n                    if (r.start.column <= end.column) {\n                        if (lineDif || r.start.column > start.column) {\n                            r.start.column = start.column;\n                            r.start.row = start.row;\n                        }\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                else if (r.start.row > endRow) {\n                    r.start.row += lineDif;\n                }\n            }\n        }\n        if (lineDif != 0 && i < n) {\n            for (; i < n; i++) {\n                var r = ranges[i];\n                r.start.row += lineDif;\n                r.end.row += lineDif;\n            }\n        }\n    };\n    return RangeList;\n}());\nRangeList.prototype.comparePoints = comparePoints;\nexports.RangeList = RangeList;\n\n});\n\nace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range_list\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RangeList = require(\"../range_list\").RangeList;\nvar Fold = /** @class */ (function (_super) {\n    __extends(Fold, _super);\n    function Fold(range, placeholder) {\n        var _this = _super.call(this) || this;\n        _this.foldLine = null;\n        _this.placeholder = placeholder;\n        _this.range = range;\n        _this.start = range.start;\n        _this.end = range.end;\n        _this.sameRow = range.start.row == range.end.row;\n        _this.subFolds = _this.ranges = [];\n        return _this;\n    }\n    Fold.prototype.toString = function () {\n        return '\"' + this.placeholder + '\" ' + this.range.toString();\n    };\n    Fold.prototype.setFoldLine = function (foldLine) {\n        this.foldLine = foldLine;\n        this.subFolds.forEach(function (fold) {\n            fold.setFoldLine(foldLine);\n        });\n    };\n    Fold.prototype.clone = function () {\n        var range = this.range.clone();\n        var fold = new Fold(range, this.placeholder);\n        this.subFolds.forEach(function (subFold) {\n            fold.subFolds.push(subFold.clone());\n        });\n        fold.collapseChildren = this.collapseChildren;\n        return fold;\n    };\n    Fold.prototype.addSubFold = function (fold) {\n        if (this.range.isEqual(fold))\n            return;\n        consumeRange(fold, this.start);\n        var row = fold.start.row, column = fold.start.column;\n        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n            cmp = this.subFolds[i].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterStart = this.subFolds[i];\n        var firstConsumed = 0;\n        if (cmp == 0) {\n            if (afterStart.range.containsRange(fold))\n                return afterStart.addSubFold(fold);\n            else\n                firstConsumed = 1;\n        }\n        var row = fold.range.end.row, column = fold.range.end.column;\n        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n            cmp = this.subFolds[j].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        if (cmp == 0)\n            j++;\n        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;\n        for (var k = firstConsumed; k < last; k++) {\n            fold.addSubFold(consumedFolds[k]);\n        }\n        fold.setFoldLine(this.foldLine);\n        return fold;\n    };\n    Fold.prototype.restoreRange = function (range) {\n        return restoreRange(range, this.start);\n    };\n    return Fold;\n}(RangeList));\nfunction consumePoint(point, anchor) {\n    point.row -= anchor.row;\n    if (point.row == 0)\n        point.column -= anchor.column;\n}\nfunction consumeRange(range, anchor) {\n    consumePoint(range.start, anchor);\n    consumePoint(range.end, anchor);\n}\nfunction restorePoint(point, anchor) {\n    if (point.row == 0)\n        point.column += anchor.column;\n    point.row += anchor.row;\n}\nfunction restoreRange(range, anchor) {\n    restorePoint(range.start, anchor);\n    restorePoint(range.end, anchor);\n}\nexports.Fold = Fold;\n\n});\n\nace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\",\"ace/mouse/mouse_event\"], function(require, exports, module){// @ts-nocheck\n\"use strict\";\nvar Range = require(\"../range\").Range;\nvar FoldLine = require(\"./fold_line\").FoldLine;\nvar Fold = require(\"./fold\").Fold;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar MouseEvent = require(\"../mouse/mouse_event\").MouseEvent;\nfunction Folding() {\n    this.getFoldAt = function (row, column, side) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n        var folds = foldLine.folds;\n        for (var i = 0; i < folds.length; i++) {\n            var range = folds[i].range;\n            if (range.contains(row, column)) {\n                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {\n                    continue;\n                }\n                else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {\n                    continue;\n                }\n                return folds[i];\n            }\n        }\n    };\n    this.getFoldsInRange = function (range) {\n        var start = range.start;\n        var end = range.end;\n        var foldLines = this.$foldData;\n        var foundFolds = [];\n        start.column += 1;\n        end.column -= 1;\n        for (var i = 0; i < foldLines.length; i++) {\n            var cmp = foldLines[i].range.compareRange(range);\n            if (cmp == 2) {\n                continue;\n            }\n            else if (cmp == -2) {\n                break;\n            }\n            var folds = foldLines[i].folds;\n            for (var j = 0; j < folds.length; j++) {\n                var fold = folds[j];\n                cmp = fold.range.compareRange(range);\n                if (cmp == -2) {\n                    break;\n                }\n                else if (cmp == 2) {\n                    continue;\n                }\n                else \n                if (cmp == 42) {\n                    break;\n                }\n                foundFolds.push(fold);\n            }\n        }\n        start.column -= 1;\n        end.column += 1;\n        return foundFolds;\n    };\n    this.getFoldsInRangeList = function (ranges) {\n        if (Array.isArray(ranges)) {\n            var folds = [];\n            ranges.forEach(function (range) {\n                folds = folds.concat(this.getFoldsInRange(range));\n            }, this);\n        }\n        else {\n            var folds = this.getFoldsInRange(ranges);\n        }\n        return folds;\n    };\n    this.getAllFolds = function () {\n        var folds = [];\n        var foldLines = this.$foldData;\n        for (var i = 0; i < foldLines.length; i++)\n            for (var j = 0; j < foldLines[i].folds.length; j++)\n                folds.push(foldLines[i].folds[j]);\n        return folds;\n    };\n    this.getFoldStringAt = function (row, column, trim, foldLine) {\n        foldLine = foldLine || this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n        var lastFold = {\n            end: { column: 0 }\n        };\n        var str, fold;\n        for (var i = 0; i < foldLine.folds.length; i++) {\n            fold = foldLine.folds[i];\n            var cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                str = this\n                    .getLine(fold.start.row)\n                    .substring(lastFold.end.column, fold.start.column);\n                break;\n            }\n            else if (cmp === 0) {\n                return null;\n            }\n            lastFold = fold;\n        }\n        if (!str)\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n        if (trim == -1)\n            return str.substring(0, column - lastFold.end.column);\n        else if (trim == 1)\n            return str.substring(column - lastFold.end.column);\n        else\n            return str;\n    };\n    this.getFoldLine = function (docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n            else if (foldLine.end.row > docRow) {\n                return null;\n            }\n        }\n        return null;\n    };\n    this.getNextFoldLine = function (docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n        }\n        return null;\n    };\n    this.getFoldedRowCount = function (first, last) {\n        var foldData = this.$foldData, rowCount = last - first + 1;\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;\n            if (end >= last) {\n                if (start < last) {\n                    if (start >= first)\n                        rowCount -= last - start;\n                    else\n                        rowCount = 0; // in one fold\n                }\n                break;\n            }\n            else if (end >= first) {\n                if (start >= first) // fold inside range\n                    rowCount -= end - start;\n                else\n                    rowCount -= end - first + 1;\n            }\n        }\n        return rowCount;\n    };\n    this.$addFoldLine = function (foldLine) {\n        this.$foldData.push(foldLine);\n        this.$foldData.sort(function (a, b) {\n            return a.start.row - b.start.row;\n        });\n        return foldLine;\n    };\n    this.addFold = function (placeholder, range) {\n        var foldData = this.$foldData;\n        var added = false;\n        var fold;\n        if (placeholder instanceof Fold)\n            fold = placeholder;\n        else {\n            fold = new Fold(range, placeholder);\n            fold.collapseChildren = range.collapseChildren;\n        }\n        this.$clipRangeToDocument(fold.range);\n        var startRow = fold.start.row;\n        var startColumn = fold.start.column;\n        var endRow = fold.end.row;\n        var endColumn = fold.end.column;\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\n        if (startFold && endFold == startFold)\n            return startFold.addSubFold(fold);\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\n            this.removeFold(startFold);\n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n            this.removeFold(endFold);\n        var folds = this.getFoldsInRange(fold.range);\n        if (folds.length > 0) {\n            this.removeFolds(folds);\n            if (!fold.collapseChildren) {\n                folds.forEach(function (subFold) {\n                    fold.addSubFold(subFold);\n                });\n            }\n        }\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (endRow == foldLine.start.row) {\n                foldLine.addFold(fold);\n                added = true;\n                break;\n            }\n            else if (startRow == foldLine.end.row) {\n                foldLine.addFold(fold);\n                added = true;\n                if (!fold.sameRow) {\n                    var foldLineNext = foldData[i + 1];\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\n                        foldLine.merge(foldLineNext);\n                        break;\n                    }\n                }\n                break;\n            }\n            else if (endRow <= foldLine.start.row) {\n                break;\n            }\n        }\n        if (!added)\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n        if (this.$useWrapMode)\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n        else\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\n        return fold;\n    };\n    this.addFolds = function (folds) {\n        folds.forEach(function (fold) {\n            this.addFold(fold);\n        }, this);\n    };\n    this.removeFold = function (fold) {\n        var foldLine = fold.foldLine;\n        var startRow = foldLine.start.row;\n        var endRow = foldLine.end.row;\n        var foldLines = this.$foldData;\n        var folds = foldLine.folds;\n        if (folds.length == 1) {\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\n        }\n        else \n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n            folds.pop();\n            foldLine.end.row = folds[folds.length - 1].end.row;\n            foldLine.end.column = folds[folds.length - 1].end.column;\n        }\n        else \n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n            folds.shift();\n            foldLine.start.row = folds[0].start.row;\n            foldLine.start.column = folds[0].start.column;\n        }\n        else \n        if (fold.sameRow) {\n            folds.splice(folds.indexOf(fold), 1);\n        }\n        else \n        {\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n            folds = newFoldLine.folds;\n            folds.shift();\n            newFoldLine.start.row = folds[0].start.row;\n            newFoldLine.start.column = folds[0].start.column;\n        }\n        if (!this.$updating) {\n            if (this.$useWrapMode)\n                this.$updateWrapData(startRow, endRow);\n            else\n                this.$updateRowLengthCache(startRow, endRow);\n        }\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\n    };\n    this.removeFolds = function (folds) {\n        var cloneFolds = [];\n        for (var i = 0; i < folds.length; i++) {\n            cloneFolds.push(folds[i]);\n        }\n        cloneFolds.forEach(function (fold) {\n            this.removeFold(fold);\n        }, this);\n        this.$modified = true;\n    };\n    this.expandFold = function (fold) {\n        this.removeFold(fold);\n        fold.subFolds.forEach(function (subFold) {\n            fold.restoreRange(subFold);\n            this.addFold(subFold);\n        }, this);\n        if (fold.collapseChildren > 0) {\n            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);\n        }\n        fold.subFolds = [];\n    };\n    this.expandFolds = function (folds) {\n        folds.forEach(function (fold) {\n            this.expandFold(fold);\n        }, this);\n    };\n    this.unfold = function (location, expandInner) {\n        var range, folds;\n        if (location == null) {\n            range = new Range(0, 0, this.getLength(), 0);\n            if (expandInner == null)\n                expandInner = true;\n        }\n        else if (typeof location == \"number\") {\n            range = new Range(location, 0, location, this.getLine(location).length);\n        }\n        else if (\"row\" in location) {\n            range = Range.fromPoints(location, location);\n        }\n        else if (Array.isArray(location)) {\n            folds = [];\n            location.forEach(function (range) {\n                folds = folds.concat(this.unfold(range));\n            }, this);\n            return folds;\n        }\n        else {\n            range = location;\n        }\n        folds = this.getFoldsInRangeList(range);\n        var outermostFolds = folds;\n        while (folds.length == 1\n            && Range.comparePoints(folds[0].start, range.start) < 0\n            && Range.comparePoints(folds[0].end, range.end) > 0) {\n            this.expandFolds(folds);\n            folds = this.getFoldsInRangeList(range);\n        }\n        if (expandInner != false) {\n            this.removeFolds(folds);\n        }\n        else {\n            this.expandFolds(folds);\n        }\n        if (outermostFolds.length)\n            return outermostFolds;\n    };\n    this.isRowFolded = function (docRow, startFoldRow) {\n        return !!this.getFoldLine(docRow, startFoldRow);\n    };\n    this.getRowFoldEnd = function (docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.end.row : docRow;\n    };\n    this.getRowFoldStart = function (docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.start.row : docRow;\n    };\n    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {\n        if (startRow == null)\n            startRow = foldLine.start.row;\n        if (startColumn == null)\n            startColumn = 0;\n        if (endRow == null)\n            endRow = foldLine.end.row;\n        if (endColumn == null)\n            endColumn = this.getLine(endRow).length;\n        var doc = this.doc;\n        var textLine = \"\";\n        foldLine.walk(function (placeholder, row, column, lastColumn) {\n            if (row < startRow)\n                return;\n            if (row == startRow) {\n                if (column < startColumn)\n                    return;\n                lastColumn = Math.max(startColumn, lastColumn);\n            }\n            if (placeholder != null) {\n                textLine += placeholder;\n            }\n            else {\n                textLine += doc.getLine(row).substring(lastColumn, column);\n            }\n        }, endRow, endColumn);\n        return textLine;\n    };\n    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine) {\n            var line;\n            line = this.doc.getLine(row);\n            return line.substring(startColumn || 0, endColumn || line.length);\n        }\n        else {\n            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);\n        }\n    };\n    this.$cloneFoldData = function () {\n        var fd = [];\n        fd = this.$foldData.map(function (foldLine) {\n            var folds = foldLine.folds.map(function (fold) {\n                return fold.clone();\n            });\n            return new FoldLine(fd, folds);\n        });\n        return fd;\n    };\n    this.toggleFold = function (tryToUnfold) {\n        var selection = this.selection;\n        var range = selection.getRange();\n        var fold;\n        var bracketPos;\n        if (range.isEmpty()) {\n            var cursor = range.start;\n            fold = this.getFoldAt(cursor.row, cursor.column);\n            if (fold) {\n                this.expandFold(fold);\n                return;\n            }\n            else if (bracketPos = this.findMatchingBracket(cursor)) {\n                if (range.comparePoint(bracketPos) == 1) {\n                    range.end = bracketPos;\n                }\n                else {\n                    range.start = bracketPos;\n                    range.start.column++;\n                    range.end.column--;\n                }\n            }\n            else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {\n                if (range.comparePoint(bracketPos) == 1)\n                    range.end = bracketPos;\n                else\n                    range.start = bracketPos;\n                range.start.column++;\n            }\n            else {\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n            }\n        }\n        else {\n            var folds = this.getFoldsInRange(range);\n            if (tryToUnfold && folds.length) {\n                this.expandFolds(folds);\n                return;\n            }\n            else if (folds.length == 1) {\n                fold = folds[0];\n            }\n        }\n        if (!fold)\n            fold = this.getFoldAt(range.start.row, range.start.column);\n        if (fold && fold.range.toString() == range.toString()) {\n            this.expandFold(fold);\n            return;\n        }\n        var placeholder = \"...\";\n        if (!range.isMultiLine()) {\n            placeholder = this.getTextRange(range);\n            if (placeholder.length < 4)\n                return;\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n        }\n        this.addFold(placeholder, range);\n    };\n    this.getCommentFoldRange = function (row, column, dir) {\n        var iterator = new TokenIterator(this, row, column);\n        var token = iterator.getCurrentToken();\n        var type = token && token.type;\n        if (token && /^comment|string/.test(type)) {\n            type = type.match(/comment|string/)[0];\n            if (type == \"comment\")\n                type += \"|doc-start|\\\\.doc\";\n            var re = new RegExp(type);\n            var range = new Range();\n            if (dir != 1) {\n                do {\n                    token = iterator.stepBackward();\n                } while (token && re.test(token.type));\n                token = iterator.stepForward();\n            }\n            range.start.row = iterator.getCurrentTokenRow();\n            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;\n            iterator = new TokenIterator(this, row, column);\n            var initState = this.getState(iterator.$row);\n            if (dir != -1) {\n                var lastRow = -1;\n                do {\n                    token = iterator.stepForward();\n                    if (lastRow == -1) {\n                        var state = this.getState(iterator.$row);\n                        if (initState.toString() !== state.toString())\n                            lastRow = iterator.$row;\n                    }\n                    else if (iterator.$row > lastRow) {\n                        break;\n                    }\n                } while (token && re.test(token.type));\n                token = iterator.stepBackward();\n            }\n            else\n                token = iterator.getCurrentToken();\n            range.end.row = iterator.getCurrentTokenRow();\n            range.end.column = iterator.getCurrentTokenColumn();\n            return range;\n        }\n    };\n    this.foldAll = function (startRow, endRow, depth, test) {\n        if (depth == undefined)\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\n        var foldWidgets = this.foldWidgets;\n        if (!foldWidgets)\n            return; // mode doesn't support folding\n        endRow = endRow || this.getLength();\n        startRow = startRow || 0;\n        for (var row = startRow; row < endRow; row++) {\n            if (foldWidgets[row] == null)\n                foldWidgets[row] = this.getFoldWidget(row);\n            if (foldWidgets[row] != \"start\")\n                continue;\n            if (test && !test(row))\n                continue;\n            var range = this.getFoldWidgetRange(row);\n            if (range && range.isMultiLine()\n                && range.end.row <= endRow\n                && range.start.row >= startRow) {\n                row = range.end.row;\n                range.collapseChildren = depth;\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n    this.foldToLevel = function (level) {\n        this.foldAll();\n        while (level-- > 0)\n            this.unfold(null, false);\n    };\n    this.foldAllComments = function () {\n        var session = this;\n        this.foldAll(null, null, null, function (row) {\n            var tokens = session.getTokens(row);\n            for (var i = 0; i < tokens.length; i++) {\n                var token = tokens[i];\n                if (token.type == \"text\" && /^\\s+$/.test(token.value))\n                    continue;\n                if (/comment/.test(token.type))\n                    return true;\n                return false;\n            }\n        });\n    };\n    this.$foldStyles = {\n        \"manual\": 1,\n        \"markbegin\": 1,\n        \"markbeginend\": 1\n    };\n    this.$foldStyle = \"markbegin\";\n    this.setFoldStyle = function (style) {\n        if (!this.$foldStyles[style])\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n        if (this.$foldStyle == style)\n            return;\n        this.$foldStyle = style;\n        if (style == \"manual\")\n            this.unfold();\n        var mode = this.$foldMode;\n        this.$setFolding(null);\n        this.$setFolding(mode);\n    };\n    this.$setFolding = function (foldMode) {\n        if (this.$foldMode == foldMode)\n            return;\n        this.$foldMode = foldMode;\n        this.off('change', this.$updateFoldWidgets);\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n        this._signal(\"changeAnnotation\");\n        if (!foldMode || this.$foldStyle == \"manual\") {\n            this.foldWidgets = null;\n            return;\n        }\n        this.foldWidgets = [];\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\n        this.on('change', this.$updateFoldWidgets);\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n    };\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n        var fw = this.foldWidgets;\n        if (!fw || (ignoreCurrent && fw[row]))\n            return {};\n        var i = row - 1, firstRange;\n        while (i >= 0) {\n            var c = fw[i];\n            if (c == null)\n                c = fw[i] = this.getFoldWidget(i);\n            if (c == \"start\") {\n                var range = this.getFoldWidgetRange(i);\n                if (!firstRange)\n                    firstRange = range;\n                if (range && range.end.row >= row)\n                    break;\n            }\n            i--;\n        }\n        return {\n            range: i !== -1 && range,\n            firstRange: firstRange\n        };\n    };\n    this.onFoldWidgetClick = function (row, e) {\n        if (e instanceof MouseEvent)\n            e = e.domEvent;\n        var options = {\n            children: e.shiftKey,\n            all: e.ctrlKey || e.metaKey,\n            siblings: e.altKey\n        };\n        var range = this.$toggleFoldWidget(row, options);\n        if (!range) {\n            var el = (e.target || e.srcElement);\n            if (el && /ace_fold-widget/.test(el.className))\n                el.className += \" ace_invalid\";\n        }\n    };\n    this.$toggleFoldWidget = function (row, options) {\n        if (!this.getFoldWidget)\n            return;\n        var type = this.getFoldWidget(row);\n        var line = this.getLine(row);\n        var dir = type === \"end\" ? -1 : 1;\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n        if (fold) {\n            if (options.children || options.all)\n                this.removeFold(fold);\n            else\n                this.expandFold(fold);\n            return fold;\n        }\n        var range = this.getFoldWidgetRange(row, true);\n        if (range && !range.isMultiLine()) {\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n            if (fold && range.isEqual(fold.range)) {\n                this.removeFold(fold);\n                return fold;\n            }\n        }\n        if (options.siblings) {\n            var data = this.getParentFoldRangeData(row);\n            if (data.range) {\n                var startRow = data.range.start.row + 1;\n                var endRow = data.range.end.row;\n            }\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n        }\n        else if (options.children) {\n            endRow = range ? range.end.row : this.getLength();\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\n        }\n        else if (range) {\n            if (options.all)\n                range.collapseChildren = 10000;\n            this.addFold(\"...\", range);\n        }\n        return range;\n    };\n    this.toggleFoldWidget = function (toggleParent) {\n        var row = this.selection.getCursor().row;\n        row = this.getRowFoldStart(row);\n        var range = this.$toggleFoldWidget(row, {});\n        if (range)\n            return;\n        var data = this.getParentFoldRangeData(row, true);\n        range = data.range || data.firstRange;\n        if (range) {\n            row = range.start.row;\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n            if (fold) {\n                this.removeFold(fold);\n            }\n            else {\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n    this.updateFoldWidgets = function (delta) {\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n            this.foldWidgets[firstRow] = null;\n        }\n        else if (delta.action == 'remove') {\n            this.foldWidgets.splice(firstRow, len + 1, null);\n        }\n        else {\n            var args = Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\n        }\n    };\n    this.tokenizerUpdateFoldWidgets = function (e) {\n        var rows = e.data;\n        if (rows.first != rows.last) {\n            if (this.foldWidgets.length > rows.first)\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\n        }\n    };\n}\nexports.Folding = Folding;\n\n});\n\nace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\nfunction BracketMatch() {\n    this.findMatchingBracket = function (position, chr) {\n        if (position.column == 0)\n            return null;\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);\n        if (charBeforeCursor == \"\")\n            return null;\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match)\n            return null;\n        if (match[1])\n            return this.$findClosingBracket(match[1], position);\n        else\n            return this.$findOpeningBracket(match[2], position);\n    };\n    this.getBracketRange = function (pos) {\n        var line = this.getLine(pos.row);\n        var before = true, range;\n        var chr = line.charAt(pos.column - 1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = { row: pos.row, column: pos.column + 1 };\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n            before = false;\n        }\n        if (!match)\n            return null;\n        if (match[1]) {\n            var bracketPos = this.$findClosingBracket(match[1], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(pos, bracketPos);\n            if (!before) {\n                range.end.column++;\n                range.start.column--;\n            }\n            range.cursor = range.end;\n        }\n        else {\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(bracketPos, pos);\n            if (!before) {\n                range.start.column++;\n                range.end.column--;\n            }\n            range.cursor = range.start;\n        }\n        return range;\n    };\n    this.getMatchingBracketRanges = function (pos, isBackwards) {\n        var line = this.getLine(pos.row);\n        var bracketsRegExp = /([\\(\\[\\{])|([\\)\\]\\}])/;\n        var chr = !isBackwards && line.charAt(pos.column - 1);\n        var match = chr && chr.match(bracketsRegExp);\n        if (!match) {\n            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);\n            pos = {\n                row: pos.row,\n                column: pos.column + 1\n            };\n            match = chr && chr.match(bracketsRegExp);\n        }\n        if (!match)\n            return null;\n        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);\n        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)\n            : this.$findOpeningBracket(match[2], pos);\n        if (!bracketPos)\n            return [startRange];\n        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);\n        return [startRange, endRange];\n    };\n    this.$brackets = {\n        \")\": \"(\",\n        \"(\": \")\",\n        \"]\": \"[\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"<\": \">\",\n        \">\": \"<\"\n    };\n    this.$findOpeningBracket = function (bracket, position, typeRe) {\n        var openBracket = this.$brackets[bracket];\n        var depth = 1;\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        if (!typeRe) {\n            typeRe = new RegExp(\"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\n                    .replace(/-close\\b/, \"-(close|open)\")\n                + \")+\");\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n        var value = token.value;\n        while (true) {\n            while (valueIndex >= 0) {\n                var chr = value.charAt(valueIndex);\n                if (chr == openBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return { row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn() };\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex -= 1;\n            }\n            do {\n                token = iterator.stepBackward();\n            } while (token && !typeRe.test(token.type));\n            if (token == null)\n                break;\n            value = token.value;\n            valueIndex = value.length - 1;\n        }\n        return null;\n    };\n    this.$findClosingBracket = function (bracket, position, typeRe) {\n        var closingBracket = this.$brackets[bracket];\n        var depth = 1;\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        if (!typeRe) {\n            typeRe = new RegExp(\"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\n                    .replace(/-open\\b/, \"-(close|open)\")\n                + \")+\");\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n        while (true) {\n            var value = token.value;\n            var valueLength = value.length;\n            while (valueIndex < valueLength) {\n                var chr = value.charAt(valueIndex);\n                if (chr == closingBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return { row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn() };\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex += 1;\n            }\n            do {\n                token = iterator.stepForward();\n            } while (token && !typeRe.test(token.type));\n            if (token == null)\n                break;\n            valueIndex = 0;\n        }\n        return null;\n    };\n    this.getMatchingTags = function (pos) {\n        var iterator = new TokenIterator(this, pos.row, pos.column);\n        var token = this.$findTagName(iterator);\n        if (!token)\n            return;\n        var prevToken = iterator.stepBackward();\n        if (prevToken.value === '<') {\n            return this.$findClosingTag(iterator, token);\n        }\n        else {\n            return this.$findOpeningTag(iterator, token);\n        }\n    };\n    this.$findTagName = function (iterator) {\n        var token = iterator.getCurrentToken();\n        var found = false;\n        var backward = false;\n        if (token && token.type.indexOf('tag-name') === -1) {\n            do {\n                if (backward)\n                    token = iterator.stepBackward();\n                else\n                    token = iterator.stepForward();\n                if (token) {\n                    if (token.value === \"/>\") {\n                        backward = true;\n                    }\n                    else if (token.type.indexOf('tag-name') !== -1) {\n                        found = true;\n                    }\n                }\n            } while (token && !found);\n        }\n        return token;\n    };\n    this.$findClosingTag = function (iterator, token) {\n        var prevToken;\n        var currentTag = token.value;\n        var tag = token.value;\n        var depth = 0;\n        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n        token = iterator.stepForward();\n        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n        var foundOpenTagEnd = false;\n        do {\n            prevToken = token;\n            if (prevToken.type.indexOf('tag-close') !== -1 && !foundOpenTagEnd) {\n                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`\n                foundOpenTagEnd = true;\n            }\n            token = iterator.stepForward();\n            if (token) {\n                if (token.value === '>' && !foundOpenTagEnd) {\n                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`\n                    foundOpenTagEnd = true;\n                }\n                if (token.type.indexOf('tag-name') !== -1) {\n                    currentTag = token.value;\n                    if (tag === currentTag) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                        }\n                        else if (prevToken.value === '</') {\n                            depth--;\n                            if (depth < 0) { //found closing tag\n                                iterator.stepBackward();\n                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </\n                                token = iterator.stepForward();\n                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n                                if (token.type.indexOf('tag-close') === -1) {\n                                    token = iterator.stepForward();\n                                }\n                                if (token && token.value === '>') {\n                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n                                }\n                                else {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (tag === currentTag && token.value === '/>') { // self-closing tag\n                    depth--;\n                    if (depth < 0) { //found self-closing tag end\n                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);\n                        var closeTagName = closeTagStart;\n                        var closeTagEnd = closeTagName;\n                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);\n                    }\n                }\n            }\n        } while (token && depth >= 0);\n        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {\n            return {\n                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),\n                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),\n                openTagName: openTagName,\n                closeTagName: closeTagName\n            };\n        }\n    };\n    this.$findOpeningTag = function (iterator, token) {\n        var prevToken = iterator.getCurrentToken();\n        var tag = token.value;\n        var depth = 0;\n        var startRow = iterator.getCurrentTokenRow();\n        var startColumn = iterator.getCurrentTokenColumn();\n        var endColumn = startColumn + 2;\n        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </\n        iterator.stepForward();\n        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);\n        if (token.type.indexOf('tag-close') === -1) {\n            token = iterator.stepForward();\n        }\n        if (!token || token.value !== \">\")\n            return;\n        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n        iterator.stepBackward();\n        iterator.stepBackward();\n        do {\n            token = prevToken;\n            startRow = iterator.getCurrentTokenRow();\n            startColumn = iterator.getCurrentTokenColumn();\n            endColumn = startColumn + token.value.length;\n            prevToken = iterator.stepBackward();\n            if (token) {\n                if (token.type.indexOf('tag-name') !== -1) {\n                    if (tag === token.value) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                            if (depth > 0) { //found opening tag\n                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);\n                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <\n                                do {\n                                    token = iterator.stepForward();\n                                } while (token && token.value !== '>');\n                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >\n                            }\n                        }\n                        else if (prevToken.value === '</') {\n                            depth--;\n                        }\n                    }\n                }\n                else if (token.value === '/>') { // self-closing tag\n                    var stepCount = 0;\n                    var tmpToken = prevToken;\n                    while (tmpToken) {\n                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {\n                            depth--;\n                            break;\n                        }\n                        else if (tmpToken.value === '<') {\n                            break;\n                        }\n                        tmpToken = iterator.stepBackward();\n                        stepCount++;\n                    }\n                    for (var i = 0; i < stepCount; i++) {\n                        iterator.stepForward();\n                    }\n                }\n            }\n        } while (prevToken && depth <= 0);\n        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {\n            return {\n                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),\n                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),\n                openTagName: openTagName,\n                closeTagName: closeTagName\n            };\n        }\n    };\n}\nexports.BracketMatch = BracketMatch;\n\n});\n\nace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/bidihandler\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/line_widgets\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/undomanager\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\nvar config = require(\"./config\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Selection = require(\"./selection\").Selection;\nvar TextMode = require(\"./mode/text\").Mode;\nvar Range = require(\"./range\").Range;\nvar LineWidgets = require(\"./line_widgets\").LineWidgets;\nvar Document = require(\"./document\").Document;\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar EditSession = /** @class */ (function () {\n    function EditSession(text, mode) { this.doc;\n        this.$breakpoints = [];\n        this.$decorations = [];\n        this.$frontMarkers = {};\n        this.$backMarkers = {};\n        this.$markerId = 1;\n        this.$undoSelect = true;\n        this.$editor = null;\n        this.prevOp = {};\n        this.$foldData = [];\n        this.id = \"session\" + (++EditSession.$uid);\n        this.$foldData.toString = function () {\n            return this.join(\"\\n\");\n        };\n        this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);\n        var _self = this;\n        this.bgTokenizer.on(\"update\", function (e) {\n            _self._signal(\"tokenizerUpdate\", e);\n        });\n        this.on(\"changeFold\", this.onChangeFold.bind(this));\n        this.$onChange = this.onChange.bind(this);\n        if (typeof text != \"object\" || !text.getLine)\n            text = new Document(/**@type{string}*/ (text));\n        this.setDocument(text);\n        this.selection = new Selection(this);\n        this.$onSelectionChange = this.onSelectionChange.bind(this);\n        this.selection.on(\"changeSelection\", this.$onSelectionChange);\n        this.selection.on(\"changeCursor\", this.$onSelectionChange);\n        this.$bidiHandler = new BidiHandler(this);\n        config.resetOptions(this);\n        this.setMode(mode);\n        config._signal(\"session\", this);\n        this.destroyed = false;\n        this.$initOperationListeners();\n    }\n    EditSession.prototype.$initOperationListeners = function () {\n        var _this = this;\n        this.curOp = null;\n        this.on(\"change\", function () {\n            if (!_this.curOp) {\n                _this.startOperation();\n                _this.curOp.selectionBefore = _this.$lastSel;\n            }\n            _this.curOp.docChanged = true;\n        }, true);\n        this.on(\"changeSelection\", function () {\n            if (!_this.curOp) {\n                _this.startOperation();\n                _this.curOp.selectionBefore = _this.$lastSel;\n            }\n            _this.curOp.selectionChanged = true;\n        }, true);\n        this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));\n    };\n    EditSession.prototype.startOperation = function (commandEvent) {\n        if (this.curOp) {\n            if (!commandEvent || this.curOp.command) {\n                return;\n            }\n            this.prevOp = this.curOp;\n        }\n        if (!commandEvent) {\n            commandEvent = {};\n        }\n        this.$operationResetTimer.schedule();\n        this.curOp = {\n            command: commandEvent.command || {},\n            args: commandEvent.args\n        };\n        this.curOp.selectionBefore = this.selection.toJSON();\n        this._signal(\"startOperation\", commandEvent);\n    };\n    EditSession.prototype.endOperation = function (e) {\n        if (this.curOp) {\n            if (e && e.returnValue === false) {\n                this.curOp = null;\n                this._signal(\"endOperation\", e);\n                return;\n            }\n            if (e == true && this.curOp.command && this.curOp.command.name == \"mouse\") {\n                return;\n            }\n            var currentSelection = this.selection.toJSON();\n            this.curOp.selectionAfter = currentSelection;\n            this.$lastSel = this.selection.toJSON();\n            this.getUndoManager().addSelection(currentSelection);\n            this._signal(\"beforeEndOperation\");\n            this.prevOp = this.curOp;\n            this.curOp = null;\n            this._signal(\"endOperation\", e);\n        }\n    };\n    EditSession.prototype.setDocument = function (doc) {\n        if (this.doc)\n            this.doc.off(\"change\", this.$onChange);\n        this.doc = doc;\n        doc.on(\"change\", this.$onChange, true);\n        this.bgTokenizer.setDocument(this.getDocument());\n        this.resetCaches();\n    };\n    EditSession.prototype.getDocument = function () {\n        return this.doc;\n    };\n    Object.defineProperty(EditSession.prototype, \"widgetManager\", {\n        get: function () {\n            var widgetManager = new LineWidgets(this);\n            this.widgetManager = widgetManager;\n            if (this.$editor)\n                widgetManager.attach(this.$editor);\n            return widgetManager;\n        },\n        set: function (value) {\n            Object.defineProperty(this, \"widgetManager\", {\n                writable: true,\n                enumerable: true,\n                configurable: true,\n                value: value,\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EditSession.prototype.$resetRowCache = function (docRow) {\n        if (!docRow) {\n            this.$docRowCache = [];\n            this.$screenRowCache = [];\n            return;\n        }\n        var l = this.$docRowCache.length;\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n        if (l > i) {\n            this.$docRowCache.splice(i, l);\n            this.$screenRowCache.splice(i, l);\n        }\n    };\n    EditSession.prototype.$getRowCacheIndex = function (cacheArray, val) {\n        var low = 0;\n        var hi = cacheArray.length - 1;\n        while (low <= hi) {\n            var mid = (low + hi) >> 1;\n            var c = cacheArray[mid];\n            if (val > c)\n                low = mid + 1;\n            else if (val < c)\n                hi = mid - 1;\n            else\n                return mid;\n        }\n        return low - 1;\n    };\n    EditSession.prototype.resetCaches = function () {\n        this.$modified = true;\n        this.$wrapData = [];\n        this.$rowLengthCache = [];\n        this.$resetRowCache(0);\n        if (!this.destroyed)\n            this.bgTokenizer.start(0);\n    };\n    EditSession.prototype.onChangeFold = function (e) {\n        var fold = e.data;\n        this.$resetRowCache(fold.start.row);\n    };\n    EditSession.prototype.onChange = function (delta) {\n        this.$modified = true;\n        this.$bidiHandler.onChange(delta);\n        this.$resetRowCache(delta.start.row);\n        var removedFolds = this.$updateInternalDataOnChange(delta);\n        if (!this.$fromUndo && this.$undoManager) {\n            if (removedFolds && removedFolds.length) {\n                this.$undoManager.add({\n                    action: \"removeFolds\",\n                    folds: removedFolds\n                }, this.mergeUndoDeltas);\n                this.mergeUndoDeltas = true;\n            }\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\n            this.mergeUndoDeltas = true;\n            this.$informUndoManager.schedule();\n        }\n        this.bgTokenizer.$updateOnChange(delta);\n        this._signal(\"change\", delta);\n    };\n    EditSession.prototype.onSelectionChange = function () {\n        this._signal(\"changeSelection\");\n    };\n    EditSession.prototype.setValue = function (text) {\n        this.doc.setValue(text);\n        this.selection.moveTo(0, 0);\n        this.$resetRowCache(0);\n        this.setUndoManager(this.$undoManager);\n        this.getUndoManager().reset();\n    };\n    EditSession.fromJSON = function (session) {\n        if (typeof session == \"string\")\n            session = JSON.parse(session);\n        var undoManager = new UndoManager();\n        undoManager.$undoStack = session.history.undo;\n        undoManager.$redoStack = session.history.redo;\n        undoManager.mark = session.history.mark;\n        undoManager.$rev = session.history.rev;\n        var editSession = new EditSession(session.value);\n        session.folds.forEach(function (fold) {\n            editSession.addFold(\"...\", Range.fromPoints(fold.start, fold.end));\n        });\n        editSession.setAnnotations(session.annotations);\n        editSession.setBreakpoints(session.breakpoints);\n        editSession.setMode(session.mode);\n        editSession.setScrollLeft(session.scrollLeft);\n        editSession.setScrollTop(session.scrollTop);\n        editSession.setUndoManager(undoManager);\n        editSession.selection.fromJSON(session.selection);\n        return editSession;\n    };\n    EditSession.prototype.toJSON = function () {\n        return {\n            annotations: this.$annotations,\n            breakpoints: this.$breakpoints,\n            folds: this.getAllFolds().map(function (fold) {\n                return fold.range;\n            }),\n            history: this.getUndoManager(),\n            mode: this.$mode.$id,\n            scrollLeft: this.$scrollLeft,\n            scrollTop: this.$scrollTop,\n            selection: this.selection.toJSON(),\n            value: this.doc.getValue()\n        };\n    };\n    EditSession.prototype.toString = function () {\n        return this.doc.getValue();\n    };\n    EditSession.prototype.getSelection = function () {\n        return this.selection;\n    };\n    EditSession.prototype.getState = function (row) {\n        return this.bgTokenizer.getState(row);\n    };\n    EditSession.prototype.getTokens = function (row) {\n        return this.bgTokenizer.getTokens(row);\n    };\n    EditSession.prototype.getTokenAt = function (row, column) {\n        var tokens = this.bgTokenizer.getTokens(row);\n        var token, c = 0;\n        if (column == null) {\n            var i = tokens.length - 1;\n            c = this.getLine(row).length;\n        }\n        else {\n            for (var i = 0; i < tokens.length; i++) {\n                c += tokens[i].value.length;\n                if (c >= column)\n                    break;\n            }\n        }\n        token = tokens[i];\n        if (!token)\n            return null;\n        token.index = i;\n        token.start = c - token.value.length;\n        return token;\n    };\n    EditSession.prototype.setUndoManager = function (undoManager) {\n        this.$undoManager = undoManager;\n        if (this.$informUndoManager)\n            this.$informUndoManager.cancel();\n        if (undoManager) {\n            var self = this;\n            undoManager.addSession(this);\n            this.$syncInformUndoManager = function () {\n                self.$informUndoManager.cancel();\n                self.mergeUndoDeltas = false;\n            };\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n        }\n        else {\n            this.$syncInformUndoManager = function () { };\n        }\n    };\n    EditSession.prototype.markUndoGroup = function () {\n        if (this.$syncInformUndoManager)\n            this.$syncInformUndoManager();\n    };\n    EditSession.prototype.getUndoManager = function () {\n        return this.$undoManager || this.$defaultUndoManager;\n    };\n    EditSession.prototype.getTabString = function () {\n        if (this.getUseSoftTabs()) {\n            return lang.stringRepeat(\" \", this.getTabSize());\n        }\n        else {\n            return \"\\t\";\n        }\n    };\n    EditSession.prototype.setUseSoftTabs = function (val) {\n        this.setOption(\"useSoftTabs\", val);\n    };\n    EditSession.prototype.getUseSoftTabs = function () {\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n    };\n    EditSession.prototype.setTabSize = function (tabSize) {\n        this.setOption(\"tabSize\", tabSize);\n    };\n    EditSession.prototype.getTabSize = function () {\n        return this.$tabSize;\n    };\n    EditSession.prototype.isTabStop = function (position) {\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n    };\n    EditSession.prototype.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\n    };\n    EditSession.prototype.getNavigateWithinSoftTabs = function () {\n        return this.$navigateWithinSoftTabs;\n    };\n    EditSession.prototype.setOverwrite = function (overwrite) {\n        this.setOption(\"overwrite\", overwrite);\n    };\n    EditSession.prototype.getOverwrite = function () {\n        return this.$overwrite;\n    };\n    EditSession.prototype.toggleOverwrite = function () {\n        this.setOverwrite(!this.$overwrite);\n    };\n    EditSession.prototype.addGutterDecoration = function (row, className) {\n        if (!this.$decorations[row])\n            this.$decorations[row] = \"\";\n        this.$decorations[row] += \" \" + className;\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.removeGutterDecoration = function (row, className) {\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.getBreakpoints = function () {\n        return this.$breakpoints;\n    };\n    EditSession.prototype.setBreakpoints = function (rows) {\n        this.$breakpoints = [];\n        for (var i = 0; i < rows.length; i++) {\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n        }\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.clearBreakpoints = function () {\n        this.$breakpoints = [];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.setBreakpoint = function (row, className) {\n        if (className === undefined)\n            className = \"ace_breakpoint\";\n        if (className)\n            this.$breakpoints[row] = className;\n        else\n            delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.clearBreakpoint = function (row) {\n        delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    EditSession.prototype.addMarker = function (range, clazz, type, inFront) {\n        var id = this.$markerId++;\n        var marker = {\n            range: range,\n            type: type || \"line\",\n            renderer: typeof type == \"function\" ? type : null,\n            clazz: clazz,\n            inFront: !!inFront,\n            id: id\n        };\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        }\n        else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n        return id;\n    };\n    EditSession.prototype.addDynamicMarker = function (marker, inFront) {\n        if (!marker.update)\n            return;\n        var id = this.$markerId++;\n        marker.id = id;\n        marker.inFront = !!inFront;\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        }\n        else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n        return marker;\n    };\n    EditSession.prototype.removeMarker = function (markerId) {\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n        if (!marker)\n            return;\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n        delete (markers[markerId]);\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n    };\n    EditSession.prototype.getMarkers = function (inFront) {\n        return inFront ? this.$frontMarkers : this.$backMarkers;\n    };\n    EditSession.prototype.highlight = function (re) {\n        if (!this.$searchHighlight) {\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n            this.$searchHighlight = this.addDynamicMarker(highlight);\n        }\n        this.$searchHighlight.setRegexp(re);\n    };\n    EditSession.prototype.highlightLines = function (startRow, endRow, clazz, inFront) {\n        if (typeof endRow != \"number\") {\n            clazz = endRow;\n            endRow = startRow;\n        }\n        if (!clazz)\n            clazz = \"ace_step\";\n        var range = new Range(startRow, 0, endRow, Infinity);\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n        return range;\n    };\n    EditSession.prototype.setAnnotations = function (annotations) {\n        this.$annotations = annotations;\n        this._signal(\"changeAnnotation\", {});\n    };\n    EditSession.prototype.getAnnotations = function () {\n        return this.$annotations || [];\n    };\n    EditSession.prototype.clearAnnotations = function () {\n        this.setAnnotations([]);\n    };\n    EditSession.prototype.$detectNewLine = function (text) {\n        var match = text.match(/^.*?(\\r?\\n)/m);\n        if (match) {\n            this.$autoNewLine = match[1];\n        }\n        else {\n            this.$autoNewLine = \"\\n\";\n        }\n    };\n    EditSession.prototype.getWordRange = function (row, column) {\n        var line = this.getLine(row);\n        var inToken = false;\n        if (column > 0)\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n        if (!inToken)\n            inToken = !!line.charAt(column).match(this.tokenRe);\n        if (inToken)\n            var re = this.tokenRe;\n        else if (/^\\s+$/.test(line.slice(column - 1, column + 1)))\n            var re = /\\s/;\n        else\n            var re = this.nonTokenRe;\n        var start = column;\n        if (start > 0) {\n            do {\n                start--;\n            } while (start >= 0 && line.charAt(start).match(re));\n            start++;\n        }\n        var end = column;\n        while (end < line.length && line.charAt(end).match(re)) {\n            end++;\n        }\n        return new Range(row, start, row, end);\n    };\n    EditSession.prototype.getAWordRange = function (row, column) {\n        var wordRange = this.getWordRange(row, column);\n        var line = this.getLine(wordRange.end.row);\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n            wordRange.end.column += 1;\n        }\n        return wordRange;\n    };\n    EditSession.prototype.setNewLineMode = function (newLineMode) {\n        this.doc.setNewLineMode(newLineMode);\n    };\n    EditSession.prototype.getNewLineMode = function () {\n        return this.doc.getNewLineMode();\n    };\n    EditSession.prototype.setUseWorker = function (useWorker) { this.setOption(\"useWorker\", useWorker); };\n    EditSession.prototype.getUseWorker = function () { return this.$useWorker; };\n    EditSession.prototype.onReloadTokenizer = function (e) {\n        var rows = e.data;\n        this.bgTokenizer.start(rows.first);\n        this._signal(\"tokenizerUpdate\", e);\n    };\n    EditSession.prototype.setMode = function (mode, cb) {\n        if (mode && typeof mode === \"object\") {\n            if (mode.getTokenizer)\n                return this.$onChangeMode(mode);\n            var options = mode;\n            var path = options.path;\n        }\n        else {\n            path = /**@type{string}*/ (mode) || \"ace/mode/text\";\n        }\n        if (!this.$modes[\"ace/mode/text\"])\n            this.$modes[\"ace/mode/text\"] = new TextMode();\n        if (this.$modes[path] && !options) {\n            this.$onChangeMode(this.$modes[path]);\n            cb && cb();\n            return;\n        }\n        this.$modeId = path;\n        config.loadModule([\"mode\", path], function (m) {\n            if (this.destroyed) {\n                return;\n            }\n            if (this.$modeId !== path)\n                return cb && cb();\n            if (this.$modes[path] && !options) {\n                this.$onChangeMode(this.$modes[path]);\n            }\n            else if (m && m.Mode) {\n                m = new m.Mode(options);\n                if (!options) {\n                    this.$modes[path] = m;\n                    m.$id = path;\n                }\n                this.$onChangeMode(m);\n            }\n            cb && cb();\n        }.bind(this));\n        if (!this.$mode)\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n    };\n    EditSession.prototype.$onChangeMode = function (mode, $isPlaceholder) {\n        if (!$isPlaceholder)\n            this.$modeId = mode.$id;\n        if (this.$mode === mode)\n            return;\n        var oldMode = this.$mode;\n        this.$mode = mode;\n        this.$stopWorker();\n        if (this.$useWorker)\n            this.$startWorker();\n        var tokenizer = mode.getTokenizer();\n        if (tokenizer.on !== undefined) {\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n            tokenizer.on(\"update\", onReloadTokenizer);\n        }\n        this.bgTokenizer.setTokenizer(tokenizer);\n        this.bgTokenizer.setDocument(this.getDocument());\n        this.tokenRe = mode.tokenRe;\n        this.nonTokenRe = mode.nonTokenRe;\n        if (!$isPlaceholder) {\n            if (mode.attachToSession)\n                mode.attachToSession(this);\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n            this.$setFolding(mode.foldingRules);\n            this.bgTokenizer.start(0);\n            this._emit(\"changeMode\", { oldMode: oldMode, mode: mode });\n        }\n    };\n    EditSession.prototype.$stopWorker = function () {\n        if (this.$worker) {\n            this.$worker.terminate();\n            this.$worker = null;\n        }\n    };\n    EditSession.prototype.$startWorker = function () {\n        try {\n            this.$worker = this.$mode.createWorker(this);\n        }\n        catch (e) {\n            config.warn(\"Could not load worker\", e);\n            this.$worker = null;\n        }\n    };\n    EditSession.prototype.getMode = function () {\n        return this.$mode;\n    };\n    EditSession.prototype.setScrollTop = function (scrollTop) {\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n            return;\n        this.$scrollTop = scrollTop;\n        this._signal(\"changeScrollTop\", scrollTop);\n    };\n    EditSession.prototype.getScrollTop = function () {\n        return this.$scrollTop;\n    };\n    EditSession.prototype.setScrollLeft = function (scrollLeft) {\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n            return;\n        this.$scrollLeft = scrollLeft;\n        this._signal(\"changeScrollLeft\", scrollLeft);\n    };\n    EditSession.prototype.getScrollLeft = function () {\n        return this.$scrollLeft;\n    };\n    EditSession.prototype.getScreenWidth = function () {\n        this.$computeWidth();\n        if (this.lineWidgets)\n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n        return this.screenWidth;\n    };\n    EditSession.prototype.getLineWidgetMaxWidth = function () {\n        if (this.lineWidgetsWidth != null)\n            return this.lineWidgetsWidth;\n        var width = 0;\n        this.lineWidgets.forEach(function (w) {\n            if (w && w.screenWidth > width)\n                width = w.screenWidth;\n        });\n        return this.lineWidgetWidth = width;\n    };\n    EditSession.prototype.$computeWidth = function (force) {\n        if (this.$modified || force) {\n            this.$modified = false;\n            if (this.$useWrapMode)\n                return this.screenWidth = this.$wrapLimit;\n            var lines = this.doc.getAllLines();\n            var cache = this.$rowLengthCache;\n            var longestScreenLine = 0;\n            var foldIndex = 0;\n            var foldLine = this.$foldData[foldIndex];\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\n            var len = lines.length;\n            for (var i = 0; i < len; i++) {\n                if (i > foldStart) {\n                    i = foldLine.end.row + 1;\n                    if (i >= len)\n                        break;\n                    foldLine = this.$foldData[foldIndex++];\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n                if (cache[i] == null)\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n                if (cache[i] > longestScreenLine)\n                    longestScreenLine = cache[i];\n            }\n            this.screenWidth = longestScreenLine;\n        }\n    };\n    EditSession.prototype.getLine = function (row) {\n        return this.doc.getLine(row);\n    };\n    EditSession.prototype.getLines = function (firstRow, lastRow) {\n        return this.doc.getLines(firstRow, lastRow);\n    };\n    EditSession.prototype.getLength = function () {\n        return this.doc.getLength();\n    };\n    EditSession.prototype.getTextRange = function (range) {\n        return this.doc.getTextRange(range || this.selection.getRange());\n    };\n    EditSession.prototype.insert = function (position, text) {\n        return this.doc.insert(position, text);\n    };\n    EditSession.prototype.remove = function (range) {\n        return this.doc.remove(range);\n    };\n    EditSession.prototype.removeFullLines = function (firstRow, lastRow) {\n        return this.doc.removeFullLines(firstRow, lastRow);\n    };\n    EditSession.prototype.undoChanges = function (deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n        this.$fromUndo = true;\n        for (var i = deltas.length - 1; i != -1; i--) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.revertDelta(delta);\n            }\n            else if (delta.folds) {\n                this.addFolds(delta.folds);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionBefore)\n                this.selection.fromJSON(deltas.selectionBefore);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\n        }\n        this.$fromUndo = false;\n    };\n    EditSession.prototype.redoChanges = function (deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n        this.$fromUndo = true;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.$safeApplyDelta(delta);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionAfter)\n                this.selection.fromJSON(deltas.selectionAfter);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\n        }\n        this.$fromUndo = false;\n    };\n    EditSession.prototype.setUndoSelect = function (enable) {\n        this.$undoSelect = enable;\n    };\n    EditSession.prototype.$getUndoSelection = function (deltas, isUndo) {\n        function isInsert(delta) {\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\n        }\n        var range, point;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (!delta.start)\n                continue; // skip folds\n            if (!range) {\n                if (isInsert(delta)) {\n                    range = Range.fromPoints(delta.start, delta.end);\n                }\n                else {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n                continue;\n            }\n            if (isInsert(delta)) {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range.setStart(point);\n                }\n                point = delta.end;\n                if (range.compare(point.row, point.column) == 1) {\n                    range.setEnd(point);\n                }\n            }\n            else {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n            }\n        }\n        return range;\n    };\n    EditSession.prototype.replace = function (range, text) {\n        return this.doc.replace(range, text);\n    };\n    EditSession.prototype.moveText = function (fromRange, toPosition, copy) {\n        var text = this.getTextRange(fromRange);\n        var folds = this.getFoldsInRange(fromRange);\n        var toRange = Range.fromPoints(toPosition, toPosition);\n        if (!copy) {\n            this.remove(fromRange);\n            var rowDiff = fromRange.start.row - fromRange.end.row;\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n            if (collDiff) {\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n                    toRange.start.column += collDiff;\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n                    toRange.end.column += collDiff;\n            }\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n                toRange.start.row += rowDiff;\n                toRange.end.row += rowDiff;\n            }\n        }\n        toRange.end = this.insert(toRange.start, text);\n        if (folds.length) {\n            var oldStart = fromRange.start;\n            var newStart = toRange.start;\n            var rowDiff = newStart.row - oldStart.row;\n            var collDiff = newStart.column - oldStart.column;\n            this.addFolds(folds.map(function (x) {\n                x = x.clone();\n                if (x.start.row == oldStart.row)\n                    x.start.column += collDiff;\n                if (x.end.row == oldStart.row)\n                    x.end.column += collDiff;\n                x.start.row += rowDiff;\n                x.end.row += rowDiff;\n                return x;\n            }));\n        }\n        return toRange;\n    };\n    EditSession.prototype.indentRows = function (startRow, endRow, indentString) {\n        indentString = indentString.replace(/\\t/g, this.getTabString());\n        for (var row = startRow; row <= endRow; row++)\n            this.doc.insertInLine({ row: row, column: 0 }, indentString);\n    };\n    EditSession.prototype.outdentRows = function (range) {\n        var rowRange = range.collapseRows();\n        var deleteRange = new Range(0, 0, 0, 0);\n        var size = this.getTabSize();\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n            var line = this.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            for (var j = 0; j < size; ++j)\n                if (line.charAt(j) != ' ')\n                    break;\n            if (j < size && line.charAt(j) == '\\t') {\n                deleteRange.start.column = j;\n                deleteRange.end.column = j + 1;\n            }\n            else {\n                deleteRange.start.column = 0;\n                deleteRange.end.column = j;\n            }\n            this.remove(deleteRange);\n        }\n    };\n    EditSession.prototype.$moveLines = function (firstRow, lastRow, dir) {\n        firstRow = this.getRowFoldStart(firstRow);\n        lastRow = this.getRowFoldEnd(lastRow);\n        if (dir < 0) {\n            var row = this.getRowFoldStart(firstRow + dir);\n            if (row < 0)\n                return 0;\n            var diff = row - firstRow;\n        }\n        else if (dir > 0) {\n            var row = this.getRowFoldEnd(lastRow + dir);\n            if (row > this.doc.getLength() - 1)\n                return 0;\n            var diff = row - lastRow;\n        }\n        else {\n            firstRow = this.$clipRowToDocument(firstRow);\n            lastRow = this.$clipRowToDocument(lastRow);\n            var diff = lastRow - firstRow + 1;\n        }\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n        var folds = this.getFoldsInRange(range).map(function (x) {\n            x = x.clone();\n            x.start.row += diff;\n            x.end.row += diff;\n            return x;\n        });\n        var lines = dir == 0\n            ? this.doc.getLines(firstRow, lastRow)\n            : this.doc.removeFullLines(firstRow, lastRow);\n        this.doc.insertFullLines(firstRow + diff, lines);\n        folds.length && this.addFolds(folds);\n        return diff;\n    };\n    EditSession.prototype.moveLinesUp = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, -1);\n    };\n    EditSession.prototype.moveLinesDown = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 1);\n    };\n    EditSession.prototype.duplicateLines = function (firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 0);\n    };\n    EditSession.prototype.$clipRowToDocument = function (row) {\n        return Math.max(0, Math.min(row, this.doc.getLength() - 1));\n    };\n    EditSession.prototype.$clipColumnToRow = function (row, column) {\n        if (column < 0)\n            return 0;\n        return Math.min(this.doc.getLine(row).length, column);\n    };\n    EditSession.prototype.$clipPositionToDocument = function (row, column) {\n        column = Math.max(0, column);\n        if (row < 0) {\n            row = 0;\n            column = 0;\n        }\n        else {\n            var len = this.doc.getLength();\n            if (row >= len) {\n                row = len - 1;\n                column = this.doc.getLine(len - 1).length;\n            }\n            else {\n                column = Math.min(this.doc.getLine(row).length, column);\n            }\n        }\n        return {\n            row: row,\n            column: column\n        };\n    };\n    EditSession.prototype.$clipRangeToDocument = function (range) {\n        if (range.start.row < 0) {\n            range.start.row = 0;\n            range.start.column = 0;\n        }\n        else {\n            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);\n        }\n        var len = this.doc.getLength() - 1;\n        if (range.end.row > len) {\n            range.end.row = len;\n            range.end.column = this.doc.getLine(len).length;\n        }\n        else {\n            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);\n        }\n        return range;\n    };\n    EditSession.prototype.setUseWrapMode = function (useWrapMode) {\n        if (useWrapMode != this.$useWrapMode) {\n            this.$useWrapMode = useWrapMode;\n            this.$modified = true;\n            this.$resetRowCache(0);\n            if (useWrapMode) {\n                var len = this.getLength();\n                this.$wrapData = Array(len);\n                this.$updateWrapData(0, len - 1);\n            }\n            this._signal(\"changeWrapMode\");\n        }\n    };\n    EditSession.prototype.getUseWrapMode = function () {\n        return this.$useWrapMode;\n    };\n    EditSession.prototype.setWrapLimitRange = function (min, max) {\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n            this.$wrapLimitRange = { min: min, max: max };\n            this.$modified = true;\n            this.$bidiHandler.markAsDirty();\n            if (this.$useWrapMode)\n                this._signal(\"changeWrapMode\");\n        }\n    };\n    EditSession.prototype.adjustWrapLimit = function (desiredLimit, $printMargin) {\n        var limits = this.$wrapLimitRange;\n        if (limits.max < 0)\n            limits = { min: $printMargin, max: $printMargin };\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n            this.$wrapLimit = wrapLimit;\n            this.$modified = true;\n            if (this.$useWrapMode) {\n                this.$updateWrapData(0, this.getLength() - 1);\n                this.$resetRowCache(0);\n                this._signal(\"changeWrapLimit\");\n            }\n            return true;\n        }\n        return false;\n    };\n    EditSession.prototype.$constrainWrapLimit = function (wrapLimit, min, max) {\n        if (min)\n            wrapLimit = Math.max(min, wrapLimit);\n        if (max)\n            wrapLimit = Math.min(max, wrapLimit);\n        return wrapLimit;\n    };\n    EditSession.prototype.getWrapLimit = function () {\n        return this.$wrapLimit;\n    };\n    EditSession.prototype.setWrapLimit = function (limit) {\n        this.setWrapLimitRange(limit, limit);\n    };\n    EditSession.prototype.getWrapLimitRange = function () {\n        return {\n            min: this.$wrapLimitRange.min,\n            max: this.$wrapLimitRange.max\n        };\n    };\n    EditSession.prototype.$updateInternalDataOnChange = function (delta) {\n        var useWrapMode = this.$useWrapMode;\n        var action = delta.action;\n        var start = delta.start;\n        var end = delta.end;\n        var firstRow = start.row;\n        var lastRow = end.row;\n        var len = lastRow - firstRow;\n        var removedFolds = null;\n        this.$updating = true;\n        if (len != 0) {\n            if (action === \"remove\") {\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n                var foldLines = this.$foldData;\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n                var foldLine = this.getFoldLine(end.row);\n                var idx = 0;\n                if (foldLine) {\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n                    foldLine.shiftRow(-len);\n                    var foldLineBefore = this.getFoldLine(firstRow);\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\n                        foldLineBefore.merge(foldLine);\n                        foldLine = foldLineBefore;\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= end.row) {\n                        foldLine.shiftRow(-len);\n                    }\n                }\n                lastRow = firstRow;\n            }\n            else {\n                var args = Array(len);\n                args.unshift(firstRow, 0);\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\n                arr.splice.apply(arr, args);\n                var foldLines = this.$foldData;\n                var foldLine = this.getFoldLine(firstRow);\n                var idx = 0;\n                if (foldLine) {\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\n                    if (cmp == 0) {\n                        foldLine = foldLine.split(start.row, start.column);\n                        if (foldLine) {\n                            foldLine.shiftRow(len);\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n                        }\n                    }\n                    else \n                    if (cmp == -1) {\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n                        foldLine.shiftRow(len);\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= firstRow) {\n                        foldLine.shiftRow(len);\n                    }\n                }\n            }\n        }\n        else {\n            len = Math.abs(delta.start.column - delta.end.column);\n            if (action === \"remove\") {\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n                len = -len;\n            }\n            var foldLine = this.getFoldLine(firstRow);\n            if (foldLine) {\n                foldLine.addRemoveChars(firstRow, start.column, len);\n            }\n        }\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n        }\n        this.$updating = false;\n        if (useWrapMode)\n            this.$updateWrapData(firstRow, lastRow);\n        else\n            this.$updateRowLengthCache(firstRow, lastRow);\n        return removedFolds;\n    };\n    EditSession.prototype.$updateRowLengthCache = function (firstRow, lastRow) {\n        this.$rowLengthCache[firstRow] = null;\n        this.$rowLengthCache[lastRow] = null;\n    };\n    EditSession.prototype.$updateWrapData = function (firstRow, lastRow) {\n        var lines = this.doc.getAllLines();\n        var tabSize = this.getTabSize();\n        var wrapData = this.$wrapData;\n        var wrapLimit = this.$wrapLimit;\n        var tokens;\n        var foldLine;\n        var row = firstRow;\n        lastRow = Math.min(lastRow, lines.length - 1);\n        while (row <= lastRow) {\n            foldLine = this.getFoldLine(row, foldLine);\n            if (!foldLine) {\n                tokens = this.$getDisplayTokens(lines[row]);\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row++;\n            }\n            else {\n                tokens = [];\n                foldLine.walk(function (placeholder, row, column, lastColumn) {\n                    var walkTokens;\n                    if (placeholder != null) {\n                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);\n                        walkTokens[0] = PLACEHOLDER_START;\n                        for (var i = 1; i < walkTokens.length; i++) {\n                            walkTokens[i] = PLACEHOLDER_BODY;\n                        }\n                    }\n                    else {\n                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);\n                    }\n                    tokens = tokens.concat(walkTokens);\n                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row = foldLine.end.row + 1;\n            }\n        }\n    };\n    EditSession.prototype.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {\n        if (tokens.length == 0) {\n            return [];\n        }\n        var splits = [];\n        var displayLength = tokens.length;\n        var lastSplit = 0, lastDocSplit = 0;\n        var isCode = this.$wrapAsCode;\n        var indentedSoftWrap = this.$indentedSoftWrap;\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\n        function getWrapIndent() {\n            var indentation = 0;\n            if (maxIndent === 0)\n                return indentation;\n            if (indentedSoftWrap) {\n                for (var i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    if (token == SPACE)\n                        indentation += 1;\n                    else if (token == TAB)\n                        indentation += tabSize;\n                    else if (token == TAB_SPACE)\n                        continue;\n                    else\n                        break;\n                }\n            }\n            if (isCode && indentedSoftWrap !== false)\n                indentation += tabSize;\n            return Math.min(indentation, maxIndent);\n        }\n        function addSplit(screenPos) {\n            var len = screenPos - lastSplit;\n            for (var i = lastSplit; i < screenPos; i++) {\n                var ch = tokens[i];\n                if (ch === 12 || ch === 2)\n                    len -= 1;\n            }\n            if (!splits.length) {\n                indent = getWrapIndent();\n                splits.indent = indent;\n            }\n            lastDocSplit += len;\n            splits.push(lastDocSplit);\n            lastSplit = screenPos;\n        }\n        var indent = 0;\n        while (displayLength - lastSplit > wrapLimit - indent) {\n            var split = lastSplit + wrapLimit - indent;\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n                addSplit(split);\n                continue;\n            }\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n                for (split; split != lastSplit - 1; split--) {\n                    if (tokens[split] == PLACEHOLDER_START) {\n                        break;\n                    }\n                }\n                if (split > lastSplit) {\n                    addSplit(split);\n                    continue;\n                }\n                split = lastSplit + wrapLimit;\n                for (split; split < tokens.length; split++) {\n                    if (tokens[split] != PLACEHOLDER_BODY) {\n                        break;\n                    }\n                }\n                if (split == tokens.length) {\n                    break; // Breaks the while-loop.\n                }\n                addSplit(split);\n                continue;\n            }\n            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                split--;\n            }\n            if (isCode) {\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                    split--;\n                }\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\n                    split--;\n                }\n            }\n            else {\n                while (split > minSplit && tokens[split] < SPACE) {\n                    split--;\n                }\n            }\n            if (split > minSplit) {\n                addSplit(++split);\n                continue;\n            }\n            split = lastSplit + wrapLimit;\n            if (tokens[split] == CHAR_EXT)\n                split--;\n            addSplit(split - indent);\n        }\n        return splits;\n    };\n    EditSession.prototype.$getDisplayTokens = function (str, offset) {\n        var arr = [];\n        var tabSize;\n        offset = offset || 0;\n        for (var i = 0; i < str.length; i++) {\n            var c = str.charCodeAt(i);\n            if (c == 9) {\n                tabSize = this.getScreenTabSize(arr.length + offset);\n                arr.push(TAB);\n                for (var n = 1; n < tabSize; n++) {\n                    arr.push(TAB_SPACE);\n                }\n            }\n            else if (c == 32) {\n                arr.push(SPACE);\n            }\n            else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {\n                arr.push(PUNCTUATION);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                arr.push(CHAR, CHAR_EXT);\n            }\n            else {\n                arr.push(CHAR);\n            }\n        }\n        return arr;\n    };\n    EditSession.prototype.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {\n        if (maxScreenColumn == 0)\n            return [0, 0];\n        if (maxScreenColumn == null)\n            maxScreenColumn = Infinity;\n        screenColumn = screenColumn || 0;\n        var c, column;\n        for (column = 0; column < str.length; column++) {\n            c = str.charCodeAt(column);\n            if (c == 9) {\n                screenColumn += this.getScreenTabSize(screenColumn);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                screenColumn += 2;\n            }\n            else {\n                screenColumn += 1;\n            }\n            if (screenColumn > maxScreenColumn) {\n                break;\n            }\n        }\n        return [screenColumn, column];\n    };\n    EditSession.prototype.getRowLength = function (row) {\n        var h = 1;\n        if (this.lineWidgets)\n            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        if (!this.$useWrapMode || !this.$wrapData[row])\n            return h;\n        else\n            return this.$wrapData[row].length + h;\n    };\n    EditSession.prototype.getRowLineCount = function (row) {\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1;\n        }\n        else {\n            return this.$wrapData[row].length + 1;\n        }\n    };\n    EditSession.prototype.getRowWrapIndent = function (screenRow) {\n        if (this.$useWrapMode) {\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n            var splits = this.$wrapData[pos.row];\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\n        }\n        else {\n            return 0;\n        }\n    };\n    EditSession.prototype.getScreenLastRowColumn = function (screenRow) {\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n        return this.documentToScreenColumn(pos.row, pos.column);\n    };\n    EditSession.prototype.getDocumentLastRowColumn = function (docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.getScreenLastRowColumn(screenRow);\n    };\n    EditSession.prototype.getDocumentLastRowColumnPosition = function (docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n    };\n    EditSession.prototype.getRowSplitData = function (row) {\n        if (!this.$useWrapMode) {\n            return undefined;\n        }\n        else {\n            return this.$wrapData[row];\n        }\n    };\n    EditSession.prototype.getScreenTabSize = function (screenColumn) {\n        return this.$tabSize - (screenColumn % this.$tabSize | 0);\n    };\n    EditSession.prototype.screenToDocumentRow = function (screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n    };\n    EditSession.prototype.screenToDocumentColumn = function (screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n    };\n    EditSession.prototype.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {\n        if (screenRow < 0)\n            return { row: 0, column: 0 };\n        var line;\n        var docRow = 0;\n        var docColumn = 0;\n        var column;\n        var row = 0;\n        var rowLength = 0;\n        var rowCache = this.$screenRowCache;\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var docRow = this.$docRowCache[i];\n            var doCache = screenRow > rowCache[l - 1];\n        }\n        else {\n            var doCache = !l;\n        }\n        var maxRow = this.getLength() - 1;\n        var foldLine = this.getNextFoldLine(docRow);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (row <= screenRow) {\n            rowLength = this.getRowLength(docRow);\n            if (row + rowLength > screenRow || docRow >= maxRow) {\n                break;\n            }\n            else {\n                row += rowLength;\n                docRow++;\n                if (docRow > foldStart) {\n                    docRow = foldLine.end.row + 1;\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n            }\n            if (doCache) {\n                this.$docRowCache.push(docRow);\n                this.$screenRowCache.push(row);\n            }\n        }\n        if (foldLine && foldLine.start.row <= docRow) {\n            line = this.getFoldDisplayLine(foldLine);\n            docRow = foldLine.start.row;\n        }\n        else if (row + rowLength <= screenRow || docRow > maxRow) {\n            return {\n                row: maxRow,\n                column: this.getLine(maxRow).length\n            };\n        }\n        else {\n            line = this.getLine(docRow);\n            foldLine = null;\n        }\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\n        if (this.$useWrapMode) {\n            var splits = this.$wrapData[docRow];\n            if (splits) {\n                column = splits[splitIndex];\n                if (splitIndex > 0 && splits.length) {\n                    wrapIndent = splits.indent;\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n                    line = line.substring(docColumn);\n                }\n            }\n        }\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\n        if (this.$useWrapMode && docColumn >= column)\n            docColumn = column - 1;\n        if (foldLine)\n            return foldLine.idxToPosition(docColumn);\n        return { row: docRow, column: docColumn };\n    };\n    EditSession.prototype.documentToScreenPosition = function (docRow, docColumn) {\n        if (typeof docColumn === \"undefined\")\n            var pos = this.$clipPositionToDocument(/**@type{Point}*/ (docRow).row, /**@type{Point}*/ (docRow).column);\n        else\n            pos = this.$clipPositionToDocument(/**@type{number}*/ (docRow), docColumn);\n        docRow = pos.row;\n        docColumn = pos.column;\n        var screenRow = 0;\n        var foldStartRow = null;\n        var fold = null;\n        fold = this.getFoldAt(docRow, docColumn, 1);\n        if (fold) {\n            docRow = fold.start.row;\n            docColumn = fold.start.column;\n        }\n        var rowEnd, row = 0;\n        var rowCache = this.$docRowCache;\n        var i = this.$getRowCacheIndex(rowCache, docRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var screenRow = this.$screenRowCache[i];\n            var doCache = docRow > rowCache[l - 1];\n        }\n        else {\n            var doCache = !l;\n        }\n        var foldLine = this.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (row < docRow) {\n            if (row >= foldStart) {\n                rowEnd = foldLine.end.row + 1;\n                if (rowEnd > docRow)\n                    break;\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            else {\n                rowEnd = row + 1;\n            }\n            screenRow += this.getRowLength(row);\n            row = rowEnd;\n            if (doCache) {\n                this.$docRowCache.push(row);\n                this.$screenRowCache.push(screenRow);\n            }\n        }\n        var textLine = \"\";\n        if (foldLine && row >= foldStart) {\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n            foldStartRow = foldLine.start.row;\n        }\n        else {\n            textLine = this.getLine(docRow).substring(0, docColumn);\n            foldStartRow = docRow;\n        }\n        var wrapIndent = 0;\n        if (this.$useWrapMode) {\n            var wrapRow = this.$wrapData[foldStartRow];\n            if (wrapRow) {\n                var screenRowOffset = 0;\n                while (textLine.length >= wrapRow[screenRowOffset]) {\n                    screenRow++;\n                    screenRowOffset++;\n                }\n                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\n            }\n        }\n        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)\n            screenRow += this.lineWidgets[row].rowsAbove;\n        return {\n            row: screenRow,\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\n        };\n    };\n    EditSession.prototype.documentToScreenColumn = function (row, docColumn) {\n        return this.documentToScreenPosition(row, docColumn).column;\n    };\n    EditSession.prototype.documentToScreenRow = function (docRow, docColumn) {\n        return this.documentToScreenPosition(docRow, docColumn).row;\n    };\n    EditSession.prototype.getScreenLength = function () {\n        var screenRows = 0;\n        var fold = null;\n        if (!this.$useWrapMode) {\n            screenRows = this.getLength();\n            var foldData = this.$foldData;\n            for (var i = 0; i < foldData.length; i++) {\n                fold = foldData[i];\n                screenRows -= fold.end.row - fold.start.row;\n            }\n        }\n        else {\n            var lastRow = this.$wrapData.length;\n            var row = 0, i = 0;\n            var fold = this.$foldData[i++];\n            var foldStart = fold ? fold.start.row : Infinity;\n            while (row < lastRow) {\n                var splits = this.$wrapData[row];\n                screenRows += splits ? splits.length + 1 : 1;\n                row++;\n                if (row > foldStart) {\n                    row = fold.end.row + 1;\n                    fold = this.$foldData[i++];\n                    foldStart = fold ? fold.start.row : Infinity;\n                }\n            }\n        }\n        if (this.lineWidgets)\n            screenRows += this.$getWidgetScreenLength();\n        return screenRows;\n    };\n    EditSession.prototype.$setFontMetrics = function (fm) {\n        if (!this.$enableVarChar)\n            return;\n        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {\n            if (maxScreenColumn === 0)\n                return [0, 0];\n            if (!maxScreenColumn)\n                maxScreenColumn = Infinity;\n            screenColumn = screenColumn || 0;\n            var c, column;\n            for (column = 0; column < str.length; column++) {\n                c = str.charAt(column);\n                if (c === \"\\t\") {\n                    screenColumn += this.getScreenTabSize(screenColumn);\n                }\n                else {\n                    screenColumn += fm.getCharacterWidth(c);\n                }\n                if (screenColumn > maxScreenColumn) {\n                    break;\n                }\n            }\n            return [screenColumn, column];\n        };\n    };\n    EditSession.prototype.getPrecedingCharacter = function () {\n        var pos = this.selection.getCursor();\n        if (pos.column === 0) {\n            return pos.row === 0 ? \"\" : this.doc.getNewLineCharacter();\n        }\n        var currentLine = this.getLine(pos.row);\n        return currentLine[pos.column - 1];\n    };\n    EditSession.prototype.destroy = function () {\n        if (!this.destroyed) {\n            this.bgTokenizer.setDocument(null);\n            this.bgTokenizer.cleanup();\n            this.destroyed = true;\n        }\n        this.endOperation();\n        this.$stopWorker();\n        this.removeAllListeners();\n        if (this.doc) {\n            this.doc.off(\"change\", this.$onChange);\n        }\n        if (this.selection) {\n            this.selection.off(\"changeCursor\", this.$onSelectionChange);\n            this.selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n        this.selection.detach();\n    };\n    return EditSession;\n}());\nEditSession.$uid = 0;\nEditSession.prototype.$modes = config.$modes;\nEditSession.prototype.getValue = EditSession.prototype.toString;\nEditSession.prototype.$defaultUndoManager = {\n    undo: function () { },\n    redo: function () { },\n    hasUndo: function () { },\n    hasRedo: function () { },\n    reset: function () { },\n    add: function () { },\n    addSelection: function () { },\n    startNewGroup: function () { },\n    addSession: function () { }\n};\nEditSession.prototype.$overwrite = false;\nEditSession.prototype.$mode = null;\nEditSession.prototype.$modeId = null;\nEditSession.prototype.$scrollTop = 0;\nEditSession.prototype.$scrollLeft = 0;\nEditSession.prototype.$wrapLimit = 80;\nEditSession.prototype.$useWrapMode = false;\nEditSession.prototype.$wrapLimitRange = {\n    min: null,\n    max: null\n};\nEditSession.prototype.lineWidgets = null;\nEditSession.prototype.isFullWidth = isFullWidth;\noop.implement(EditSession.prototype, EventEmitter);\nvar CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;\nfunction isFullWidth(c) {\n    if (c < 0x1100)\n        return false;\n    return c >= 0x1100 && c <= 0x115F ||\n        c >= 0x11A3 && c <= 0x11A7 ||\n        c >= 0x11FA && c <= 0x11FF ||\n        c >= 0x2329 && c <= 0x232A ||\n        c >= 0x2E80 && c <= 0x2E99 ||\n        c >= 0x2E9B && c <= 0x2EF3 ||\n        c >= 0x2F00 && c <= 0x2FD5 ||\n        c >= 0x2FF0 && c <= 0x2FFB ||\n        c >= 0x3000 && c <= 0x303E ||\n        c >= 0x3041 && c <= 0x3096 ||\n        c >= 0x3099 && c <= 0x30FF ||\n        c >= 0x3105 && c <= 0x312D ||\n        c >= 0x3131 && c <= 0x318E ||\n        c >= 0x3190 && c <= 0x31BA ||\n        c >= 0x31C0 && c <= 0x31E3 ||\n        c >= 0x31F0 && c <= 0x321E ||\n        c >= 0x3220 && c <= 0x3247 ||\n        c >= 0x3250 && c <= 0x32FE ||\n        c >= 0x3300 && c <= 0x4DBF ||\n        c >= 0x4E00 && c <= 0xA48C ||\n        c >= 0xA490 && c <= 0xA4C6 ||\n        c >= 0xA960 && c <= 0xA97C ||\n        c >= 0xAC00 && c <= 0xD7A3 ||\n        c >= 0xD7B0 && c <= 0xD7C6 ||\n        c >= 0xD7CB && c <= 0xD7FB ||\n        c >= 0xF900 && c <= 0xFAFF ||\n        c >= 0xFE10 && c <= 0xFE19 ||\n        c >= 0xFE30 && c <= 0xFE52 ||\n        c >= 0xFE54 && c <= 0xFE66 ||\n        c >= 0xFE68 && c <= 0xFE6B ||\n        c >= 0xFF01 && c <= 0xFF60 ||\n        c >= 0xFFE0 && c <= 0xFFE6;\n}\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\nconfig.defineOptions(EditSession.prototype, \"session\", {\n    wrap: {\n        set: function (value) {\n            if (!value || value == \"off\")\n                value = false;\n            else if (value == \"free\")\n                value = true;\n            else if (value == \"printMargin\")\n                value = -1;\n            else if (typeof value == \"string\")\n                value = parseInt(value, 10) || false;\n            if (this.$wrap == value)\n                return;\n            this.$wrap = value;\n            if (!value) {\n                this.setUseWrapMode(false);\n            }\n            else {\n                var col = typeof value == \"number\" ? value : null;\n                this.setWrapLimitRange(col, col);\n                this.setUseWrapMode(true);\n            }\n        },\n        get: function () {\n            if (this.getUseWrapMode()) {\n                if (this.$wrap == -1)\n                    return \"printMargin\";\n                if (!this.getWrapLimitRange().min)\n                    return \"free\";\n                return this.$wrap;\n            }\n            return \"off\";\n        },\n        handlesSet: true\n    },\n    wrapMethod: {\n        set: function (val) {\n            val = val == \"auto\"\n                ? this.$mode.type != \"text\"\n                : val != \"text\";\n            if (val != this.$wrapAsCode) {\n                this.$wrapAsCode = val;\n                if (this.$useWrapMode) {\n                    this.$useWrapMode = false;\n                    this.setUseWrapMode(true);\n                }\n            }\n        },\n        initialValue: \"auto\"\n    },\n    indentedSoftWrap: {\n        set: function () {\n            if (this.$useWrapMode) {\n                this.$useWrapMode = false;\n                this.setUseWrapMode(true);\n            }\n        },\n        initialValue: true\n    },\n    firstLineNumber: {\n        set: function () { this._signal(\"changeBreakpoint\"); },\n        initialValue: 1\n    },\n    useWorker: {\n        set: function (useWorker) {\n            this.$useWorker = useWorker;\n            this.$stopWorker();\n            if (useWorker)\n                this.$startWorker();\n        },\n        initialValue: true\n    },\n    useSoftTabs: { initialValue: true },\n    tabSize: {\n        set: function (tabSize) {\n            tabSize = parseInt(tabSize);\n            if (tabSize > 0 && this.$tabSize !== tabSize) {\n                this.$modified = true;\n                this.$rowLengthCache = [];\n                this.$tabSize = tabSize;\n                this._signal(\"changeTabSize\");\n            }\n        },\n        initialValue: 4,\n        handlesSet: true\n    },\n    navigateWithinSoftTabs: { initialValue: false },\n    foldStyle: {\n        set: function (val) { this.setFoldStyle(val); },\n        handlesSet: true\n    },\n    overwrite: {\n        set: function (val) { this._signal(\"changeOverwrite\"); },\n        initialValue: false\n    },\n    newLineMode: {\n        set: function (val) { this.doc.setNewLineMode(val); },\n        get: function () { return this.doc.getNewLineMode(); },\n        handlesSet: true\n    },\n    mode: {\n        set: function (val) { this.setMode(val); },\n        get: function () { return this.$modeId; },\n        handlesSet: true\n    }\n});\nexports.EditSession = EditSession;\n\n});\n\nace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\nvar Search = /** @class */ (function () {\n    function Search() {\n        this.$options = {};\n    }\n    Search.prototype.set = function (options) {\n        oop.mixin(this.$options, options);\n        return this;\n    };\n    Search.prototype.getOptions = function () {\n        return lang.copyObject(this.$options);\n    };\n    Search.prototype.setOptions = function (options) {\n        this.$options = options;\n    };\n    Search.prototype.find = function (session) {\n        var options = this.$options;\n        var iterator = this.$matchIterator(session, options);\n        if (!iterator)\n            return false;\n        var firstRange = null;\n        iterator.forEach(function (sr, sc, er, ec) {\n            firstRange = new Range(sr, sc, er, ec);\n            if (sc == ec && options.start && /**@type{Range}*/ (options.start).start\n                && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/ (options.start))) {\n                firstRange = null;\n                return false;\n            }\n            return true;\n        });\n        return firstRange;\n    };\n    Search.prototype.findAll = function (session) {\n        var options = this.$options;\n        if (!options.needle)\n            return [];\n        this.$assembleRegExp(options);\n        var range = options.range;\n        var lines = range\n            ? session.getLines(range.start.row, range.end.row)\n            : session.doc.getAllLines();\n        var ranges = [];\n        var re = options.re;\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var maxRow = lines.length - len;\n            var prevRange;\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n                for (var j = 0; j < len; j++)\n                    if (lines[row + j].search(re[j]) == -1)\n                        continue outer;\n                var startLine = lines[row];\n                var line = lines[row + len - 1];\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (prevRange && prevRange.end.row === row &&\n                    prevRange.end.column > startIndex) {\n                    continue;\n                }\n                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));\n                if (len > 2)\n                    row = row + len - 2;\n            }\n        }\n        else {\n            for (var matches, i = 0; i < lines.length; i++) {\n                if (this.$isMultilineSearch(options)) {\n                    var lng = lines.length - 1;\n                    matches = this.$multiLineForward(session, re, i, lng);\n                    if (matches) {\n                        var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;\n                        if (end_row > i)\n                            i = end_row;\n                        ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));\n                    }\n                }\n                else {\n                    matches = lang.getMatchOffsets(lines[i], re);\n                    for (var j = 0; j < matches.length; j++) {\n                        var match = matches[j];\n                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n                    }\n                }\n            }\n        }\n        if (range) {\n            var startColumn = range.start.column;\n            var endColumn = range.end.column;\n            var i = 0, j = ranges.length - 1;\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)\n                i++;\n            var endRow = range.end.row - range.start.row;\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)\n                j--;\n            ranges = ranges.slice(i, j + 1);\n            for (i = 0, j = ranges.length; i < j; i++) {\n                ranges[i].start.row += range.start.row;\n                ranges[i].end.row += range.start.row;\n            }\n        }\n        return ranges;\n    };\n    Search.prototype.parseReplaceString = function (replaceString) {\n        var CharCode = {\n            DollarSign: 36,\n            Ampersand: 38,\n            Digit0: 48,\n            Digit1: 49,\n            Digit9: 57,\n            Backslash: 92,\n            n: 110,\n            t: 116\n        };\n        var replacement = '';\n        for (var i = 0, len = replaceString.length; i < len; i++) {\n            var chCode = replaceString.charCodeAt(i);\n            if (chCode === CharCode.Backslash) {\n                i++;\n                if (i >= len) {\n                    replacement += \"\\\\\";\n                    break;\n                }\n                var nextChCode = replaceString.charCodeAt(i);\n                switch (nextChCode) {\n                    case CharCode.Backslash:\n                        replacement += \"\\\\\";\n                        break;\n                    case CharCode.n:\n                        replacement += \"\\n\";\n                        break;\n                    case CharCode.t:\n                        replacement += \"\\t\";\n                        break;\n                }\n                continue;\n            }\n            if (chCode === CharCode.DollarSign) {\n                i++;\n                if (i >= len) {\n                    replacement += \"$\";\n                    break;\n                }\n                var nextChCode_1 = replaceString.charCodeAt(i);\n                if (nextChCode_1 === CharCode.DollarSign) {\n                    replacement += \"$$\";\n                    continue;\n                }\n                if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {\n                    replacement += \"$&\";\n                    continue;\n                }\n                if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {\n                    replacement += \"$\" + replaceString[i];\n                    continue;\n                }\n            }\n            replacement += replaceString[i];\n        }\n        return replacement || replaceString;\n    };\n    Search.prototype.replace = function (input, replacement) {\n        var options = this.$options;\n        var re = this.$assembleRegExp(options);\n        if (options.$isMultiLine)\n            return replacement;\n        if (!re)\n            return;\n        var mtSearch = this.$isMultilineSearch(options);\n        if (mtSearch)\n            input = input.replace(/\\r\\n|\\r|\\n/g, \"\\n\");\n        var match = re.exec(input);\n        if (!match || (!mtSearch && match[0].length != input.length))\n            return null;\n        replacement = options.regExp\n            ? this.parseReplaceString(replacement)\n            : replacement.replace(/\\$/g, \"$$$$\");\n        replacement = input.replace(re, replacement);\n        if (options.preserveCase) {\n            replacement = replacement.split(\"\");\n            for (var i = Math.min(input.length, input.length); i--;) {\n                var ch = input[i];\n                if (ch && ch.toLowerCase() != ch)\n                    replacement[i] = replacement[i].toUpperCase();\n                else\n                    replacement[i] = replacement[i].toLowerCase();\n            }\n            replacement = replacement.join(\"\");\n        }\n        return replacement;\n    };\n    Search.prototype.$assembleRegExp = function (options, $disableFakeMultiline) {\n        if (options.needle instanceof RegExp)\n            return options.re = options.needle;\n        var needle = options.needle;\n        if (!options.needle)\n            return options.re = false;\n        if (!options.regExp)\n            needle = lang.escapeRegExp(needle);\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n        try {\n            new RegExp(needle, \"u\");\n            options.$supportsUnicodeFlag = true;\n            modifier += \"u\";\n        }\n        catch (e) {\n            options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\\{2}/gu\n        }\n        if (options.wholeWord)\n            needle = addWordBoundary(needle, options);\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n        if (options.$isMultiLine)\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n        try {\n            var re = new RegExp(needle, modifier);\n        }\n        catch (e) {\n            re = false;\n        }\n        return options.re = re;\n    };\n    Search.prototype.$assembleMultilineRegExp = function (needle, modifier) {\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n        var re = [];\n        for (var i = 0; i < parts.length; i++)\n            try {\n                re.push(new RegExp(parts[i], modifier));\n            }\n            catch (e) {\n                return false;\n            }\n        return re;\n    };\n    Search.prototype.$isMultilineSearch = function (options) {\n        return options.re && /\\\\r\\\\n|\\\\r|\\\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;\n    };\n    Search.prototype.$multiLineForward = function (session, re, start, last) {\n        var line, chunk = chunkEnd(session, start);\n        for (var row = start; row <= last;) {\n            for (var i = 0; i < chunk; i++) {\n                if (row > last)\n                    break;\n                var next = session.getLine(row++);\n                line = line == null ? next : line + \"\\n\" + next;\n            }\n            var match = re.exec(line);\n            re.lastIndex = 0;\n            if (match) {\n                var beforeMatch = line.slice(0, match.index).split(\"\\n\");\n                var matchedText = match[0].split(\"\\n\");\n                var startRow = start + beforeMatch.length - 1;\n                var startCol = beforeMatch[beforeMatch.length - 1].length;\n                var endRow = startRow + matchedText.length - 1;\n                var endCol = matchedText.length == 1\n                    ? startCol + matchedText[0].length\n                    : matchedText[matchedText.length - 1].length;\n                return {\n                    startRow: startRow,\n                    startCol: startCol,\n                    endRow: endRow,\n                    endCol: endCol\n                };\n            }\n        }\n        return null;\n    };\n    Search.prototype.$multiLineBackward = function (session, re, endIndex, start, first) {\n        var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;\n        for (var row = start; row >= first;) {\n            for (var i = 0; i < chunk && row >= first; i++) {\n                var next = session.getLine(row--);\n                line = line == null ? next : next + \"\\n\" + line;\n            }\n            var match = multiLineBackwardMatch(line, re, endMargin);\n            if (match) {\n                var beforeMatch = line.slice(0, match.index).split(\"\\n\");\n                var matchedText = match[0].split(\"\\n\");\n                var startRow = row + beforeMatch.length;\n                var startCol = beforeMatch[beforeMatch.length - 1].length;\n                var endRow = startRow + matchedText.length - 1;\n                var endCol = matchedText.length == 1\n                    ? startCol + matchedText[0].length\n                    : matchedText[matchedText.length - 1].length;\n                return {\n                    startRow: startRow,\n                    startCol: startCol,\n                    endRow: endRow,\n                    endCol: endCol\n                };\n            }\n        }\n        return null;\n    };\n    Search.prototype.$matchIterator = function (session, options) {\n        var re = this.$assembleRegExp(options);\n        if (!re)\n            return false;\n        var mtSearch = this.$isMultilineSearch(options);\n        var mtForward = this.$multiLineForward;\n        var mtBackward = this.$multiLineBackward;\n        var backwards = options.backwards == true;\n        var skipCurrent = options.skipCurrent != false;\n        var supportsUnicodeFlag = re.unicode;\n        var range = options.range;\n        var start = options.start;\n        if (!start)\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n        if (start.start)\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n        var firstRow = range ? range.start.row : 0;\n        var lastRow = range ? range.end.row : session.getLength() - 1;\n        if (backwards) {\n            var forEach = function (callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row--; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n            };\n        }\n        else {\n            var forEach = function (callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row = row + 1; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n            };\n        }\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var forEachInLine = function (row, offset, callback) {\n                var startRow = backwards ? row - len + 1 : row;\n                if (startRow < 0 || startRow + len > session.getLength())\n                    return;\n                var line = session.getLine(startRow);\n                var startIndex = line.search(re[0]);\n                if (!backwards && startIndex < offset || startIndex === -1)\n                    return;\n                for (var i = 1; i < len; i++) {\n                    line = session.getLine(startRow + i);\n                    if (line.search(re[i]) == -1)\n                        return;\n                }\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (backwards && endIndex > offset)\n                    return;\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\n                    return true;\n            };\n        }\n        else if (backwards) {\n            var forEachInLine = function (row, endIndex, callback) {\n                if (mtSearch) {\n                    var pos = mtBackward(session, re, endIndex, row, firstRow);\n                    if (!pos)\n                        return false;\n                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))\n                        return true;\n                }\n                else {\n                    var line = session.getLine(row);\n                    var matches = [];\n                    var m, last = 0;\n                    re.lastIndex = 0;\n                    while ((m = re.exec(line))) {\n                        var length = m[0].length;\n                        last = m.index;\n                        if (!length) {\n                            if (last >= line.length)\n                                break;\n                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);\n                        }\n                        if (m.index + length > endIndex)\n                            break;\n                        matches.push(m.index, length);\n                    }\n                    for (var i = matches.length - 1; i >= 0; i -= 2) {\n                        var column = matches[i - 1];\n                        var length = matches[i];\n                        if (callback(row, column, row, column + length))\n                            return true;\n                    }\n                }\n            };\n        }\n        else {\n            var forEachInLine = function (row, startIndex, callback) {\n                re.lastIndex = startIndex;\n                if (mtSearch) {\n                    var pos = mtForward(session, re, row, lastRow);\n                    if (pos) {\n                        var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;\n                        if (end_row > row)\n                            row = end_row;\n                    }\n                    if (!pos)\n                        return false;\n                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))\n                        return true;\n                }\n                else {\n                    var line = session.getLine(row);\n                    var last;\n                    var m;\n                    while ((m = re.exec(line))) {\n                        var length = m[0].length;\n                        last = m.index;\n                        if (callback(row, last, row, last + length))\n                            return true;\n                        if (!length) {\n                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);\n                            if (last >= line.length)\n                                return false;\n                        }\n                    }\n                }\n            };\n        }\n        return { forEach: forEach };\n    };\n    return Search;\n}());\nfunction addWordBoundary(needle, options) {\n    var supportsLookbehind = lang.supportsLookbehind();\n    function wordBoundary(c, firstChar) {\n        if (firstChar === void 0) { firstChar = true; }\n        var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp(\"[\\\\p{L}\\\\p{N}_]\", \"u\") : new RegExp(\"\\\\w\");\n        if (wordRegExp.test(c) || options.regExp) {\n            if (supportsLookbehind && options.$supportsUnicodeFlag) {\n                if (firstChar)\n                    return \"(?<=^|[^\\\\p{L}\\\\p{N}_])\";\n                return \"(?=[^\\\\p{L}\\\\p{N}_]|$)\";\n            }\n            return \"\\\\b\";\n        }\n        return \"\";\n    }\n    var needleArray = Array.from(needle);\n    var firstChar = needleArray[0];\n    var lastChar = needleArray[needleArray.length - 1];\n    return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);\n}\nfunction multiLineBackwardMatch(line, re, endMargin) {\n    var match = null;\n    var from = 0;\n    while (from <= line.length) {\n        re.lastIndex = from;\n        var newMatch = re.exec(line);\n        if (!newMatch)\n            break;\n        var end = newMatch.index + newMatch[0].length;\n        if (end > line.length - endMargin)\n            break;\n        if (!match || end > match.index + match[0].length)\n            match = newMatch;\n        from = newMatch.index + 1;\n    }\n    return match;\n}\nfunction chunkEnd(session, start) {\n    var base = 5000, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;\n    return targetLine + 1;\n}\nexports.Search = Search;\n\n});\n\nace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})(); var keyUtil = require(\"../lib/keys\");\nvar useragent = require(\"../lib/useragent\");\nvar KEY_MODS = keyUtil.KEY_MODS;\nvar MultiHashHandler = /** @class */ (function () {\n    function MultiHashHandler(config, platform) {\n        this.$init(config, platform, false);\n    }\n    MultiHashHandler.prototype.$init = function (config, platform, $singleCommand) {\n        this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n        this.commands = {};\n        this.commandKeyBinding = {};\n        this.addCommands(config);\n        this.$singleCommand = $singleCommand;\n    };\n    MultiHashHandler.prototype.addCommand = function (command) {\n        if (this.commands[command.name])\n            this.removeCommand(command);\n        this.commands[command.name] = command;\n        if (command.bindKey)\n            this._buildKeyHash(command);\n    };\n    MultiHashHandler.prototype.removeCommand = function (command, keepCommand) {\n        var name = command && (typeof command === 'string' ? command : command.name);\n        command = this.commands[name];\n        if (!keepCommand)\n            delete this.commands[name];\n        var ckb = this.commandKeyBinding;\n        for (var keyId in ckb) {\n            var cmdGroup = ckb[keyId];\n            if (cmdGroup == command) {\n                delete ckb[keyId];\n            }\n            else if (Array.isArray(cmdGroup)) {\n                var i = cmdGroup.indexOf(command);\n                if (i != -1) {\n                    cmdGroup.splice(i, 1);\n                    if (cmdGroup.length == 1)\n                        ckb[keyId] = cmdGroup[0];\n                }\n            }\n        }\n    };\n    MultiHashHandler.prototype.bindKey = function (key, command, position) {\n        if (typeof key == \"object\" && key) {\n            if (position == undefined)\n                position = key.position;\n            key = key[this.platform];\n        }\n        if (!key)\n            return;\n        if (typeof command == \"function\")\n            return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/ (key) }); (key).split(\"|\").forEach(function (keyPart) {\n            var chain = \"\";\n            if (keyPart.indexOf(\" \") != -1) {\n                var parts = keyPart.split(/\\s+/);\n                keyPart = parts.pop();\n                parts.forEach(function (keyPart) {\n                    var binding = this.parseKeys(keyPart);\n                    var id = KEY_MODS[binding.hashId] + binding.key;\n                    chain += (chain ? \" \" : \"\") + id;\n                    this._addCommandToBinding(chain, \"chainKeys\");\n                }, this);\n                chain += \" \";\n            }\n            var binding = this.parseKeys(keyPart);\n            var id = KEY_MODS[binding.hashId] + binding.key;\n            this._addCommandToBinding(chain + id, command, position);\n        }, this);\n    };\n    MultiHashHandler.prototype._addCommandToBinding = function (keyId, command, position) {\n        var ckb = this.commandKeyBinding, i;\n        if (!command) {\n            delete ckb[keyId];\n        }\n        else if (!ckb[keyId] || this.$singleCommand) {\n            ckb[keyId] = command;\n        }\n        else {\n            if (!Array.isArray(ckb[keyId])) {\n                ckb[keyId] = [ckb[keyId]];\n            }\n            else if ((i = ckb[keyId].indexOf(command)) != -1) {\n                ckb[keyId].splice(i, 1);\n            }\n            if (typeof position != \"number\") {\n                position = getPosition(command);\n            }\n            var commands = ckb[keyId];\n            for (i = 0; i < commands.length; i++) {\n                var other = commands[i];\n                var otherPos = getPosition(other);\n                if (otherPos > position)\n                    break;\n            }\n            commands.splice(i, 0, command);\n        }\n    };\n    MultiHashHandler.prototype.addCommands = function (commands) {\n        commands && Object.keys(commands).forEach(function (name) {\n            var command = commands[name];\n            if (!command)\n                return;\n            if (typeof command === \"string\")\n                return this.bindKey(command, name);\n            if (typeof command === \"function\")\n                command = { exec: command };\n            if (typeof command !== \"object\")\n                return;\n            if (!command.name)\n                command.name = name;\n            this.addCommand(command);\n        }, this);\n    };\n    MultiHashHandler.prototype.removeCommands = function (commands) {\n        Object.keys(commands).forEach(function (name) {\n            this.removeCommand(commands[name]);\n        }, this);\n    };\n    MultiHashHandler.prototype.bindKeys = function (keyList) {\n        Object.keys(keyList).forEach(function (key) {\n            this.bindKey(key, keyList[key]);\n        }, this);\n    };\n    MultiHashHandler.prototype._buildKeyHash = function (command) {\n        this.bindKey(command.bindKey, command);\n    };\n    MultiHashHandler.prototype.parseKeys = function (keys) {\n        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function (x) { return x; });\n        var key = parts.pop();\n        var keyCode = keyUtil[key];\n        if (keyUtil.FUNCTION_KEYS[keyCode])\n            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n        else if (!parts.length)\n            return { key: key, hashId: -1 };\n        else if (parts.length == 1 && parts[0] == \"shift\")\n            return { key: key.toUpperCase(), hashId: -1 };\n        var hashId = 0;\n        for (var i = parts.length; i--;) {\n            var modifier = keyUtil.KEY_MODS[parts[i]];\n            if (modifier == null) {\n                if (typeof console != \"undefined\")\n                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n                return false;\n            }\n            hashId |= modifier;\n        }\n        return { key: key, hashId: hashId };\n    };\n    MultiHashHandler.prototype.findKeyCommand = function (hashId, keyString) {\n        var key = KEY_MODS[hashId] + keyString;\n        return this.commandKeyBinding[key];\n    };\n    MultiHashHandler.prototype.handleKeyboard = function (data, hashId, keyString, keyCode) {\n        if (keyCode < 0)\n            return;\n        var key = KEY_MODS[hashId] + keyString;\n        var command = this.commandKeyBinding[key];\n        if (data.$keyChain) {\n            data.$keyChain += \" \" + key;\n            command = this.commandKeyBinding[data.$keyChain] || command;\n        }\n        if (command) {\n            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n                data.$keyChain = data.$keyChain || key;\n                return { command: \"null\" };\n            }\n        }\n        if (data.$keyChain) {\n            if ((!hashId || hashId == 4) && keyString.length == 1)\n                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input\n            else if (hashId == -1 || keyCode > 0)\n                data.$keyChain = \"\"; // reset keyChain\n        }\n        return { command: command };\n    };\n    MultiHashHandler.prototype.getStatusText = function (editor, data) {\n        return data.$keyChain || \"\";\n    };\n    return MultiHashHandler;\n}());\nfunction getPosition(command) {\n    return typeof command == \"object\" && command.bindKey\n        && command.bindKey.position\n        || (command.isDefault ? -100 : 0);\n}\nvar HashHandler = /** @class */ (function (_super) {\n    __extends(HashHandler, _super);\n    function HashHandler(config, platform) {\n        var _this = _super.call(this, config, platform) || this;\n        _this.$singleCommand = true;\n        return _this;\n    }\n    return HashHandler;\n}(MultiHashHandler));\nHashHandler.call = function (thisArg, config, platform) {\n    MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);\n};\nMultiHashHandler.call = function (thisArg, config, platform) {\n    MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);\n};\nexports.HashHandler = HashHandler;\nexports.MultiHashHandler = MultiHashHandler;\n\n});\n\nace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"../lib/oop\");\nvar MultiHashHandler = require(\"../keyboard/hash_handler\").MultiHashHandler;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar CommandManager = /** @class */ (function (_super) {\n    __extends(CommandManager, _super);\n    function CommandManager(platform, commands) {\n        var _this = _super.call(this, commands, platform) || this;\n        _this.byName = _this.commands;\n        _this.setDefaultHandler(\"exec\", function (e) {\n            if (!e.args) {\n                return e.command.exec(e.editor, {}, e.event, true);\n            }\n            return e.command.exec(e.editor, e.args, e.event, false);\n        });\n        return _this;\n    }\n    CommandManager.prototype.exec = function (command, editor, args) {\n        if (Array.isArray(command)) {\n            for (var i = command.length; i--;) {\n                if (this.exec(command[i], editor, args))\n                    return true;\n            }\n            return false;\n        }\n        if (typeof command === \"string\")\n            command = this.commands[command];\n        if (!this.canExecute(command, editor)) {\n            return false;\n        }\n        var e = { editor: editor, command: command, args: args };\n        e.returnValue = this._emit(\"exec\", e);\n        this._signal(\"afterExec\", e);\n        return e.returnValue === false ? false : true;\n    };\n    CommandManager.prototype.canExecute = function (command, editor) {\n        if (typeof command === \"string\")\n            command = this.commands[command];\n        if (!command)\n            return false;\n        if (editor && editor.$readOnly && !command.readOnly)\n            return false;\n        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))\n            return false;\n        return true;\n    };\n    CommandManager.prototype.toggleRecording = function (editor) {\n        if (this.$inReplay)\n            return;\n        editor && editor._emit(\"changeStatus\");\n        if (this.recording) {\n            this.macro.pop();\n            this.off(\"exec\", this.$addCommandToMacro);\n            if (!this.macro.length)\n                this.macro = this.oldMacro;\n            return this.recording = false;\n        }\n        if (!this.$addCommandToMacro) {\n            this.$addCommandToMacro = function (e) {\n                this.macro.push([e.command, e.args]);\n            }.bind(this);\n        }\n        this.oldMacro = this.macro;\n        this.macro = [];\n        this.on(\"exec\", this.$addCommandToMacro);\n        return this.recording = true;\n    };\n    CommandManager.prototype.replay = function (editor) {\n        if (this.$inReplay || !this.macro)\n            return;\n        if (this.recording)\n            return this.toggleRecording(editor);\n        try {\n            this.$inReplay = true;\n            this.macro.forEach(function (x) {\n                if (typeof x == \"string\")\n                    this.exec(x, editor);\n                else\n                    this.exec(x[0], editor, x[1]);\n            }, this);\n        }\n        finally {\n            this.$inReplay = false;\n        }\n    };\n    CommandManager.prototype.trimMacro = function (m) {\n        return m.map(function (x) {\n            if (typeof x[0] != \"string\")\n                x[0] = x[0].name;\n            if (!x[1])\n                x = x[0];\n            return x;\n        });\n    };\n    return CommandManager;\n}(MultiHashHandler));\noop.implement(CommandManager.prototype, EventEmitter);\nexports.CommandManager = CommandManager;\n\n});\n\nace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar lang = require(\"../lib/lang\");\nvar config = require(\"../config\");\nvar Range = require(\"../range\").Range;\nfunction bindKey(win, mac) {\n    return { win: win, mac: mac };\n}\nexports.commands = [{\n        name: \"showSettingsMenu\",\n        description: \"Show settings menu\",\n        bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/settings_menu\", function (module) {\n                module.init(editor);\n                editor.showSettingsMenu();\n            });\n        },\n        readOnly: true\n    }, {\n        name: \"goToNextError\",\n        description: \"Go to next error\",\n        bindKey: bindKey(\"Alt-E\", \"F4\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/error_marker\", function (module) {\n                module.showErrorMarker(editor, 1);\n            });\n        },\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"goToPreviousError\",\n        description: \"Go to previous error\",\n        bindKey: bindKey(\"Alt-Shift-E\", \"Shift-F4\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/error_marker\", function (module) {\n                module.showErrorMarker(editor, -1);\n            });\n        },\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"selectall\",\n        description: \"Select all\",\n        bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n        exec: function (editor) { editor.selectAll(); },\n        readOnly: true\n    }, {\n        name: \"centerselection\",\n        description: \"Center selection\",\n        bindKey: bindKey(null, \"Ctrl-L\"),\n        exec: function (editor) { editor.centerSelection(); },\n        readOnly: true\n    }, {\n        name: \"gotoline\",\n        description: \"Go to line...\",\n        bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n        exec: function (editor, line) {\n            if (typeof line === \"number\" && !isNaN(line))\n                editor.gotoLine(line);\n            editor.prompt({ $type: \"gotoLine\" });\n        },\n        readOnly: true\n    }, {\n        name: \"fold\",\n        bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n        exec: function (editor) { editor.session.toggleFold(false); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"unfold\",\n        bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n        exec: function (editor) { editor.session.toggleFold(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"toggleFoldWidget\",\n        description: \"Toggle fold widget\",\n        bindKey: bindKey(\"F2\", \"F2\"),\n        exec: function (editor) { editor.session.toggleFoldWidget(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"toggleParentFoldWidget\",\n        description: \"Toggle parent fold widget\",\n        bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n        exec: function (editor) { editor.session.toggleFoldWidget(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldall\",\n        description: \"Fold all\",\n        bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n        exec: function (editor) { editor.session.foldAll(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldAllComments\",\n        description: \"Fold all comments\",\n        bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n        exec: function (editor) { editor.session.foldAllComments(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"foldOther\",\n        description: \"Fold other\",\n        bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n        exec: function (editor) {\n            editor.session.foldAll();\n            editor.session.unfold(editor.selection.getAllRanges());\n        },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"unfoldall\",\n        description: \"Unfold all\",\n        bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n        exec: function (editor) { editor.session.unfold(); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"findnext\",\n        description: \"Find next\",\n        bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n        exec: function (editor) { editor.findNext(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"findprevious\",\n        description: \"Find previous\",\n        bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n        exec: function (editor) { editor.findPrevious(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"center\",\n        readOnly: true\n    }, {\n        name: \"selectOrFindNext\",\n        description: \"Select or find next\",\n        bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n        exec: function (editor) {\n            if (editor.selection.isEmpty())\n                editor.selection.selectWord();\n            else\n                editor.findNext();\n        },\n        readOnly: true\n    }, {\n        name: \"selectOrFindPrevious\",\n        description: \"Select or find previous\",\n        bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n        exec: function (editor) {\n            if (editor.selection.isEmpty())\n                editor.selection.selectWord();\n            else\n                editor.findPrevious();\n        },\n        readOnly: true\n    }, {\n        name: \"find\",\n        description: \"Find\",\n        bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/searchbox\", function (e) { e.Search(editor); });\n        },\n        readOnly: true\n    }, {\n        name: \"overwrite\",\n        description: \"Overwrite\",\n        bindKey: \"Insert\",\n        exec: function (editor) { editor.toggleOverwrite(); },\n        readOnly: true\n    }, {\n        name: \"selecttostart\",\n        description: \"Select to start\",\n        bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Home|Command-Shift-Up\"),\n        exec: function (editor) { editor.getSelection().selectFileStart(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"gotostart\",\n        description: \"Go to start\",\n        bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n        exec: function (editor) { editor.navigateFileStart(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"selectup\",\n        description: \"Select up\",\n        bindKey: bindKey(\"Shift-Up\", \"Shift-Up|Ctrl-Shift-P\"),\n        exec: function (editor) { editor.getSelection().selectUp(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"golineup\",\n        description: \"Go line up\",\n        bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n        exec: function (editor, args) { editor.navigateUp(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttoend\",\n        description: \"Select to end\",\n        bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-End|Command-Shift-Down\"),\n        exec: function (editor) { editor.getSelection().selectFileEnd(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"gotoend\",\n        description: \"Go to end\",\n        bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n        exec: function (editor) { editor.navigateFileEnd(); },\n        multiSelectAction: \"forEach\",\n        readOnly: true,\n        scrollIntoView: \"animate\",\n        aceCommandGroup: \"fileJump\"\n    }, {\n        name: \"selectdown\",\n        description: \"Select down\",\n        bindKey: bindKey(\"Shift-Down\", \"Shift-Down|Ctrl-Shift-N\"),\n        exec: function (editor) { editor.getSelection().selectDown(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"golinedown\",\n        description: \"Go line down\",\n        bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n        exec: function (editor, args) { editor.navigateDown(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectwordleft\",\n        description: \"Select word left\",\n        bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n        exec: function (editor) { editor.getSelection().selectWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotowordleft\",\n        description: \"Go to word left\",\n        bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n        exec: function (editor) { editor.navigateWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttolinestart\",\n        description: \"Select to line start\",\n        bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left|Ctrl-Shift-A\"),\n        exec: function (editor) { editor.getSelection().selectLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotolinestart\",\n        description: \"Go to line start\",\n        bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n        exec: function (editor) { editor.navigateLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectleft\",\n        description: \"Select left\",\n        bindKey: bindKey(\"Shift-Left\", \"Shift-Left|Ctrl-Shift-B\"),\n        exec: function (editor) { editor.getSelection().selectLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotoleft\",\n        description: \"Go to left\",\n        bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n        exec: function (editor, args) { editor.navigateLeft(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectwordright\",\n        description: \"Select word right\",\n        bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n        exec: function (editor) { editor.getSelection().selectWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotowordright\",\n        description: \"Go to word right\",\n        bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n        exec: function (editor) { editor.navigateWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selecttolineend\",\n        description: \"Select to line end\",\n        bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right|Shift-End|Ctrl-Shift-E\"),\n        exec: function (editor) { editor.getSelection().selectLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotolineend\",\n        description: \"Go to line end\",\n        bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n        exec: function (editor) { editor.navigateLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectright\",\n        description: \"Select right\",\n        bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n        exec: function (editor) { editor.getSelection().selectRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"gotoright\",\n        description: \"Go to right\",\n        bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n        exec: function (editor, args) { editor.navigateRight(args.times); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectpagedown\",\n        description: \"Select page down\",\n        bindKey: \"Shift-PageDown\",\n        exec: function (editor) { editor.selectPageDown(); },\n        readOnly: true\n    }, {\n        name: \"pagedown\",\n        description: \"Page down\",\n        bindKey: bindKey(null, \"Option-PageDown\"),\n        exec: function (editor) { editor.scrollPageDown(); },\n        readOnly: true\n    }, {\n        name: \"gotopagedown\",\n        description: \"Go to page down\",\n        bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n        exec: function (editor) { editor.gotoPageDown(); },\n        readOnly: true\n    }, {\n        name: \"selectpageup\",\n        description: \"Select page up\",\n        bindKey: \"Shift-PageUp\",\n        exec: function (editor) { editor.selectPageUp(); },\n        readOnly: true\n    }, {\n        name: \"pageup\",\n        description: \"Page up\",\n        bindKey: bindKey(null, \"Option-PageUp\"),\n        exec: function (editor) { editor.scrollPageUp(); },\n        readOnly: true\n    }, {\n        name: \"gotopageup\",\n        description: \"Go to page up\",\n        bindKey: \"PageUp\",\n        exec: function (editor) { editor.gotoPageUp(); },\n        readOnly: true\n    }, {\n        name: \"scrollup\",\n        description: \"Scroll up\",\n        bindKey: bindKey(\"Ctrl-Up\", null),\n        exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n        readOnly: true\n    }, {\n        name: \"scrolldown\",\n        description: \"Scroll down\",\n        bindKey: bindKey(\"Ctrl-Down\", null),\n        exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n        readOnly: true\n    }, {\n        name: \"selectlinestart\",\n        description: \"Select line start\",\n        bindKey: \"Shift-Home\",\n        exec: function (editor) { editor.getSelection().selectLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectlineend\",\n        description: \"Select line end\",\n        bindKey: \"Shift-End\",\n        exec: function (editor) { editor.getSelection().selectLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"togglerecording\",\n        description: \"Toggle recording\",\n        bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n        exec: function (editor) { editor.commands.toggleRecording(editor); },\n        readOnly: true\n    }, {\n        name: \"replaymacro\",\n        description: \"Replay macro\",\n        bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n        exec: function (editor) { editor.commands.replay(editor); },\n        readOnly: true\n    }, {\n        name: \"jumptomatching\",\n        description: \"Jump to matching\",\n        bindKey: bindKey(\"Ctrl-\\\\|Ctrl-P\", \"Command-\\\\\"),\n        exec: function (editor) { editor.jumpToMatching(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"selecttomatching\",\n        description: \"Select to matching\",\n        bindKey: bindKey(\"Ctrl-Shift-\\\\|Ctrl-Shift-P\", \"Command-Shift-\\\\\"),\n        exec: function (editor) { editor.jumpToMatching(true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"expandToMatching\",\n        description: \"Expand to matching\",\n        bindKey: bindKey(\"Ctrl-Shift-M\", \"Ctrl-Shift-M\"),\n        exec: function (editor) { editor.jumpToMatching(true, true); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"animate\",\n        readOnly: true\n    }, {\n        name: \"passKeysToBrowser\",\n        description: \"Pass keys to browser\",\n        bindKey: bindKey(null, null),\n        exec: function () { },\n        passEvent: true,\n        readOnly: true\n    }, {\n        name: \"copy\",\n        description: \"Copy\",\n        exec: function (editor) {\n        },\n        readOnly: true\n    },\n    {\n        name: \"cut\",\n        description: \"Cut\",\n        exec: function (editor) {\n            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();\n            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();\n            editor._emit(\"cut\", range);\n            if (!range.isEmpty())\n                editor.session.remove(range);\n            editor.clearSelection();\n        },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"paste\",\n        description: \"Paste\",\n        exec: function (editor, args) {\n            editor.$handlePaste(args);\n        },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removeline\",\n        description: \"Remove line\",\n        bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n        exec: function (editor) { editor.removeLines(); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEachLine\"\n    }, {\n        name: \"duplicateSelection\",\n        description: \"Duplicate selection\",\n        bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n        exec: function (editor) { editor.duplicateSelection(); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"sortlines\",\n        description: \"Sort lines\",\n        bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n        exec: function (editor) { editor.sortLines(); },\n        scrollIntoView: \"selection\",\n        multiSelectAction: \"forEachLine\"\n    }, {\n        name: \"togglecomment\",\n        description: \"Toggle comment\",\n        bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n        exec: function (editor) { editor.toggleCommentLines(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"toggleBlockComment\",\n        description: \"Toggle block comment\",\n        bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n        exec: function (editor) { editor.toggleBlockComment(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"modifyNumberUp\",\n        description: \"Modify number up\",\n        bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n        exec: function (editor) { editor.modifyNumber(1); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"modifyNumberDown\",\n        description: \"Modify number down\",\n        bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n        exec: function (editor) { editor.modifyNumber(-1); },\n        scrollIntoView: \"cursor\",\n        multiSelectAction: \"forEach\"\n    }, {\n        name: \"replace\",\n        description: \"Replace\",\n        bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n        exec: function (editor) {\n            config.loadModule(\"ace/ext/searchbox\", function (e) { e.Search(editor, true); });\n        }\n    }, {\n        name: \"undo\",\n        description: \"Undo\",\n        bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n        exec: function (editor) { editor.undo(); }\n    }, {\n        name: \"redo\",\n        description: \"Redo\",\n        bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n        exec: function (editor) { editor.redo(); }\n    }, {\n        name: \"copylinesup\",\n        description: \"Copy lines up\",\n        bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n        exec: function (editor) { editor.copyLinesUp(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"movelinesup\",\n        description: \"Move lines up\",\n        bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n        exec: function (editor) { editor.moveLinesUp(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"copylinesdown\",\n        description: \"Copy lines down\",\n        bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n        exec: function (editor) { editor.copyLinesDown(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"movelinesdown\",\n        description: \"Move lines down\",\n        bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n        exec: function (editor) { editor.moveLinesDown(); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"del\",\n        description: \"Delete\",\n        bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n        exec: function (editor) { editor.remove(\"right\"); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"backspace\",\n        description: \"Backspace\",\n        bindKey: bindKey(\"Shift-Backspace|Backspace\", \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"),\n        exec: function (editor) { editor.remove(\"left\"); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"cut_or_delete\",\n        description: \"Cut or delete\",\n        bindKey: bindKey(\"Shift-Delete\", null),\n        exec: function (editor) {\n            if (editor.selection.isEmpty()) {\n                editor.remove(\"left\");\n            }\n            else {\n                return false;\n            }\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolinestart\",\n        description: \"Remove to line start\",\n        bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n        exec: function (editor) { editor.removeToLineStart(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolineend\",\n        description: \"Remove to line end\",\n        bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K|Command-Delete\"),\n        exec: function (editor) { editor.removeToLineEnd(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolinestarthard\",\n        description: \"Remove to line start hard\",\n        bindKey: bindKey(\"Ctrl-Shift-Backspace\", null),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.start.column = 0;\n            editor.session.remove(range);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removetolineendhard\",\n        description: \"Remove to line end hard\",\n        bindKey: bindKey(\"Ctrl-Shift-Delete\", null),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.end.column = Number.MAX_VALUE;\n            editor.session.remove(range);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removewordleft\",\n        description: \"Remove word left\",\n        bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n        exec: function (editor) { editor.removeWordLeft(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"removewordright\",\n        description: \"Remove word right\",\n        bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n        exec: function (editor) { editor.removeWordRight(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"outdent\",\n        description: \"Outdent\",\n        bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n        exec: function (editor) { editor.blockOutdent(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"indent\",\n        description: \"Indent\",\n        bindKey: bindKey(\"Tab\", \"Tab\"),\n        exec: function (editor) { editor.indent(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"blockoutdent\",\n        description: \"Block outdent\",\n        bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n        exec: function (editor) { editor.blockOutdent(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"blockindent\",\n        description: \"Block indent\",\n        bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n        exec: function (editor) { editor.blockIndent(); },\n        multiSelectAction: \"forEachLine\",\n        scrollIntoView: \"selectionPart\"\n    }, {\n        name: \"insertstring\",\n        description: \"Insert string\",\n        exec: function (editor, str) { editor.insert(str); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"inserttext\",\n        description: \"Insert text\",\n        exec: function (editor, args) {\n            editor.insert(lang.stringRepeat(args.text || \"\", args.times || 1));\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"splitline\",\n        description: \"Split line\",\n        bindKey: bindKey(null, \"Ctrl-O\"),\n        exec: function (editor) { editor.splitLine(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"transposeletters\",\n        description: \"Transpose letters\",\n        bindKey: bindKey(\"Alt-Shift-X\", \"Ctrl-T\"),\n        exec: function (editor) { editor.transposeLetters(); },\n        multiSelectAction: function (editor) { editor.transposeSelections(1); },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"touppercase\",\n        description: \"To uppercase\",\n        bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n        exec: function (editor) { editor.toUpperCase(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"tolowercase\",\n        description: \"To lowercase\",\n        bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n        exec: function (editor) { editor.toLowerCase(); },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"autoindent\",\n        description: \"Auto Indent\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) { editor.autoIndent(); },\n        scrollIntoView: \"animate\"\n    }, {\n        name: \"expandtoline\",\n        description: \"Expand to line\",\n        bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n        exec: function (editor) {\n            var range = editor.selection.getRange();\n            range.start.column = range.end.column = 0;\n            range.end.row++;\n            editor.selection.setRange(range, false);\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"openlink\",\n        bindKey: bindKey(\"Ctrl+F3\", \"F3\"),\n        exec: function (editor) { editor.openLink(); }\n    }, {\n        name: \"joinlines\",\n        description: \"Join lines\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            var isBackwards = editor.selection.isBackwards();\n            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;\n            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n            var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n            var insertLine = editor.session.doc.getLine(selectionStart.row);\n            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n                if (curLine.length !== 0) {\n                    curLine = \" \" + curLine;\n                }\n                insertLine += curLine;\n            }\n            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n                insertLine += editor.session.doc.getNewLineCharacter();\n            }\n            editor.clearSelection();\n            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n            if (selectedCount > 0) {\n                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n            }\n            else {\n                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n            }\n        },\n        multiSelectAction: \"forEach\",\n        readOnly: true\n    }, {\n        name: \"invertSelection\",\n        description: \"Invert selection\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            var endRow = editor.session.doc.getLength() - 1;\n            var endCol = editor.session.doc.getLine(endRow).length;\n            var ranges = editor.selection.rangeList.ranges;\n            var newRanges = [];\n            if (ranges.length < 1) {\n                ranges = [editor.selection.getRange()];\n            }\n            for (var i = 0; i < ranges.length; i++) {\n                if (i == (ranges.length - 1)) {\n                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n                    }\n                }\n                if (i === 0) {\n                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n                    }\n                }\n                else {\n                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));\n                }\n            }\n            editor.exitMultiSelectMode();\n            editor.clearSelection();\n            for (var i = 0; i < newRanges.length; i++) {\n                editor.selection.addRange(newRanges[i], false);\n            }\n        },\n        readOnly: true,\n        scrollIntoView: \"none\"\n    }, {\n        name: \"addLineAfter\",\n        description: \"Add new line after the current line\",\n        exec: function (editor) {\n            editor.selection.clearSelection();\n            editor.navigateLineEnd();\n            editor.insert(\"\\n\");\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"addLineBefore\",\n        description: \"Add new line before the current line\",\n        exec: function (editor) {\n            editor.selection.clearSelection();\n            var cursor = editor.getCursorPosition();\n            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);\n            editor.insert(\"\\n\");\n            if (cursor.row === 0)\n                editor.navigateUp();\n        },\n        multiSelectAction: \"forEach\",\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"openCommandPallete\",\n        exec: function (editor) {\n            console.warn(\"This is an obsolete command. Please use `openCommandPalette` instead.\");\n            editor.prompt({ $type: \"commands\" });\n        },\n        readOnly: true\n    }, {\n        name: \"openCommandPalette\",\n        description: \"Open command palette\",\n        bindKey: bindKey(\"F1\", \"F1\"),\n        exec: function (editor) {\n            editor.prompt({ $type: \"commands\" });\n        },\n        readOnly: true\n    }, {\n        name: \"modeSelect\",\n        description: \"Change language mode...\",\n        bindKey: bindKey(null, null),\n        exec: function (editor) {\n            editor.prompt({ $type: \"modes\" });\n        },\n        readOnly: true\n    }];\nfor (var i = 1; i < 9; i++) {\n    exports.commands.push({\n        name: \"foldToLevel\" + i,\n        description: \"Fold To Level \" + i,\n        level: i,\n        exec: function (editor) { editor.session.foldToLevel(this.level); },\n        scrollIntoView: \"center\",\n        readOnly: true\n    });\n}\n\n});\n\nace.define(\"ace/keyboard/gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/mouse/default_gutter_handler\"], function(require, exports, module){\"use strict\";\nvar keys = require('../lib/keys');\nvar GutterTooltip = require(\"../mouse/default_gutter_handler\").GutterTooltip;\nvar GutterKeyboardHandler = /** @class */ (function () {\n    function GutterKeyboardHandler(editor) {\n        this.editor = editor;\n        this.gutterLayer = editor.renderer.$gutterLayer;\n        this.element = editor.renderer.$gutter;\n        this.lines = editor.renderer.$gutterLayer.$lines;\n        this.activeRowIndex = null;\n        this.activeLane = null;\n        this.annotationTooltip = new GutterTooltip(this.editor);\n    }\n    GutterKeyboardHandler.prototype.addListener = function () {\n        this.element.addEventListener(\"keydown\", this.$onGutterKeyDown.bind(this));\n        this.element.addEventListener(\"focusout\", this.$blurGutter.bind(this));\n        this.editor.on(\"mousewheel\", this.$blurGutter.bind(this));\n    };\n    GutterKeyboardHandler.prototype.removeListener = function () {\n        this.element.removeEventListener(\"keydown\", this.$onGutterKeyDown.bind(this));\n        this.element.removeEventListener(\"focusout\", this.$blurGutter.bind(this));\n        this.editor.off(\"mousewheel\", this.$blurGutter.bind(this));\n    };\n    GutterKeyboardHandler.prototype.$onGutterKeyDown = function (e) {\n        if (this.annotationTooltip.isOpen) {\n            e.preventDefault();\n            if (e.keyCode === keys[\"escape\"])\n                this.annotationTooltip.hideTooltip();\n            return;\n        }\n        if (e.target === this.element) {\n            if (e.keyCode != keys[\"enter\"]) {\n                return;\n            }\n            e.preventDefault();\n            var row = this.editor.getCursorPosition().row;\n            if (!this.editor.isRowVisible(row))\n                this.editor.scrollToLine(row, true, true);\n            setTimeout(\n            function () {\n                var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);\n                var nearestFoldIndex = this.$findNearestFoldWidget(index);\n                var nearestAnnotationIndex = this.$findNearestAnnotation(index);\n                if (nearestFoldIndex === null && nearestAnnotationIndex === null)\n                    return;\n                if (nearestFoldIndex === null && nearestAnnotationIndex !== null) {\n                    this.activeRowIndex = nearestAnnotationIndex;\n                    this.activeLane = \"annotation\";\n                    this.$focusAnnotation(this.activeRowIndex);\n                    return;\n                }\n                if (nearestFoldIndex !== null && nearestAnnotationIndex === null) {\n                    this.activeRowIndex = nearestFoldIndex;\n                    this.activeLane = \"fold\";\n                    this.$focusFoldWidget(this.activeRowIndex);\n                    return;\n                }\n                if (Math.abs(nearestAnnotationIndex - index) < Math.abs(nearestFoldIndex - index)) {\n                    this.activeRowIndex = nearestAnnotationIndex;\n                    this.activeLane = \"annotation\";\n                    this.$focusAnnotation(this.activeRowIndex);\n                    return;\n                }\n                else {\n                    this.activeRowIndex = nearestFoldIndex;\n                    this.activeLane = \"fold\";\n                    this.$focusFoldWidget(this.activeRowIndex);\n                    return;\n                }\n            }.bind(this), 10);\n            return;\n        }\n        this.$handleGutterKeyboardInteraction(e);\n        setTimeout(function () {\n            this.editor._signal(\"gutterkeydown\", new GutterKeyboardEvent(e, this));\n        }.bind(this), 10);\n    };\n    GutterKeyboardHandler.prototype.$handleGutterKeyboardInteraction = function (e) {\n        if (e.keyCode === keys[\"tab\"]) {\n            e.preventDefault();\n            return;\n        }\n        if (e.keyCode === keys[\"escape\"]) {\n            e.preventDefault();\n            this.$blurGutter();\n            this.element.focus();\n            this.lane = null;\n            return;\n        }\n        if (e.keyCode === keys[\"up\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$moveFoldWidgetUp();\n                    break;\n                case \"annotation\":\n                    this.$moveAnnotationUp();\n                    break;\n            }\n            return;\n        }\n        if (e.keyCode === keys[\"down\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$moveFoldWidgetDown();\n                    break;\n                case \"annotation\":\n                    this.$moveAnnotationDown();\n                    break;\n            }\n            return;\n        }\n        if (e.keyCode === keys[\"left\"]) {\n            e.preventDefault();\n            this.$switchLane(\"annotation\");\n            return;\n        }\n        if (e.keyCode === keys[\"right\"]) {\n            e.preventDefault();\n            this.$switchLane(\"fold\");\n            return;\n        }\n        if (e.keyCode === keys[\"enter\"] || e.keyCode === keys[\"space\"]) {\n            e.preventDefault();\n            switch (this.activeLane) {\n                case \"fold\":\n                    if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'start') {\n                        var rowFoldingWidget = this.$rowIndexToRow(this.activeRowIndex);\n                        this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);\n                        setTimeout(\n                        function () {\n                            if (this.$rowIndexToRow(this.activeRowIndex) !== rowFoldingWidget) {\n                                this.$blurFoldWidget(this.activeRowIndex);\n                                this.activeRowIndex = this.$rowToRowIndex(rowFoldingWidget);\n                                this.$focusFoldWidget(this.activeRowIndex);\n                            }\n                        }.bind(this), 10);\n                        break;\n                    }\n                    else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'end') {\n                        break;\n                    }\n                    return;\n                case \"annotation\":\n                    var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];\n                    var rect = gutterElement.getBoundingClientRect();\n                    var style = this.annotationTooltip.getElement().style;\n                    style.left = rect.right + \"px\";\n                    style.top = rect.bottom + \"px\";\n                    this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));\n                    break;\n            }\n            return;\n        }\n    };\n    GutterKeyboardHandler.prototype.$blurGutter = function () {\n        if (this.activeRowIndex !== null) {\n            switch (this.activeLane) {\n                case \"fold\":\n                    this.$blurFoldWidget(this.activeRowIndex);\n                    break;\n                case \"annotation\":\n                    this.$blurAnnotation(this.activeRowIndex);\n                    break;\n            }\n        }\n        if (this.annotationTooltip.isOpen)\n            this.annotationTooltip.hideTooltip();\n        return;\n    };\n    GutterKeyboardHandler.prototype.$isFoldWidgetVisible = function (index) {\n        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));\n        var isIconVisible = this.$getFoldWidget(index).style.display !== \"none\";\n        return isRowFullyVisible && isIconVisible;\n    };\n    GutterKeyboardHandler.prototype.$isAnnotationVisible = function (index) {\n        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));\n        var isIconVisible = this.$getAnnotation(index).style.display !== \"none\";\n        return isRowFullyVisible && isIconVisible;\n    };\n    GutterKeyboardHandler.prototype.$getFoldWidget = function (index) {\n        var cell = this.lines.get(index);\n        var element = cell.element;\n        return element.childNodes[1];\n    };\n    GutterKeyboardHandler.prototype.$getAnnotation = function (index) {\n        var cell = this.lines.get(index);\n        var element = cell.element;\n        return element.childNodes[2];\n    };\n    GutterKeyboardHandler.prototype.$findNearestFoldWidget = function (index) {\n        if (this.$isFoldWidgetVisible(index))\n            return index;\n        var i = 0;\n        while (index - i > 0 || index + i < this.lines.getLength() - 1) {\n            i++;\n            if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))\n                return index - i;\n            if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))\n                return index + i;\n        }\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$findNearestAnnotation = function (index) {\n        if (this.$isAnnotationVisible(index))\n            return index;\n        var i = 0;\n        while (index - i > 0 || index + i < this.lines.getLength() - 1) {\n            i++;\n            if (index - i >= 0 && this.$isAnnotationVisible(index - i))\n                return index - i;\n            if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))\n                return index + i;\n        }\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$focusFoldWidget = function (index) {\n        if (index == null)\n            return;\n        var foldWidget = this.$getFoldWidget(index);\n        foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);\n        foldWidget.focus();\n    };\n    GutterKeyboardHandler.prototype.$focusAnnotation = function (index) {\n        if (index == null)\n            return;\n        var annotation = this.$getAnnotation(index);\n        annotation.classList.add(this.editor.renderer.keyboardFocusClassName);\n        annotation.focus();\n    };\n    GutterKeyboardHandler.prototype.$blurFoldWidget = function (index) {\n        var foldWidget = this.$getFoldWidget(index);\n        foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);\n        foldWidget.blur();\n    };\n    GutterKeyboardHandler.prototype.$blurAnnotation = function (index) {\n        var annotation = this.$getAnnotation(index);\n        annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);\n        annotation.blur();\n    };\n    GutterKeyboardHandler.prototype.$moveFoldWidgetUp = function () {\n        var index = this.activeRowIndex;\n        while (index > 0) {\n            index--;\n            if (this.$isFoldWidgetVisible(index)) {\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusFoldWidget(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveFoldWidgetDown = function () {\n        var index = this.activeRowIndex;\n        while (index < this.lines.getLength() - 1) {\n            index++;\n            if (this.$isFoldWidgetVisible(index)) {\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusFoldWidget(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveAnnotationUp = function () {\n        var index = this.activeRowIndex;\n        while (index > 0) {\n            index--;\n            if (this.$isAnnotationVisible(index)) {\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusAnnotation(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$moveAnnotationDown = function () {\n        var index = this.activeRowIndex;\n        while (index < this.lines.getLength() - 1) {\n            index++;\n            if (this.$isAnnotationVisible(index)) {\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = index;\n                this.$focusAnnotation(this.activeRowIndex);\n                return;\n            }\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$switchLane = function (desinationLane) {\n        switch (desinationLane) {\n            case \"annotation\":\n                if (this.activeLane === \"annotation\") {\n                    break;\n                }\n                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);\n                if (annotationIndex == null) {\n                    break;\n                }\n                this.activeLane = \"annotation\";\n                this.$blurFoldWidget(this.activeRowIndex);\n                this.activeRowIndex = annotationIndex;\n                this.$focusAnnotation(this.activeRowIndex);\n                break;\n            case \"fold\":\n                if (this.activeLane === \"fold\") {\n                    break;\n                }\n                var foldWidgetIndex = this.$findNearestFoldWidget(this.activeRowIndex);\n                if (foldWidgetIndex == null) {\n                    break;\n                }\n                this.activeLane = \"fold\";\n                this.$blurAnnotation(this.activeRowIndex);\n                this.activeRowIndex = foldWidgetIndex;\n                this.$focusFoldWidget(this.activeRowIndex);\n                break;\n        }\n        return;\n    };\n    GutterKeyboardHandler.prototype.$rowIndexToRow = function (index) {\n        var cell = this.lines.get(index);\n        if (cell)\n            return cell.row;\n        return null;\n    };\n    GutterKeyboardHandler.prototype.$rowToRowIndex = function (row) {\n        for (var i = 0; i < this.lines.getLength(); i++) {\n            var cell = this.lines.get(i);\n            if (cell.row == row)\n                return i;\n        }\n        return null;\n    };\n    return GutterKeyboardHandler;\n}());\nexports.GutterKeyboardHandler = GutterKeyboardHandler;\nvar GutterKeyboardEvent = /** @class */ (function () {\n    function GutterKeyboardEvent(domEvent, gutterKeyboardHandler) {\n        this.gutterKeyboardHandler = gutterKeyboardHandler;\n        this.domEvent = domEvent;\n    }\n    GutterKeyboardEvent.prototype.getKey = function () {\n        return keys.keyCodeToString(this.domEvent.keyCode);\n    };\n    GutterKeyboardEvent.prototype.getRow = function () {\n        return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);\n    };\n    GutterKeyboardEvent.prototype.isInAnnotationLane = function () {\n        return this.gutterKeyboardHandler.activeLane === \"annotation\";\n    };\n    GutterKeyboardEvent.prototype.isInFoldLane = function () {\n        return this.gutterKeyboardHandler.activeLane === \"fold\";\n    };\n    return GutterKeyboardEvent;\n}());\nexports.GutterKeyboardEvent = GutterKeyboardEvent;\n\n});\n\nace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\",\"ace/keyboard/gutter_handler\",\"ace/config\",\"ace/clipboard\",\"ace/lib/keys\"], function(require, exports, module){\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar useragent = require(\"./lib/useragent\");\nvar TextInput = require(\"./keyboard/textinput\").TextInput;\nvar MouseHandler = require(\"./mouse/mouse_handler\").MouseHandler;\nvar FoldHandler = require(\"./mouse/fold_handler\").FoldHandler;\nvar KeyBinding = require(\"./keyboard/keybinding\").KeyBinding;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Search = require(\"./search\").Search;\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar CommandManager = require(\"./commands/command_manager\").CommandManager;\nvar defaultCommands = require(\"./commands/default_commands\").commands;\nvar config = require(\"./config\");\nvar TokenIterator = require(\"./token_iterator\").TokenIterator;\nvar GutterKeyboardHandler = require(\"./keyboard/gutter_handler\").GutterKeyboardHandler;\nvar nls = require(\"./config\").nls;\nvar clipboard = require(\"./clipboard\");\nvar keys = require('./lib/keys');\nvar Editor = /** @class */ (function () {\n    function Editor(renderer, session, options) { this.session;\n        this.$toDestroy = [];\n        var container = renderer.getContainerElement();\n        this.container = container;\n        this.renderer = renderer;\n        this.id = \"editor\" + (++Editor.$uid);\n        this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n        if (typeof document == \"object\") {\n            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);\n            this.renderer.textarea = this.textInput.getElement();\n            this.$mouseHandler = new MouseHandler(this);\n            new FoldHandler(this);\n        }\n        this.keyBinding = new KeyBinding(this);\n        this.$search = new Search().set({\n            wrap: true\n        });\n        this.$historyTracker = this.$historyTracker.bind(this);\n        this.commands.on(\"exec\", this.$historyTracker);\n        this.$initOperationListeners();\n        this._$emitInputEvent = lang.delayedCall(function () {\n            this._signal(\"input\", {});\n            if (this.session && !this.session.destroyed)\n                this.session.bgTokenizer.scheduleStart();\n        }.bind(this));\n        this.on(\"change\", function (_, _self) {\n            _self._$emitInputEvent.schedule(31);\n        });\n        this.setSession(session || options && options.session || new EditSession(\"\"));\n        config.resetOptions(this);\n        if (options)\n            this.setOptions(options);\n        config._signal(\"editor\", this);\n    }\n    Editor.prototype.$initOperationListeners = function () {\n        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n    };\n    Editor.prototype.startOperation = function (commandEvent) {\n        this.session.startOperation(commandEvent);\n    };\n    Editor.prototype.endOperation = function (e) {\n        this.session.endOperation(e);\n    };\n    Editor.prototype.onStartOperation = function (commandEvent) {\n        this.curOp = this.session.curOp;\n        this.curOp.scrollTop = this.renderer.scrollTop;\n        this.prevOp = this.session.prevOp;\n        if (!commandEvent) {\n            this.previousCommand = null;\n        }\n    };\n    Editor.prototype.onEndOperation = function (e) {\n        if (this.curOp && this.session) {\n            if (e && e.returnValue === false) {\n                this.curOp = null;\n                return;\n            }\n            this._signal(\"beforeEndOperation\");\n            if (!this.curOp)\n                return;\n            var command = this.curOp.command;\n            var scrollIntoView = command && command.scrollIntoView;\n            if (scrollIntoView) {\n                switch (scrollIntoView) {\n                    case \"center-animate\":\n                        scrollIntoView = \"animate\";\n                    case \"center\":\n                        this.renderer.scrollCursorIntoView(null, 0.5);\n                        break;\n                    case \"animate\":\n                    case \"cursor\":\n                        this.renderer.scrollCursorIntoView();\n                        break;\n                    case \"selectionPart\":\n                        var range = this.selection.getRange();\n                        var config = this.renderer.layerConfig;\n                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                if (scrollIntoView == \"animate\")\n                    this.renderer.animateScrolling(this.curOp.scrollTop);\n            }\n            this.$lastSel = this.session.selection.toJSON();\n            this.prevOp = this.curOp;\n            this.curOp = null;\n        }\n    };\n    Editor.prototype.$historyTracker = function (e) {\n        if (!this.$mergeUndoDeltas)\n            return;\n        var prev = this.prevOp;\n        var mergeableCommands = this.$mergeableCommands;\n        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n        if (e.command.name == \"insertstring\") {\n            var text = e.args;\n            if (this.mergeNextCommand === undefined)\n                this.mergeNextCommand = true;\n            shouldMerge = shouldMerge\n                && this.mergeNextCommand // previous command allows to coalesce with\n                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n            this.mergeNextCommand = true;\n        }\n        else {\n            shouldMerge = shouldMerge\n                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n        }\n        if (this.$mergeUndoDeltas != \"always\"\n            && Date.now() - this.sequenceStartTime > 2000) {\n            shouldMerge = false; // the sequence is too long\n        }\n        if (shouldMerge)\n            this.session.mergeUndoDeltas = true;\n        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n            this.sequenceStartTime = Date.now();\n    };\n    Editor.prototype.setKeyboardHandler = function (keyboardHandler, cb) {\n        if (keyboardHandler && typeof keyboardHandler === \"string\" && keyboardHandler != \"ace\") {\n            this.$keybindingId = keyboardHandler;\n            var _self = this;\n            config.loadModule([\"keybinding\", keyboardHandler], function (module) {\n                if (_self.$keybindingId == keyboardHandler)\n                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n                cb && cb();\n            });\n        }\n        else {\n            this.$keybindingId = null;\n            this.keyBinding.setKeyboardHandler(keyboardHandler);\n            cb && cb();\n        }\n    };\n    Editor.prototype.getKeyboardHandler = function () {\n        return this.keyBinding.getKeyboardHandler();\n    };\n    Editor.prototype.setSession = function (session) {\n        if (this.session == session)\n            return;\n        if (this.curOp)\n            this.endOperation();\n        this.curOp = {};\n        var oldSession = this.session;\n        if (oldSession) {\n            this.session.off(\"change\", this.$onDocumentChange);\n            this.session.off(\"changeMode\", this.$onChangeMode);\n            this.session.off(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.session.off(\"changeTabSize\", this.$onChangeTabSize);\n            this.session.off(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.session.off(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.session.off(\"changeFold\", this.$onChangeFold);\n            this.session.off(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.session.off(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.session.off(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.session.off(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.session.off(\"changeOverwrite\", this.$onCursorChange);\n            this.session.off(\"changeScrollTop\", this.$onScrollTopChange);\n            this.session.off(\"changeScrollLeft\", this.$onScrollLeftChange);\n            this.session.off(\"startOperation\", this.$onStartOperation);\n            this.session.off(\"endOperation\", this.$onEndOperation);\n            var selection = this.session.getSelection();\n            selection.off(\"changeCursor\", this.$onCursorChange);\n            selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n        this.session = session;\n        if (session) {\n            this.$onDocumentChange = this.onDocumentChange.bind(this);\n            session.on(\"change\", this.$onDocumentChange);\n            this.renderer.setSession(session);\n            this.$onChangeMode = this.onChangeMode.bind(this);\n            session.on(\"changeMode\", this.$onChangeMode);\n            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n            session.on(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n            session.on(\"changeTabSize\", this.$onChangeTabSize);\n            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n            session.on(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n            session.on(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.$onChangeFold = this.onChangeFold.bind(this);\n            session.on(\"changeFold\", this.$onChangeFold);\n            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n            this.session.on(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n            this.session.on(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n            this.session.on(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n            this.session.on(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.$onCursorChange = this.onCursorChange.bind(this);\n            this.session.on(\"changeOverwrite\", this.$onCursorChange);\n            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n            this.session.on(\"changeScrollTop\", this.$onScrollTopChange);\n            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n            this.session.on(\"changeScrollLeft\", this.$onScrollLeftChange);\n            this.selection = session.getSelection();\n            this.selection.on(\"changeCursor\", this.$onCursorChange);\n            this.$onSelectionChange = this.onSelectionChange.bind(this);\n            this.selection.on(\"changeSelection\", this.$onSelectionChange);\n            this.$onStartOperation = this.onStartOperation.bind(this);\n            this.session.on(\"startOperation\", this.$onStartOperation);\n            this.$onEndOperation = this.onEndOperation.bind(this);\n            this.session.on(\"endOperation\", this.$onEndOperation);\n            this.onChangeMode();\n            this.onCursorChange();\n            this.onScrollTopChange();\n            this.onScrollLeftChange();\n            this.onSelectionChange();\n            this.onChangeFrontMarker();\n            this.onChangeBackMarker();\n            this.onChangeBreakpoint();\n            this.onChangeAnnotation();\n            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n            this.renderer.updateFull();\n        }\n        else {\n            this.selection = null;\n            this.renderer.setSession(session);\n        }\n        this._signal(\"changeSession\", {\n            session: session,\n            oldSession: oldSession\n        });\n        this.curOp = null;\n        oldSession && oldSession._signal(\"changeEditor\", { oldEditor: this });\n        if (oldSession)\n            oldSession.$editor = null;\n        session && session._signal(\"changeEditor\", { editor: this });\n        if (session)\n            session.$editor = this;\n        if (session && !session.destroyed)\n            session.bgTokenizer.scheduleStart();\n    };\n    Editor.prototype.getSession = function () {\n        return this.session;\n    };\n    Editor.prototype.setValue = function (val, cursorPos) {\n        this.session.doc.setValue(val);\n        if (!cursorPos)\n            this.selectAll();\n        else if (cursorPos == 1)\n            this.navigateFileEnd();\n        else if (cursorPos == -1)\n            this.navigateFileStart();\n        return val;\n    };\n    Editor.prototype.getValue = function () {\n        return this.session.getValue();\n    };\n    Editor.prototype.getSelection = function () {\n        return this.selection;\n    };\n    Editor.prototype.resize = function (force) {\n        this.renderer.onResize(force);\n    };\n    Editor.prototype.setTheme = function (theme, cb) {\n        this.renderer.setTheme(theme, cb);\n    };\n    Editor.prototype.getTheme = function () {\n        return this.renderer.getTheme();\n    };\n    Editor.prototype.setStyle = function (style) {\n        this.renderer.setStyle(style);\n    };\n    Editor.prototype.unsetStyle = function (style) {\n        this.renderer.unsetStyle(style);\n    };\n    Editor.prototype.getFontSize = function () {\n        return this.getOption(\"fontSize\") ||\n            dom.computedStyle(this.container).fontSize;\n    };\n    Editor.prototype.setFontSize = function (size) {\n        this.setOption(\"fontSize\", size);\n    };\n    Editor.prototype.$highlightBrackets = function () {\n        if (this.$highlightPending) {\n            return;\n        }\n        var self = this;\n        this.$highlightPending = true;\n        setTimeout(function () {\n            self.$highlightPending = false;\n            var session = self.session;\n            if (!session || session.destroyed)\n                return;\n            if (session.$bracketHighlight) {\n                session.$bracketHighlight.markerIds.forEach(function (id) {\n                    session.removeMarker(id);\n                });\n                session.$bracketHighlight = null;\n            }\n            var pos = self.getCursorPosition();\n            var handler = self.getKeyboardHandler();\n            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);\n            var ranges = session.getMatchingBracketRanges(pos, isBackwards);\n            if (!ranges) {\n                var iterator = new TokenIterator(session, pos.row, pos.column);\n                var token = iterator.getCurrentToken();\n                if (token && /\\b(?:tag-open|tag-name)/.test(token.type)) {\n                    var tagNamesRanges = session.getMatchingTags(pos);\n                    if (tagNamesRanges) {\n                        ranges = [\n                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,\n                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName\n                        ];\n                    }\n                }\n            }\n            if (!ranges && session.$mode.getMatching)\n                ranges = session.$mode.getMatching(self.session);\n            if (!ranges) {\n                if (self.getHighlightIndentGuides())\n                    self.renderer.$textLayer.$highlightIndentGuide();\n                return;\n            }\n            var markerType = \"ace_bracket\";\n            if (!Array.isArray(ranges)) {\n                ranges = [ranges];\n            }\n            else if (ranges.length == 1) {\n                markerType = \"ace_error_bracket\";\n            }\n            if (ranges.length == 2) {\n                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)\n                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];\n                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)\n                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];\n            }\n            session.$bracketHighlight = {\n                ranges: ranges,\n                markerIds: ranges.map(function (range) {\n                    return session.addMarker(range, markerType, \"text\");\n                })\n            };\n            if (self.getHighlightIndentGuides())\n                self.renderer.$textLayer.$highlightIndentGuide();\n        }, 50);\n    };\n    Editor.prototype.focus = function () {\n        this.textInput.focus();\n    };\n    Editor.prototype.isFocused = function () {\n        return this.textInput.isFocused();\n    };\n    Editor.prototype.blur = function () {\n        this.textInput.blur();\n    };\n    Editor.prototype.onFocus = function (e) {\n        if (this.$isFocused)\n            return;\n        this.$isFocused = true;\n        this.renderer.showCursor();\n        this.renderer.visualizeFocus();\n        this._emit(\"focus\", e);\n    };\n    Editor.prototype.onBlur = function (e) {\n        if (!this.$isFocused)\n            return;\n        this.$isFocused = false;\n        this.renderer.hideCursor();\n        this.renderer.visualizeBlur();\n        this._emit(\"blur\", e);\n    };\n    Editor.prototype.$cursorChange = function () {\n        this.renderer.updateCursor();\n        this.$highlightBrackets();\n        this.$updateHighlightActiveLine();\n    };\n    Editor.prototype.onDocumentChange = function (delta) {\n        var wrap = this.session.$useWrapMode;\n        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);\n        this.renderer.updateLines(delta.start.row, lastRow, wrap);\n        this._signal(\"change\", delta);\n        this.$cursorChange();\n    };\n    Editor.prototype.onTokenizerUpdate = function (e) {\n        var rows = e.data;\n        this.renderer.updateLines(rows.first, rows.last);\n    };\n    Editor.prototype.onScrollTopChange = function () {\n        this.renderer.scrollToY(this.session.getScrollTop());\n    };\n    Editor.prototype.onScrollLeftChange = function () {\n        this.renderer.scrollToX(this.session.getScrollLeft());\n    };\n    Editor.prototype.onCursorChange = function () {\n        this.$cursorChange();\n        this._signal(\"changeSelection\");\n    };\n    Editor.prototype.$updateHighlightActiveLine = function () {\n        var session = this.getSession();\n        var highlight;\n        if (this.$highlightActiveLine) {\n            if (this.$selectionStyle != \"line\" || !this.selection.isMultiLine())\n                highlight = this.getCursorPosition();\n            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())\n                highlight = false;\n            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n                highlight = false;\n        }\n        if (session.$highlightLineMarker && !highlight) {\n            session.removeMarker(session.$highlightLineMarker.id);\n            session.$highlightLineMarker = null;\n        }\n        else if (!session.$highlightLineMarker && highlight) {\n            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n            session.$highlightLineMarker = range;\n        }\n        else if (highlight) {\n            session.$highlightLineMarker.start.row = highlight.row;\n            session.$highlightLineMarker.end.row = highlight.row;\n            session.$highlightLineMarker.start.column = highlight.column;\n            session._signal(\"changeBackMarker\");\n        }\n    };\n    Editor.prototype.onSelectionChange = function (e) {\n        var session = this.session;\n        if (session.$selectionMarker) {\n            session.removeMarker(session.$selectionMarker);\n        }\n        session.$selectionMarker = null;\n        if (!this.selection.isEmpty()) {\n            var range = this.selection.getRange();\n            var style = this.getSelectionStyle();\n            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n        }\n        else {\n            this.$updateHighlightActiveLine();\n        }\n        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n        this.session.highlight(re);\n        this._signal(\"changeSelection\");\n    };\n    Editor.prototype.$getSelectionHighLightRegexp = function () {\n        var session = this.session;\n        var selection = this.getSelectionRange();\n        if (selection.isEmpty() || selection.isMultiLine())\n            return;\n        var startColumn = selection.start.column;\n        var endColumn = selection.end.column;\n        var line = session.getLine(selection.start.row);\n        var needle = line.substring(startColumn, endColumn);\n        if (needle.length > 5000 || !/[\\w\\d]/.test(needle))\n            return;\n        var re = this.$search.$assembleRegExp({\n            wholeWord: true,\n            caseSensitive: true,\n            needle: needle\n        });\n        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);\n        if (!re.test(wordWithBoundary))\n            return;\n        return re;\n    };\n    Editor.prototype.onChangeFrontMarker = function () {\n        this.renderer.updateFrontMarkers();\n    };\n    Editor.prototype.onChangeBackMarker = function () {\n        this.renderer.updateBackMarkers();\n    };\n    Editor.prototype.onChangeBreakpoint = function () {\n        this.renderer.updateBreakpoints();\n    };\n    Editor.prototype.onChangeAnnotation = function () {\n        this.renderer.setAnnotations(this.session.getAnnotations());\n    };\n    Editor.prototype.onChangeMode = function (e) {\n        this.renderer.updateText();\n        this._emit(\"changeMode\", e);\n    };\n    Editor.prototype.onChangeWrapLimit = function () {\n        this.renderer.updateFull();\n    };\n    Editor.prototype.onChangeWrapMode = function () {\n        this.renderer.onResize(true);\n    };\n    Editor.prototype.onChangeFold = function () {\n        this.$updateHighlightActiveLine();\n        this.renderer.updateFull();\n    };\n    Editor.prototype.getSelectedText = function () {\n        return this.session.getTextRange(this.getSelectionRange());\n    };\n    Editor.prototype.getCopyText = function () {\n        var text = this.getSelectedText();\n        var nl = this.session.doc.getNewLineCharacter();\n        var copyLine = false;\n        if (!text && this.$copyWithEmptySelection) {\n            copyLine = true;\n            var ranges = this.selection.getAllRanges();\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (i && ranges[i - 1].start.row == range.start.row)\n                    continue;\n                text += this.session.getLine(range.start.row) + nl;\n            }\n        }\n        var e = { text: text };\n        this._signal(\"copy\", e);\n        clipboard.lineMode = copyLine ? e.text : false;\n        return e.text;\n    };\n    Editor.prototype.onCopy = function () {\n        this.commands.exec(\"copy\", this);\n    };\n    Editor.prototype.onCut = function () {\n        this.commands.exec(\"cut\", this);\n    };\n    Editor.prototype.onPaste = function (text, event) {\n        var e = { text: text, event: event };\n        this.commands.exec(\"paste\", this, e);\n    };\n    Editor.prototype.$handlePaste = function (e) {\n        if (typeof e == \"string\")\n            e = { text: e };\n        this._signal(\"paste\", e);\n        var text = e.text;\n        var lineMode = text === clipboard.lineMode;\n        var session = this.session;\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {\n            if (lineMode)\n                session.insert({ row: this.selection.lead.row, column: 0 }, text);\n            else\n                this.insert(text);\n        }\n        else if (lineMode) {\n            this.selection.rangeList.ranges.forEach(function (range) {\n                session.insert({ row: range.start.row, column: 0 }, text);\n            });\n        }\n        else {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var ranges = this.selection.rangeList.ranges;\n            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);\n            if (lines.length != ranges.length || isFullLine)\n                return this.commands.exec(\"insertstring\", this, text);\n            for (var i = ranges.length; i--;) {\n                var range = ranges[i];\n                if (!range.isEmpty())\n                    session.remove(range);\n                session.insert(range.start, lines[i]);\n            }\n        }\n    };\n    Editor.prototype.execCommand = function (command, args) {\n        return this.commands.exec(command, this, args);\n    };\n    Editor.prototype.insert = function (text, pasted) {\n        var session = this.session;\n        var mode = session.getMode();\n        var cursor = this.getCursorPosition();\n        if (this.getBehavioursEnabled() && !pasted) {\n            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n            if (transform) {\n                if (text !== transform.text) {\n                    if (!this.inVirtualSelectionMode) {\n                        this.session.mergeUndoDeltas = false;\n                        this.mergeNextCommand = false;\n                    }\n                }\n                text = transform.text;\n            }\n        }\n        if (text == \"\\t\")\n            text = this.session.getTabString();\n        if (!this.selection.isEmpty()) {\n            var range = this.getSelectionRange();\n            cursor = this.session.remove(range);\n            this.clearSelection();\n        }\n        else if (this.session.getOverwrite() && text.indexOf(\"\\n\") == -1) {\n            var range = Range.fromPoints(cursor, cursor);\n            range.end.column += text.length;\n            this.session.remove(range);\n        }\n        if (text == \"\\n\" || text == \"\\r\\n\") {\n            var line = session.getLine(cursor.row);\n            if (cursor.column > line.search(/\\S|$/)) {\n                var d = line.substr(cursor.column).search(/\\S|$/);\n                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n            }\n        }\n        this.clearSelection();\n        var start = cursor.column;\n        var lineState = session.getState(cursor.row);\n        var line = session.getLine(cursor.row);\n        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n        session.insert(cursor, text);\n        if (transform && transform.selection) {\n            if (transform.selection.length == 2) { // Transform relative to the current column\n                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));\n            }\n            else { // Transform relative to the current row.\n                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));\n            }\n        }\n        if (this.$enableAutoIndent) {\n            if (session.getDocument().isNewLine(text)) {\n                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);\n            }\n            if (shouldOutdent)\n                mode.autoOutdent(lineState, session, cursor.row);\n        }\n    };\n    Editor.prototype.autoIndent = function () {\n        var session = this.session;\n        var mode = session.getMode();\n        var ranges = this.selection.isEmpty()\n            ? [new Range(0, 0, session.doc.getLength() - 1, 0)]\n            : this.selection.getAllRanges();\n        var prevLineState = \"\";\n        var prevLine = \"\";\n        var lineIndent = \"\";\n        var tab = session.getTabString();\n        for (var i = 0; i < ranges.length; i++) {\n            var startRow = ranges[i].start.row;\n            var endRow = ranges[i].end.row;\n            for (var row = startRow; row <= endRow; row++) {\n                if (row > 0) {\n                    prevLineState = session.getState(row - 1);\n                    prevLine = session.getLine(row - 1);\n                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);\n                }\n                var line = session.getLine(row);\n                var currIndent = mode.$getIndent(line);\n                if (lineIndent !== currIndent) {\n                    if (currIndent.length > 0) {\n                        var range = new Range(row, 0, row, currIndent.length);\n                        session.remove(range);\n                    }\n                    if (lineIndent.length > 0) {\n                        session.insert({ row: row, column: 0 }, lineIndent);\n                    }\n                }\n                mode.autoOutdent(prevLineState, session, row);\n            }\n        }\n    };\n    Editor.prototype.onTextInput = function (text, composition) {\n        if (!composition)\n            return this.keyBinding.onTextInput(text);\n        this.startOperation({ command: { name: \"insertstring\" } });\n        var applyComposition = this.applyComposition.bind(this, text, composition);\n        if (this.selection.rangeCount)\n            this.forEachSelection(applyComposition);\n        else\n            applyComposition();\n        this.endOperation();\n    };\n    Editor.prototype.applyComposition = function (text, composition) {\n        if (composition.extendLeft || composition.extendRight) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.extendLeft;\n            r.end.column += composition.extendRight;\n            if (r.start.column < 0) {\n                r.start.row--;\n                r.start.column += this.session.getLine(r.start.row).length + 1;\n            }\n            this.selection.setRange(r);\n            if (!text && !r.isEmpty())\n                this.remove();\n        }\n        if (text || !this.selection.isEmpty())\n            this.insert(text, true);\n        if (composition.restoreStart || composition.restoreEnd) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.restoreStart;\n            r.end.column -= composition.restoreEnd;\n            this.selection.setRange(r);\n        }\n    };\n    Editor.prototype.onCommandKey = function (e, hashId, keyCode) {\n        return this.keyBinding.onCommandKey(e, hashId, keyCode);\n    };\n    Editor.prototype.setOverwrite = function (overwrite) {\n        this.session.setOverwrite(overwrite);\n    };\n    Editor.prototype.getOverwrite = function () {\n        return this.session.getOverwrite();\n    };\n    Editor.prototype.toggleOverwrite = function () {\n        this.session.toggleOverwrite();\n    };\n    Editor.prototype.setScrollSpeed = function (speed) {\n        this.setOption(\"scrollSpeed\", speed);\n    };\n    Editor.prototype.getScrollSpeed = function () {\n        return this.getOption(\"scrollSpeed\");\n    };\n    Editor.prototype.setDragDelay = function (dragDelay) {\n        this.setOption(\"dragDelay\", dragDelay);\n    };\n    Editor.prototype.getDragDelay = function () {\n        return this.getOption(\"dragDelay\");\n    };\n    Editor.prototype.setSelectionStyle = function (val) {\n        this.setOption(\"selectionStyle\", val);\n    };\n    Editor.prototype.getSelectionStyle = function () {\n        return this.getOption(\"selectionStyle\");\n    };\n    Editor.prototype.setHighlightActiveLine = function (shouldHighlight) {\n        this.setOption(\"highlightActiveLine\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightActiveLine = function () {\n        return this.getOption(\"highlightActiveLine\");\n    };\n    Editor.prototype.setHighlightGutterLine = function (shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightGutterLine = function () {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    Editor.prototype.setHighlightSelectedWord = function (shouldHighlight) {\n        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n    };\n    Editor.prototype.getHighlightSelectedWord = function () {\n        return this.$highlightSelectedWord;\n    };\n    Editor.prototype.setAnimatedScroll = function (shouldAnimate) {\n        this.renderer.setAnimatedScroll(shouldAnimate);\n    };\n    Editor.prototype.getAnimatedScroll = function () {\n        return this.renderer.getAnimatedScroll();\n    };\n    Editor.prototype.setShowInvisibles = function (showInvisibles) {\n        this.renderer.setShowInvisibles(showInvisibles);\n    };\n    Editor.prototype.getShowInvisibles = function () {\n        return this.renderer.getShowInvisibles();\n    };\n    Editor.prototype.setDisplayIndentGuides = function (display) {\n        this.renderer.setDisplayIndentGuides(display);\n    };\n    Editor.prototype.getDisplayIndentGuides = function () {\n        return this.renderer.getDisplayIndentGuides();\n    };\n    Editor.prototype.setHighlightIndentGuides = function (highlight) {\n        this.renderer.setHighlightIndentGuides(highlight);\n    };\n    Editor.prototype.getHighlightIndentGuides = function () {\n        return this.renderer.getHighlightIndentGuides();\n    };\n    Editor.prototype.setShowPrintMargin = function (showPrintMargin) {\n        this.renderer.setShowPrintMargin(showPrintMargin);\n    };\n    Editor.prototype.getShowPrintMargin = function () {\n        return this.renderer.getShowPrintMargin();\n    };\n    Editor.prototype.setPrintMarginColumn = function (showPrintMargin) {\n        this.renderer.setPrintMarginColumn(showPrintMargin);\n    };\n    Editor.prototype.getPrintMarginColumn = function () {\n        return this.renderer.getPrintMarginColumn();\n    };\n    Editor.prototype.setReadOnly = function (readOnly) {\n        this.setOption(\"readOnly\", readOnly);\n    };\n    Editor.prototype.getReadOnly = function () {\n        return this.getOption(\"readOnly\");\n    };\n    Editor.prototype.setBehavioursEnabled = function (enabled) {\n        this.setOption(\"behavioursEnabled\", enabled);\n    };\n    Editor.prototype.getBehavioursEnabled = function () {\n        return this.getOption(\"behavioursEnabled\");\n    };\n    Editor.prototype.setWrapBehavioursEnabled = function (enabled) {\n        this.setOption(\"wrapBehavioursEnabled\", enabled);\n    };\n    Editor.prototype.getWrapBehavioursEnabled = function () {\n        return this.getOption(\"wrapBehavioursEnabled\");\n    };\n    Editor.prototype.setShowFoldWidgets = function (show) {\n        this.setOption(\"showFoldWidgets\", show);\n    };\n    Editor.prototype.getShowFoldWidgets = function () {\n        return this.getOption(\"showFoldWidgets\");\n    };\n    Editor.prototype.setFadeFoldWidgets = function (fade) {\n        this.setOption(\"fadeFoldWidgets\", fade);\n    };\n    Editor.prototype.getFadeFoldWidgets = function () {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    Editor.prototype.remove = function (dir) {\n        if (this.selection.isEmpty()) {\n            if (dir == \"left\")\n                this.selection.selectLeft();\n            else\n                this.selection.selectRight();\n        }\n        var range = this.getSelectionRange();\n        if (this.getBehavioursEnabled()) {\n            var session = this.session;\n            var state = session.getState(range.start.row);\n            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n            if (range.end.column === 0) {\n                var text = session.getTextRange(range);\n                if (text[text.length - 1] == \"\\n\") {\n                    var line = session.getLine(range.end.row);\n                    if (/^\\s+$/.test(line)) {\n                        range.end.column = line.length;\n                    }\n                }\n            }\n            if (new_range)\n                range = new_range;\n        }\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    Editor.prototype.removeWordRight = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectWordRight();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeWordLeft = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectWordLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeToLineStart = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectLineStart();\n        if (this.selection.isEmpty())\n            this.selection.selectLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    Editor.prototype.removeToLineEnd = function () {\n        if (this.selection.isEmpty())\n            this.selection.selectLineEnd();\n        var range = this.getSelectionRange();\n        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n            range.end.column = 0;\n            range.end.row++;\n        }\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    Editor.prototype.splitLine = function () {\n        if (!this.selection.isEmpty()) {\n            this.session.remove(this.getSelectionRange());\n            this.clearSelection();\n        }\n        var cursor = this.getCursorPosition();\n        this.insert(\"\\n\");\n        this.moveCursorToPosition(cursor);\n    };\n    Editor.prototype.setGhostText = function (text, position) {\n        this.renderer.setGhostText(text, position);\n    };\n    Editor.prototype.removeGhostText = function () {\n        this.renderer.removeGhostText();\n    };\n    Editor.prototype.transposeLetters = function () {\n        if (!this.selection.isEmpty()) {\n            return;\n        }\n        var cursor = this.getCursorPosition();\n        var column = cursor.column;\n        if (column === 0)\n            return;\n        var line = this.session.getLine(cursor.row);\n        var swap, range;\n        if (column < line.length) {\n            swap = line.charAt(column) + line.charAt(column - 1);\n            range = new Range(cursor.row, column - 1, cursor.row, column + 1);\n        }\n        else {\n            swap = line.charAt(column - 1) + line.charAt(column - 2);\n            range = new Range(cursor.row, column - 2, cursor.row, column);\n        }\n        this.session.replace(range, swap);\n        this.session.selection.moveToPosition(range.end);\n    };\n    Editor.prototype.toLowerCase = function () {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toLowerCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    Editor.prototype.toUpperCase = function () {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toUpperCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    Editor.prototype.indent = function () {\n        var session = this.session;\n        var range = this.getSelectionRange();\n        if (range.start.row < range.end.row) {\n            var rows = this.$getSelectedRows();\n            session.indentRows(rows.first, rows.last, \"\\t\");\n            return;\n        }\n        else if (range.start.column < range.end.column) {\n            var text = session.getTextRange(range);\n            if (!/^\\s+$/.test(text)) {\n                var rows = this.$getSelectedRows();\n                session.indentRows(rows.first, rows.last, \"\\t\");\n                return;\n            }\n        }\n        var line = session.getLine(range.start.row);\n        var position = range.start;\n        var size = session.getTabSize();\n        var column = session.documentToScreenColumn(position.row, position.column);\n        if (this.session.getUseSoftTabs()) {\n            var count = (size - column % size);\n            var indentString = lang.stringRepeat(\" \", count);\n        }\n        else {\n            var count = column % size;\n            while (line[range.start.column - 1] == \" \" && count) {\n                range.start.column--;\n                count--;\n            }\n            this.selection.setSelectionRange(range);\n            indentString = \"\\t\";\n        }\n        return this.insert(indentString);\n    };\n    Editor.prototype.blockIndent = function () {\n        var rows = this.$getSelectedRows();\n        this.session.indentRows(rows.first, rows.last, \"\\t\");\n    };\n    Editor.prototype.blockOutdent = function () {\n        var selection = this.session.getSelection();\n        this.session.outdentRows(selection.getRange());\n    };\n    Editor.prototype.sortLines = function () {\n        var rows = this.$getSelectedRows();\n        var session = this.session;\n        var lines = [];\n        for (var i = rows.first; i <= rows.last; i++)\n            lines.push(session.getLine(i));\n        lines.sort(function (a, b) {\n            if (a.toLowerCase() < b.toLowerCase())\n                return -1;\n            if (a.toLowerCase() > b.toLowerCase())\n                return 1;\n            return 0;\n        });\n        var deleteRange = new Range(0, 0, 0, 0);\n        for (var i = rows.first; i <= rows.last; i++) {\n            var line = session.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            deleteRange.end.column = line.length;\n            session.replace(deleteRange, lines[i - rows.first]);\n        }\n    };\n    Editor.prototype.toggleCommentLines = function () {\n        var state = this.session.getState(this.getCursorPosition().row);\n        var rows = this.$getSelectedRows();\n        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n    };\n    Editor.prototype.toggleBlockComment = function () {\n        var cursor = this.getCursorPosition();\n        var state = this.session.getState(cursor.row);\n        var range = this.getSelectionRange();\n        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n    };\n    Editor.prototype.getNumberAt = function (row, column) {\n        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n        _numberRx.lastIndex = 0;\n        var s = this.session.getLine(row);\n        while (_numberRx.lastIndex < column) {\n            var m = _numberRx.exec(s);\n            if (m.index <= column && m.index + m[0].length >= column) {\n                var number = {\n                    value: m[0],\n                    start: m.index,\n                    end: m.index + m[0].length\n                };\n                return number;\n            }\n        }\n        return null;\n    };\n    Editor.prototype.modifyNumber = function (amount) {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        var charRange = new Range(row, column - 1, row, column);\n        var c = this.session.getTextRange(charRange);\n        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n            var nr = this.getNumberAt(row, column);\n            if (nr) {\n                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n                var decimals = nr.start + nr.value.length - fp;\n                var t = parseFloat(nr.value);\n                t *= Math.pow(10, decimals);\n                if (fp !== nr.end && column < fp) {\n                    amount *= Math.pow(10, nr.end - column - 1);\n                }\n                else {\n                    amount *= Math.pow(10, nr.end - column);\n                }\n                t += amount;\n                t /= Math.pow(10, decimals);\n                var nnr = t.toFixed(decimals);\n                var replaceRange = new Range(row, nr.start, row, nr.end);\n                this.session.replace(replaceRange, nnr);\n                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));\n            }\n        }\n        else {\n            this.toggleWord();\n        }\n    };\n    Editor.prototype.toggleWord = function () {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        this.selection.selectWord();\n        var currentState = this.getSelectedText();\n        var currWordStart = this.selection.getWordRange().start.column;\n        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\\s/);\n        var delta = column - currWordStart - 1;\n        if (delta < 0)\n            delta = 0;\n        var curLength = 0, itLength = 0;\n        var that = this;\n        if (currentState.match(/[A-Za-z0-9_]+/)) {\n            wordParts.forEach(function (item, i) {\n                itLength = curLength + item.length;\n                if (delta >= curLength && delta <= itLength) {\n                    currentState = item;\n                    that.selection.clearSelection();\n                    that.moveCursorTo(row, curLength + currWordStart);\n                    that.selection.selectTo(row, itLength + currWordStart);\n                }\n                curLength = itLength;\n            });\n        }\n        var wordPairs = this.$toggleWordPairs;\n        var reg;\n        for (var i = 0; i < wordPairs.length; i++) {\n            var item = wordPairs[i];\n            for (var j = 0; j <= 1; j++) {\n                var negate = +!j;\n                var firstCondition = currentState.match(new RegExp('^\\\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\\\s?$', 'i'));\n                if (firstCondition) {\n                    var secondCondition = currentState.match(new RegExp('([_]|^|\\\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\\\s)', 'g'));\n                    if (secondCondition) {\n                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {\n                            var res = item[negate];\n                            if (result.toUpperCase() == result) {\n                                res = res.toUpperCase();\n                            }\n                            else if (result.charAt(0).toUpperCase() == result.charAt(0)) {\n                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);\n                            }\n                            return res;\n                        });\n                        this.insert(reg);\n                        reg = \"\";\n                    }\n                }\n            }\n        }\n    };\n    Editor.prototype.findLinkAt = function (row, column) {\n        var e_1, _a;\n        var line = this.session.getLine(row);\n        var wordParts = line.split(/((?:https?|ftp):\\/\\/[\\S]+)/);\n        var columnPosition = column;\n        if (columnPosition < 0)\n            columnPosition = 0;\n        var previousPosition = 0, currentPosition = 0, match;\n        try {\n            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {\n                var item = wordParts_1_1.value;\n                currentPosition = previousPosition + item.length;\n                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {\n                    if (item.match(/((?:https?|ftp):\\/\\/[\\S]+)/)) {\n                        match = item.replace(/[\\s:.,'\";}\\]]+$/, \"\");\n                        break;\n                    }\n                }\n                previousPosition = currentPosition;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return match;\n    };\n    Editor.prototype.openLink = function () {\n        var cursor = this.selection.getCursor();\n        var url = this.findLinkAt(cursor.row, cursor.column);\n        if (url)\n            window.open(url, '_blank');\n        return url != null;\n    };\n    Editor.prototype.removeLines = function () {\n        var rows = this.$getSelectedRows();\n        this.session.removeFullLines(rows.first, rows.last);\n        this.clearSelection();\n    };\n    Editor.prototype.duplicateSelection = function () {\n        var sel = this.selection;\n        var doc = this.session;\n        var range = sel.getRange();\n        var reverse = sel.isBackwards();\n        if (range.isEmpty()) {\n            var row = range.start.row;\n            doc.duplicateLines(row, row);\n        }\n        else {\n            var point = reverse ? range.start : range.end;\n            var endPoint = doc.insert(point, doc.getTextRange(range));\n            range.start = point;\n            range.end = endPoint;\n            sel.setSelectionRange(range, reverse);\n        }\n    };\n    Editor.prototype.moveLinesDown = function () {\n        this.$moveLines(1, false);\n    };\n    Editor.prototype.moveLinesUp = function () {\n        this.$moveLines(-1, false);\n    };\n    Editor.prototype.moveText = function (range, toPosition, copy) {\n        return this.session.moveText(range, toPosition, copy);\n    };\n    Editor.prototype.copyLinesUp = function () {\n        this.$moveLines(-1, true);\n    };\n    Editor.prototype.copyLinesDown = function () {\n        this.$moveLines(1, true);\n    };\n    Editor.prototype.$moveLines = function (dir, copy) {\n        var rows, moved;\n        var selection = this.selection;\n        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n            var range = selection.toOrientedRange();\n            rows = this.$getSelectedRows(range);\n            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);\n            if (copy && dir == -1)\n                moved = 0;\n            range.moveBy(moved, 0);\n            selection.fromOrientedRange(range);\n        }\n        else {\n            var ranges = selection.rangeList.ranges;\n            selection.rangeList.detach(this.session);\n            this.inVirtualSelectionMode = true;\n            var diff = 0;\n            var totalDiff = 0;\n            var l = ranges.length;\n            for (var i = 0; i < l; i++) {\n                var rangeIndex = i;\n                ranges[i].moveBy(diff, 0);\n                rows = this.$getSelectedRows(ranges[i]);\n                var first = rows.first;\n                var last = rows.last;\n                while (++i < l) {\n                    if (totalDiff)\n                        ranges[i].moveBy(totalDiff, 0);\n                    var subRows = this.$getSelectedRows(ranges[i]);\n                    if (copy && subRows.first != last)\n                        break;\n                    else if (!copy && subRows.first > last + 1)\n                        break;\n                    last = subRows.last;\n                }\n                i--;\n                diff = this.session.$moveLines(first, last, copy ? 0 : dir);\n                if (copy && dir == -1)\n                    rangeIndex = i + 1;\n                while (rangeIndex <= i) {\n                    ranges[rangeIndex].moveBy(diff, 0);\n                    rangeIndex++;\n                }\n                if (!copy)\n                    diff = 0;\n                totalDiff += diff;\n            }\n            selection.fromOrientedRange(selection.ranges[0]);\n            selection.rangeList.attach(this.session);\n            this.inVirtualSelectionMode = false;\n        }\n    };\n    Editor.prototype.$getSelectedRows = function (range) {\n        range = (range || this.getSelectionRange()).collapseRows();\n        return {\n            first: this.session.getRowFoldStart(range.start.row),\n            last: this.session.getRowFoldEnd(range.end.row)\n        };\n    };\n    Editor.prototype.onCompositionStart = function (compositionState) {\n        this.renderer.showComposition(compositionState);\n    };\n    Editor.prototype.onCompositionUpdate = function (text) {\n        this.renderer.setCompositionText(text);\n    };\n    Editor.prototype.onCompositionEnd = function () {\n        this.renderer.hideComposition();\n    };\n    Editor.prototype.getFirstVisibleRow = function () {\n        return this.renderer.getFirstVisibleRow();\n    };\n    Editor.prototype.getLastVisibleRow = function () {\n        return this.renderer.getLastVisibleRow();\n    };\n    Editor.prototype.isRowVisible = function (row) {\n        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n    };\n    Editor.prototype.isRowFullyVisible = function (row) {\n        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n    };\n    Editor.prototype.$getVisibleRowCount = function () {\n        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n    };\n    Editor.prototype.$moveByPage = function (dir, select) {\n        var renderer = this.renderer;\n        var config = this.renderer.layerConfig;\n        var rows = dir * Math.floor(config.height / config.lineHeight);\n        if (select === true) {\n            this.selection.$moveSelection(function () {\n                this.moveCursorBy(rows, 0);\n            });\n        }\n        else if (select === false) {\n            this.selection.moveCursorBy(rows, 0);\n            this.selection.clearSelection();\n        }\n        var scrollTop = renderer.scrollTop;\n        renderer.scrollBy(0, rows * config.lineHeight);\n        if (select != null)\n            renderer.scrollCursorIntoView(null, 0.5);\n        renderer.animateScrolling(scrollTop);\n    };\n    Editor.prototype.selectPageDown = function () {\n        this.$moveByPage(1, true);\n    };\n    Editor.prototype.selectPageUp = function () {\n        this.$moveByPage(-1, true);\n    };\n    Editor.prototype.gotoPageDown = function () {\n        this.$moveByPage(1, false);\n    };\n    Editor.prototype.gotoPageUp = function () {\n        this.$moveByPage(-1, false);\n    };\n    Editor.prototype.scrollPageDown = function () {\n        this.$moveByPage(1);\n    };\n    Editor.prototype.scrollPageUp = function () {\n        this.$moveByPage(-1);\n    };\n    Editor.prototype.scrollToRow = function (row) {\n        this.renderer.scrollToRow(row);\n    };\n    Editor.prototype.scrollToLine = function (line, center, animate, callback) {\n        this.renderer.scrollToLine(line, center, animate, callback);\n    };\n    Editor.prototype.centerSelection = function () {\n        var range = this.getSelectionRange();\n        var pos = {\n            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n        };\n        this.renderer.alignCursor(pos, 0.5);\n    };\n    Editor.prototype.getCursorPosition = function () {\n        return this.selection.getCursor();\n    };\n    Editor.prototype.getCursorPositionScreen = function () {\n        return this.session.documentToScreenPosition(this.getCursorPosition());\n    };\n    Editor.prototype.getSelectionRange = function () {\n        return this.selection.getRange();\n    };\n    Editor.prototype.selectAll = function () {\n        this.selection.selectAll();\n    };\n    Editor.prototype.clearSelection = function () {\n        this.selection.clearSelection();\n    };\n    Editor.prototype.moveCursorTo = function (row, column) {\n        this.selection.moveCursorTo(row, column);\n    };\n    Editor.prototype.moveCursorToPosition = function (pos) {\n        this.selection.moveCursorToPosition(pos);\n    };\n    Editor.prototype.jumpToMatching = function (select, expand) {\n        var cursor = this.getCursorPosition();\n        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n        var prevToken = iterator.getCurrentToken();\n        var tokenCount = 0;\n        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {\n            prevToken = iterator.stepBackward();\n        }\n        var token = prevToken || iterator.stepForward();\n        if (!token)\n            return;\n        var matchType;\n        var found = false;\n        var depth = {};\n        var i = cursor.column - token.start;\n        var bracketType;\n        var brackets = {\n            \")\": \"(\",\n            \"(\": \"(\",\n            \"]\": \"[\",\n            \"[\": \"[\",\n            \"{\": \"{\",\n            \"}\": \"{\"\n        };\n        do {\n            if (token.value.match(/[{}()\\[\\]]/g)) {\n                for (; i < token.value.length && !found; i++) {\n                    if (!brackets[token.value[i]]) {\n                        continue;\n                    }\n                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n                    if (isNaN(depth[bracketType])) {\n                        depth[bracketType] = 0;\n                    }\n                    switch (token.value[i]) {\n                        case '(':\n                        case '[':\n                        case '{':\n                            depth[bracketType]++;\n                            break;\n                        case ')':\n                        case ']':\n                        case '}':\n                            depth[bracketType]--;\n                            if (depth[bracketType] === -1) {\n                                matchType = 'bracket';\n                                found = true;\n                            }\n                            break;\n                    }\n                }\n            }\n            else if (token.type.indexOf('tag-name') !== -1) {\n                if (isNaN(depth[token.value])) {\n                    depth[token.value] = 0;\n                }\n                if (prevToken.value === '<' && tokenCount > 1) {\n                    depth[token.value]++;\n                }\n                else if (prevToken.value === '</') {\n                    depth[token.value]--;\n                }\n                if (depth[token.value] === -1) {\n                    matchType = 'tag';\n                    found = true;\n                }\n            }\n            if (!found) {\n                prevToken = token;\n                tokenCount++;\n                token = iterator.stepForward();\n                i = 0;\n            }\n        } while (token && !found);\n        if (!matchType)\n            return;\n        var range, pos;\n        if (matchType === 'bracket') {\n            range = this.session.getBracketRange(cursor);\n            if (!range) {\n                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);\n                pos = range.start;\n                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)\n                    < 2)\n                    range = this.session.getBracketRange(pos);\n            }\n        }\n        else if (matchType === 'tag') {\n            if (!token || token.type.indexOf('tag-name') === -1)\n                return;\n            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);\n            if (range.compare(cursor.row, cursor.column) === 0) {\n                var tagsRanges = this.session.getMatchingTags(cursor);\n                if (tagsRanges) {\n                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {\n                        range = tagsRanges.closeTag;\n                        pos = range.start;\n                    }\n                    else {\n                        range = tagsRanges.openTag;\n                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column\n                            === cursor.column)\n                            pos = range.end;\n                        else\n                            pos = range.start;\n                    }\n                }\n            }\n            pos = pos || range.start;\n        }\n        pos = range && range.cursor || pos;\n        if (pos) {\n            if (select) {\n                if (range && expand) {\n                    this.selection.setRange(range);\n                }\n                else if (range && range.isEqual(this.getSelectionRange())) {\n                    this.clearSelection();\n                }\n                else {\n                    this.selection.selectTo(pos.row, pos.column);\n                }\n            }\n            else {\n                this.selection.moveTo(pos.row, pos.column);\n            }\n        }\n    };\n    Editor.prototype.gotoLine = function (lineNumber, column, animate) {\n        this.selection.clearSelection();\n        this.session.unfold({ row: lineNumber - 1, column: column || 0 });\n        this.exitMultiSelectMode && this.exitMultiSelectMode();\n        this.moveCursorTo(lineNumber - 1, column || 0);\n        if (!this.isRowFullyVisible(lineNumber - 1))\n            this.scrollToLine(lineNumber - 1, true, animate);\n    };\n    Editor.prototype.navigateTo = function (row, column) {\n        this.selection.moveTo(row, column);\n    };\n    Editor.prototype.navigateUp = function (times) {\n        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n            var selectionStart = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionStart);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(-times || -1, 0);\n    };\n    Editor.prototype.navigateDown = function (times) {\n        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n            var selectionEnd = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionEnd);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(times || 1, 0);\n    };\n    Editor.prototype.navigateLeft = function (times) {\n        if (!this.selection.isEmpty()) {\n            var selectionStart = this.getSelectionRange().start;\n            this.moveCursorToPosition(selectionStart);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorLeft();\n            }\n        }\n        this.clearSelection();\n    };\n    Editor.prototype.navigateRight = function (times) {\n        if (!this.selection.isEmpty()) {\n            var selectionEnd = this.getSelectionRange().end;\n            this.moveCursorToPosition(selectionEnd);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorRight();\n            }\n        }\n        this.clearSelection();\n    };\n    Editor.prototype.navigateLineStart = function () {\n        this.selection.moveCursorLineStart();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateLineEnd = function () {\n        this.selection.moveCursorLineEnd();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateFileEnd = function () {\n        this.selection.moveCursorFileEnd();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateFileStart = function () {\n        this.selection.moveCursorFileStart();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateWordRight = function () {\n        this.selection.moveCursorWordRight();\n        this.clearSelection();\n    };\n    Editor.prototype.navigateWordLeft = function () {\n        this.selection.moveCursorWordLeft();\n        this.clearSelection();\n    };\n    Editor.prototype.replace = function (replacement, options) {\n        if (options)\n            this.$search.set(options);\n        var range = this.$search.find(this.session);\n        var replaced = 0;\n        if (!range)\n            return replaced;\n        if (this.$tryReplace(range, replacement)) {\n            replaced = 1;\n        }\n        this.selection.setSelectionRange(range);\n        this.renderer.scrollSelectionIntoView(range.start, range.end);\n        return replaced;\n    };\n    Editor.prototype.replaceAll = function (replacement, options) {\n        if (options) {\n            this.$search.set(options);\n        }\n        var ranges = this.$search.findAll(this.session);\n        var replaced = 0;\n        if (!ranges.length)\n            return replaced;\n        var selection = this.getSelectionRange();\n        this.selection.moveTo(0, 0);\n        for (var i = ranges.length - 1; i >= 0; --i) {\n            if (this.$tryReplace(ranges[i], replacement)) {\n                replaced++;\n            }\n        }\n        this.selection.setSelectionRange(selection);\n        return replaced;\n    };\n    Editor.prototype.$tryReplace = function (range, replacement) {\n        var input = this.session.getTextRange(range);\n        replacement = this.$search.replace(input, replacement);\n        if (replacement !== null) {\n            range.end = this.session.replace(range, replacement);\n            return range;\n        }\n        else {\n            return null;\n        }\n    };\n    Editor.prototype.getLastSearchOptions = function () {\n        return this.$search.getOptions();\n    };\n    Editor.prototype.find = function (needle, options, animate) {\n        if (!options)\n            options = {};\n        if (typeof needle == \"string\" || needle instanceof RegExp)\n            options.needle = needle;\n        else if (typeof needle == \"object\")\n            oop.mixin(options, needle);\n        var range = this.selection.getRange();\n        if (options.needle == null) {\n            needle = this.session.getTextRange(range)\n                || this.$search.$options.needle;\n            if (!needle) {\n                range = this.session.getWordRange(range.start.row, range.start.column);\n                needle = this.session.getTextRange(range);\n            }\n            this.$search.set({ needle: needle });\n        }\n        this.$search.set(options);\n        if (!options.start)\n            this.$search.set({ start: range });\n        var newRange = this.$search.find(this.session);\n        if (options.preventScroll)\n            return newRange;\n        if (newRange) {\n            this.revealRange(newRange, animate);\n            return newRange;\n        }\n        if (options.backwards)\n            range.start = range.end;\n        else\n            range.end = range.start;\n        this.selection.setRange(range);\n    };\n    Editor.prototype.findNext = function (options, animate) {\n        this.find({ skipCurrent: true, backwards: false }, options, animate);\n    };\n    Editor.prototype.findPrevious = function (options, animate) {\n        this.find(options, { skipCurrent: true, backwards: true }, animate);\n    };\n    Editor.prototype.revealRange = function (range, animate) {\n        this.session.unfold(range);\n        this.selection.setSelectionRange(range);\n        var scrollTop = this.renderer.scrollTop;\n        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n        if (animate !== false)\n            this.renderer.animateScrolling(scrollTop);\n    };\n    Editor.prototype.undo = function () {\n        this.session.getUndoManager().undo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    Editor.prototype.redo = function () {\n        this.session.getUndoManager().redo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    Editor.prototype.destroy = function () {\n        if (this.$toDestroy) {\n            this.$toDestroy.forEach(function (el) {\n                el.destroy();\n            });\n            this.$toDestroy = null;\n        }\n        if (this.$mouseHandler)\n            this.$mouseHandler.destroy();\n        this.renderer.destroy();\n        this._signal(\"destroy\", this);\n        if (this.session)\n            this.session.destroy();\n        if (this._$emitInputEvent)\n            this._$emitInputEvent.cancel();\n        this.removeAllListeners();\n    };\n    Editor.prototype.setAutoScrollEditorIntoView = function (enable) {\n        if (!enable)\n            return;\n        var rect;\n        var self = this;\n        var shouldScroll = false;\n        if (!this.$scrollAnchor)\n            this.$scrollAnchor = document.createElement(\"div\");\n        var scrollAnchor = this.$scrollAnchor;\n        scrollAnchor.style.cssText = \"position:absolute\";\n        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n        var onChangeSelection = this.on(\"changeSelection\", function () {\n            shouldScroll = true;\n        });\n        var onBeforeRender = this.renderer.on(\"beforeRender\", function () {\n            if (shouldScroll)\n                rect = self.renderer.container.getBoundingClientRect();\n        });\n        var onAfterRender = this.renderer.on(\"afterRender\", function () {\n            if (shouldScroll && rect && (self.isFocused()\n                || self.searchBox && self.searchBox.isFocused())) {\n                var renderer = self.renderer;\n                var pos = renderer.$cursorLayer.$pixelPos;\n                var config = renderer.layerConfig;\n                var top = pos.top - config.offset;\n                if (pos.top >= 0 && top + rect.top < 0) {\n                    shouldScroll = true;\n                }\n                else if (pos.top < config.height &&\n                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n                    shouldScroll = false;\n                }\n                else {\n                    shouldScroll = null;\n                }\n                if (shouldScroll != null) {\n                    scrollAnchor.style.top = top + \"px\";\n                    scrollAnchor.style.left = pos.left + \"px\";\n                    scrollAnchor.style.height = config.lineHeight + \"px\";\n                    scrollAnchor.scrollIntoView(shouldScroll);\n                }\n                shouldScroll = rect = null;\n            }\n        });\n        this.setAutoScrollEditorIntoView = function (enable) {\n            if (enable)\n                return;\n            delete this.setAutoScrollEditorIntoView;\n            this.off(\"changeSelection\", onChangeSelection);\n            this.renderer.off(\"afterRender\", onAfterRender);\n            this.renderer.off(\"beforeRender\", onBeforeRender);\n        };\n    };\n    Editor.prototype.$resetCursorStyle = function () {\n        var style = this.$cursorStyle || \"ace\";\n        var cursorLayer = this.renderer.$cursorLayer;\n        if (!cursorLayer)\n            return;\n        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n    };\n    Editor.prototype.prompt = function (message, options, callback) {\n        var editor = this;\n        config.loadModule(\"ace/ext/prompt\", function (module) {\n            module.prompt(editor, message, options, callback);\n        });\n    };\n    return Editor;\n}());\nEditor.$uid = 0;\nEditor.prototype.curOp = null;\nEditor.prototype.prevOp = {};\nEditor.prototype.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\nEditor.prototype.$toggleWordPairs = [\n    [\"first\", \"last\"],\n    [\"true\", \"false\"],\n    [\"yes\", \"no\"],\n    [\"width\", \"height\"],\n    [\"top\", \"bottom\"],\n    [\"right\", \"left\"],\n    [\"on\", \"off\"],\n    [\"x\", \"y\"],\n    [\"get\", \"set\"],\n    [\"max\", \"min\"],\n    [\"horizontal\", \"vertical\"],\n    [\"show\", \"hide\"],\n    [\"add\", \"remove\"],\n    [\"up\", \"down\"],\n    [\"before\", \"after\"],\n    [\"even\", \"odd\"],\n    [\"in\", \"out\"],\n    [\"inside\", \"outside\"],\n    [\"next\", \"previous\"],\n    [\"increase\", \"decrease\"],\n    [\"attach\", \"detach\"],\n    [\"&&\", \"||\"],\n    [\"==\", \"!=\"]\n];\noop.implement(Editor.prototype, EventEmitter);\nconfig.defineOptions(Editor.prototype, \"editor\", {\n    selectionStyle: {\n        set: function (style) {\n            this.onSelectionChange();\n            this._signal(\"changeSelectionStyle\", { data: style });\n        },\n        initialValue: \"line\"\n    },\n    highlightActiveLine: {\n        set: function () { this.$updateHighlightActiveLine(); },\n        initialValue: true\n    },\n    highlightSelectedWord: {\n        set: function (shouldHighlight) { this.$onSelectionChange(); },\n        initialValue: true\n    },\n    readOnly: {\n        set: function (readOnly) {\n            this.textInput.setReadOnly(readOnly);\n            this.$resetCursorStyle();\n        },\n        initialValue: false\n    },\n    copyWithEmptySelection: {\n        set: function (value) {\n            this.textInput.setCopyWithEmptySelection(value);\n        },\n        initialValue: false\n    },\n    cursorStyle: {\n        set: function (val) { this.$resetCursorStyle(); },\n        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n        initialValue: \"ace\"\n    },\n    mergeUndoDeltas: {\n        values: [false, true, \"always\"],\n        initialValue: true\n    },\n    behavioursEnabled: { initialValue: true },\n    wrapBehavioursEnabled: { initialValue: true },\n    enableAutoIndent: { initialValue: true },\n    autoScrollEditorIntoView: {\n        set: function (val) { this.setAutoScrollEditorIntoView(val); }\n    },\n    keyboardHandler: {\n        set: function (val) { this.setKeyboardHandler(val); },\n        get: function () { return this.$keybindingId; },\n        handlesSet: true\n    },\n    value: {\n        set: function (val) { this.session.setValue(val); },\n        get: function () { return this.getValue(); },\n        handlesSet: true,\n        hidden: true\n    },\n    session: {\n        set: function (val) { this.setSession(val); },\n        get: function () { return this.session; },\n        handlesSet: true,\n        hidden: true\n    },\n    showLineNumbers: {\n        set: function (show) {\n            this.renderer.$gutterLayer.setShowLineNumbers(show);\n            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);\n            if (show && this.$relativeLineNumbers)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        },\n        initialValue: true\n    },\n    relativeLineNumbers: {\n        set: function (value) {\n            if (this.$showLineNumbers && value)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        }\n    },\n    placeholder: {\n        set: function (message) {\n            if (!this.$updatePlaceholder) {\n                this.$updatePlaceholder = function () {\n                    var hasValue = this.session && (this.renderer.$composition ||\n                        this.session.getLength() > 1 || this.session.getLine(0).length > 0);\n                    if (hasValue && this.renderer.placeholderNode) {\n                        this.renderer.off(\"afterRender\", this.$updatePlaceholder);\n                        dom.removeCssClass(this.container, \"ace_hasPlaceholder\");\n                        this.renderer.placeholderNode.remove();\n                        this.renderer.placeholderNode = null;\n                    }\n                    else if (!hasValue && !this.renderer.placeholderNode) {\n                        this.renderer.on(\"afterRender\", this.$updatePlaceholder);\n                        dom.addCssClass(this.container, \"ace_hasPlaceholder\");\n                        var el = dom.createElement(\"div\");\n                        el.className = \"ace_placeholder\";\n                        el.textContent = this.$placeholder || \"\";\n                        this.renderer.placeholderNode = el;\n                        this.renderer.content.appendChild(this.renderer.placeholderNode);\n                    }\n                    else if (!hasValue && this.renderer.placeholderNode) {\n                        this.renderer.placeholderNode.textContent = this.$placeholder || \"\";\n                    }\n                }.bind(this);\n                this.on(\"input\", this.$updatePlaceholder);\n            }\n            this.$updatePlaceholder();\n        }\n    },\n    enableKeyboardAccessibility: {\n        set: function (value) {\n            var blurCommand = {\n                name: \"blurTextInput\",\n                description: \"Set focus to the editor content div to allow tabbing through the page\",\n                bindKey: \"Esc\",\n                exec: function (editor) {\n                    editor.blur();\n                    editor.renderer.scroller.focus();\n                },\n                readOnly: true\n            };\n            var focusOnEnterKeyup = function (e) {\n                if (e.target == this.renderer.scroller && e.keyCode === keys['enter']) {\n                    e.preventDefault();\n                    var row = this.getCursorPosition().row;\n                    if (!this.isRowVisible(row))\n                        this.scrollToLine(row, true, true);\n                    this.focus();\n                }\n            };\n            var gutterKeyboardHandler;\n            if (value) {\n                this.renderer.enableKeyboardAccessibility = true;\n                this.renderer.keyboardFocusClassName = \"ace_keyboard-focus\";\n                this.textInput.getElement().setAttribute(\"tabindex\", -1);\n                this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);\n                this.renderer.scroller.setAttribute(\"tabindex\", 0);\n                this.renderer.scroller.setAttribute(\"role\", \"group\");\n                this.renderer.scroller.setAttribute(\"aria-roledescription\", nls(\"editor.scroller.aria-roledescription\", \"editor\"));\n                this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);\n                this.renderer.scroller.setAttribute(\"aria-label\", nls(\"editor.scroller.aria-label\", \"Editor content, press Enter to start editing, press Escape to exit\"));\n                this.renderer.scroller.addEventListener(\"keyup\", focusOnEnterKeyup.bind(this));\n                this.commands.addCommand(blurCommand);\n                this.renderer.$gutter.setAttribute(\"tabindex\", 0);\n                this.renderer.$gutter.setAttribute(\"aria-hidden\", false);\n                this.renderer.$gutter.setAttribute(\"role\", \"group\");\n                this.renderer.$gutter.setAttribute(\"aria-roledescription\", nls(\"editor.gutter.aria-roledescription\", \"editor gutter\"));\n                this.renderer.$gutter.setAttribute(\"aria-label\", nls(\"editor.gutter.aria-label\", \"Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit\"));\n                this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);\n                this.renderer.content.setAttribute(\"aria-hidden\", true);\n                if (!gutterKeyboardHandler)\n                    gutterKeyboardHandler = new GutterKeyboardHandler(this);\n                gutterKeyboardHandler.addListener();\n                this.textInput.setAriaOptions({\n                    setLabel: true\n                });\n            }\n            else {\n                this.renderer.enableKeyboardAccessibility = false;\n                this.textInput.getElement().setAttribute(\"tabindex\", 0);\n                this.textInput.setNumberOfExtraLines(0);\n                this.renderer.scroller.setAttribute(\"tabindex\", -1);\n                this.renderer.scroller.removeAttribute(\"role\");\n                this.renderer.scroller.removeAttribute(\"aria-roledescription\");\n                this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);\n                this.renderer.scroller.removeAttribute(\"aria-label\");\n                this.renderer.scroller.removeEventListener(\"keyup\", focusOnEnterKeyup.bind(this));\n                this.commands.removeCommand(blurCommand);\n                this.renderer.content.removeAttribute(\"aria-hidden\");\n                this.renderer.$gutter.setAttribute(\"tabindex\", -1);\n                this.renderer.$gutter.setAttribute(\"aria-hidden\", true);\n                this.renderer.$gutter.removeAttribute(\"role\");\n                this.renderer.$gutter.removeAttribute(\"aria-roledescription\");\n                this.renderer.$gutter.removeAttribute(\"aria-label\");\n                this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);\n                if (gutterKeyboardHandler)\n                    gutterKeyboardHandler.removeListener();\n            }\n        },\n        initialValue: false\n    },\n    textInputAriaLabel: {\n        set: function (val) { this.$textInputAriaLabel = val; },\n        initialValue: \"\"\n    },\n    enableMobileMenu: {\n        set: function (val) { this.$enableMobileMenu = val; },\n        initialValue: true\n    },\n    customScrollbar: \"renderer\",\n    hScrollBarAlwaysVisible: \"renderer\",\n    vScrollBarAlwaysVisible: \"renderer\",\n    highlightGutterLine: \"renderer\",\n    animatedScroll: \"renderer\",\n    showInvisibles: \"renderer\",\n    showPrintMargin: \"renderer\",\n    printMarginColumn: \"renderer\",\n    printMargin: \"renderer\",\n    fadeFoldWidgets: \"renderer\",\n    showFoldWidgets: \"renderer\",\n    displayIndentGuides: \"renderer\",\n    highlightIndentGuides: \"renderer\",\n    showGutter: \"renderer\",\n    fontSize: \"renderer\",\n    fontFamily: \"renderer\",\n    maxLines: \"renderer\",\n    minLines: \"renderer\",\n    scrollPastEnd: \"renderer\",\n    fixedWidthGutter: \"renderer\",\n    theme: \"renderer\",\n    hasCssTransforms: \"renderer\",\n    maxPixelHeight: \"renderer\",\n    useTextareaForIME: \"renderer\",\n    useResizeObserver: \"renderer\",\n    useSvgGutterIcons: \"renderer\",\n    showFoldedAnnotations: \"renderer\",\n    scrollSpeed: \"$mouseHandler\",\n    dragDelay: \"$mouseHandler\",\n    dragEnabled: \"$mouseHandler\",\n    focusTimeout: \"$mouseHandler\",\n    tooltipFollowsMouse: \"$mouseHandler\",\n    firstLineNumber: \"session\",\n    overwrite: \"session\",\n    newLineMode: \"session\",\n    useWorker: \"session\",\n    useSoftTabs: \"session\",\n    navigateWithinSoftTabs: \"session\",\n    tabSize: \"session\",\n    wrap: \"session\",\n    indentedSoftWrap: \"session\",\n    foldStyle: \"session\",\n    mode: \"session\"\n});\nvar relativeNumberRenderer = {\n    getText: function (/**@type{EditSession}*/ session, /**@type{number}*/ row) {\n        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? \"\\xb7\" : \"\"))) + \"\";\n    },\n    getWidth: function (session, /**@type{number}*/ lastLineNumber, config) {\n        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;\n    },\n    update: function (e, /**@type{Editor}*/ editor) {\n        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);\n    },\n    attach: function (/**@type{Editor}*/ editor) {\n        editor.renderer.$gutterLayer.$renderer = this;\n        editor.on(\"changeSelection\", this.update);\n        this.update(null, editor);\n    },\n    detach: function (/**@type{Editor}*/ editor) {\n        if (editor.renderer.$gutterLayer.$renderer == this)\n            editor.renderer.$gutterLayer.$renderer = null;\n        editor.off(\"changeSelection\", this.update);\n        this.update(null, editor);\n    }\n};\nexports.Editor = Editor;\n\n});\n\nace.define(\"ace/layer/lines\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar Lines = /** @class */ (function () {\n    function Lines(element, canvasHeight) {\n        this.element = element;\n        this.canvasHeight = canvasHeight || 500000;\n        this.element.style.height = (this.canvasHeight * 2) + \"px\";\n        this.cells = [];\n        this.cellCache = [];\n        this.$offsetCoefficient = 0;\n    }\n    Lines.prototype.moveContainer = function (config) {\n        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);\n    };\n    Lines.prototype.pageChanged = function (oldConfig, newConfig) {\n        return (Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==\n            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight));\n    };\n    Lines.prototype.computeLineTop = function (row, config, session) {\n        var screenTop = config.firstRowScreen * config.lineHeight;\n        var screenPage = Math.floor(screenTop / this.canvasHeight);\n        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;\n        return lineTop - (screenPage * this.canvasHeight);\n    };\n    Lines.prototype.computeLineHeight = function (row, config, session) {\n        return config.lineHeight * session.getRowLineCount(row);\n    };\n    Lines.prototype.getLength = function () {\n        return this.cells.length;\n    };\n    Lines.prototype.get = function (index) {\n        return this.cells[index];\n    };\n    Lines.prototype.shift = function () {\n        this.$cacheCell(this.cells.shift());\n    };\n    Lines.prototype.pop = function () {\n        this.$cacheCell(this.cells.pop());\n    };\n    Lines.prototype.push = function (cell) {\n        if (Array.isArray(cell)) {\n            this.cells.push.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i = 0; i < cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            this.element.appendChild(fragment);\n        }\n        else {\n            this.cells.push(cell);\n            this.element.appendChild(cell.element);\n        }\n    };\n    Lines.prototype.unshift = function (cell) {\n        if (Array.isArray(cell)) {\n            this.cells.unshift.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i = 0; i < cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            if (this.element.firstChild)\n                this.element.insertBefore(fragment, this.element.firstChild);\n            else\n                this.element.appendChild(fragment);\n        }\n        else {\n            this.cells.unshift(cell);\n            this.element.insertAdjacentElement(\"afterbegin\", cell.element);\n        }\n    };\n    Lines.prototype.last = function () {\n        if (this.cells.length)\n            return this.cells[this.cells.length - 1];\n        else\n            return null;\n    };\n    Lines.prototype.$cacheCell = function (cell) {\n        if (!cell)\n            return;\n        cell.element.remove();\n        this.cellCache.push(cell);\n    };\n    Lines.prototype.createCell = function (row, config, session, initElement) {\n        var cell = this.cellCache.pop();\n        if (!cell) {\n            var element = dom.createElement(\"div\");\n            if (initElement)\n                initElement(element);\n            this.element.appendChild(element);\n            cell = {\n                element: element,\n                text: \"\",\n                row: row\n            };\n        }\n        cell.row = row;\n        return cell;\n    };\n    return Lines;\n}());\nexports.Lines = Lines;\n\n});\n\nace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/layer/lines\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Lines = require(\"./lines\").Lines;\nvar nls = require(\"../config\").nls;\nvar Gutter = /** @class */ (function () {\n    function Gutter(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_gutter-layer\";\n        parentEl.appendChild(this.element);\n        this.setShowFoldWidgets(this.$showFoldWidgets);\n        this.gutterWidth = 0;\n        this.$annotations = [];\n        this.$updateAnnotations = this.$updateAnnotations.bind(this);\n        this.$lines = new Lines(this.element);\n        this.$lines.$offsetCoefficient = 1;\n    }\n    Gutter.prototype.setSession = function (session) {\n        if (this.session)\n            this.session.off(\"change\", this.$updateAnnotations);\n        this.session = session;\n        if (session)\n            session.on(\"change\", this.$updateAnnotations);\n    };\n    Gutter.prototype.addGutterDecoration = function (row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n        this.session.addGutterDecoration(row, className);\n    };\n    Gutter.prototype.removeGutterDecoration = function (row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n        this.session.removeGutterDecoration(row, className);\n    };\n    Gutter.prototype.setAnnotations = function (annotations) {\n        this.$annotations = [];\n        for (var i = 0; i < annotations.length; i++) {\n            var annotation = annotations[i];\n            var row = annotation.row;\n            var rowInfo = this.$annotations[row];\n            if (!rowInfo)\n                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };\n            var annoText = annotation.text;\n            var displayAnnoText = annotation.text;\n            var annoType = annotation.type;\n            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || \"\";\n            if (rowInfo.text.indexOf(annoText) === -1) {\n                rowInfo.text.push(annoText);\n                rowInfo.type.push(annoType);\n                rowInfo.displayText.push(displayAnnoText);\n            }\n            var className = annotation.className;\n            if (className) {\n                rowInfo.className = className;\n            }\n            else if (annoType === \"error\") {\n                rowInfo.className = \" ace_error\";\n            }\n            else if (annoType === \"security\" && !/\\bace_error\\b/.test(rowInfo.className)) {\n                rowInfo.className = \" ace_security\";\n            }\n            else if (annoType === \"warning\" && !/\\bace_(error|security)\\b/.test(rowInfo.className)) {\n                rowInfo.className = \" ace_warning\";\n            }\n            else if (annoType === \"info\" && !rowInfo.className) {\n                rowInfo.className = \" ace_info\";\n            }\n            else if (annoType === \"hint\" && !rowInfo.className) {\n                rowInfo.className = \" ace_hint\";\n            }\n        }\n    };\n    Gutter.prototype.$updateAnnotations = function (delta) {\n        if (!this.$annotations.length)\n            return;\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n        }\n        else if (delta.action == 'remove') {\n            this.$annotations.splice(firstRow, len + 1, null);\n        }\n        else {\n            var args = new Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.$annotations.splice.apply(this.$annotations, args);\n        }\n    };\n    Gutter.prototype.update = function (config) {\n        this.config = config;\n        var session = this.session;\n        var firstRow = config.firstRow;\n        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar\n        session.getLength() - 1);\n        this.oldLastRow = lastRow;\n        this.config = config;\n        this.$lines.moveContainer(config);\n        this.$updateCursorRow();\n        var fold = session.getNextFoldLine(firstRow);\n        var foldStart = fold ? fold.start.row : Infinity;\n        var cell = null;\n        var index = -1;\n        var row = firstRow;\n        while (true) {\n            if (row > foldStart) {\n                row = fold.end.row + 1;\n                fold = session.getNextFoldLine(row, fold);\n                foldStart = fold ? fold.start.row : Infinity;\n            }\n            if (row > lastRow) {\n                while (this.$lines.getLength() > index + 1)\n                    this.$lines.pop();\n                break;\n            }\n            cell = this.$lines.get(++index);\n            if (cell) {\n                cell.row = row;\n            }\n            else {\n                cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n                this.$lines.push(cell);\n            }\n            this.$renderCell(cell, config, fold, row);\n            row++;\n        }\n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n    Gutter.prototype.$updateGutterWidth = function (config) {\n        var session = this.session;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var firstLineNumber = session.$firstLineNumber;\n        var lastLineText = this.$lines.last() ? this.$lines.last().text : \"\";\n        if (this.$fixedWidth || session.$useWrapMode)\n            lastLineText = session.getLength() + firstLineNumber - 1;\n        var gutterWidth = gutterRenderer\n            ? gutterRenderer.getWidth(session, lastLineText, config)\n            : lastLineText.toString().length * config.characterWidth;\n        var padding = this.$padding || this.$computePadding();\n        gutterWidth += padding.left + padding.right;\n        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n            this.gutterWidth = gutterWidth; (this.element.parentNode).style.width =\n                this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n            this._signal(\"changeGutterWidth\", gutterWidth);\n        }\n    };\n    Gutter.prototype.$updateCursorRow = function () {\n        if (!this.$highlightGutterLine)\n            return;\n        var position = this.session.selection.getCursor();\n        if (this.$cursorRow === position.row)\n            return;\n        this.$cursorRow = position.row;\n    };\n    Gutter.prototype.updateLineHighlight = function () {\n        if (!this.$highlightGutterLine)\n            return;\n        var row = this.session.selection.cursor.row;\n        this.$cursorRow = row;\n        if (this.$cursorCell && this.$cursorCell.row == row)\n            return;\n        if (this.$cursorCell)\n            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n        var cells = this.$lines.cells;\n        this.$cursorCell = null;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            if (cell.row >= this.$cursorRow) {\n                if (cell.row > this.$cursorRow) {\n                    var fold = this.session.getFoldLine(this.$cursorRow);\n                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)\n                        cell = cells[i - 1];\n                    else\n                        break;\n                }\n                cell.element.className = \"ace_gutter-active-line \" + cell.element.className;\n                this.$cursorCell = cell;\n                break;\n            }\n        }\n    };\n    Gutter.prototype.scrollLines = function (config) {\n        var oldConfig = this.config;\n        this.config = config;\n        this.$updateCursorRow();\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        this.$lines.moveContainer(config);\n        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar\n        this.session.getLength() - 1);\n        var oldLastRow = this.oldLastRow;\n        this.oldLastRow = lastRow;\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)\n                this.$lines.shift();\n        if (oldLastRow > lastRow)\n            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)\n                this.$lines.pop();\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n        if (lastRow > oldLastRow) {\n            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));\n        }\n        this.updateLineHighlight();\n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n    Gutter.prototype.$renderLines = function (config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n            this.$renderCell(cell, config, foldLine, row);\n            fragment.push(cell);\n            row++;\n        }\n        return fragment;\n    };\n    Gutter.prototype.$renderCell = function (cell, config, fold, row) {\n        var element = cell.element;\n        var session = this.session;\n        var textNode = element.childNodes[0];\n        var foldWidget = element.childNodes[1];\n        var annotationNode = element.childNodes[2];\n        var annotationIconNode = annotationNode.firstChild;\n        var firstLineNumber = session.$firstLineNumber;\n        var breakpoints = session.$breakpoints;\n        var decorations = session.$decorations;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;\n        var lineHeight = config.lineHeight + \"px\";\n        var className = this.$useSvgGutterIcons ? \"ace_gutter-cell_svg-icons \" : \"ace_gutter-cell \";\n        var iconClassName = this.$useSvgGutterIcons ? \"ace_icon_svg\" : \"ace_icon\";\n        var rowText = (gutterRenderer\n            ? gutterRenderer.getText(session, row)\n            : row + firstLineNumber).toString();\n        if (this.$highlightGutterLine) {\n            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row)) {\n                className += \"ace_gutter-active-line \";\n                if (this.$cursorCell != cell) {\n                    if (this.$cursorCell)\n                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n                    this.$cursorCell = cell;\n                }\n            }\n        }\n        if (breakpoints[row])\n            className += breakpoints[row];\n        if (decorations[row])\n            className += decorations[row];\n        if (this.$annotations[row] && row !== foldStart)\n            className += this.$annotations[row].className;\n        if (foldWidgets) {\n            var c = foldWidgets[row];\n            if (c == null)\n                c = foldWidgets[row] = session.getFoldWidget(row);\n        }\n        if (c) {\n            var foldClass = \"ace_fold-widget ace_\" + c;\n            var isClosedFold = c == \"start\" && row == foldStart && row < fold.end.row;\n            if (isClosedFold) {\n                foldClass += \" ace_closed\";\n                var foldAnnotationClass = \"\";\n                var annotationInFold = false;\n                for (var i = row + 1; i <= fold.end.row; i++) {\n                    if (!this.$annotations[i])\n                        continue;\n                    if (this.$annotations[i].className === \" ace_error\") {\n                        annotationInFold = true;\n                        foldAnnotationClass = \" ace_error_fold\";\n                        break;\n                    }\n                    if (this.$annotations[i].className === \" ace_security\") {\n                        annotationInFold = true;\n                        foldAnnotationClass = \" ace_security_fold\";\n                    }\n                    else if (this.$annotations[i].className === \" ace_warning\" &&\n                        foldAnnotationClass !== \" ace_security_fold\") {\n                        annotationInFold = true;\n                        foldAnnotationClass = \" ace_warning_fold\";\n                    }\n                }\n                className += foldAnnotationClass;\n            }\n            else\n                foldClass += \" ace_open\";\n            if (foldWidget.className != foldClass)\n                foldWidget.className = foldClass;\n            dom.setStyle(foldWidget.style, \"height\", lineHeight);\n            dom.setStyle(foldWidget.style, \"display\", \"inline-block\");\n            foldWidget.setAttribute(\"role\", \"button\");\n            foldWidget.setAttribute(\"tabindex\", \"-1\");\n            var foldRange = session.getFoldWidgetRange(row);\n            if (foldRange)\n                foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.range.aria-label\", \"Toggle code folding, rows $0 through $1\", [\n                    foldRange.start.row + 1,\n                    foldRange.end.row + 1\n                ]));\n            else {\n                if (fold)\n                    foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.closed.aria-label\", \"Toggle code folding, rows $0 through $1\", [\n                        fold.start.row + 1,\n                        fold.end.row + 1\n                    ]));\n                else\n                    foldWidget.setAttribute(\"aria-label\", nls(\"gutter.code-folding.open.aria-label\", \"Toggle code folding, row $0\", [row + 1]));\n            }\n            if (isClosedFold) {\n                foldWidget.setAttribute(\"aria-expanded\", \"false\");\n                foldWidget.setAttribute(\"title\", nls(\"gutter.code-folding.closed.title\", \"Unfold code\"));\n            }\n            else {\n                foldWidget.setAttribute(\"aria-expanded\", \"true\");\n                foldWidget.setAttribute(\"title\", nls(\"gutter.code-folding.open.title\", \"Fold code\"));\n            }\n        }\n        else {\n            if (foldWidget) {\n                dom.setStyle(foldWidget.style, \"display\", \"none\");\n                foldWidget.setAttribute(\"tabindex\", \"0\");\n                foldWidget.removeAttribute(\"role\");\n                foldWidget.removeAttribute(\"aria-label\");\n            }\n        }\n        if (annotationInFold && this.$showFoldedAnnotations) {\n            annotationNode.className = \"ace_gutter_annotation\";\n            annotationIconNode.className = iconClassName;\n            annotationIconNode.className += foldAnnotationClass;\n            dom.setStyle(annotationIconNode.style, \"height\", lineHeight);\n            dom.setStyle(annotationNode.style, \"display\", \"block\");\n            dom.setStyle(annotationNode.style, \"height\", lineHeight);\n            var ariaLabel;\n            switch (foldAnnotationClass) {\n                case \" ace_error_fold\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.error\", \"Error, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_security_fold\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.security\", \"Security finding, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_warning_fold\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.warning\", \"Warning, read annotations row $0\", [rowText]);\n                    break;\n            }\n            annotationNode.setAttribute(\"aria-label\", ariaLabel);\n            annotationNode.setAttribute(\"tabindex\", \"-1\");\n            annotationNode.setAttribute(\"role\", \"button\");\n        }\n        else if (this.$annotations[row]) {\n            annotationNode.className = \"ace_gutter_annotation\";\n            annotationIconNode.className = iconClassName;\n            if (this.$useSvgGutterIcons)\n                annotationIconNode.className += this.$annotations[row].className;\n            else\n                element.classList.add(this.$annotations[row].className.replace(\" \", \"\"));\n            dom.setStyle(annotationIconNode.style, \"height\", lineHeight);\n            dom.setStyle(annotationNode.style, \"display\", \"block\");\n            dom.setStyle(annotationNode.style, \"height\", lineHeight);\n            var ariaLabel;\n            switch (this.$annotations[row].className) {\n                case \" ace_error\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.error\", \"Error, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_security\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.security\", \"Security finding, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_warning\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.warning\", \"Warning, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_info\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.info\", \"Info, read annotations row $0\", [rowText]);\n                    break;\n                case \" ace_hint\":\n                    ariaLabel = nls(\"gutter.annotation.aria-label.hint\", \"Suggestion, read annotations row $0\", [rowText]);\n                    break;\n            }\n            annotationNode.setAttribute(\"aria-label\", ariaLabel);\n            annotationNode.setAttribute(\"tabindex\", \"-1\");\n            annotationNode.setAttribute(\"role\", \"button\");\n        }\n        else {\n            dom.setStyle(annotationNode.style, \"display\", \"none\");\n            annotationNode.removeAttribute(\"aria-label\");\n            annotationNode.removeAttribute(\"role\");\n            annotationNode.setAttribute(\"tabindex\", \"0\");\n        }\n        if (rowText !== textNode.data) {\n            textNode.data = rowText;\n        }\n        if (element.className != className)\n            element.className = className;\n        dom.setStyle(cell.element.style, \"height\", this.$lines.computeLineHeight(row, config, session) + \"px\");\n        dom.setStyle(cell.element.style, \"top\", this.$lines.computeLineTop(row, config, session) + \"px\");\n        cell.text = rowText;\n        if (annotationNode.style.display === \"none\" && foldWidget.style.display === \"none\")\n            cell.element.setAttribute(\"aria-hidden\", true);\n        else\n            cell.element.setAttribute(\"aria-hidden\", false);\n        return cell;\n    };\n    Gutter.prototype.setHighlightGutterLine = function (highlightGutterLine) {\n        this.$highlightGutterLine = highlightGutterLine;\n    };\n    Gutter.prototype.setShowLineNumbers = function (show) {\n        this.$renderer = !show && {\n            getWidth: function () { return 0; },\n            getText: function () { return \"\"; }\n        };\n    };\n    Gutter.prototype.getShowLineNumbers = function () {\n        return this.$showLineNumbers;\n    };\n    Gutter.prototype.setShowFoldWidgets = function (show) {\n        if (show)\n            dom.addCssClass(this.element, \"ace_folding-enabled\");\n        else\n            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n        this.$showFoldWidgets = show;\n        this.$padding = null;\n    };\n    Gutter.prototype.getShowFoldWidgets = function () {\n        return this.$showFoldWidgets;\n    };\n    Gutter.prototype.$computePadding = function () {\n        if (!this.element.firstChild)\n            return { left: 0, right: 0 };\n        var style = dom.computedStyle(/**@type{Element}*/ (this.element.firstChild));\n        this.$padding = {};\n        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)\n            + (parseInt(style.paddingLeft) || 0) + 1;\n        this.$padding.right = (parseInt(style.borderRightWidth) || 0)\n            + (parseInt(style.paddingRight) || 0);\n        return this.$padding;\n    };\n    Gutter.prototype.getRegion = function (point) {\n        var padding = this.$padding || this.$computePadding();\n        var rect = this.element.getBoundingClientRect();\n        if (point.x < padding.left + rect.left)\n            return \"markers\";\n        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n            return \"foldWidgets\";\n    };\n    return Gutter;\n}());\nGutter.prototype.$fixedWidth = false;\nGutter.prototype.$highlightGutterLine = true;\nGutter.prototype.$renderer = \"\";\nGutter.prototype.$showLineNumbers = true;\nGutter.prototype.$showFoldWidgets = true;\noop.implement(Gutter.prototype, EventEmitter);\nfunction onCreateCell(element) {\n    var textNode = document.createTextNode('');\n    element.appendChild(textNode);\n    var foldWidget = dom.createElement(\"span\");\n    element.appendChild(foldWidget);\n    var annotationNode = dom.createElement(\"span\");\n    element.appendChild(annotationNode);\n    var annotationIconNode = dom.createElement(\"span\");\n    annotationNode.appendChild(annotationIconNode);\n    return element;\n}\nexports.Gutter = Gutter;\n\n});\n\nace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar dom = require(\"../lib/dom\");\nvar Marker = /** @class */ (function () {\n    function Marker(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_marker-layer\";\n        parentEl.appendChild(this.element);\n    }\n    Marker.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n    };\n    Marker.prototype.setSession = function (session) {\n        this.session = session;\n    };\n    Marker.prototype.setMarkers = function (markers) {\n        this.markers = markers;\n    };\n    Marker.prototype.elt = function (className, css) {\n        var x = this.i != -1 && this.element.childNodes[this.i];\n        if (!x) {\n            x = document.createElement(\"div\");\n            this.element.appendChild(x);\n            this.i = -1;\n        }\n        else {\n            this.i++;\n        }\n        x.style.cssText = css;\n        x.className = className;\n    };\n    Marker.prototype.update = function (config) {\n        if (!config)\n            return;\n        this.config = config;\n        this.i = 0;\n        var html;\n        for (var key in this.markers) {\n            var marker = this.markers[key];\n            if (!marker.range) {\n                marker.update(html, this, this.session, config);\n                continue;\n            }\n            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n            if (range.isEmpty())\n                continue;\n            range = range.toScreenRange(this.session);\n            if (marker.renderer) {\n                var top = this.$getTop(range.start.row, config);\n                var left = this.$padding + range.start.column * config.characterWidth;\n                marker.renderer(html, range, left, top, config);\n            }\n            else if (marker.type == \"fullLine\") {\n                this.drawFullLineMarker(html, range, marker.clazz, config);\n            }\n            else if (marker.type == \"screenLine\") {\n                this.drawScreenLineMarker(html, range, marker.clazz, config);\n            }\n            else if (range.isMultiLine()) {\n                if (marker.type == \"text\")\n                    this.drawTextMarker(html, range, marker.clazz, config);\n                else\n                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n            }\n            else {\n                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\" + \" ace_br15\", config);\n            }\n        }\n        if (this.i != -1) {\n            while (this.i < this.element.childElementCount)\n                this.element.removeChild(this.element.lastChild);\n        }\n    };\n    Marker.prototype.$getTop = function (row, layerConfig) {\n        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n    };\n    Marker.prototype.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {\n        var session = this.session;\n        var start = range.start.row;\n        var end = range.end.row;\n        var row = start;\n        var prev = 0;\n        var curr = 0;\n        var next = session.getScreenLastRowColumn(row);\n        var lineRange = new Range(row, range.start.column, row, curr);\n        for (; row <= end; row++) {\n            lineRange.start.row = lineRange.end.row = row;\n            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);\n            lineRange.end.column = next;\n            prev = curr;\n            curr = next;\n            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;\n            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? \" ace_start\" : \"\") + \" ace_br\"\n                + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);\n        }\n    };\n    Marker.prototype.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var padding = this.$padding;\n        var height = config.lineHeight;\n        var top = this.$getTop(range.start.row, config);\n        var left = padding + range.start.column * config.characterWidth;\n        extraStyle = extraStyle || \"\";\n        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {\n            var range1 = range.clone();\n            range1.end.row = range1.start.row;\n            range1.end.column = this.session.getLine(range1.start.row).length;\n            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br1 ace_start\", config, null, extraStyle);\n        }\n        else {\n            this.elt(clazz + \" ace_br1 ace_start\", \"height:\" + height + \"px;\" + \"right:\" + padding + \"px;\" + \"top:\" + top + \"px;left:\" + left + \"px;\" + (extraStyle || \"\"));\n        }\n        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {\n            var range1 = range.clone();\n            range1.start.row = range1.end.row;\n            range1.start.column = 0;\n            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br12\", config, null, extraStyle);\n        }\n        else {\n            top = this.$getTop(range.end.row, config);\n            var width = range.end.column * config.characterWidth;\n            this.elt(clazz + \" ace_br12\", \"height:\" + height + \"px;\" +\n                \"width:\" + width + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + padding + \"px;\" + (extraStyle || \"\"));\n        }\n        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n        if (height <= 0)\n            return;\n        top = this.$getTop(range.start.row + 1, config);\n        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);\n        this.elt(clazz + (radiusClass ? \" ace_br\" + radiusClass : \"\"), \"height:\" + height + \"px;\" +\n            \"right:\" + padding + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:\" + padding + \"px;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        if (this.session.$bidiHandler.isBidiRow(range.start.row))\n            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);\n        var height = config.lineHeight;\n        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n        var top = this.$getTop(range.start.row, config);\n        var left = this.$padding + range.start.column * config.characterWidth;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"width:\" + width + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:\" + left + \"px;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;\n        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);\n        selections.forEach(function (selection) {\n            this.elt(clazz, \"height:\" + height + \"px;\" +\n                \"width:\" + (selection.width + (extraLength || 0)) + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + (padding + selection.left) + \"px;\" + (extraStyle || \"\"));\n        }, this);\n    };\n    Marker.prototype.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        if (range.start.row != range.end.row)\n            height += this.$getTop(range.end.row, config) - top;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:0;right:0;\" + (extraStyle || \"\"));\n    };\n    Marker.prototype.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        this.elt(clazz, \"height:\" + height + \"px;\" +\n            \"top:\" + top + \"px;\" +\n            \"left:0;right:0;\" + (extraStyle || \"\"));\n    };\n    return Marker;\n}());\nMarker.prototype.$padding = 0;\nfunction getBorderClass(tl, tr, br, bl) {\n    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);\n}\nexports.Marker = Marker;\n\n});\n\nace.define(\"ace/layer/text_util\",[\"require\",\"exports\",\"module\"], function(require, exports, module){// Tokens for which Ace just uses a simple TextNode and does not add any special className.\nvar textTokens = new Set([\"text\", \"rparen\", \"lparen\"]);\nexports.isTextToken = function (tokenType) {\n    return textTokens.has(tokenType);\n};\n\n});\n\nace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/layer/lines\",\"ace/lib/event_emitter\",\"ace/config\",\"ace/layer/text_util\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar Lines = require(\"./lines\").Lines;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar nls = require(\"../config\").nls;\nvar isTextToken = require(\"./text_util\").isTextToken;\nvar Text = /** @class */ (function () {\n    function Text(parentEl) {\n        this.dom = dom;\n        this.element = this.dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_text-layer\";\n        parentEl.appendChild(this.element);\n        this.$updateEolChar = this.$updateEolChar.bind(this);\n        this.$lines = new Lines(this.element);\n    }\n    Text.prototype.$updateEolChar = function () {\n        var doc = this.session.doc;\n        var unixMode = doc.getNewLineCharacter() == \"\\n\" && doc.getNewLineMode() != \"windows\";\n        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;\n        if (this.EOL_CHAR != EOL_CHAR) {\n            this.EOL_CHAR = EOL_CHAR;\n            return true;\n        }\n    };\n    Text.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n        this.element.style.margin = \"0 \" + padding + \"px\";\n    };\n    Text.prototype.getLineHeight = function () {\n        return this.$fontMetrics.$characterSize.height || 0;\n    };\n    Text.prototype.getCharacterWidth = function () {\n        return this.$fontMetrics.$characterSize.width || 0;\n    };\n    Text.prototype.$setFontMetrics = function (measure) {\n        this.$fontMetrics = measure;\n        this.$fontMetrics.on(\"changeCharacterSize\", \n        function (e) {\n            this._signal(\"changeCharacterSize\", e);\n        }.bind(this));\n        this.$pollSizeChanges();\n    };\n    Text.prototype.checkForSizeChanges = function () {\n        this.$fontMetrics.checkForSizeChanges();\n    };\n    Text.prototype.$pollSizeChanges = function () {\n        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n    };\n    Text.prototype.setSession = function (session) {\n        this.session = session;\n        if (session)\n            this.$computeTabString();\n    };\n    Text.prototype.setShowInvisibles = function (showInvisibles) {\n        if (this.showInvisibles == showInvisibles)\n            return false;\n        this.showInvisibles = showInvisibles;\n        if (typeof showInvisibles == \"string\") {\n            this.showSpaces = /tab/i.test(showInvisibles);\n            this.showTabs = /space/i.test(showInvisibles);\n            this.showEOL = /eol/i.test(showInvisibles);\n        }\n        else {\n            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;\n        }\n        this.$computeTabString();\n        return true;\n    };\n    Text.prototype.setDisplayIndentGuides = function (display) {\n        if (this.displayIndentGuides == display)\n            return false;\n        this.displayIndentGuides = display;\n        this.$computeTabString();\n        return true;\n    };\n    Text.prototype.setHighlightIndentGuides = function (highlight) {\n        if (this.$highlightIndentGuides === highlight)\n            return false;\n        this.$highlightIndentGuides = highlight;\n        return highlight;\n    };\n    Text.prototype.$computeTabString = function () {\n        var tabSize = this.session.getTabSize();\n        this.tabSize = tabSize; var tabStr = this.$tabStrings = [0];\n        for (var i = 1; i < tabSize + 1; i++) {\n            if (this.showTabs) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_tab\";\n                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);\n                tabStr.push(span);\n            }\n            else {\n                tabStr.push(this.dom.createTextNode(lang.stringRepeat(\" \", i), this.element));\n            }\n        }\n        if (this.displayIndentGuides) {\n            this.$indentGuideRe = /\\s\\S| \\t|\\t |\\s$/;\n            var className = \"ace_indent-guide\";\n            var spaceClass = this.showSpaces ? \" ace_invisible ace_invisible_space\" : \"\";\n            var spaceContent = this.showSpaces\n                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)\n                : lang.stringRepeat(\" \", this.tabSize);\n            var tabClass = this.showTabs ? \" ace_invisible ace_invisible_tab\" : \"\";\n            var tabContent = this.showTabs\n                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)\n                : spaceContent;\n            var span = this.dom.createElement(\"span\");\n            span.className = className + spaceClass;\n            span.textContent = spaceContent;\n            this.$tabStrings[\" \"] = span;\n            var span = this.dom.createElement(\"span\");\n            span.className = className + tabClass;\n            span.textContent = tabContent;\n            this.$tabStrings[\"\\t\"] = span;\n        }\n    };\n    Text.prototype.updateLines = function (config, firstRow, lastRow) {\n        if (this.config.lastRow != config.lastRow ||\n            this.config.firstRow != config.firstRow) {\n            return this.update(config);\n        }\n        this.config = config;\n        var first = Math.max(firstRow, config.firstRow);\n        var last = Math.min(lastRow, config.lastRow);\n        var lineElements = this.element.childNodes;\n        var lineElementsIdx = 0;\n        for (var row = config.firstRow; row < first; row++) {\n            var foldLine = this.session.getFoldLine(row);\n            if (foldLine) {\n                if (foldLine.containsRow(first)) {\n                    first = foldLine.start.row;\n                    break;\n                }\n                else {\n                    row = foldLine.end.row;\n                }\n            }\n            lineElementsIdx++;\n        }\n        var heightChanged = false;\n        var row = first;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > last)\n                break; var lineElement = lineElements[lineElementsIdx++];\n            if (lineElement) {\n                this.dom.removeChildren(lineElement);\n                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);\n                if (heightChanged)\n                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + \"px\";\n                var height = (config.lineHeight * this.session.getRowLength(row)) + \"px\";\n                if (lineElement.style.height != height) {\n                    heightChanged = true;\n                    lineElement.style.height = height;\n                }\n            }\n            row++;\n        }\n        if (heightChanged) {\n            while (lineElementsIdx < this.$lines.cells.length) {\n                var cell = this.$lines.cells[lineElementsIdx++];\n                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + \"px\";\n            }\n        }\n    };\n    Text.prototype.scrollLines = function (config) {\n        var oldConfig = this.config;\n        this.config = config;\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        this.$lines.moveContainer(config);\n        var lastRow = config.lastRow;\n        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n            return this.update(config);\n        if (config.lastRow < oldConfig.firstRow)\n            return this.update(config);\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)\n                this.$lines.shift();\n        if (oldConfig.lastRow > config.lastRow)\n            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)\n                this.$lines.pop();\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n        if (config.lastRow > oldConfig.lastRow) {\n            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));\n        }\n        this.$highlightIndentGuide();\n    };\n    Text.prototype.$renderLinesFragment = function (config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row + 1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n            var line = this.$lines.createCell(row, config, this.session);\n            var lineEl = line.element;\n            this.dom.removeChildren(lineEl);\n            dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\");\n            dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\");\n            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);\n            if (this.$useLineGroups()) {\n                lineEl.className = \"ace_line_group\";\n            }\n            else {\n                lineEl.className = \"ace_line\";\n            }\n            fragment.push(line);\n            row++;\n        }\n        return fragment;\n    };\n    Text.prototype.update = function (config) {\n        this.$lines.moveContainer(config);\n        this.config = config;\n        var firstRow = config.firstRow;\n        var lastRow = config.lastRow;\n        var lines = this.$lines;\n        while (lines.getLength())\n            lines.pop();\n        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));\n    };\n    Text.prototype.$renderToken = function (parent, screenColumn, token, value) {\n        var self = this;\n        var re = /(\\t)|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\uFEFF\\uFFF9-\\uFFFC\\u2066\\u2067\\u2068\\u202A\\u202B\\u202D\\u202E\\u202C\\u2069\\u2060\\u2061\\u2062\\u2063\\u2064\\u206A\\u206B\\u206B\\u206C\\u206D\\u206E\\u206F]+)|(\\u3000)|([\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3001-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n        var valueFragment = this.dom.createFragment(this.element);\n        var m;\n        var i = 0;\n        while (m = re.exec(value)) {\n            var tab = m[1];\n            var simpleSpace = m[2];\n            var controlCharacter = m[3];\n            var cjkSpace = m[4];\n            var cjk = m[5];\n            if (!self.showSpaces && simpleSpace)\n                continue;\n            var before = i != m.index ? value.slice(i, m.index) : \"\";\n            i = m.index + m[0].length;\n            if (before) {\n                valueFragment.appendChild(this.dom.createTextNode(before, this.element));\n            }\n            if (tab) {\n                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);\n                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));\n                screenColumn += tabSize - 1;\n            }\n            else if (simpleSpace) {\n                if (self.showSpaces) {\n                    var span = this.dom.createElement(\"span\");\n                    span.className = \"ace_invisible ace_invisible_space\";\n                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);\n                    valueFragment.appendChild(span);\n                }\n                else {\n                    valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));\n                }\n            }\n            else if (controlCharacter) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_space ace_invalid\";\n                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);\n                valueFragment.appendChild(span);\n            }\n            else if (cjkSpace) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = self.showSpaces ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;\n                valueFragment.appendChild(span);\n            }\n            else if (cjk) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = \"ace_cjk\";\n                span.textContent = cjk;\n                valueFragment.appendChild(span);\n            }\n        }\n        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));\n        if (!isTextToken(token.type)) {\n            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n            var span = this.dom.createElement(\"span\");\n            if (token.type == \"fold\") {\n                span.style.width = (token.value.length * this.config.characterWidth) + \"px\";\n                span.setAttribute(\"title\", nls(\"inline-fold.closed.title\", \"Unfold code\"));\n            }\n            span.className = classes;\n            span.appendChild(valueFragment);\n            parent.appendChild(span);\n        }\n        else {\n            parent.appendChild(valueFragment);\n        }\n        return screenColumn + value.length;\n    };\n    Text.prototype.renderIndentGuide = function (parent, value, max) {\n        var cols = value.search(this.$indentGuideRe);\n        if (cols <= 0 || cols >= max)\n            return value;\n        if (value[0] == \" \") {\n            cols -= cols % this.tabSize;\n            var count = cols / this.tabSize;\n            for (var i = 0; i < count; i++) {\n                parent.appendChild(this.$tabStrings[\" \"].cloneNode(true));\n            }\n            this.$highlightIndentGuide();\n            return value.substr(cols);\n        }\n        else if (value[0] == \"\\t\") {\n            for (var i = 0; i < cols; i++) {\n                parent.appendChild(this.$tabStrings[\"\\t\"].cloneNode(true));\n            }\n            this.$highlightIndentGuide();\n            return value.substr(cols);\n        }\n        this.$highlightIndentGuide();\n        return value;\n    };\n    Text.prototype.$highlightIndentGuide = function () {\n        if (!this.$highlightIndentGuides || !this.displayIndentGuides)\n            return;\n        this.$highlightIndentGuideMarker = {\n            indentLevel: undefined,\n            start: undefined,\n            end: undefined,\n            dir: undefined\n        };\n        var lines = this.session.doc.$lines;\n        if (!lines)\n            return;\n        var cursor = this.session.selection.getCursor();\n        var initialIndent = /^\\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;\n        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);\n        this.$highlightIndentGuideMarker = {\n            indentLevel: elementIndentLevel,\n            start: cursor.row\n        };\n        var bracketHighlight = this.session.$bracketHighlight;\n        if (bracketHighlight) {\n            var ranges = this.session.$bracketHighlight.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                if (cursor.row !== ranges[i].start.row) {\n                    this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;\n                    if (cursor.row > ranges[i].start.row) {\n                        this.$highlightIndentGuideMarker.dir = -1;\n                    }\n                    else {\n                        this.$highlightIndentGuideMarker.dir = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (!this.$highlightIndentGuideMarker.end) {\n            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {\n                this.$highlightIndentGuideMarker.dir = 1;\n                for (var i = cursor.row + 1; i < lines.length; i++) {\n                    var line = lines[i];\n                    var currentIndent = /^\\s*/.exec(line)[0].length;\n                    if (line !== '') {\n                        this.$highlightIndentGuideMarker.end = i;\n                        if (currentIndent <= initialIndent)\n                            break;\n                    }\n                }\n            }\n        }\n        this.$renderHighlightIndentGuide();\n    };\n    Text.prototype.$clearActiveIndentGuide = function () {\n        var activeIndentGuides = this.element.querySelectorAll(\".ace_indent-guide-active\");\n        activeIndentGuides.forEach(function (el) {\n            el.classList.remove(\"ace_indent-guide-active\");\n        });\n    };\n    Text.prototype.$setIndentGuideActive = function (cell, indentLevel) {\n        var line = this.session.doc.getLine(cell.row);\n        if (line !== \"\") {\n            var element = cell.element;\n            if (cell.element.classList && cell.element.classList.contains(\"ace_line_group\")) {\n                if (cell.element.childNodes.length > 0) {\n                    element = cell.element.childNodes[0];\n                }\n                else {\n                    return;\n                }\n            }\n            var childNodes = element.childNodes;\n            if (childNodes) {\n                var node = childNodes[indentLevel - 1];\n                if (node && node.classList && node.classList.contains(\"ace_indent-guide\"))\n                    node.classList.add(\"ace_indent-guide-active\");\n            }\n        }\n    };\n    Text.prototype.$renderHighlightIndentGuide = function () {\n        if (!this.$lines)\n            return;\n        var cells = this.$lines.cells;\n        this.$clearActiveIndentGuide();\n        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;\n        if (indentLevel !== 0) {\n            if (this.$highlightIndentGuideMarker.dir === 1) {\n                for (var i = 0; i < cells.length; i++) {\n                    var cell = cells[i];\n                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start\n                        + 1) {\n                        if (cell.row >= this.$highlightIndentGuideMarker.end)\n                            break;\n                        this.$setIndentGuideActive(cell, indentLevel);\n                    }\n                }\n            }\n            else {\n                for (var i = cells.length - 1; i >= 0; i--) {\n                    var cell = cells[i];\n                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {\n                        if (cell.row < this.$highlightIndentGuideMarker.end)\n                            break;\n                        this.$setIndentGuideActive(cell, indentLevel);\n                    }\n                }\n            }\n        }\n    };\n    Text.prototype.$createLineElement = function (parent) {\n        var lineEl = this.dom.createElement(\"div\");\n        lineEl.className = \"ace_line\";\n        lineEl.style.height = this.config.lineHeight + \"px\";\n        return lineEl;\n    };\n    Text.prototype.$renderWrappedLine = function (parent, tokens, splits) {\n        var chars = 0;\n        var split = 0;\n        var splitChars = splits[0];\n        var screenColumn = 0;\n        var lineEl = this.$createLineElement();\n        parent.appendChild(lineEl);\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                chars = value.length;\n                value = this.renderIndentGuide(lineEl, value, splitChars);\n                if (!value)\n                    continue;\n                chars -= value.length;\n            }\n            if (chars + value.length < splitChars) {\n                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                chars += value.length;\n            }\n            else {\n                while (chars + value.length >= splitChars) {\n                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));\n                    value = value.substring(splitChars - chars);\n                    chars = splitChars;\n                    lineEl = this.$createLineElement();\n                    parent.appendChild(lineEl);\n                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(\"\\xa0\", splits.indent), this.element));\n                    split++;\n                    screenColumn = 0;\n                    splitChars = splits[split] || Number.MAX_VALUE;\n                }\n                if (value.length != 0) {\n                    chars += value.length;\n                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                }\n            }\n        }\n        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)\n            this.$renderOverflowMessage(lineEl, screenColumn, null, \"\", true);\n    };\n    Text.prototype.$renderSimpleLine = function (parent, tokens) {\n        var screenColumn = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                value = this.renderIndentGuide(parent, value);\n                if (!value)\n                    continue;\n            }\n            if (screenColumn + value.length > this.MAX_LINE_LENGTH)\n                return this.$renderOverflowMessage(parent, screenColumn, token, value);\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        }\n    };\n    Text.prototype.$renderOverflowMessage = function (parent, screenColumn, token, value, hide) {\n        token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));\n        var overflowEl = this.dom.createElement(\"span\");\n        overflowEl.className = \"ace_inline_button ace_keyword ace_toggle_wrap\";\n        overflowEl.textContent = hide ? \"<hide>\" : \"<click to see more...>\";\n        parent.appendChild(overflowEl);\n    };\n    Text.prototype.$renderLine = function (parent, row, foldLine) {\n        if (!foldLine && foldLine != false)\n            foldLine = this.session.getFoldLine(row);\n        if (foldLine)\n            var tokens = this.$getFoldLineTokens(row, foldLine);\n        else\n            var tokens = this.session.getTokens(row);\n        var lastLineEl = parent;\n        if (tokens.length) {\n            var splits = this.session.getRowSplitData(row);\n            if (splits && splits.length) {\n                this.$renderWrappedLine(parent, tokens, splits);\n                var lastLineEl = parent.lastChild;\n            }\n            else {\n                var lastLineEl = parent;\n                if (this.$useLineGroups()) {\n                    lastLineEl = this.$createLineElement();\n                    parent.appendChild(lastLineEl);\n                }\n                this.$renderSimpleLine(lastLineEl, tokens);\n            }\n        }\n        else if (this.$useLineGroups()) {\n            lastLineEl = this.$createLineElement();\n            parent.appendChild(lastLineEl);\n        }\n        if (this.showEOL && lastLineEl) {\n            if (foldLine)\n                row = foldLine.end.row;\n            var invisibleEl = this.dom.createElement(\"span\");\n            invisibleEl.className = \"ace_invisible ace_invisible_eol\";\n            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;\n            lastLineEl.appendChild(invisibleEl);\n        }\n    };\n    Text.prototype.$getFoldLineTokens = function (row, foldLine) {\n        var session = this.session;\n        var renderTokens = [];\n        function addTokens(tokens, from, to) {\n            var idx = 0, col = 0;\n            while ((col + tokens[idx].value.length) < from) {\n                col += tokens[idx].value.length;\n                idx++;\n                if (idx == tokens.length)\n                    return;\n            }\n            if (col != from) {\n                var value = tokens[idx].value.substring(from - col);\n                if (value.length > (to - from))\n                    value = value.substring(0, to - from);\n                renderTokens.push({\n                    type: tokens[idx].type,\n                    value: value\n                });\n                col = from + value.length;\n                idx += 1;\n            }\n            while (col < to && idx < tokens.length) {\n                var value = tokens[idx].value;\n                if (value.length + col > to) {\n                    renderTokens.push({\n                        type: tokens[idx].type,\n                        value: value.substring(0, to - col)\n                    });\n                }\n                else\n                    renderTokens.push(tokens[idx]);\n                col += value.length;\n                idx += 1;\n            }\n        }\n        var tokens = session.getTokens(row);\n        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {\n            if (placeholder != null) {\n                renderTokens.push({\n                    type: \"fold\",\n                    value: placeholder\n                });\n            }\n            else {\n                if (isNewRow)\n                    tokens = session.getTokens(row);\n                if (tokens.length)\n                    addTokens(tokens, lastColumn, column);\n            }\n        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n        return renderTokens;\n    };\n    Text.prototype.$useLineGroups = function () {\n        return this.session.getUseWrapMode();\n    };\n    return Text;\n}());\nText.prototype.EOF_CHAR = \"\\xB6\";\nText.prototype.EOL_CHAR_LF = \"\\xAC\";\nText.prototype.EOL_CHAR_CRLF = \"\\xa4\";\nText.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;\nText.prototype.TAB_CHAR = \"\\u2014\"; //\"\\u21E5\";\nText.prototype.SPACE_CHAR = \"\\xB7\";\nText.prototype.$padding = 0;\nText.prototype.MAX_LINE_LENGTH = 10000;\nText.prototype.showInvisibles = false;\nText.prototype.showSpaces = false;\nText.prototype.showTabs = false;\nText.prototype.showEOL = false;\nText.prototype.displayIndentGuides = true;\nText.prototype.$highlightIndentGuides = true;\nText.prototype.$tabStrings = [];\nText.prototype.destroy = {};\nText.prototype.onChangeTabSize = Text.prototype.$computeTabString;\noop.implement(Text.prototype, EventEmitter);\nexports.Text = Text;\n\n});\n\nace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar Cursor = /** @class */ (function () {\n    function Cursor(parentEl) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_layer ace_cursor-layer\";\n        parentEl.appendChild(this.element);\n        this.isVisible = false;\n        this.isBlinking = true;\n        this.blinkInterval = 1000;\n        this.smoothBlinking = false;\n        this.cursors = [];\n        this.cursor = this.addCursor();\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.$updateCursors = this.$updateOpacity.bind(this);\n    }\n    Cursor.prototype.$updateOpacity = function (val) {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--;)\n            dom.setStyle(cursors[i].style, \"opacity\", val ? \"\" : \"0\");\n    };\n    Cursor.prototype.$startCssAnimation = function () {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--;)\n            cursors[i].style.animationDuration = this.blinkInterval + \"ms\";\n        this.$isAnimating = true;\n        setTimeout(function () {\n            if (this.$isAnimating) {\n                dom.addCssClass(this.element, \"ace_animate-blinking\");\n            }\n        }.bind(this));\n    };\n    Cursor.prototype.$stopCssAnimation = function () {\n        this.$isAnimating = false;\n        dom.removeCssClass(this.element, \"ace_animate-blinking\");\n    };\n    Cursor.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n    };\n    Cursor.prototype.setSession = function (session) {\n        this.session = session;\n    };\n    Cursor.prototype.setBlinking = function (blinking) {\n        if (blinking != this.isBlinking) {\n            this.isBlinking = blinking;\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.setBlinkInterval = function (blinkInterval) {\n        if (blinkInterval != this.blinkInterval) {\n            this.blinkInterval = blinkInterval;\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.setSmoothBlinking = function (smoothBlinking) {\n        if (smoothBlinking != this.smoothBlinking) {\n            this.smoothBlinking = smoothBlinking;\n            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n            this.$updateCursors(true);\n            this.restartTimer();\n        }\n    };\n    Cursor.prototype.addCursor = function () {\n        var el = dom.createElement(\"div\");\n        el.className = \"ace_cursor\";\n        this.element.appendChild(el);\n        this.cursors.push(el);\n        return el;\n    };\n    Cursor.prototype.removeCursor = function () {\n        if (this.cursors.length > 1) {\n            var el = this.cursors.pop();\n            el.parentNode.removeChild(el);\n            return el;\n        }\n    };\n    Cursor.prototype.hideCursor = function () {\n        this.isVisible = false;\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n    Cursor.prototype.showCursor = function () {\n        this.isVisible = true;\n        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n    Cursor.prototype.restartTimer = function () {\n        var update = this.$updateCursors;\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n        this.$stopCssAnimation();\n        if (this.smoothBlinking) {\n            this.$isSmoothBlinking = false;\n            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n        }\n        update(true);\n        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {\n            this.$stopCssAnimation();\n            return;\n        }\n        if (this.smoothBlinking) {\n            this.$isSmoothBlinking = true;\n            setTimeout(function () {\n                if (this.$isSmoothBlinking) {\n                    dom.addCssClass(this.element, \"ace_smooth-blinking\");\n                }\n            }.bind(this));\n        }\n        if (dom.HAS_CSS_ANIMATION) {\n            this.$startCssAnimation();\n        }\n        else {\n            var blink = /**@this{Cursor}*/ function () {\n                this.timeoutId = setTimeout(function () {\n                    update(false);\n                }, 0.6 * this.blinkInterval);\n            }.bind(this);\n            this.intervalId = setInterval(function () {\n                update(true);\n                blink();\n            }, this.blinkInterval);\n            blink();\n        }\n    };\n    Cursor.prototype.getPixelPosition = function (position, onScreen) {\n        if (!this.config || !this.session)\n            return { left: 0, top: 0 };\n        if (!position)\n            position = this.session.selection.getCursor();\n        var pos = this.session.documentToScreenPosition(position);\n        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : pos.column * this.config.characterWidth);\n        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n            this.config.lineHeight;\n        return { left: cursorLeft, top: cursorTop };\n    };\n    Cursor.prototype.isCursorInView = function (pixelPos, config) {\n        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;\n    };\n    Cursor.prototype.update = function (config) {\n        this.config = config;\n        var selections = this.session.$selectionMarkers;\n        var i = 0, cursorIndex = 0;\n        if (selections === undefined || selections.length === 0) {\n            selections = [{ cursor: null }];\n        }\n        for (var i = 0, n = selections.length; i < n; i++) {\n            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n            if ((pixelPos.top > config.height + config.offset ||\n                pixelPos.top < 0) && i > 1) {\n                continue;\n            }\n            var element = this.cursors[cursorIndex++] || this.addCursor();\n            var style = element.style;\n            if (!this.drawCursor) {\n                if (!this.isCursorInView(pixelPos, config)) {\n                    dom.setStyle(style, \"display\", \"none\");\n                }\n                else {\n                    dom.setStyle(style, \"display\", \"block\");\n                    dom.translate(element, pixelPos.left, pixelPos.top);\n                    dom.setStyle(style, \"width\", Math.round(config.characterWidth) + \"px\");\n                    dom.setStyle(style, \"height\", config.lineHeight + \"px\");\n                }\n            }\n            else {\n                this.drawCursor(element, pixelPos, config, selections[i], this.session);\n            }\n        }\n        while (this.cursors.length > cursorIndex)\n            this.removeCursor();\n        var overwrite = this.session.getOverwrite();\n        this.$setOverwrite(overwrite);\n        this.$pixelPos = pixelPos;\n        this.restartTimer();\n    };\n    Cursor.prototype.$setOverwrite = function (overwrite) {\n        if (overwrite != this.overwrite) {\n            this.overwrite = overwrite;\n            if (overwrite)\n                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n            else\n                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n        }\n    };\n    Cursor.prototype.destroy = function () {\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n    };\n    return Cursor;\n}());\nCursor.prototype.$padding = 0;\nCursor.prototype.drawCursor = null;\nexports.Cursor = Cursor;\n\n});\n\nace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar MAX_SCROLL_H = 0x8000;\nvar Scrollbar = /** @class */ (function () {\n    function Scrollbar(parent, classSuffix) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_scrollbar ace_scrollbar\" + classSuffix;\n        this.inner = dom.createElement(\"div\");\n        this.inner.className = \"ace_scrollbar-inner\";\n        this.inner.textContent = \"\\xa0\";\n        this.element.appendChild(this.inner);\n        parent.appendChild(this.element);\n        this.setVisible(false);\n        this.skipEvent = false;\n        event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n        event.addListener(this.element, \"mousedown\", event.preventDefault);\n    }\n    Scrollbar.prototype.setVisible = function (isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n    return Scrollbar;\n}());\noop.implement(Scrollbar.prototype, EventEmitter);\nvar VScrollBar = /** @class */ (function (_super) {\n    __extends(VScrollBar, _super);\n    function VScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-v') || this;\n        _this.scrollTop = 0;\n        _this.scrollHeight = 0;\n        renderer.$scrollbarWidth =\n            _this.width = dom.scrollbarWidth(parent.ownerDocument);\n        _this.inner.style.width =\n            _this.element.style.width = (_this.width || 15) + 5 + \"px\";\n        _this.$minWidth = 0;\n        return _this;\n    }\n    VScrollBar.prototype.onScroll = function () {\n        if (!this.skipEvent) {\n            this.scrollTop = this.element.scrollTop;\n            if (this.coeff != 1) {\n                var h = this.element.clientHeight / this.scrollHeight;\n                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);\n            }\n            this._emit(\"scroll\", { data: this.scrollTop });\n        }\n        this.skipEvent = false;\n    };\n    VScrollBar.prototype.getWidth = function () {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    VScrollBar.prototype.setHeight = function (height) {\n        this.element.style.height = height + \"px\";\n    };\n    VScrollBar.prototype.setScrollHeight = function (height) {\n        this.scrollHeight = height;\n        if (height > MAX_SCROLL_H) {\n            this.coeff = MAX_SCROLL_H / height;\n            height = MAX_SCROLL_H;\n        }\n        else if (this.coeff != 1) {\n            this.coeff = 1;\n        }\n        this.inner.style.height = height + \"px\";\n    };\n    VScrollBar.prototype.setScrollTop = function (scrollTop) {\n        if (this.scrollTop != scrollTop) {\n            this.skipEvent = true;\n            this.scrollTop = scrollTop;\n            this.element.scrollTop = scrollTop * this.coeff;\n        }\n    };\n    return VScrollBar;\n}(Scrollbar));\nVScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;\nvar HScrollBar = /** @class */ (function (_super) {\n    __extends(HScrollBar, _super);\n    function HScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-h') || this;\n        _this.scrollLeft = 0;\n        _this.height = renderer.$scrollbarWidth;\n        _this.inner.style.height =\n            _this.element.style.height = (_this.height || 15) + 5 + \"px\";\n        return _this;\n    }\n    HScrollBar.prototype.onScroll = function () {\n        if (!this.skipEvent) {\n            this.scrollLeft = this.element.scrollLeft;\n            this._emit(\"scroll\", { data: this.scrollLeft });\n        }\n        this.skipEvent = false;\n    };\n    HScrollBar.prototype.getHeight = function () {\n        return this.isVisible ? this.height : 0;\n    };\n    HScrollBar.prototype.setWidth = function (width) {\n        this.element.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setInnerWidth = function (width) {\n        this.inner.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setScrollWidth = function (width) {\n        this.inner.style.width = width + \"px\";\n    };\n    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {\n        if (this.scrollLeft != scrollLeft) {\n            this.skipEvent = true;\n            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n        }\n    };\n    return HScrollBar;\n}(Scrollbar));\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n\n});\n\nace.define(\"ace/scrollbar_custom\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\ndom.importCssString(\".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\\n  position: absolute;\\n  background: rgba(128, 128, 128, 0.6);\\n  -moz-box-sizing: border-box;\\n  box-sizing: border-box;\\n  border: 1px solid #bbb;\\n  border-radius: 2px;\\n  z-index: 8;\\n}\\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\\n  position: absolute;\\n  z-index: 6;\\n  background: none;\\n  overflow: hidden!important;\\n}\\n.ace_editor>.ace_sb-v {\\n  z-index: 6;\\n  right: 0;\\n  top: 0;\\n  width: 12px;\\n}\\n.ace_editor>.ace_sb-v div {\\n  z-index: 8;\\n  right: 0;\\n  width: 100%;\\n}\\n.ace_editor>.ace_sb-h {\\n  bottom: 0;\\n  left: 0;\\n  height: 12px;\\n}\\n.ace_editor>.ace_sb-h div {\\n  bottom: 0;\\n  height: 100%;\\n}\\n.ace_editor>.ace_sb_grabbed {\\n  z-index: 8;\\n  background: #000;\\n}\", \"ace_scrollbar.css\", false);\nvar ScrollBar = /** @class */ (function () {\n    function ScrollBar(parent, classSuffix) {\n        this.element = dom.createElement(\"div\");\n        this.element.className = \"ace_sb\" + classSuffix;\n        this.inner = dom.createElement(\"div\");\n        this.inner.className = \"\";\n        this.element.appendChild(this.inner);\n        this.VScrollWidth = 12;\n        this.HScrollHeight = 12;\n        parent.appendChild(this.element);\n        this.setVisible(false);\n        this.skipEvent = false;\n        event.addMultiMouseDownListener(this.element, [500, 300, 300], this, \"onMouseDown\");\n    }\n    ScrollBar.prototype.setVisible = function (isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n    return ScrollBar;\n}());\noop.implement(ScrollBar.prototype, EventEmitter);\nvar VScrollBar = /** @class */ (function (_super) {\n    __extends(VScrollBar, _super);\n    function VScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-v') || this;\n        _this.scrollTop = 0;\n        _this.scrollHeight = 0;\n        _this.parent = parent;\n        _this.width = _this.VScrollWidth;\n        _this.renderer = renderer;\n        _this.inner.style.width = _this.element.style.width = (_this.width || 15) + \"px\";\n        _this.$minWidth = 0;\n        return _this;\n    }\n    VScrollBar.prototype.onMouseDown = function (eType, e) {\n        if (eType !== \"mousedown\")\n            return;\n        if (event.getButton(e) !== 0 || e.detail === 2) {\n            return;\n        }\n        if (e.target === this.inner) {\n            var self = this;\n            var mousePageY = e.clientY;\n            var onMouseMove = function (e) {\n                mousePageY = e.clientY;\n            };\n            var onMouseUp = function () {\n                clearInterval(timerId);\n            };\n            var startY = e.clientY;\n            var startTop = this.thumbTop;\n            var onScrollInterval = function () {\n                if (mousePageY === undefined)\n                    return;\n                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);\n                if (scrollTop === self.scrollTop)\n                    return;\n                self._emit(\"scroll\", { data: scrollTop });\n            };\n            event.capture(this.inner, onMouseMove, onMouseUp);\n            var timerId = setInterval(onScrollInterval, 20);\n            return event.preventDefault(e);\n        }\n        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;\n        this._emit(\"scroll\", { data: this.scrollTopFromThumbTop(top) });\n        return event.preventDefault(e);\n    };\n    VScrollBar.prototype.getHeight = function () {\n        return this.height;\n    };\n    VScrollBar.prototype.scrollTopFromThumbTop = function (thumbTop) {\n        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);\n        scrollTop = scrollTop >> 0;\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        else if (scrollTop > this.pageHeight - this.viewHeight) {\n            scrollTop = this.pageHeight - this.viewHeight;\n        }\n        return scrollTop;\n    };\n    VScrollBar.prototype.getWidth = function () {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    VScrollBar.prototype.setHeight = function (height) {\n        this.height = Math.max(0, height);\n        this.slideHeight = this.height;\n        this.viewHeight = this.height;\n        this.setScrollHeight(this.pageHeight, true);\n    };\n    VScrollBar.prototype.setScrollHeight = function (height, force) {\n        if (this.pageHeight === height && !force)\n            return;\n        this.pageHeight = height;\n        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;\n        if (this.thumbHeight > this.slideHeight)\n            this.thumbHeight = this.slideHeight;\n        if (this.thumbHeight < 15)\n            this.thumbHeight = 15;\n        this.inner.style.height = this.thumbHeight + \"px\";\n        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {\n            this.scrollTop = (this.pageHeight - this.viewHeight);\n            if (this.scrollTop < 0)\n                this.scrollTop = 0;\n            this._emit(\"scroll\", { data: this.scrollTop });\n        }\n    };\n    VScrollBar.prototype.setScrollTop = function (scrollTop) {\n        this.scrollTop = scrollTop;\n        if (scrollTop < 0)\n            scrollTop = 0;\n        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);\n        this.inner.style.top = this.thumbTop + \"px\";\n    };\n    return VScrollBar;\n}(ScrollBar));\nVScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;\nvar HScrollBar = /** @class */ (function (_super) {\n    __extends(HScrollBar, _super);\n    function HScrollBar(parent, renderer) {\n        var _this = _super.call(this, parent, '-h') || this;\n        _this.scrollLeft = 0;\n        _this.scrollWidth = 0;\n        _this.height = _this.HScrollHeight;\n        _this.inner.style.height = _this.element.style.height = (_this.height || 12) + \"px\";\n        _this.renderer = renderer;\n        return _this;\n    }\n    HScrollBar.prototype.onMouseDown = function (eType, e) {\n        if (eType !== \"mousedown\")\n            return;\n        if (event.getButton(e) !== 0 || e.detail === 2) {\n            return;\n        }\n        if (e.target === this.inner) {\n            var self = this;\n            var mousePageX = e.clientX;\n            var onMouseMove = function (e) {\n                mousePageX = e.clientX;\n            };\n            var onMouseUp = function () {\n                clearInterval(timerId);\n            };\n            var startX = e.clientX;\n            var startLeft = this.thumbLeft;\n            var onScrollInterval = function () {\n                if (mousePageX === undefined)\n                    return;\n                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);\n                if (scrollLeft === self.scrollLeft)\n                    return;\n                self._emit(\"scroll\", { data: scrollLeft });\n            };\n            event.capture(this.inner, onMouseMove, onMouseUp);\n            var timerId = setInterval(onScrollInterval, 20);\n            return event.preventDefault(e);\n        }\n        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;\n        this._emit(\"scroll\", { data: this.scrollLeftFromThumbLeft(left) });\n        return event.preventDefault(e);\n    };\n    HScrollBar.prototype.getHeight = function () {\n        return this.isVisible ? this.height : 0;\n    };\n    HScrollBar.prototype.scrollLeftFromThumbLeft = function (thumbLeft) {\n        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);\n        scrollLeft = scrollLeft >> 0;\n        if (scrollLeft < 0) {\n            scrollLeft = 0;\n        }\n        else if (scrollLeft > this.pageWidth - this.viewWidth) {\n            scrollLeft = this.pageWidth - this.viewWidth;\n        }\n        return scrollLeft;\n    };\n    HScrollBar.prototype.setWidth = function (width) {\n        this.width = Math.max(0, width);\n        this.element.style.width = this.width + \"px\";\n        this.slideWidth = this.width;\n        this.viewWidth = this.width;\n        this.setScrollWidth(this.pageWidth, true);\n    };\n    HScrollBar.prototype.setScrollWidth = function (width, force) {\n        if (this.pageWidth === width && !force)\n            return;\n        this.pageWidth = width;\n        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;\n        if (this.thumbWidth > this.slideWidth)\n            this.thumbWidth = this.slideWidth;\n        if (this.thumbWidth < 15)\n            this.thumbWidth = 15;\n        this.inner.style.width = this.thumbWidth + \"px\";\n        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {\n            this.scrollLeft = (this.pageWidth - this.viewWidth);\n            if (this.scrollLeft < 0)\n                this.scrollLeft = 0;\n            this._emit(\"scroll\", { data: this.scrollLeft });\n        }\n    };\n    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {\n        this.scrollLeft = scrollLeft;\n        if (scrollLeft < 0)\n            scrollLeft = 0;\n        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);\n        this.inner.style.left = (this.thumbLeft) + \"px\";\n    };\n    return HScrollBar;\n}(ScrollBar));\nHScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n\n});\n\nace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(require, exports, module){\"use strict\";\nvar event = require(\"./lib/event\");\nvar RenderLoop = /** @class */ (function () {\n    function RenderLoop(onRender, win) {\n        this.onRender = onRender;\n        this.pending = false;\n        this.changes = 0;\n        this.$recursionLimit = 2;\n        this.window = win || window;\n        var _self = this;\n        this._flush = function (ts) {\n            _self.pending = false;\n            var changes = _self.changes;\n            if (changes) {\n                event.blockIdle(100);\n                _self.changes = 0;\n                _self.onRender(changes);\n            }\n            if (_self.changes) {\n                if (_self.$recursionLimit-- < 0)\n                    return;\n                _self.schedule();\n            }\n            else {\n                _self.$recursionLimit = 2;\n            }\n        };\n    }\n    RenderLoop.prototype.schedule = function (change) {\n        this.changes = this.changes | change;\n        if (this.changes && !this.pending) {\n            event.nextFrame(this._flush);\n            this.pending = true;\n        }\n    };\n    RenderLoop.prototype.clear = function (change) {\n        var changes = this.changes;\n        this.changes = 0;\n        return changes;\n    };\n    return RenderLoop;\n}());\nexports.RenderLoop = RenderLoop;\n\n});\n\nace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(require, exports, module){var oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar CHAR_COUNT = 512;\nvar USE_OBSERVER = typeof ResizeObserver == \"function\";\nvar L = 200;\nvar FontMetrics = /** @class */ (function () {\n    function FontMetrics(parentEl) {\n        this.el = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.el.style, true);\n        this.$main = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.$main.style);\n        this.$measureNode = dom.createElement(\"div\");\n        this.$setMeasureNodeStyles(this.$measureNode.style);\n        this.el.appendChild(this.$main);\n        this.el.appendChild(this.$measureNode);\n        parentEl.appendChild(this.el);\n        this.$measureNode.textContent = lang.stringRepeat(\"X\", CHAR_COUNT);\n        this.$characterSize = { width: 0, height: 0 };\n        if (USE_OBSERVER)\n            this.$addObserver();\n        else\n            this.checkForSizeChanges();\n    }\n    FontMetrics.prototype.$setMeasureNodeStyles = function (style, isRoot) {\n        style.width = style.height = \"auto\";\n        style.left = style.top = \"0px\";\n        style.visibility = \"hidden\";\n        style.position = \"absolute\";\n        style.whiteSpace = \"pre\";\n        if (useragent.isIE < 8) {\n            style[\"font-family\"] = \"inherit\";\n        }\n        else {\n            style.font = \"inherit\";\n        }\n        style.overflow = isRoot ? \"hidden\" : \"visible\";\n    };\n    FontMetrics.prototype.checkForSizeChanges = function (size) {\n        if (size === undefined)\n            size = this.$measureSizes();\n        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n            this.$measureNode.style.fontWeight = \"bold\";\n            var boldSize = this.$measureSizes();\n            this.$measureNode.style.fontWeight = \"\";\n            this.$characterSize = size;\n            this.charSizes = Object.create(null);\n            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n            this._emit(\"changeCharacterSize\", { data: size });\n        }\n    };\n    FontMetrics.prototype.$addObserver = function () {\n        var self = this;\n        this.$observer = new window.ResizeObserver(function (e) {\n            self.checkForSizeChanges();\n        });\n        this.$observer.observe(this.$measureNode);\n    };\n    FontMetrics.prototype.$pollSizeChanges = function () {\n        if (this.$pollSizeChangesTimer || this.$observer)\n            return this.$pollSizeChangesTimer;\n        var self = this;\n        return this.$pollSizeChangesTimer = event.onIdle(function cb() {\n            self.checkForSizeChanges();\n            event.onIdle(cb, 500);\n        }, 500);\n    };\n    FontMetrics.prototype.setPolling = function (val) {\n        if (val) {\n            this.$pollSizeChanges();\n        }\n        else if (this.$pollSizeChangesTimer) {\n            clearInterval(this.$pollSizeChangesTimer);\n            this.$pollSizeChangesTimer = 0;\n        }\n    };\n    FontMetrics.prototype.$measureSizes = function (node) {\n        var size = {\n            height: (node || this.$measureNode).clientHeight,\n            width: (node || this.$measureNode).clientWidth / CHAR_COUNT\n        };\n        if (size.width === 0 || size.height === 0)\n            return null;\n        return size;\n    };\n    FontMetrics.prototype.$measureCharWidth = function (ch) {\n        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);\n        var rect = this.$main.getBoundingClientRect();\n        return rect.width / CHAR_COUNT;\n    };\n    FontMetrics.prototype.getCharacterWidth = function (ch) {\n        var w = this.charSizes[ch];\n        if (w === undefined) {\n            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n        }\n        return w;\n    };\n    FontMetrics.prototype.destroy = function () {\n        clearInterval(this.$pollSizeChangesTimer);\n        if (this.$observer)\n            this.$observer.disconnect();\n        if (this.el && this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    };\n    FontMetrics.prototype.$getZoom = function (element) {\n        if (!element || !element.parentElement)\n            return 1;\n        return (Number(window.getComputedStyle(element)[\"zoom\"]) || 1) * this.$getZoom(element.parentElement);\n    };\n    FontMetrics.prototype.$initTransformMeasureNodes = function () {\n        var t = function (t, l) {\n            return [\"div\", {\n                    style: \"position: absolute;top:\" + t + \"px;left:\" + l + \"px;\"\n                }];\n        };\n        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);\n    };\n    FontMetrics.prototype.transformCoordinates = function (clientPos, elPos) {\n        if (clientPos) {\n            var zoom = this.$getZoom(this.el);\n            clientPos = mul(1 / zoom, clientPos);\n        }\n        function solve(l1, l2, r) {\n            var det = l1[1] * l2[0] - l1[0] * l2[1];\n            return [\n                (-l2[1] * r[0] + l2[0] * r[1]) / det,\n                (+l1[1] * r[0] - l1[0] * r[1]) / det\n            ];\n        }\n        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }\n        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }\n        function mul(a, b) { return [a * b[0], a * b[1]]; }\n        if (!this.els)\n            this.$initTransformMeasureNodes();\n        function p(el) {\n            var r = el.getBoundingClientRect();\n            return [r.left, r.top];\n        }\n        var a = p(this.els[0]);\n        var b = p(this.els[1]);\n        var c = p(this.els[2]);\n        var d = p(this.els[3]);\n        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));\n        var m1 = mul(1 + h[0], sub(b, a));\n        var m2 = mul(1 + h[1], sub(c, a));\n        if (elPos) {\n            var x = elPos;\n            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;\n            var ut = add(mul(x[0], m1), mul(x[1], m2));\n            return add(mul(1 / k / L, ut), a);\n        }\n        var u = sub(clientPos, a);\n        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);\n        return mul(L, f);\n    };\n    return FontMetrics;\n}());\nFontMetrics.prototype.$characterSize = { width: 0, height: 0 };\noop.implement(FontMetrics.prototype, EventEmitter);\nexports.FontMetrics = FontMetrics;\n\n});\n\nace.define(\"ace/css/editor-css\",[\"require\",\"exports\",\"module\"], function(require, exports, module){/*\nstyles = []\nfor (var i = 1; i < 16; i++) {\n    styles.push(\".ace_br\" + i + \"{\" + (\n        [\"top-left\", \"top-right\", \"bottom-right\", \"bottom-left\"]\n    ).map(function(x, j) {\n        return i & (1<<j) ? \"border-\" + x + \"-radius: 3px;\" : \"\"\n    }).filter(Boolean).join(\" \") + \"}\")\n}\nstyles.join(\"\\\\n\")\n*/\nmodule.exports = \"\\n.ace_br1 {border-top-left-radius    : 3px;}\\n.ace_br2 {border-top-right-radius   : 3px;}\\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\\n.ace_br4 {border-bottom-right-radius: 3px;}\\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\\n.ace_br8 {border-bottom-left-radius : 3px;}\\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\\n\\n\\n.ace_editor {\\n    position: relative;\\n    overflow: hidden;\\n    padding: 0;\\n    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;\\n    direction: ltr;\\n    text-align: left;\\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n    forced-color-adjust: none;\\n}\\n\\n.ace_scroller {\\n    position: absolute;\\n    overflow: hidden;\\n    top: 0;\\n    bottom: 0;\\n    background-color: inherit;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    cursor: text;\\n}\\n\\n.ace_content {\\n    position: absolute;\\n    box-sizing: border-box;\\n    min-width: 100%;\\n    contain: style size layout;\\n    font-variant-ligatures: no-common-ligatures;\\n}\\n\\n.ace_keyboard-focus:focus {\\n    box-shadow: inset 0 0 0 2px #5E9ED6;\\n    outline: none;\\n}\\n\\n.ace_dragging .ace_scroller:before{\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    content: '';\\n    background: rgba(250, 250, 250, 0.01);\\n    z-index: 1000;\\n}\\n.ace_dragging.ace_dark .ace_scroller:before{\\n    background: rgba(0, 0, 0, 0.01);\\n}\\n\\n.ace_gutter {\\n    position: absolute;\\n    overflow : hidden;\\n    width: auto;\\n    top: 0;\\n    bottom: 0;\\n    left: 0;\\n    cursor: default;\\n    z-index: 4;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    contain: style size layout;\\n}\\n\\n.ace_gutter-active-line {\\n    position: absolute;\\n    left: 0;\\n    right: 0;\\n}\\n\\n.ace_scroller.ace_scroll-left:after {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\n    pointer-events: none;\\n}\\n\\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    padding-left: 19px;\\n    padding-right: 6px;\\n    background-repeat: no-repeat;\\n}\\n\\n.ace_gutter-cell_svg-icons .ace_gutter_annotation {\\n    margin-left: -14px;\\n    float: left;\\n}\\n\\n.ace_gutter-cell .ace_gutter_annotation {\\n    margin-left: -19px;\\n    float: left;\\n}\\n\\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n\\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n\\n.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\n    background-repeat: no-repeat;\\n    background-position: 2px center;\\n}\\n\\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\n}\\n\\n.ace_icon_svg.ace_error {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_security {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_warning {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==\\\");\\n    background-color: darkorange;\\n}\\n.ace_icon_svg.ace_info {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==\\\");\\n    background-color: royalblue;\\n}\\n.ace_icon_svg.ace_hint {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==\\\");\\n    background-color: silver;\\n}\\n\\n.ace_icon_svg.ace_error_fold {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_security_fold {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=\\\");\\n    background-color: crimson;\\n}\\n.ace_icon_svg.ace_warning_fold {\\n    -webkit-mask-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=\\\");\\n    background-color: darkorange;\\n}\\n\\n.ace_scrollbar {\\n    contain: strict;\\n    position: absolute;\\n    right: 0;\\n    bottom: 0;\\n    z-index: 6;\\n}\\n\\n.ace_scrollbar-inner {\\n    position: absolute;\\n    cursor: text;\\n    left: 0;\\n    top: 0;\\n}\\n\\n.ace_scrollbar-v{\\n    overflow-x: hidden;\\n    overflow-y: scroll;\\n    top: 0;\\n}\\n\\n.ace_scrollbar-h {\\n    overflow-x: scroll;\\n    overflow-y: hidden;\\n    left: 0;\\n}\\n\\n.ace_print-margin {\\n    position: absolute;\\n    height: 100%;\\n}\\n\\n.ace_text-input {\\n    position: absolute;\\n    z-index: 0;\\n    width: 0.5em;\\n    height: 1em;\\n    opacity: 0;\\n    background: transparent;\\n    -moz-appearance: none;\\n    appearance: none;\\n    border: none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    font: inherit;\\n    padding: 0 1px;\\n    margin: 0 -1px;\\n    contain: strict;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\\n    white-space: pre!important;\\n}\\n.ace_text-input.ace_composition {\\n    background: transparent;\\n    color: inherit;\\n    z-index: 1000;\\n    opacity: 1;\\n}\\n.ace_composition_placeholder { color: transparent }\\n.ace_composition_marker { \\n    border-bottom: 1px solid;\\n    position: absolute;\\n    border-radius: 0;\\n    margin-top: 1px;\\n}\\n\\n[ace_nocontext=true] {\\n    transform: none!important;\\n    filter: none!important;\\n    clip-path: none!important;\\n    mask : none!important;\\n    contain: none!important;\\n    perspective: none!important;\\n    mix-blend-mode: initial!important;\\n    z-index: auto;\\n}\\n\\n.ace_layer {\\n    z-index: 1;\\n    position: absolute;\\n    overflow: hidden;\\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\\n    word-wrap: normal;\\n    white-space: pre;\\n    height: 100%;\\n    width: 100%;\\n    box-sizing: border-box;\\n    /* setting pointer-events: auto; on node under the mouse, which changes\\n        during scroll, will break mouse wheel scrolling in Safari */\\n    pointer-events: none;\\n}\\n\\n.ace_gutter-layer {\\n    position: relative;\\n    width: auto;\\n    text-align: right;\\n    pointer-events: auto;\\n    height: 1000000px;\\n    contain: style size layout;\\n}\\n\\n.ace_text-layer {\\n    font: inherit !important;\\n    position: absolute;\\n    height: 1000000px;\\n    width: 1000000px;\\n    contain: style size layout;\\n}\\n\\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\\n    contain: style size layout;\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n}\\n\\n.ace_hidpi .ace_text-layer,\\n.ace_hidpi .ace_gutter-layer,\\n.ace_hidpi .ace_content,\\n.ace_hidpi .ace_gutter {\\n    contain: strict;\\n}\\n.ace_hidpi .ace_text-layer > .ace_line, \\n.ace_hidpi .ace_text-layer > .ace_line_group {\\n    contain: strict;\\n}\\n\\n.ace_cjk {\\n    display: inline-block;\\n    text-align: center;\\n}\\n\\n.ace_cursor-layer {\\n    z-index: 4;\\n}\\n\\n.ace_cursor {\\n    z-index: 4;\\n    position: absolute;\\n    box-sizing: border-box;\\n    border-left: 2px solid;\\n    /* workaround for smooth cursor repaintng whole screen in chrome */\\n    transform: translatez(0);\\n}\\n\\n.ace_multiselect .ace_cursor {\\n    border-left-width: 1px;\\n}\\n\\n.ace_slim-cursors .ace_cursor {\\n    border-left-width: 1px;\\n}\\n\\n.ace_overwrite-cursors .ace_cursor {\\n    border-left-width: 0;\\n    border-bottom: 1px solid;\\n}\\n\\n.ace_hidden-cursors .ace_cursor {\\n    opacity: 0.2;\\n}\\n\\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\\n    opacity: 0;\\n}\\n\\n.ace_smooth-blinking .ace_cursor {\\n    transition: opacity 0.18s;\\n}\\n\\n.ace_animate-blinking .ace_cursor {\\n    animation-duration: 1000ms;\\n    animation-timing-function: step-end;\\n    animation-name: blink-ace-animate;\\n    animation-iteration-count: infinite;\\n}\\n\\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\\n    animation-duration: 1000ms;\\n    animation-timing-function: ease-in-out;\\n    animation-name: blink-ace-animate-smooth;\\n}\\n    \\n@keyframes blink-ace-animate {\\n    from, to { opacity: 1; }\\n    60% { opacity: 0; }\\n}\\n\\n@keyframes blink-ace-animate-smooth {\\n    from, to { opacity: 1; }\\n    45% { opacity: 1; }\\n    60% { opacity: 0; }\\n    85% { opacity: 0; }\\n}\\n\\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\n    position: absolute;\\n    z-index: 3;\\n}\\n\\n.ace_marker-layer .ace_selection {\\n    position: absolute;\\n    z-index: 5;\\n}\\n\\n.ace_marker-layer .ace_bracket {\\n    position: absolute;\\n    z-index: 6;\\n}\\n\\n.ace_marker-layer .ace_error_bracket {\\n    position: absolute;\\n    border-bottom: 1px solid #DE5555;\\n    border-radius: 0;\\n}\\n\\n.ace_marker-layer .ace_active-line {\\n    position: absolute;\\n    z-index: 2;\\n}\\n\\n.ace_marker-layer .ace_selected-word {\\n    position: absolute;\\n    z-index: 4;\\n    box-sizing: border-box;\\n}\\n\\n.ace_line .ace_fold {\\n    box-sizing: border-box;\\n\\n    display: inline-block;\\n    height: 11px;\\n    margin-top: -2px;\\n    vertical-align: middle;\\n\\n    background-image:\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\n    background-repeat: no-repeat, repeat-x;\\n    background-position: center center, top left;\\n    color: transparent;\\n\\n    border: 1px solid black;\\n    border-radius: 2px;\\n\\n    cursor: pointer;\\n    pointer-events: auto;\\n}\\n\\n.ace_dark .ace_fold {\\n}\\n\\n.ace_fold:hover{\\n    background-image:\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\n        url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\n}\\n\\n.ace_tooltip {\\n    background-color: #f5f5f5;\\n    border: 1px solid gray;\\n    border-radius: 1px;\\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\n    color: black;\\n    max-width: 100%;\\n    padding: 3px 4px;\\n    position: fixed;\\n    z-index: 999999;\\n    box-sizing: border-box;\\n    cursor: default;\\n    white-space: pre-wrap;\\n    word-wrap: break-word;\\n    line-height: normal;\\n    font-style: normal;\\n    font-weight: normal;\\n    letter-spacing: normal;\\n    pointer-events: none;\\n    overflow: auto;\\n    max-width: min(60em, 66vw);\\n    overscroll-behavior: contain;\\n}\\n.ace_tooltip pre {\\n    white-space: pre-wrap;\\n}\\n\\n.ace_tooltip.ace_dark {\\n    background-color: #636363;\\n    color: #fff;\\n}\\n\\n.ace_tooltip:focus {\\n    outline: 1px solid #5E9ED6;\\n}\\n\\n.ace_icon {\\n    display: inline-block;\\n    width: 18px;\\n    vertical-align: top;\\n}\\n\\n.ace_icon_svg {\\n    display: inline-block;\\n    width: 12px;\\n    vertical-align: top;\\n    -webkit-mask-repeat: no-repeat;\\n    -webkit-mask-size: 12px;\\n    -webkit-mask-position: center;\\n}\\n\\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\\n    padding-right: 13px;\\n}\\n\\n.ace_fold-widget {\\n    box-sizing: border-box;\\n\\n    margin: 0 -12px 0 1px;\\n    display: none;\\n    width: 11px;\\n    vertical-align: top;\\n\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\n    background-repeat: no-repeat;\\n    background-position: center;\\n\\n    border-radius: 3px;\\n    \\n    border: 1px solid transparent;\\n    cursor: pointer;\\n}\\n\\n.ace_folding-enabled .ace_fold-widget {\\n    display: inline-block;   \\n}\\n\\n.ace_fold-widget.ace_end {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\n}\\n\\n.ace_fold-widget.ace_closed {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\n}\\n\\n.ace_fold-widget:hover {\\n    border: 1px solid rgba(0, 0, 0, 0.3);\\n    background-color: rgba(255, 255, 255, 0.2);\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\n}\\n\\n.ace_fold-widget:active {\\n    border: 1px solid rgba(0, 0, 0, 0.4);\\n    background-color: rgba(0, 0, 0, 0.05);\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\n}\\n/**\\n * Dark version for fold widgets\\n */\\n.ace_dark .ace_fold-widget {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\n}\\n.ace_dark .ace_fold-widget.ace_end {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\n}\\n.ace_dark .ace_fold-widget.ace_closed {\\n    background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\n}\\n.ace_dark .ace_fold-widget:hover {\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\n    background-color: rgba(255, 255, 255, 0.1);\\n}\\n.ace_dark .ace_fold-widget:active {\\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\n}\\n\\n.ace_inline_button {\\n    border: 1px solid lightgray;\\n    display: inline-block;\\n    margin: -1px 8px;\\n    padding: 0 5px;\\n    pointer-events: auto;\\n    cursor: pointer;\\n}\\n.ace_inline_button:hover {\\n    border-color: gray;\\n    background: rgba(200,200,200,0.2);\\n    display: inline-block;\\n    pointer-events: auto;\\n}\\n\\n.ace_fold-widget.ace_invalid {\\n    background-color: #FFB4B4;\\n    border-color: #DE5555;\\n}\\n\\n.ace_fade-fold-widgets .ace_fold-widget {\\n    transition: opacity 0.4s ease 0.05s;\\n    opacity: 0;\\n}\\n\\n.ace_fade-fold-widgets:hover .ace_fold-widget {\\n    transition: opacity 0.05s ease 0.05s;\\n    opacity:1;\\n}\\n\\n.ace_underline {\\n    text-decoration: underline;\\n}\\n\\n.ace_bold {\\n    font-weight: bold;\\n}\\n\\n.ace_nobold .ace_bold {\\n    font-weight: normal;\\n}\\n\\n.ace_italic {\\n    font-style: italic;\\n}\\n\\n\\n.ace_error-marker {\\n    background-color: rgba(255, 0, 0,0.2);\\n    position: absolute;\\n    z-index: 9;\\n}\\n\\n.ace_highlight-marker {\\n    background-color: rgba(255, 255, 0,0.2);\\n    position: absolute;\\n    z-index: 8;\\n}\\n\\n.ace_mobile-menu {\\n    position: absolute;\\n    line-height: 1.5;\\n    border-radius: 4px;\\n    -ms-user-select: none;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    user-select: none;\\n    background: white;\\n    box-shadow: 1px 3px 2px grey;\\n    border: 1px solid #dcdcdc;\\n    color: black;\\n}\\n.ace_dark > .ace_mobile-menu {\\n    background: #333;\\n    color: #ccc;\\n    box-shadow: 1px 3px 2px grey;\\n    border: 1px solid #444;\\n\\n}\\n.ace_mobile-button {\\n    padding: 2px;\\n    cursor: pointer;\\n    overflow: hidden;\\n}\\n.ace_mobile-button:hover {\\n    background-color: #eee;\\n    opacity:1;\\n}\\n.ace_mobile-button:active {\\n    background-color: #ddd;\\n}\\n\\n.ace_placeholder {\\n    position: relative;\\n    font-family: arial;\\n    transform: scale(0.9);\\n    transform-origin: left;\\n    white-space: pre;\\n    opacity: 0.7;\\n    margin: 0 10px;\\n    z-index: 1;\\n}\\n\\n.ace_ghost_text {\\n    opacity: 0.5;\\n    font-style: italic;\\n}\\n\\n.ace_ghost_text_container > div {\\n    white-space: pre;\\n}\\n\\n.ghost_text_line_wrapped::after {\\n    content: \\\"\\u21A9\\\";\\n    position: absolute;\\n}\\n\\n.ace_lineWidgetContainer.ace_ghost_text {\\n    margin: 0px 4px\\n}\\n\\n.ace_screenreader-only {\\n    position:absolute;\\n    left:-10000px;\\n    top:auto;\\n    width:1px;\\n    height:1px;\\n    overflow:hidden;\\n}\\n\\n.ace_hidden_token {\\n    display: none;\\n}\";\n\n});\n\nace.define(\"ace/layer/decorators\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Decorator = /** @class */ (function () {\n    function Decorator(parent, renderer) {\n        this.canvas = dom.createElement(\"canvas\");\n        this.renderer = renderer;\n        this.pixelRatio = 1;\n        this.maxHeight = renderer.layerConfig.maxHeight;\n        this.lineHeight = renderer.layerConfig.lineHeight;\n        this.canvasHeight = parent.parent.scrollHeight;\n        this.heightRatio = this.canvasHeight / this.maxHeight;\n        this.canvasWidth = parent.width;\n        this.minDecorationHeight = (2 * this.pixelRatio) | 0;\n        this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;\n        this.canvas.width = this.canvasWidth;\n        this.canvas.height = this.canvasHeight;\n        this.canvas.style.top = 0 + \"px\";\n        this.canvas.style.right = 0 + \"px\";\n        this.canvas.style.zIndex = 7 + \"px\";\n        this.canvas.style.position = \"absolute\";\n        this.colors = {};\n        this.colors.dark = {\n            \"error\": \"rgba(255, 18, 18, 1)\",\n            \"warning\": \"rgba(18, 136, 18, 1)\",\n            \"info\": \"rgba(18, 18, 136, 1)\"\n        };\n        this.colors.light = {\n            \"error\": \"rgb(255,51,51)\",\n            \"warning\": \"rgb(32,133,72)\",\n            \"info\": \"rgb(35,68,138)\"\n        };\n        parent.element.appendChild(this.canvas);\n    }\n    Decorator.prototype.$updateDecorators = function (config) {\n        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;\n        if (config) {\n            this.maxHeight = config.maxHeight;\n            this.lineHeight = config.lineHeight;\n            this.canvasHeight = config.height;\n            var allLineHeight = (config.lastRow + 1) * this.lineHeight;\n            if (allLineHeight < this.canvasHeight) {\n                this.heightRatio = 1;\n            }\n            else {\n                this.heightRatio = this.canvasHeight / this.maxHeight;\n            }\n        }\n        var ctx = this.canvas.getContext(\"2d\");\n        function compare(a, b) {\n            if (a.priority < b.priority)\n                return -1;\n            if (a.priority > b.priority)\n                return 1;\n            return 0;\n        }\n        var annotations = this.renderer.session.$annotations;\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (annotations) {\n            var priorities = {\n                \"info\": 1,\n                \"warning\": 2,\n                \"error\": 3\n            };\n            annotations.forEach(function (item) {\n                item.priority = priorities[item.type] || null;\n            });\n            annotations = annotations.sort(compare);\n            var foldData = this.renderer.session.$foldData;\n            for (var i = 0; i < annotations.length; i++) {\n                var row = annotations[i].row;\n                var compensateFold = this.compensateFoldRows(row, foldData);\n                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);\n                var y1 = Math.round(((row - compensateFold) * this.lineHeight * this.heightRatio));\n                var y2 = Math.round((((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio));\n                var height = y2 - y1;\n                if (height < this.minDecorationHeight) {\n                    var yCenter = ((y1 + y2) / 2) | 0;\n                    if (yCenter < this.halfMinDecorationHeight) {\n                        yCenter = this.halfMinDecorationHeight;\n                    }\n                    else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {\n                        yCenter = this.canvasHeight - this.halfMinDecorationHeight;\n                    }\n                    y1 = Math.round(yCenter - this.halfMinDecorationHeight);\n                    y2 = Math.round(yCenter + this.halfMinDecorationHeight);\n                }\n                ctx.fillStyle = colors[annotations[i].type] || null;\n                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);\n            }\n        }\n        var cursor = this.renderer.session.selection.getCursor();\n        if (cursor) {\n            var compensateFold = this.compensateFoldRows(cursor.row, foldData);\n            var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);\n            ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n            ctx.fillRect(0, currentY, this.canvasWidth, 2);\n        }\n    };\n    Decorator.prototype.compensateFoldRows = function (row, foldData) {\n        var compensateFold = 0;\n        if (foldData && foldData.length > 0) {\n            for (var j = 0; j < foldData.length; j++) {\n                if (row > foldData[j].start.row && row < foldData[j].end.row) {\n                    compensateFold += row - foldData[j].start.row;\n                }\n                else if (row >= foldData[j].end.row) {\n                    compensateFold += foldData[j].end.row - foldData[j].start.row;\n                }\n            }\n        }\n        return compensateFold;\n    };\n    return Decorator;\n}());\noop.implement(Decorator.prototype, EventEmitter);\nexports.Decorator = Decorator;\n\n});\n\nace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/config\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/scrollbar_custom\",\"ace/scrollbar_custom\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\",\"ace/css/editor-css\",\"ace/layer/decorators\",\"ace/lib/useragent\",\"ace/layer/text_util\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar config = require(\"./config\");\nvar GutterLayer = require(\"./layer/gutter\").Gutter;\nvar MarkerLayer = require(\"./layer/marker\").Marker;\nvar TextLayer = require(\"./layer/text\").Text;\nvar CursorLayer = require(\"./layer/cursor\").Cursor;\nvar HScrollBar = require(\"./scrollbar\").HScrollBar;\nvar VScrollBar = require(\"./scrollbar\").VScrollBar;\nvar HScrollBarCustom = require(\"./scrollbar_custom\").HScrollBar;\nvar VScrollBarCustom = require(\"./scrollbar_custom\").VScrollBar;\nvar RenderLoop = require(\"./renderloop\").RenderLoop;\nvar FontMetrics = require(\"./layer/font_metrics\").FontMetrics;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar editorCss = require(\"./css/editor-css\");\nvar Decorator = require(\"./layer/decorators\").Decorator;\nvar useragent = require(\"./lib/useragent\");\nvar isTextToken = require(\"./layer/text_util\").isTextToken;\ndom.importCssString(editorCss, \"ace_editor.css\", false);\nvar VirtualRenderer = /** @class */ (function () {\n    function VirtualRenderer(container, theme) {\n        var _self = this;\n        this.container = container || dom.createElement(\"div\");\n        dom.addCssClass(this.container, \"ace_editor\");\n        if (dom.HI_DPI)\n            dom.addCssClass(this.container, \"ace_hidpi\");\n        this.setTheme(theme);\n        if (config.get(\"useStrictCSP\") == null)\n            config.set(\"useStrictCSP\", false);\n        this.$gutter = dom.createElement(\"div\");\n        this.$gutter.className = \"ace_gutter\";\n        this.container.appendChild(this.$gutter);\n        this.$gutter.setAttribute(\"aria-hidden\", \"true\");\n        this.scroller = dom.createElement(\"div\");\n        this.scroller.className = \"ace_scroller\";\n        this.container.appendChild(this.scroller);\n        this.content = dom.createElement(\"div\");\n        this.content.className = \"ace_content\";\n        this.scroller.appendChild(this.content);\n        this.$gutterLayer = new GutterLayer(this.$gutter);\n        this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n        this.$markerBack = new MarkerLayer(this.content);\n        var textLayer = this.$textLayer = new TextLayer(this.content);\n        this.canvas = textLayer.element;\n        this.$markerFront = new MarkerLayer(this.content);\n        this.$cursorLayer = new CursorLayer(this.content);\n        this.$horizScroll = false;\n        this.$vScroll = false;\n        this.scrollBar =\n            this.scrollBarV = new VScrollBar(this.container, this);\n        this.scrollBarH = new HScrollBar(this.container, this);\n        this.scrollBarV.on(\"scroll\", function (e) {\n            if (!_self.$scrollAnimation)\n                _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n        });\n        this.scrollBarH.on(\"scroll\", function (e) {\n            if (!_self.$scrollAnimation)\n                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n        });\n        this.scrollTop = 0;\n        this.scrollLeft = 0;\n        this.cursorPos = {\n            row: 0,\n            column: 0\n        };\n        this.$fontMetrics = new FontMetrics(this.container);\n        this.$textLayer.$setFontMetrics(this.$fontMetrics);\n        this.$textLayer.on(\"changeCharacterSize\", function (e) {\n            _self.updateCharacterSize();\n            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n            _self._signal(\"changeCharacterSize\", e);\n        });\n        this.$size = {\n            width: 0,\n            height: 0,\n            scrollerHeight: 0,\n            scrollerWidth: 0,\n            $dirty: true\n        };\n        this.layerConfig = {\n            width: 1,\n            padding: 0,\n            firstRow: 0,\n            firstRowScreen: 0,\n            lastRow: 0,\n            lineHeight: 0,\n            characterWidth: 0,\n            minHeight: 1,\n            maxHeight: 1,\n            offset: 0,\n            height: 1,\n            gutterOffset: 1\n        };\n        this.scrollMargin = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            v: 0,\n            h: 0\n        };\n        this.margin = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            v: 0,\n            h: 0\n        };\n        this.$keepTextAreaAtCursor = !useragent.isIOS;\n        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.updateCharacterSize();\n        this.setPadding(4);\n        this.$addResizeObserver();\n        config.resetOptions(this);\n        config._signal(\"renderer\", this);\n    }\n    VirtualRenderer.prototype.updateCharacterSize = function () {\n        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n        }\n        this.layerConfig.characterWidth =\n            this.characterWidth = this.$textLayer.getCharacterWidth();\n        this.layerConfig.lineHeight =\n            this.lineHeight = this.$textLayer.getLineHeight();\n        this.$updatePrintMargin();\n        dom.setStyle(this.scroller.style, \"line-height\", this.lineHeight + \"px\");\n    };\n    VirtualRenderer.prototype.setSession = function (session) {\n        if (this.session)\n            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n        this.session = session;\n        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n            session.setScrollTop(-this.scrollMargin.top);\n        this.$cursorLayer.setSession(session);\n        this.$markerBack.setSession(session);\n        this.$markerFront.setSession(session);\n        this.$gutterLayer.setSession(session);\n        this.$textLayer.setSession(session);\n        if (!session)\n            return;\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.session.$setFontMetrics(this.$fontMetrics);\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n        this.onChangeNewLineMode();\n        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n    };\n    VirtualRenderer.prototype.updateLines = function (firstRow, lastRow, force) {\n        if (lastRow === undefined)\n            lastRow = Infinity;\n        if (!this.$changedLines) {\n            this.$changedLines = {\n                firstRow: firstRow,\n                lastRow: lastRow\n            };\n        }\n        else {\n            if (this.$changedLines.firstRow > firstRow)\n                this.$changedLines.firstRow = firstRow;\n            if (this.$changedLines.lastRow < lastRow)\n                this.$changedLines.lastRow = lastRow;\n        }\n        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n            if (force)\n                this.$changedLines.lastRow = this.layerConfig.lastRow;\n            else\n                return;\n        }\n        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n            return;\n        this.$loop.schedule(this.CHANGE_LINES);\n    };\n    VirtualRenderer.prototype.onChangeNewLineMode = function () {\n        this.$loop.schedule(this.CHANGE_TEXT);\n        this.$textLayer.$updateEolChar();\n        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);\n    };\n    VirtualRenderer.prototype.onChangeTabSize = function () {\n        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n        this.$textLayer.onChangeTabSize();\n    };\n    VirtualRenderer.prototype.updateText = function () {\n        this.$loop.schedule(this.CHANGE_TEXT);\n    };\n    VirtualRenderer.prototype.updateFull = function (force) {\n        if (force)\n            this.$renderChanges(this.CHANGE_FULL, true);\n        else\n            this.$loop.schedule(this.CHANGE_FULL);\n    };\n    VirtualRenderer.prototype.updateFontSize = function () {\n        this.$textLayer.checkForSizeChanges();\n    };\n    VirtualRenderer.prototype.$updateSizeAsync = function () {\n        if (this.$loop.pending)\n            this.$size.$dirty = true;\n        else\n            this.onResize();\n    };\n    VirtualRenderer.prototype.onResize = function (force, gutterWidth, width, height) {\n        if (this.resizing > 2)\n            return;\n        else if (this.resizing > 0)\n            this.resizing++;\n        else\n            this.resizing = force ? 1 : 0;\n        var el = this.container;\n        if (!height)\n            height = el.clientHeight || el.scrollHeight;\n        if (!height && this.$maxLines && this.lineHeight > 1) {\n            if (!el.style.height || el.style.height == \"0px\") {\n                el.style.height = \"1px\";\n                height = el.clientHeight || el.scrollHeight;\n            }\n        }\n        if (!width)\n            width = el.clientWidth || el.scrollWidth;\n        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n        if (this.$resizeTimer)\n            this.$resizeTimer.cancel();\n        if (!this.$size.scrollerHeight || (!width && !height))\n            return this.resizing = 0;\n        if (force)\n            this.$gutterLayer.$padding = null;\n        if (force)\n            this.$renderChanges(changes | this.$changes, true);\n        else\n            this.$loop.schedule(changes | this.$changes);\n        if (this.resizing)\n            this.resizing = 0;\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        if (this.$customScrollbar) {\n            this.$updateCustomScrollbar(true);\n        }\n    };\n    VirtualRenderer.prototype.$updateCachedSize = function (force, gutterWidth, width, height) {\n        height -= (this.$extraHeight || 0);\n        var changes = 0;\n        var size = this.$size;\n        var oldSize = {\n            width: size.width,\n            height: size.height,\n            scrollerHeight: size.scrollerHeight,\n            scrollerWidth: size.scrollerWidth\n        };\n        if (height && (force || size.height != height)) {\n            size.height = height;\n            changes |= this.CHANGE_SIZE;\n            size.scrollerHeight = size.height;\n            if (this.$horizScroll)\n                size.scrollerHeight -= this.scrollBarH.getHeight();\n            this.scrollBarV.setHeight(size.scrollerHeight);\n            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n            changes = changes | this.CHANGE_SCROLL;\n        }\n        if (width && (force || size.width != width)) {\n            changes |= this.CHANGE_SIZE;\n            size.width = width;\n            if (gutterWidth == null)\n                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n            this.gutterWidth = gutterWidth;\n            dom.setStyle(this.scrollBarH.element.style, \"left\", gutterWidth + \"px\");\n            dom.setStyle(this.scroller.style, \"left\", gutterWidth + this.margin.left + \"px\");\n            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);\n            dom.setStyle(this.$gutter.style, \"left\", this.margin.left + \"px\");\n            var right = this.scrollBarV.getWidth() + \"px\";\n            dom.setStyle(this.scrollBarH.element.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"bottom\", this.scrollBarH.getHeight());\n            this.scrollBarH.setWidth(size.scrollerWidth);\n            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {\n                changes |= this.CHANGE_FULL;\n            }\n        }\n        size.$dirty = !width || !height;\n        if (changes)\n            this._signal(\"resize\", oldSize);\n        return changes;\n    };\n    VirtualRenderer.prototype.onGutterResize = function (width) {\n        var gutterWidth = this.$showGutter ? width : 0;\n        if (gutterWidth != this.gutterWidth)\n            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        }\n        else if (this.$size.$dirty) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        }\n        else {\n            this.$computeLayerConfig();\n        }\n    };\n    VirtualRenderer.prototype.adjustWrapLimit = function () {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth);\n        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n    };\n    VirtualRenderer.prototype.setAnimatedScroll = function (shouldAnimate) {\n        this.setOption(\"animatedScroll\", shouldAnimate);\n    };\n    VirtualRenderer.prototype.getAnimatedScroll = function () {\n        return this.$animatedScroll;\n    };\n    VirtualRenderer.prototype.setShowInvisibles = function (showInvisibles) {\n        this.setOption(\"showInvisibles\", showInvisibles);\n        this.session.$bidiHandler.setShowInvisibles(showInvisibles);\n    };\n    VirtualRenderer.prototype.getShowInvisibles = function () {\n        return this.getOption(\"showInvisibles\");\n    };\n    VirtualRenderer.prototype.getDisplayIndentGuides = function () {\n        return this.getOption(\"displayIndentGuides\");\n    };\n    VirtualRenderer.prototype.setDisplayIndentGuides = function (display) {\n        this.setOption(\"displayIndentGuides\", display);\n    };\n    VirtualRenderer.prototype.getHighlightIndentGuides = function () {\n        return this.getOption(\"highlightIndentGuides\");\n    };\n    VirtualRenderer.prototype.setHighlightIndentGuides = function (highlight) {\n        this.setOption(\"highlightIndentGuides\", highlight);\n    };\n    VirtualRenderer.prototype.setShowPrintMargin = function (showPrintMargin) {\n        this.setOption(\"showPrintMargin\", showPrintMargin);\n    };\n    VirtualRenderer.prototype.getShowPrintMargin = function () {\n        return this.getOption(\"showPrintMargin\");\n    };\n    VirtualRenderer.prototype.setPrintMarginColumn = function (printMarginColumn) {\n        this.setOption(\"printMarginColumn\", printMarginColumn);\n    };\n    VirtualRenderer.prototype.getPrintMarginColumn = function () {\n        return this.getOption(\"printMarginColumn\");\n    };\n    VirtualRenderer.prototype.getShowGutter = function () {\n        return this.getOption(\"showGutter\");\n    };\n    VirtualRenderer.prototype.setShowGutter = function (show) {\n        return this.setOption(\"showGutter\", show);\n    };\n    VirtualRenderer.prototype.getFadeFoldWidgets = function () {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    VirtualRenderer.prototype.setFadeFoldWidgets = function (show) {\n        this.setOption(\"fadeFoldWidgets\", show);\n    };\n    VirtualRenderer.prototype.setHighlightGutterLine = function (shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n    VirtualRenderer.prototype.getHighlightGutterLine = function () {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    VirtualRenderer.prototype.$updatePrintMargin = function () {\n        if (!this.$showPrintMargin && !this.$printMarginEl)\n            return;\n        if (!this.$printMarginEl) {\n            var containerEl = dom.createElement(\"div\");\n            containerEl.className = \"ace_layer ace_print-margin-layer\";\n            this.$printMarginEl = dom.createElement(\"div\");\n            this.$printMarginEl.className = \"ace_print-margin\";\n            containerEl.appendChild(this.$printMarginEl);\n            this.content.insertBefore(containerEl, this.content.firstChild);\n        }\n        var style = this.$printMarginEl.style;\n        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + \"px\";\n        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n        if (this.session && this.session.$wrap == -1)\n            this.adjustWrapLimit();\n    };\n    VirtualRenderer.prototype.getContainerElement = function () {\n        return this.container;\n    };\n    VirtualRenderer.prototype.getMouseEventTarget = function () {\n        return this.scroller;\n    };\n    VirtualRenderer.prototype.getTextAreaContainer = function () {\n        return this.container;\n    };\n    VirtualRenderer.prototype.$moveTextAreaToCursor = function () {\n        if (this.$isMousePressed)\n            return;\n        var style = this.textarea.style;\n        var composition = this.$composition;\n        if (!this.$keepTextAreaAtCursor && !composition) {\n            dom.translate(this.textarea, -100, 0);\n            return;\n        }\n        var pixelPos = this.$cursorLayer.$pixelPos;\n        if (!pixelPos)\n            return;\n        if (composition && composition.markerRange)\n            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);\n        var config = this.layerConfig;\n        var posTop = pixelPos.top;\n        var posLeft = pixelPos.left;\n        posTop -= config.offset;\n        var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;\n        if (posTop < 0 || posTop > config.height - h) {\n            dom.translate(this.textarea, 0, 0);\n            return;\n        }\n        var w = 1;\n        var maxTop = this.$size.height - h;\n        if (!composition) {\n            posTop += this.lineHeight;\n        }\n        else {\n            if (composition.useTextareaForIME) {\n                var val = this.textarea.value;\n                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);\n            }\n            else {\n                posTop += this.lineHeight + 2;\n            }\n        }\n        posLeft -= this.scrollLeft;\n        if (posLeft > this.$size.scrollerWidth - w)\n            posLeft = this.$size.scrollerWidth - w;\n        posLeft += this.gutterWidth + this.margin.left;\n        dom.setStyle(style, \"height\", h + \"px\");\n        dom.setStyle(style, \"width\", w + \"px\");\n        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));\n    };\n    VirtualRenderer.prototype.getFirstVisibleRow = function () {\n        return this.layerConfig.firstRow;\n    };\n    VirtualRenderer.prototype.getFirstFullyVisibleRow = function () {\n        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n    };\n    VirtualRenderer.prototype.getLastFullyVisibleRow = function () {\n        var config = this.layerConfig;\n        var lastRow = config.lastRow;\n        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;\n        if (top - this.session.getScrollTop() > config.height - config.lineHeight)\n            return lastRow - 1;\n        return lastRow;\n    };\n    VirtualRenderer.prototype.getLastVisibleRow = function () {\n        return this.layerConfig.lastRow;\n    };\n    VirtualRenderer.prototype.setPadding = function (padding) {\n        this.$padding = padding;\n        this.$textLayer.setPadding(padding);\n        this.$cursorLayer.setPadding(padding);\n        this.$markerFront.setPadding(padding);\n        this.$markerBack.setPadding(padding);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.$updatePrintMargin();\n    };\n    VirtualRenderer.prototype.setScrollMargin = function (top, bottom, left, right) {\n        var sm = this.scrollMargin;\n        sm.top = top | 0;\n        sm.bottom = bottom | 0;\n        sm.right = right | 0;\n        sm.left = left | 0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        if (sm.top && this.scrollTop <= 0 && this.session)\n            this.session.setScrollTop(-sm.top);\n        this.updateFull();\n    };\n    VirtualRenderer.prototype.setMargin = function (top, bottom, left, right) {\n        var sm = this.margin;\n        sm.top = top | 0;\n        sm.bottom = bottom | 0;\n        sm.right = right | 0;\n        sm.left = left | 0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);\n        this.updateFull();\n    };\n    VirtualRenderer.prototype.getHScrollBarAlwaysVisible = function () {\n        return this.$hScrollBarAlwaysVisible;\n    };\n    VirtualRenderer.prototype.setHScrollBarAlwaysVisible = function (alwaysVisible) {\n        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    VirtualRenderer.prototype.getVScrollBarAlwaysVisible = function () {\n        return this.$vScrollBarAlwaysVisible;\n    };\n    VirtualRenderer.prototype.setVScrollBarAlwaysVisible = function (alwaysVisible) {\n        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    VirtualRenderer.prototype.$updateScrollBarV = function () {\n        var scrollHeight = this.layerConfig.maxHeight;\n        var scrollerHeight = this.$size.scrollerHeight;\n        if (!this.$maxLines && this.$scrollPastEnd) {\n            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n            if (this.scrollTop > scrollHeight - scrollerHeight) {\n                scrollHeight = this.scrollTop + scrollerHeight;\n                this.scrollBarV.scrollTop = null;\n            }\n        }\n        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n    };\n    VirtualRenderer.prototype.$updateScrollBarH = function () {\n        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n    };\n    VirtualRenderer.prototype.freeze = function () {\n        this.$frozen = true;\n    };\n    VirtualRenderer.prototype.unfreeze = function () {\n        this.$frozen = false;\n    };\n    VirtualRenderer.prototype.$renderChanges = function (changes, force) {\n        if (this.$changes) {\n            changes |= this.$changes;\n            this.$changes = 0;\n        }\n        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n            this.$changes |= changes;\n            return;\n        }\n        if (this.$size.$dirty) {\n            this.$changes |= changes;\n            return this.onResize(true);\n        }\n        if (!this.lineHeight) {\n            this.$textLayer.checkForSizeChanges();\n        }\n        this._signal(\"beforeRender\", changes);\n        if (this.session && this.session.$bidiHandler)\n            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);\n        var config = this.layerConfig;\n        if (changes & this.CHANGE_FULL ||\n            changes & this.CHANGE_SIZE ||\n            changes & this.CHANGE_TEXT ||\n            changes & this.CHANGE_LINES ||\n            changes & this.CHANGE_SCROLL ||\n            changes & this.CHANGE_H_SCROLL) {\n            changes |= this.$computeLayerConfig() | this.$loop.clear();\n            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n                var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;\n                if (st > 0) {\n                    this.scrollTop = st;\n                    changes = changes | this.CHANGE_SCROLL;\n                    changes |= this.$computeLayerConfig() | this.$loop.clear();\n                }\n            }\n            config = this.layerConfig;\n            this.$updateScrollBarV();\n            if (changes & this.CHANGE_H_SCROLL)\n                this.$updateScrollBarH();\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            var width = config.width + 2 * this.$padding + \"px\";\n            var height = config.minHeight + \"px\";\n            dom.setStyle(this.content.style, \"width\", width);\n            dom.setStyle(this.content.style, \"height\", height);\n        }\n        if (changes & this.CHANGE_H_SCROLL) {\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller \" : \"ace_scroller ace_scroll-left \";\n            if (this.enableKeyboardAccessibility)\n                this.scroller.className += this.keyboardFocusClassName;\n        }\n        if (changes & this.CHANGE_FULL) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n        if (changes & this.CHANGE_SCROLL) {\n            this.$changedLines = null;\n            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n                this.$textLayer.update(config);\n            else\n                this.$textLayer.scrollLines(config);\n            if (this.$showGutter) {\n                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)\n                    this.$gutterLayer.update(config);\n                else\n                    this.$gutterLayer.scrollLines(config);\n            }\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n        if (changes & this.CHANGE_TEXT) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_LINES) {\n            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        else if (changes & this.CHANGE_CURSOR) {\n            if (this.$highlightGutterLine)\n                this.$gutterLayer.updateLineHighlight(config);\n            if (this.$customScrollbar) {\n                this.$scrollDecorator.$updateDecorators(config);\n            }\n        }\n        if (changes & this.CHANGE_CURSOR) {\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n        }\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n            this.$markerFront.update(config);\n        }\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n            this.$markerBack.update(config);\n        }\n        this._signal(\"afterRender\", changes);\n    };\n    VirtualRenderer.prototype.$autosize = function () {\n        var height = this.session.getScreenLength() * this.lineHeight;\n        var maxHeight = this.$maxLines * this.lineHeight;\n        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);\n        if (this.$horizScroll)\n            desiredHeight += this.scrollBarH.getHeight();\n        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)\n            desiredHeight = this.$maxPixelHeight;\n        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;\n        var vScroll = !hideScrollbars && height > maxHeight;\n        if (desiredHeight != this.desiredHeight ||\n            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n            if (vScroll != this.$vScroll) {\n                this.$vScroll = vScroll;\n                this.scrollBarV.setVisible(vScroll);\n            }\n            var w = this.container.clientWidth;\n            this.container.style.height = desiredHeight + \"px\";\n            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n            this.desiredHeight = desiredHeight;\n            this._signal(\"autosize\");\n        }\n    };\n    VirtualRenderer.prototype.$computeLayerConfig = function () {\n        var session = this.session;\n        var size = this.$size;\n        var hideScrollbars = size.height <= 2 * this.lineHeight;\n        var screenLines = this.session.getScreenLength();\n        var maxHeight = screenLines * this.lineHeight;\n        var longestLine = this.$getLongestLine();\n        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n        var hScrollChanged = this.$horizScroll !== horizScroll;\n        if (hScrollChanged) {\n            this.$horizScroll = horizScroll;\n            this.scrollBarH.setVisible(horizScroll);\n        }\n        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine\n        if (this.$maxLines && this.lineHeight > 1) {\n            this.$autosize();\n            hideScrollbars = size.height <= 2 * this.lineHeight;\n        }\n        var minHeight = size.scrollerHeight + this.lineHeight;\n        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n            : 0;\n        maxHeight += scrollPastEnd;\n        var sm = this.scrollMargin;\n        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));\n        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));\n        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);\n        var vScrollChanged = vScrollBefore !== vScroll;\n        if (vScrollChanged) {\n            this.$vScroll = vScroll;\n            this.scrollBarV.setVisible(vScroll);\n        }\n        var offset = this.scrollTop % this.lineHeight;\n        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n        var lastRow = firstRow + lineCount;\n        var firstRowScreen, firstRowHeight;\n        var lineHeight = this.lineHeight;\n        firstRow = session.screenToDocumentRow(firstRow, 0);\n        var foldLine = session.getFoldLine(firstRow);\n        if (foldLine) {\n            firstRow = foldLine.start.row;\n        }\n        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n            firstRowHeight;\n        offset = this.scrollTop - firstRowScreen * lineHeight;\n        var changes = 0;\n        if (this.layerConfig.width != longestLine || hScrollChanged)\n            changes = this.CHANGE_H_SCROLL;\n        if (hScrollChanged || vScrollChanged) {\n            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n            this._signal(\"scrollbarVisibilityChanged\");\n            if (vScrollChanged)\n                longestLine = this.$getLongestLine();\n        }\n        this.layerConfig = {\n            width: longestLine,\n            padding: this.$padding,\n            firstRow: firstRow,\n            firstRowScreen: firstRowScreen,\n            lastRow: lastRow,\n            lineHeight: lineHeight,\n            characterWidth: this.characterWidth,\n            minHeight: minHeight,\n            maxHeight: maxHeight,\n            offset: offset,\n            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,\n            height: this.$size.scrollerHeight\n        };\n        if (this.session.$bidiHandler)\n            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);\n        return changes;\n    };\n    VirtualRenderer.prototype.$updateLines = function () {\n        if (!this.$changedLines)\n            return;\n        var firstRow = this.$changedLines.firstRow;\n        var lastRow = this.$changedLines.lastRow;\n        this.$changedLines = null;\n        var layerConfig = this.layerConfig;\n        if (firstRow > layerConfig.lastRow + 1) {\n            return;\n        }\n        if (lastRow < layerConfig.firstRow) {\n            return;\n        }\n        if (lastRow === Infinity) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(layerConfig);\n            this.$textLayer.update(layerConfig);\n            return;\n        }\n        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n        return true;\n    };\n    VirtualRenderer.prototype.$getLongestLine = function () {\n        var charCount = this.session.getScreenWidth();\n        if (this.showInvisibles && !this.session.$useWrapMode)\n            charCount += 1;\n        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)\n            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;\n        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n    };\n    VirtualRenderer.prototype.updateFrontMarkers = function () {\n        this.$markerFront.setMarkers(this.session.getMarkers(true));\n        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n    };\n    VirtualRenderer.prototype.updateBackMarkers = function () {\n        this.$markerBack.setMarkers(this.session.getMarkers());\n        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n    };\n    VirtualRenderer.prototype.addGutterDecoration = function (row, className) {\n        this.$gutterLayer.addGutterDecoration(row, className);\n    };\n    VirtualRenderer.prototype.removeGutterDecoration = function (row, className) {\n        this.$gutterLayer.removeGutterDecoration(row, className);\n    };\n    VirtualRenderer.prototype.updateBreakpoints = function (rows) {\n        this._rows = rows;\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    VirtualRenderer.prototype.setAnnotations = function (annotations) {\n        this.$gutterLayer.setAnnotations(annotations);\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    VirtualRenderer.prototype.updateCursor = function () {\n        this.$loop.schedule(this.CHANGE_CURSOR);\n    };\n    VirtualRenderer.prototype.hideCursor = function () {\n        this.$cursorLayer.hideCursor();\n    };\n    VirtualRenderer.prototype.showCursor = function () {\n        this.$cursorLayer.showCursor();\n    };\n    VirtualRenderer.prototype.scrollSelectionIntoView = function (anchor, lead, offset) {\n        this.scrollCursorIntoView(anchor, offset);\n        this.scrollCursorIntoView(lead, offset);\n    };\n    VirtualRenderer.prototype.scrollCursorIntoView = function (cursor, offset, $viewMargin) {\n        if (this.$size.scrollerHeight === 0)\n            return;\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var newLeft = pos.left;\n        var newTop = pos.top;\n        var topMargin = $viewMargin && $viewMargin.top || 0;\n        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n        if (this.$scrollAnimation) {\n            this.$stopAnimation = true;\n        }\n        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n        if (currentTop + topMargin > newTop) {\n            if (offset && currentTop + topMargin > newTop + this.lineHeight)\n                newTop -= offset * this.$size.scrollerHeight;\n            if (newTop === 0)\n                newTop = -this.scrollMargin.top;\n            this.session.setScrollTop(newTop);\n        }\n        else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {\n            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)\n                newTop += offset * this.$size.scrollerHeight;\n            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);\n        }\n        var currentLeft = this.scrollLeft;\n        var twoCharsWidth = 2 * this.layerConfig.characterWidth;\n        if (newLeft - twoCharsWidth < currentLeft) {\n            newLeft -= twoCharsWidth;\n            if (newLeft < this.$padding + twoCharsWidth) {\n                newLeft = -this.scrollMargin.left;\n            }\n            this.session.setScrollLeft(newLeft);\n        }\n        else {\n            newLeft += twoCharsWidth;\n            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {\n                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));\n            }\n            else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {\n                this.session.setScrollLeft(0);\n            }\n        }\n    };\n    VirtualRenderer.prototype.getScrollTop = function () {\n        return this.session.getScrollTop();\n    };\n    VirtualRenderer.prototype.getScrollLeft = function () {\n        return this.session.getScrollLeft();\n    };\n    VirtualRenderer.prototype.getScrollTopRow = function () {\n        return this.scrollTop / this.lineHeight;\n    };\n    VirtualRenderer.prototype.getScrollBottomRow = function () {\n        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n    };\n    VirtualRenderer.prototype.scrollToRow = function (row) {\n        this.session.setScrollTop(row * this.lineHeight);\n    };\n    VirtualRenderer.prototype.alignCursor = function (cursor, alignment) {\n        if (typeof cursor == \"number\")\n            cursor = { row: cursor, column: 0 };\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var h = this.$size.scrollerHeight - this.lineHeight;\n        var offset = pos.top - h * (alignment || 0);\n        this.session.setScrollTop(offset);\n        return offset;\n    };\n    VirtualRenderer.prototype.$calcSteps = function (fromValue, toValue) {\n        var i = 0;\n        var l = this.STEPS;\n        var steps = [];\n        var func = function (t, x_min, dx) {\n            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n        };\n        for (i = 0; i < l; ++i)\n            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n        return steps;\n    };\n    VirtualRenderer.prototype.scrollToLine = function (line, center, animate, callback) {\n        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });\n        var offset = pos.top;\n        if (center)\n            offset -= this.$size.scrollerHeight / 2;\n        var initialScroll = this.scrollTop;\n        this.session.setScrollTop(offset);\n        if (animate !== false)\n            this.animateScrolling(initialScroll, callback);\n    };\n    VirtualRenderer.prototype.animateScrolling = function (fromValue, callback) {\n        var toValue = this.scrollTop;\n        if (!this.$animatedScroll)\n            return;\n        var _self = this;\n        if (fromValue == toValue)\n            return;\n        if (this.$scrollAnimation) {\n            var oldSteps = this.$scrollAnimation.steps;\n            if (oldSteps.length) {\n                fromValue = oldSteps[0];\n                if (fromValue == toValue)\n                    return;\n            }\n        }\n        var steps = _self.$calcSteps(fromValue, toValue);\n        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };\n        clearInterval(this.$timer);\n        _self.session.setScrollTop(steps.shift());\n        _self.session.$scrollTop = toValue;\n        function endAnimation() {\n            _self.$timer = clearInterval(_self.$timer);\n            _self.$scrollAnimation = null;\n            _self.$stopAnimation = false;\n            callback && callback();\n        }\n        this.$timer = setInterval(function () {\n            if (_self.$stopAnimation) {\n                endAnimation();\n                return;\n            }\n            if (!_self.session)\n                return clearInterval(_self.$timer);\n            if (steps.length) {\n                _self.session.setScrollTop(steps.shift());\n                _self.session.$scrollTop = toValue;\n            }\n            else if (toValue != null) {\n                _self.session.$scrollTop = -1;\n                _self.session.setScrollTop(toValue);\n                toValue = null;\n            }\n            else {\n                endAnimation();\n            }\n        }, 10);\n    };\n    VirtualRenderer.prototype.scrollToY = function (scrollTop) {\n        if (this.scrollTop !== scrollTop) {\n            this.$loop.schedule(this.CHANGE_SCROLL);\n            this.scrollTop = scrollTop;\n        }\n    };\n    VirtualRenderer.prototype.scrollToX = function (scrollLeft) {\n        if (this.scrollLeft !== scrollLeft)\n            this.scrollLeft = scrollLeft;\n        this.$loop.schedule(this.CHANGE_H_SCROLL);\n    };\n    VirtualRenderer.prototype.scrollTo = function (x, y) {\n        this.session.setScrollTop(y);\n        this.session.setScrollLeft(x);\n    };\n    VirtualRenderer.prototype.scrollBy = function (deltaX, deltaY) {\n        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n    };\n    VirtualRenderer.prototype.isScrollableBy = function (deltaX, deltaY) {\n        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n            return true;\n        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n            return true;\n        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n            return true;\n        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n            - this.layerConfig.width < -1 + this.scrollMargin.right)\n            return true;\n    };\n    VirtualRenderer.prototype.pixelToScreenCoordinates = function (x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = { top: 0, left: 0 };\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        }\n        else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n        return { row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX: offsetX };\n    };\n    VirtualRenderer.prototype.screenToTextCoordinates = function (x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = { top: 0, left: 0 };\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        }\n        else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);\n    };\n    VirtualRenderer.prototype.textToScreenCoordinates = function (row, column) {\n        var canvasPos = this.scroller.getBoundingClientRect();\n        var pos = this.session.documentToScreenPosition(row, column);\n        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : Math.round(pos.column * this.characterWidth));\n        var y = pos.row * this.lineHeight;\n        return {\n            pageX: canvasPos.left + x - this.scrollLeft,\n            pageY: canvasPos.top + y - this.scrollTop\n        };\n    };\n    VirtualRenderer.prototype.visualizeFocus = function () {\n        dom.addCssClass(this.container, \"ace_focus\");\n    };\n    VirtualRenderer.prototype.visualizeBlur = function () {\n        dom.removeCssClass(this.container, \"ace_focus\");\n    };\n    VirtualRenderer.prototype.showComposition = function (composition) {\n        this.$composition = composition;\n        if (!composition.cssText) {\n            composition.cssText = this.textarea.style.cssText;\n        }\n        if (composition.useTextareaForIME == undefined)\n            composition.useTextareaForIME = this.$useTextareaForIME;\n        if (this.$useTextareaForIME) {\n            dom.addCssClass(this.textarea, \"ace_composition\");\n            this.textarea.style.cssText = \"\";\n            this.$moveTextAreaToCursor();\n            this.$cursorLayer.element.style.display = \"none\";\n        }\n        else {\n            composition.markerId = this.session.addMarker(composition.markerRange, \"ace_composition_marker\", \"text\");\n        }\n    };\n    VirtualRenderer.prototype.setCompositionText = function (text) {\n        var cursor = this.session.selection.cursor;\n        this.addToken(text, \"composition_placeholder\", cursor.row, cursor.column);\n        this.$moveTextAreaToCursor();\n    };\n    VirtualRenderer.prototype.hideComposition = function () {\n        if (!this.$composition)\n            return;\n        if (this.$composition.markerId)\n            this.session.removeMarker(this.$composition.markerId);\n        dom.removeCssClass(this.textarea, \"ace_composition\");\n        this.textarea.style.cssText = this.$composition.cssText;\n        var cursor = this.session.selection.cursor;\n        this.removeExtraToken(cursor.row, cursor.column);\n        this.$composition = null;\n        this.$cursorLayer.element.style.display = \"\";\n    };\n    VirtualRenderer.prototype.setGhostText = function (text, position) {\n        var cursor = this.session.selection.cursor;\n        var insertPosition = position || { row: cursor.row, column: cursor.column };\n        this.removeGhostText();\n        var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);\n        this.addToken(textChunks[0].text, \"ghost_text\", insertPosition.row, insertPosition.column);\n        this.$ghostText = {\n            text: text,\n            position: {\n                row: insertPosition.row,\n                column: insertPosition.column\n            }\n        };\n        var widgetDiv = dom.createElement(\"div\");\n        if (textChunks.length > 1) {\n            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);\n            var lastLineDiv;\n            textChunks.slice(1).forEach(function (el) {\n                var chunkDiv = dom.createElement(\"div\");\n                var chunkSpan = dom.createElement(\"span\");\n                chunkSpan.className = \"ace_ghost_text\";\n                if (el.wrapped)\n                    chunkDiv.className = \"ghost_text_line_wrapped\";\n                if (el.text.length === 0)\n                    el.text = \" \";\n                chunkSpan.appendChild(dom.createTextNode(el.text));\n                chunkDiv.appendChild(chunkSpan);\n                widgetDiv.appendChild(chunkDiv);\n                lastLineDiv = chunkDiv;\n            });\n            hiddenTokens.forEach(function (token) {\n                var element = dom.createElement(\"span\");\n                if (!isTextToken(token.type))\n                    element.className = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n                element.appendChild(dom.createTextNode(token.value));\n                lastLineDiv.appendChild(element);\n            });\n            this.$ghostTextWidget = {\n                el: widgetDiv,\n                row: insertPosition.row,\n                column: insertPosition.column,\n                className: \"ace_ghost_text_container\"\n            };\n            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);\n            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);\n            var el = this.container;\n            var height = el.getBoundingClientRect().height;\n            var ghostTextHeight = textChunks.length * this.lineHeight;\n            var fitsY = ghostTextHeight < (height - pixelPosition.top);\n            if (fitsY)\n                return;\n            if (ghostTextHeight < height) {\n                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);\n            }\n            else {\n                this.scrollToRow(insertPosition.row);\n            }\n        }\n    };\n    VirtualRenderer.prototype.$calculateWrappedTextChunks = function (text, position) {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth) - 2;\n        limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small\n        var textLines = text.split(/\\r?\\n/);\n        var textChunks = [];\n        for (var i = 0; i < textLines.length; i++) {\n            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);\n            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);\n            if (wrapSplits.length > 0) {\n                var start = 0;\n                wrapSplits.push(textLines[i].length);\n                for (var j = 0; j < wrapSplits.length; j++) {\n                    var textSlice = textLines[i].slice(start, wrapSplits[j]);\n                    textChunks.push({ text: textSlice, wrapped: true });\n                    start = wrapSplits[j];\n                }\n            }\n            else {\n                textChunks.push({ text: textLines[i], wrapped: false });\n            }\n        }\n        return textChunks;\n    };\n    VirtualRenderer.prototype.removeGhostText = function () {\n        if (!this.$ghostText)\n            return;\n        var position = this.$ghostText.position;\n        this.removeExtraToken(position.row, position.column);\n        if (this.$ghostTextWidget) {\n            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);\n            this.$ghostTextWidget = null;\n        }\n        this.$ghostText = null;\n    };\n    VirtualRenderer.prototype.addToken = function (text, type, row, column) {\n        var session = this.session;\n        session.bgTokenizer.lines[row] = null;\n        var newToken = { type: type, value: text };\n        var tokens = session.getTokens(row);\n        if (column == null || !tokens.length) {\n            tokens.push(newToken);\n        }\n        else {\n            var l = 0;\n            for (var i = 0; i < tokens.length; i++) {\n                var token = tokens[i];\n                l += token.value.length;\n                if (column <= l) {\n                    var diff = token.value.length - (l - column);\n                    var before = token.value.slice(0, diff);\n                    var after = token.value.slice(diff);\n                    tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });\n                    break;\n                }\n            }\n        }\n        this.updateLines(row, row);\n    };\n    VirtualRenderer.prototype.hideTokensAfterPosition = function (row, column) {\n        var tokens = this.session.getTokens(row);\n        var l = 0;\n        var hasPassedCursor = false;\n        var hiddenTokens = [];\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            l += token.value.length;\n            if (token.type === \"ghost_text\")\n                continue;\n            if (hasPassedCursor) {\n                hiddenTokens.push({ type: token.type, value: token.value });\n                token.type = \"hidden_token\";\n                continue;\n            }\n            if (l === column) {\n                hasPassedCursor = true;\n            }\n        }\n        this.updateLines(row, row);\n        return hiddenTokens;\n    };\n    VirtualRenderer.prototype.removeExtraToken = function (row, column) {\n        this.session.bgTokenizer.lines[row] = null;\n        this.updateLines(row, row);\n    };\n    VirtualRenderer.prototype.setTheme = function (theme, cb) {\n        var _self = this;\n        this.$themeId = theme;\n        _self._dispatchEvent('themeChange', { theme: theme });\n        if (!theme || typeof theme == \"string\") {\n            var moduleName = theme || this.$options.theme.initialValue;\n            config.loadModule([\"theme\", moduleName], afterLoad);\n        }\n        else {\n            afterLoad(theme);\n        }\n        function afterLoad(module) {\n            if (_self.$themeId != theme)\n                return cb && cb();\n            if (!module || !module.cssClass)\n                throw new Error(\"couldn't load module \" + theme + \" or it didn't call define\");\n            if (module.$id)\n                _self.$themeId = module.$id;\n            dom.importCssString(module.cssText, module.cssClass, _self.container);\n            if (_self.theme)\n                dom.removeCssClass(_self.container, _self.theme.cssClass);\n            var padding = \"padding\" in module ? module.padding\n                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n            if (_self.$padding && padding != _self.$padding)\n                _self.setPadding(padding);\n            _self.$theme = module.cssClass;\n            _self.theme = module;\n            dom.addCssClass(_self.container, module.cssClass);\n            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n            if (_self.$size) {\n                _self.$size.width = 0;\n                _self.$updateSizeAsync();\n            }\n            _self._dispatchEvent('themeLoaded', { theme: module });\n            cb && cb();\n            if (useragent.isSafari && _self.scroller) {\n                _self.scroller.style.background = \"red\";\n                _self.scroller.style.background = \"\";\n            }\n        }\n    };\n    VirtualRenderer.prototype.getTheme = function () {\n        return this.$themeId;\n    };\n    VirtualRenderer.prototype.setStyle = function (style, include) {\n        dom.setCssClass(this.container, style, include !== false);\n    };\n    VirtualRenderer.prototype.unsetStyle = function (style) {\n        dom.removeCssClass(this.container, style);\n    };\n    VirtualRenderer.prototype.setCursorStyle = function (style) {\n        dom.setStyle(this.scroller.style, \"cursor\", style);\n    };\n    VirtualRenderer.prototype.setMouseCursor = function (cursorStyle) {\n        dom.setStyle(this.scroller.style, \"cursor\", cursorStyle);\n    };\n    VirtualRenderer.prototype.attachToShadowRoot = function () {\n        dom.importCssString(editorCss, \"ace_editor.css\", this.container);\n    };\n    VirtualRenderer.prototype.destroy = function () {\n        this.freeze();\n        this.$fontMetrics.destroy();\n        this.$cursorLayer.destroy();\n        this.removeAllListeners();\n        this.container.textContent = \"\";\n        this.setOption(\"useResizeObserver\", false);\n    };\n    VirtualRenderer.prototype.$updateCustomScrollbar = function (val) {\n        var _self = this;\n        this.$horizScroll = this.$vScroll = null;\n        this.scrollBarV.element.remove();\n        this.scrollBarH.element.remove();\n        if (this.$scrollDecorator) {\n            delete this.$scrollDecorator;\n        }\n        if (val === true) {\n            this.scrollBarV = new VScrollBarCustom(this.container, this);\n            this.scrollBarH = new HScrollBarCustom(this.container, this);\n            this.scrollBarV.setHeight(this.$size.scrollerHeight);\n            this.scrollBarH.setWidth(this.$size.scrollerWidth);\n            this.scrollBarV.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n            });\n            this.scrollBarH.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n            });\n            this.$scrollDecorator = new Decorator(this.scrollBarV, this);\n            this.$scrollDecorator.$updateDecorators();\n        }\n        else {\n            this.scrollBarV = new VScrollBar(this.container, this);\n            this.scrollBarH = new HScrollBar(this.container, this);\n            this.scrollBarV.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n            });\n            this.scrollBarH.addEventListener(\"scroll\", function (e) {\n                if (!_self.$scrollAnimation)\n                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n            });\n        }\n    };\n    VirtualRenderer.prototype.$addResizeObserver = function () {\n        if (!window.ResizeObserver || this.$resizeObserver)\n            return;\n        var self = this;\n        this.$resizeTimer = lang.delayedCall(function () {\n            if (!self.destroyed)\n                self.onResize();\n        }, 50);\n        this.$resizeObserver = new window.ResizeObserver(function (e) {\n            var w = e[0].contentRect.width;\n            var h = e[0].contentRect.height;\n            if (Math.abs(self.$size.width - w) > 1\n                || Math.abs(self.$size.height - h) > 1) {\n                self.$resizeTimer.delay();\n            }\n            else {\n                self.$resizeTimer.cancel();\n            }\n        });\n        this.$resizeObserver.observe(this.container);\n    };\n    return VirtualRenderer;\n}());\nVirtualRenderer.prototype.CHANGE_CURSOR = 1;\nVirtualRenderer.prototype.CHANGE_MARKER = 2;\nVirtualRenderer.prototype.CHANGE_GUTTER = 4;\nVirtualRenderer.prototype.CHANGE_SCROLL = 8;\nVirtualRenderer.prototype.CHANGE_LINES = 16;\nVirtualRenderer.prototype.CHANGE_TEXT = 32;\nVirtualRenderer.prototype.CHANGE_SIZE = 64;\nVirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;\nVirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;\nVirtualRenderer.prototype.CHANGE_FULL = 512;\nVirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;\nVirtualRenderer.prototype.$changes = 0;\nVirtualRenderer.prototype.$padding = null;\nVirtualRenderer.prototype.$frozen = false;\nVirtualRenderer.prototype.STEPS = 8;\noop.implement(VirtualRenderer.prototype, EventEmitter);\nconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n    useResizeObserver: {\n        set: function (value) {\n            if (!value && this.$resizeObserver) {\n                this.$resizeObserver.disconnect();\n                this.$resizeTimer.cancel();\n                this.$resizeTimer = this.$resizeObserver = null;\n            }\n            else if (value && !this.$resizeObserver) {\n                this.$addResizeObserver();\n            }\n        }\n    },\n    animatedScroll: { initialValue: false },\n    showInvisibles: {\n        set: function (value) {\n            if (this.$textLayer.setShowInvisibles(value))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: false\n    },\n    showPrintMargin: {\n        set: function () { this.$updatePrintMargin(); },\n        initialValue: true\n    },\n    printMarginColumn: {\n        set: function () { this.$updatePrintMargin(); },\n        initialValue: 80\n    },\n    printMargin: {\n        set: function (val) {\n            if (typeof val == \"number\")\n                this.$printMarginColumn = val;\n            this.$showPrintMargin = !!val;\n            this.$updatePrintMargin();\n        },\n        get: function () {\n            return this.$showPrintMargin && this.$printMarginColumn;\n        }\n    },\n    showGutter: {\n        set: function (show) {\n            this.$gutter.style.display = show ? \"block\" : \"none\";\n            this.$loop.schedule(this.CHANGE_FULL);\n            this.onGutterResize();\n        },\n        initialValue: true\n    },\n    useSvgGutterIcons: {\n        set: function (value) {\n            this.$gutterLayer.$useSvgGutterIcons = value;\n        },\n        initialValue: false\n    },\n    showFoldedAnnotations: {\n        set: function (value) {\n            this.$gutterLayer.$showFoldedAnnotations = value;\n        },\n        initialValue: false\n    },\n    fadeFoldWidgets: {\n        set: function (show) {\n            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n        },\n        initialValue: false\n    },\n    showFoldWidgets: {\n        set: function (show) {\n            this.$gutterLayer.setShowFoldWidgets(show);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    displayIndentGuides: {\n        set: function (show) {\n            if (this.$textLayer.setDisplayIndentGuides(show))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: true\n    },\n    highlightIndentGuides: {\n        set: function (show) {\n            if (this.$textLayer.setHighlightIndentGuides(show) == true) {\n                this.$textLayer.$highlightIndentGuide();\n            }\n            else {\n                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);\n            }\n        },\n        initialValue: true\n    },\n    highlightGutterLine: {\n        set: function (shouldHighlight) {\n            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    hScrollBarAlwaysVisible: {\n        set: function (val) {\n            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    vScrollBarAlwaysVisible: {\n        set: function (val) {\n            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    fontSize: {\n        set: function (size) {\n            if (typeof size == \"number\")\n                size = size + \"px\";\n            this.container.style.fontSize = size;\n            this.updateFontSize();\n        },\n        initialValue: 12\n    },\n    fontFamily: {\n        set: function (name) {\n            this.container.style.fontFamily = name;\n            this.updateFontSize();\n        }\n    },\n    maxLines: {\n        set: function (val) {\n            this.updateFull();\n        }\n    },\n    minLines: {\n        set: function (val) {\n            if (!(this.$minLines < 0x1ffffffffffff))\n                this.$minLines = 0;\n            this.updateFull();\n        }\n    },\n    maxPixelHeight: {\n        set: function (val) {\n            this.updateFull();\n        },\n        initialValue: 0\n    },\n    scrollPastEnd: {\n        set: function (val) {\n            val = +val || 0;\n            if (this.$scrollPastEnd == val)\n                return;\n            this.$scrollPastEnd = val;\n            this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: 0,\n        handlesSet: true\n    },\n    fixedWidthGutter: {\n        set: function (val) {\n            this.$gutterLayer.$fixedWidth = !!val;\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        }\n    },\n    customScrollbar: {\n        set: function (val) {\n            this.$updateCustomScrollbar(val);\n        },\n        initialValue: false\n    },\n    theme: {\n        set: function (val) { this.setTheme(val); },\n        get: function () { return this.$themeId || this.theme; },\n        initialValue: \"./theme/textmate\",\n        handlesSet: true\n    },\n    hasCssTransforms: {},\n    useTextareaForIME: {\n        initialValue: !useragent.isMobile && !useragent.isIE\n    }\n});\nexports.VirtualRenderer = VirtualRenderer;\n\n});\n\nace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar net = require(\"../lib/net\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar config = require(\"../config\");\n\nfunction $workerBlob(workerUrl) {\n    var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n    try {\n        return new Blob([script], {\"type\": \"application/javascript\"});\n    } catch (e) { // Backwards-compatibility\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n        var blobBuilder = new BlobBuilder();\n        blobBuilder.append(script);\n        return blobBuilder.getBlob(\"application/javascript\");\n    }\n}\n\nfunction createWorker(workerUrl) {\n    if (typeof Worker == \"undefined\")\n        return { postMessage: function() {}, terminate: function() {} };\n    if (config.get(\"loadWorkerFromBlob\")) {\n        var blob = $workerBlob(workerUrl);\n        var URL = window.URL || window.webkitURL;\n        var blobURL = URL.createObjectURL(blob);\n        return new Worker(blobURL);\n    }\n    return new Worker(workerUrl);\n}\n\nvar WorkerClient = function(worker) {\n    if (!worker.postMessage)\n        worker = this.$createWorkerFromOldConfig.apply(this, arguments);\n\n    this.$worker = worker;\n    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n\n    this.callbackId = 1;\n    this.callbacks = {};\n\n    this.$worker.onmessage = this.onMessage;\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {\n        if (require.nameToUrl && !require.toUrl)\n            require.toUrl = require.nameToUrl;\n\n        if (config.get(\"packaged\") || !require.toUrl) {\n            workerUrl = workerUrl || config.moduleUrl(mod, \"worker\");\n        } else {\n            var normalizePath = this.$normalizePath;\n            workerUrl = workerUrl || normalizePath(require.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n            var tlns = {};\n            topLevelNamespaces.forEach(function(ns) {\n                tlns[ns] = normalizePath(require.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n            });\n        }\n\n        this.$worker = createWorker(workerUrl);\n        if (importScripts) {\n            this.send(\"importScripts\", importScripts);\n        }\n        this.$worker.postMessage({\n            init : true,\n            tlns : tlns,\n            module : mod,\n            classname : classname\n        });\n        return this.$worker;\n    };\n\n    this.onMessage = function(e) {\n        var msg = e.data;\n        switch (msg.type) {\n            case \"event\":\n                this._signal(msg.name, {data: msg.data});\n                break;\n            case \"call\":\n                var callback = this.callbacks[msg.id];\n                if (callback) {\n                    callback(msg.data);\n                    delete this.callbacks[msg.id];\n                }\n                break;\n            case \"error\":\n                this.reportError(msg.data);\n                break;\n            case \"log\":\n                window.console && console.log && console.log.apply(console, msg.data);\n                break;\n        }\n    };\n    \n    this.reportError = function(err) {\n        window.console && console.error && console.error(err);\n    };\n\n    this.$normalizePath = function(path) {\n        return net.qualifyURL(path);\n    };\n\n    this.terminate = function() {\n        this._signal(\"terminate\", {});\n        this.deltaQueue = null;\n        this.$worker.terminate();\n        this.$worker.onerror = function(e) {\n            e.preventDefault();\n        };\n        this.$worker = null;\n        if (this.$doc)\n            this.$doc.off(\"change\", this.changeListener);\n        this.$doc = null;\n    };\n\n    this.send = function(cmd, args) {\n        this.$worker.postMessage({command: cmd, args: args});\n    };\n\n    this.call = function(cmd, args, callback) {\n        if (callback) {\n            var id = this.callbackId++;\n            this.callbacks[id] = callback;\n            args.push(id);\n        }\n        this.send(cmd, args);\n    };\n\n    this.emit = function(event, data) {\n        try {\n            if (data.data && data.data.err)\n                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};\n                this.$worker && this.$worker.postMessage({event: event, data: {data: data.data}});\n        }\n        catch(ex) {\n            console.error(ex.stack);\n        }\n    };\n\n    this.attachToDocument = function(doc) {\n        if (this.$doc)\n            this.terminate();\n\n        this.$doc = doc;\n        this.call(\"setValue\", [doc.getValue()]);\n        doc.on(\"change\", this.changeListener, true);\n    };\n\n    this.changeListener = function(delta) {\n        if (!this.deltaQueue) {\n            this.deltaQueue = [];\n            setTimeout(this.$sendDeltaQueue, 0);\n        }\n        if (delta.action == \"insert\")\n            this.deltaQueue.push(delta.start, delta.lines);\n        else\n            this.deltaQueue.push(delta.start, delta.end);\n    };\n\n    this.$sendDeltaQueue = function() {\n        var q = this.deltaQueue;\n        if (!q) return;\n        this.deltaQueue = null;\n        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {\n            this.call(\"setValue\", [this.$doc.getValue()]);\n        } else\n            this.emit(\"change\", {data: q});\n    };\n\n}).call(WorkerClient.prototype);\n\n\nvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n    var main = null;\n    var emitSync = false;\n    var sender = Object.create(EventEmitter);\n\n    var messageBuffer = [];\n    var workerClient = new WorkerClient({\n        messageBuffer: messageBuffer,\n        terminate: function() {},\n        postMessage: function(e) {\n            messageBuffer.push(e);\n            if (!main) return;\n            if (emitSync)\n                setTimeout(processNext);\n            else\n                processNext();\n        }\n    });\n\n    workerClient.setEmitSync = function(val) { emitSync = val; };\n\n    var processNext = function() {\n        var msg = messageBuffer.shift();\n        if (msg.command)\n            main[msg.command].apply(main, msg.args);\n        else if (msg.event)\n            sender._signal(msg.event, msg.data);\n    };\n\n    sender.postMessage = function(msg) {\n        workerClient.onMessage({data: msg});\n    };\n    sender.callback = function(data, callbackId) {\n        this.postMessage({type: \"call\", id: callbackId, data: data});\n    };\n    sender.emit = function(name, data) {\n        this.postMessage({type: \"event\", name: name, data: data});\n    };\n\n    config.loadModule([\"worker\", mod], function(Main) {\n        main = new Main[classname](sender);\n        while (messageBuffer.length)\n            processNext();\n    });\n\n    return workerClient;\n};\n\nexports.UIWorkerClient = UIWorkerClient;\nexports.WorkerClient = WorkerClient;\nexports.createWorker = createWorker;\n\n\n});\n\nace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar oop = require(\"./lib/oop\");\nvar PlaceHolder = /** @class */ (function () {\n    function PlaceHolder(session, length, pos, others, mainClass, othersClass) {\n        var _self = this;\n        this.length = length;\n        this.session = session;\n        this.doc = session.getDocument();\n        this.mainClass = mainClass;\n        this.othersClass = othersClass;\n        this.$onUpdate = this.onUpdate.bind(this);\n        this.doc.on(\"change\", this.$onUpdate, true);\n        this.$others = others;\n        this.$onCursorChange = function () {\n            setTimeout(function () {\n                _self.onCursorChange();\n            });\n        };\n        this.$pos = pos;\n        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()[\"$undostack\"] || { length: -1 };\n        this.$undoStackDepth = undoStack.length;\n        this.setup();\n        session.selection.on(\"changeCursor\", this.$onCursorChange);\n    }\n    PlaceHolder.prototype.setup = function () {\n        var _self = this;\n        var doc = this.doc;\n        var session = this.session;\n        this.selectionBefore = session.selection.toJSON();\n        if (session.selection.inMultiSelectMode)\n            session.selection.toSingleRange();\n        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);\n        var pos = this.pos;\n        pos.$insertRight = true;\n        pos.detach();\n        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n        this.others = [];\n        this.$others.forEach(function (other) {\n            var anchor = doc.createAnchor(other.row, other.column);\n            anchor.$insertRight = true;\n            anchor.detach();\n            _self.others.push(anchor);\n        });\n        session.setUndoSelect(false);\n    };\n    PlaceHolder.prototype.showOtherMarkers = function () {\n        if (this.othersActive)\n            return;\n        var session = this.session;\n        var _self = this;\n        this.othersActive = true;\n        this.others.forEach(function (anchor) {\n            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);\n        });\n    };\n    PlaceHolder.prototype.hideOtherMarkers = function () {\n        if (!this.othersActive)\n            return;\n        this.othersActive = false;\n        for (var i = 0; i < this.others.length; i++) {\n            this.session.removeMarker(this.others[i].markerId);\n        }\n    };\n    PlaceHolder.prototype.onUpdate = function (delta) {\n        if (this.$updating)\n            return this.updateAnchors(delta);\n        var range = delta;\n        if (range.start.row !== range.end.row)\n            return;\n        if (range.start.row !== this.pos.row)\n            return;\n        this.$updating = true;\n        var lengthDiff = delta.action === \"insert\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;\n        var distanceFromStart = range.start.column - this.pos.column;\n        this.updateAnchors(delta);\n        if (inMainRange)\n            this.length += lengthDiff;\n        if (inMainRange && !this.session.$fromUndo) {\n            if (delta.action === 'insert') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };\n                    this.doc.insertMergedLines(newPos, delta.lines);\n                }\n            }\n            else if (delta.action === 'remove') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };\n                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n                }\n            }\n        }\n        this.$updating = false;\n        this.updateMarkers();\n    };\n    PlaceHolder.prototype.updateAnchors = function (delta) {\n        this.pos.onChange(delta);\n        for (var i = this.others.length; i--;)\n            this.others[i].onChange(delta);\n        this.updateMarkers();\n    };\n    PlaceHolder.prototype.updateMarkers = function () {\n        if (this.$updating)\n            return;\n        var _self = this;\n        var session = this.session;\n        var updateMarker = function (pos, className) {\n            session.removeMarker(pos.markerId);\n            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);\n        };\n        updateMarker(this.pos, this.mainClass);\n        for (var i = this.others.length; i--;)\n            updateMarker(this.others[i], this.othersClass);\n    };\n    PlaceHolder.prototype.onCursorChange = function (event) {\n        if (this.$updating || !this.session)\n            return;\n        var pos = this.session.selection.getCursor();\n        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n            this.showOtherMarkers();\n            this._emit(\"cursorEnter\", event);\n        }\n        else {\n            this.hideOtherMarkers();\n            this._emit(\"cursorLeave\", event);\n        }\n    };\n    PlaceHolder.prototype.detach = function () {\n        this.session.removeMarker(this.pos && this.pos.markerId);\n        this.hideOtherMarkers();\n        this.doc.off(\"change\", this.$onUpdate);\n        this.session.selection.off(\"changeCursor\", this.$onCursorChange);\n        this.session.setUndoSelect(true);\n        this.session = null;\n    };\n    PlaceHolder.prototype.cancel = function () {\n        if (this.$undoStackDepth === -1)\n            return;\n        var undoManager = this.session.getUndoManager();\n        var undosRequired = (undoManager.$undoStack || undoManager[\"$undostack\"]).length - this.$undoStackDepth;\n        for (var i = 0; i < undosRequired; i++) {\n            undoManager.undo(this.session, true);\n        }\n        if (this.selectionBefore)\n            this.session.selection.fromJSON(this.selectionBefore);\n    };\n    return PlaceHolder;\n}());\noop.implement(PlaceHolder.prototype, EventEmitter);\nexports.PlaceHolder = PlaceHolder;\n\n});\n\nace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module){var event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nfunction onMouseDown(e) {\n    var ev = e.domEvent;\n    var alt = ev.altKey;\n    var shift = ev.shiftKey;\n    var ctrl = ev.ctrlKey;\n    var accel = e.getAccelKey();\n    var button = e.getButton();\n    if (ctrl && useragent.isMac)\n        button = ev.button;\n    if (e.editor.inMultiSelectMode && button == 2) {\n        e.editor.textInput.onContextMenu(e.domEvent);\n        return;\n    }\n    if (!ctrl && !alt && !accel) {\n        if (button === 0 && e.editor.inMultiSelectMode)\n            e.editor.exitMultiSelectMode();\n        return;\n    }\n    if (button !== 0)\n        return;\n    var editor = e.editor;\n    var selection = editor.selection;\n    var isMultiSelect = editor.inMultiSelectMode;\n    var pos = e.getDocumentPosition();\n    var cursor = selection.getCursor();\n    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n    var mouseX = e.x, mouseY = e.y;\n    var onMouseSelection = function (e) {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    var session = editor.session;\n    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n    var screenCursor = screenAnchor;\n    var selectionMode;\n    if (editor.$mouseHandler.$enableJumpToDef) {\n        if (ctrl && alt || accel && alt)\n            selectionMode = shift ? \"block\" : \"add\";\n        else if (alt && editor.$blockSelectEnabled)\n            selectionMode = \"block\";\n    }\n    else {\n        if (accel && !alt) {\n            selectionMode = \"add\";\n            if (!isMultiSelect && shift)\n                return;\n        }\n        else if (alt && editor.$blockSelectEnabled) {\n            selectionMode = \"block\";\n        }\n    }\n    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n        editor.$mouseHandler.cancelContextMenu();\n    }\n    if (selectionMode == \"add\") {\n        if (!isMultiSelect && inSelection)\n            return; // dragging\n        if (!isMultiSelect) {\n            var range = selection.toOrientedRange();\n            editor.addSelectionMarker(range);\n        }\n        var oldRange = selection.rangeList.rangeAtPoint(pos);\n        editor.inVirtualSelectionMode = true;\n        if (shift) {\n            oldRange = null;\n            range = selection.ranges[0] || range;\n            editor.removeSelectionMarker(range);\n        }\n        editor.once(\"mouseup\", function () {\n            var tmpSel = selection.toOrientedRange();\n            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n                selection.substractPoint(tmpSel.cursor);\n            else {\n                if (shift) {\n                    selection.substractPoint(range.cursor);\n                }\n                else if (range) {\n                    editor.removeSelectionMarker(range);\n                    selection.addRange(range);\n                }\n                selection.addRange(tmpSel);\n            }\n            editor.inVirtualSelectionMode = false;\n        });\n    }\n    else if (selectionMode == \"block\") {\n        e.stop();\n        editor.inVirtualSelectionMode = true;\n        var initialRange;\n        var rectSel = [];\n        var blockSelect = function () {\n            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);\n            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n                return;\n            screenCursor = newCursor;\n            editor.selection.moveToPosition(cursor);\n            editor.renderer.scrollCursorIntoView();\n            editor.removeSelectionMarkers(rectSel);\n            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n            rectSel.forEach(editor.addSelectionMarker, editor);\n            editor.updateSelectionMarkers();\n        };\n        if (isMultiSelect && !accel) {\n            selection.toSingleRange();\n        }\n        else if (!isMultiSelect && accel) {\n            initialRange = selection.toOrientedRange();\n            editor.addSelectionMarker(initialRange);\n        }\n        if (shift)\n            screenAnchor = session.documentToScreenPosition(selection.lead);\n        else\n            selection.moveToPosition(pos);\n        screenCursor = { row: -1, column: -1 };\n        var onMouseSelectionEnd = function (e) {\n            blockSelect();\n            clearInterval(timerId);\n            editor.removeSelectionMarkers(rectSel);\n            if (!rectSel.length)\n                rectSel = [selection.toOrientedRange()];\n            if (initialRange) {\n                editor.removeSelectionMarker(initialRange);\n                selection.toSingleRange(initialRange);\n            }\n            for (var i = 0; i < rectSel.length; i++)\n                selection.addRange(rectSel[i]);\n            editor.inVirtualSelectionMode = false;\n            editor.$mouseHandler.$clickSelection = null;\n        };\n        var onSelectionInterval = blockSelect;\n        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n        var timerId = setInterval(function () { onSelectionInterval(); }, 20);\n        return e.preventDefault();\n    }\n}\nexports.onMouseDown = onMouseDown;\n\n});\n\nace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(require, exports, module){/**\n * commands to enter multiselect mode\n * @type {import(\"../../ace-internal\").Ace.Command[]}\n */\nexports.defaultCommands = [{\n        name: \"addCursorAbove\",\n        description: \"Add cursor above\",\n        exec: function (editor) { editor.selectMoreLines(-1); },\n        bindKey: { win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorBelow\",\n        description: \"Add cursor below\",\n        exec: function (editor) { editor.selectMoreLines(1); },\n        bindKey: { win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorAboveSkipCurrent\",\n        description: \"Add cursor above (skip current)\",\n        exec: function (editor) { editor.selectMoreLines(-1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"addCursorBelowSkipCurrent\",\n        description: \"Add cursor below (skip current)\",\n        exec: function (editor) { editor.selectMoreLines(1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectMoreBefore\",\n        description: \"Select more before\",\n        exec: function (editor) { editor.selectMore(-1); },\n        bindKey: { win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectMoreAfter\",\n        description: \"Select more after\",\n        exec: function (editor) { editor.selectMore(1); },\n        bindKey: { win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectNextBefore\",\n        description: \"Select next before\",\n        exec: function (editor) { editor.selectMore(-1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"selectNextAfter\",\n        description: \"Select next after\",\n        exec: function (editor) { editor.selectMore(1, true); },\n        bindKey: { win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }, {\n        name: \"toggleSplitSelectionIntoLines\",\n        description: \"Split selection into lines\",\n        exec: function (editor) {\n            if (editor.multiSelect.rangeCount > 1)\n                editor.multiSelect.joinSelections();\n            else\n                editor.multiSelect.splitIntoLines();\n        },\n        bindKey: { win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\" },\n        readOnly: true\n    }, {\n        name: \"splitSelectionIntoLines\",\n        description: \"Split into lines\",\n        exec: function (editor) { editor.multiSelect.splitIntoLines(); },\n        readOnly: true\n    }, {\n        name: \"alignCursors\",\n        description: \"Align cursors\",\n        exec: function (editor) { editor.alignCursors(); },\n        bindKey: { win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\" },\n        scrollIntoView: \"cursor\"\n    }, {\n        name: \"findAll\",\n        description: \"Find all\",\n        exec: function (editor) { editor.findAll(); },\n        bindKey: { win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\" },\n        scrollIntoView: \"cursor\",\n        readOnly: true\n    }];\nexports.multiSelectCommands = [{\n        name: \"singleSelection\",\n        description: \"Single selection\",\n        bindKey: \"esc\",\n        exec: function (editor) { editor.exitMultiSelectMode(); },\n        scrollIntoView: \"cursor\",\n        readOnly: true,\n        isAvailable: function (editor) { return editor && editor.inMultiSelectMode; }\n    }];\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nexports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n});\n\nace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(require, exports, module){/**\n * @typedef {import(\"./anchor\").Anchor} Anchor\n * @typedef {import(\"../ace-internal\").Ace.Point} Point\n * @typedef {import(\"../ace-internal\").Ace.ScreenCoordinates} ScreenCoordinates\n */\nvar RangeList = require(\"./range_list\").RangeList;\nvar Range = require(\"./range\").Range;\nvar Selection = require(\"./selection\").Selection;\nvar onMouseDown = require(\"./mouse/multi_select_handler\").onMouseDown;\nvar event = require(\"./lib/event\");\nvar lang = require(\"./lib/lang\");\nvar commands = require(\"./commands/multi_select_commands\");\nexports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\nvar Search = require(\"./search\").Search;\nvar search = new Search();\nfunction find(session, needle, dir) {\n    search.$options.wrap = true;\n    search.$options.needle = needle;\n    search.$options.backwards = dir == -1;\n    return search.find(session);\n}\nvar EditSession = require(\"./edit_session\").EditSession;\n(function () {\n    this.getSelectionMarkers = function () {\n        return this.$selectionMarkers;\n    };\n}).call(EditSession.prototype);\n(function () {\n    this.ranges = null;\n    this.rangeList = null;\n    this.addRange = function (range, $blockChangeEvents) {\n        if (!range)\n            return;\n        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n            var oldRange = this.toOrientedRange();\n            this.rangeList.add(oldRange);\n            this.rangeList.add(range);\n            if (this.rangeList.ranges.length != 2) {\n                this.rangeList.removeAll();\n                return $blockChangeEvents || this.fromOrientedRange(range);\n            }\n            this.rangeList.removeAll();\n            this.rangeList.add(oldRange);\n            this.$onAddRange(oldRange);\n        }\n        if (!range.cursor)\n            range.cursor = range.end;\n        var removed = this.rangeList.add(range);\n        this.$onAddRange(range);\n        if (removed.length)\n            this.$onRemoveRange(removed);\n        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n            this._signal(\"multiSelect\");\n            this.inMultiSelectMode = true;\n            this.session.$undoSelect = false;\n            this.rangeList.attach(this.session);\n        }\n        return $blockChangeEvents || this.fromOrientedRange(range);\n    };\n    this.toSingleRange = function (range) {\n        range = range || this.ranges[0];\n        var removed = this.rangeList.removeAll();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n        range && this.fromOrientedRange(range);\n    };\n    this.substractPoint = function (pos) {\n        var removed = this.rangeList.substractPoint(pos);\n        if (removed) {\n            this.$onRemoveRange(removed);\n            return removed[0];\n        }\n    };\n    this.mergeOverlappingRanges = function () {\n        var removed = this.rangeList.merge();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n    };\n    this.$onAddRange = function (range) {\n        this.rangeCount = this.rangeList.ranges.length;\n        this.ranges.unshift(range);\n        this._signal(\"addRange\", { range: range });\n    };\n    this.$onRemoveRange = function (removed) {\n        this.rangeCount = this.rangeList.ranges.length;\n        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n            var lastRange = this.rangeList.ranges.pop();\n            removed.push(lastRange);\n            this.rangeCount = 0;\n        }\n        for (var i = removed.length; i--;) {\n            var index = this.ranges.indexOf(removed[i]);\n            this.ranges.splice(index, 1);\n        }\n        this._signal(\"removeRange\", { ranges: removed });\n        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n            this.inMultiSelectMode = false;\n            this._signal(\"singleSelect\");\n            this.session.$undoSelect = true;\n            this.rangeList.detach(this.session);\n        }\n        lastRange = lastRange || this.ranges[0];\n        if (lastRange && !lastRange.isEqual(this.getRange()))\n            this.fromOrientedRange(lastRange);\n    };\n    this.$initRangeList = function () {\n        if (this.rangeList)\n            return;\n        this.rangeList = new RangeList();\n        this.ranges = [];\n        this.rangeCount = 0;\n    };\n    this.getAllRanges = function () {\n        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n    };\n    this.splitIntoLines = function () {\n        var ranges = this.ranges.length ? this.ranges : [this.getRange()];\n        var newRanges = [];\n        for (var i = 0; i < ranges.length; i++) {\n            var range = ranges[i];\n            var row = range.start.row;\n            var endRow = range.end.row;\n            if (row === endRow) {\n                newRanges.push(range.clone());\n            }\n            else {\n                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));\n                while (++row < endRow)\n                    newRanges.push(this.getLineRange(row, true));\n                newRanges.push(new Range(endRow, 0, endRow, range.end.column));\n            }\n            if (i == 0 && !this.isBackwards())\n                newRanges = newRanges.reverse();\n        }\n        this.toSingleRange();\n        for (var i = newRanges.length; i--;)\n            this.addRange(newRanges[i]);\n    };\n    this.joinSelections = function () {\n        var ranges = this.rangeList.ranges;\n        var lastRange = ranges[ranges.length - 1];\n        var range = Range.fromPoints(ranges[0].start, lastRange.end);\n        this.toSingleRange();\n        this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n    };\n    this.toggleBlockSelection = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        }\n        else {\n            var cursor = this.session.documentToScreenPosition(this.cursor);\n            var anchor = this.session.documentToScreenPosition(this.anchor);\n            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {\n        var rectSel = [];\n        var xBackwards = screenCursor.column < screenAnchor.column;\n        if (xBackwards) {\n            var startColumn = screenCursor.column;\n            var endColumn = screenAnchor.column;\n            var startOffsetX = screenCursor.offsetX;\n            var endOffsetX = screenAnchor.offsetX;\n        }\n        else {\n            var startColumn = screenAnchor.column;\n            var endColumn = screenCursor.column;\n            var startOffsetX = screenAnchor.offsetX;\n            var endOffsetX = screenCursor.offsetX;\n        }\n        var yBackwards = screenCursor.row < screenAnchor.row;\n        if (yBackwards) {\n            var startRow = screenCursor.row;\n            var endRow = screenAnchor.row;\n        }\n        else {\n            var startRow = screenAnchor.row;\n            var endRow = screenCursor.row;\n        }\n        if (startColumn < 0)\n            startColumn = 0;\n        if (startRow < 0)\n            startRow = 0;\n        if (startRow == endRow)\n            includeEmptyLines = true;\n        var docEnd;\n        for (var row = startRow; row <= endRow; row++) {\n            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));\n            if (range.isEmpty()) {\n                if (docEnd && isSamePoint(range.end, docEnd))\n                    break;\n                docEnd = range.end;\n            }\n            range.cursor = xBackwards ? range.start : range.end;\n            rectSel.push(range);\n        }\n        if (yBackwards)\n            rectSel.reverse();\n        if (!includeEmptyLines) {\n            var end = rectSel.length - 1;\n            while (rectSel[end].isEmpty() && end > 0)\n                end--;\n            if (end > 0) {\n                var start = 0;\n                while (rectSel[start].isEmpty())\n                    start++;\n            }\n            for (var i = end; i >= start; i--) {\n                if (rectSel[i].isEmpty())\n                    rectSel.splice(i, 1);\n            }\n        }\n        return rectSel;\n    };\n}).call(Selection.prototype);\nvar Editor = require(\"./editor\").Editor;\n(function () {\n    this.updateSelectionMarkers = function () {\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.addSelectionMarker = function (orientedRange) {\n        if (!orientedRange.cursor)\n            orientedRange.cursor = orientedRange.end;\n        var style = this.getSelectionStyle();\n        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n        this.session.$selectionMarkers.push(orientedRange);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n        return orientedRange;\n    };\n    this.removeSelectionMarker = function (range) {\n        if (!range.marker)\n            return;\n        this.session.removeMarker(range.marker);\n        var index = this.session.$selectionMarkers.indexOf(range);\n        if (index != -1)\n            this.session.$selectionMarkers.splice(index, 1);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n    };\n    this.removeSelectionMarkers = function (ranges) {\n        var markerList = this.session.$selectionMarkers;\n        for (var i = ranges.length; i--;) {\n            var range = ranges[i];\n            if (!range.marker)\n                continue;\n            this.session.removeMarker(range.marker);\n            var index = markerList.indexOf(range);\n            if (index != -1)\n                markerList.splice(index, 1);\n        }\n        this.session.selectionMarkerCount = markerList.length;\n    };\n    this.$onAddRange = function (e) {\n        this.addSelectionMarker(e.range);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onRemoveRange = function (e) {\n        this.removeSelectionMarkers(e.ranges);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onMultiSelect = function (e) {\n        if (this.inMultiSelectMode)\n            return;\n        this.inMultiSelectMode = true;\n        this.setStyle(\"ace_multiselect\");\n        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.$onSingleSelect = function (e) {\n        if (this.session.multiSelect.inVirtualMode)\n            return;\n        this.inMultiSelectMode = false;\n        this.unsetStyle(\"ace_multiselect\");\n        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n        this._emit(\"changeSelection\");\n    };\n    this.$onMultiSelectExec = function (e) {\n        var command = e.command;\n        var editor = e.editor;\n        if (!editor.multiSelect)\n            return;\n        if (!command.multiSelectAction) {\n            var result = command.exec(editor, e.args || {});\n            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n            editor.multiSelect.mergeOverlappingRanges();\n        }\n        else if (command.multiSelectAction == \"forEach\") {\n            result = editor.forEachSelection(command, e.args);\n        }\n        else if (command.multiSelectAction == \"forEachLine\") {\n            result = editor.forEachSelection(command, e.args, true);\n        }\n        else if (command.multiSelectAction == \"single\") {\n            editor.exitMultiSelectMode();\n            result = command.exec(editor, e.args || {});\n        }\n        else {\n            result = command.multiSelectAction(editor, e.args || {});\n        }\n        return result;\n    };\n    this.forEachSelection = function (cmd, args, options) {\n        if (this.inVirtualSelectionMode)\n            return;\n        var keepOrder = options && options.keepOrder;\n        var $byLines = options == true || options && options.$byLines;\n        var session = this.session;\n        var selection = this.selection;\n        var rangeList = selection.rangeList;\n        var ranges = (keepOrder ? selection : rangeList).ranges;\n        var result;\n        if (!ranges.length)\n            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n        var reg = selection._eventRegistry;\n        selection._eventRegistry = {};\n        var tmpSel = new Selection(session);\n        this.inVirtualSelectionMode = true;\n        for (var i = ranges.length; i--;) {\n            if ($byLines) {\n                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n                    i--;\n            }\n            tmpSel.fromOrientedRange(ranges[i]);\n            tmpSel.index = i;\n            this.selection = session.selection = tmpSel;\n            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n            if (!result && cmdResult !== undefined)\n                result = cmdResult;\n            tmpSel.toOrientedRange(ranges[i]);\n        }\n        tmpSel.detach();\n        this.selection = session.selection = selection;\n        this.inVirtualSelectionMode = false;\n        selection._eventRegistry = reg;\n        selection.mergeOverlappingRanges();\n        if (selection.ranges[0])\n            selection.fromOrientedRange(selection.ranges[0]);\n        var anim = this.renderer.$scrollAnimation;\n        this.onCursorChange();\n        this.onSelectionChange();\n        if (anim && anim.from == anim.to)\n            this.renderer.animateScrolling(anim.from);\n        return result;\n    };\n    this.exitMultiSelectMode = function () {\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n            return;\n        this.multiSelect.toSingleRange();\n    };\n    this.getSelectedText = function () {\n        var text = \"\";\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var ranges = this.multiSelect.rangeList.ranges;\n            var buf = [];\n            for (var i = 0; i < ranges.length; i++) {\n                buf.push(this.session.getTextRange(ranges[i]));\n            }\n            var nl = this.session.getDocument().getNewLineCharacter();\n            text = buf.join(nl);\n            if (text.length == (buf.length - 1) * nl.length)\n                text = \"\";\n        }\n        else if (!this.selection.isEmpty()) {\n            text = this.session.getTextRange(this.getSelectionRange());\n        }\n        return text;\n    };\n    this.$checkMultiselectChange = function (e, anchor) {\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var range = this.multiSelect.ranges[0];\n            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n                return;\n            var pos = anchor == this.multiSelect.anchor\n                ? range.cursor == range.start ? range.end : range.start\n                : range.cursor;\n            if (pos.row != anchor.row\n                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)\n                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n            else\n                this.multiSelect.mergeOverlappingRanges();\n        }\n    };\n    this.findAll = function (needle, options, additive) {\n        options = options || {};\n        options.needle = needle || options.needle;\n        if (options.needle == undefined) {\n            var range = this.selection.isEmpty()\n                ? this.selection.getWordRange()\n                : this.selection.getRange();\n            options.needle = this.session.getTextRange(range);\n        }\n        this.$search.set(options);\n        var ranges = this.$search.findAll(this.session);\n        if (!ranges.length)\n            return 0;\n        var selection = this.multiSelect;\n        if (!additive)\n            selection.toSingleRange(ranges[0]);\n        for (var i = ranges.length; i--;)\n            selection.addRange(ranges[i], true);\n        if (range && selection.rangeList.rangeAtPoint(range.start))\n            selection.addRange(range, true);\n        return ranges.length;\n    };\n    this.selectMoreLines = function (dir, skip) {\n        var range = this.selection.toOrientedRange();\n        var isBackwards = range.cursor == range.end;\n        var screenLead = this.session.documentToScreenPosition(range.cursor);\n        if (this.selection.$desiredColumn)\n            screenLead.column = this.selection.$desiredColumn;\n        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n        if (!range.isEmpty()) {\n            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n        }\n        else {\n            var anchor = lead;\n        }\n        if (isBackwards) {\n            var newRange = Range.fromPoints(lead, anchor);\n            newRange.cursor = newRange.start;\n        }\n        else {\n            var newRange = Range.fromPoints(anchor, lead);\n            newRange.cursor = newRange.end;\n        }\n        newRange.desiredColumn = screenLead.column;\n        if (!this.selection.inMultiSelectMode) {\n            this.selection.addRange(range);\n        }\n        else {\n            if (skip)\n                var toRemove = range.cursor;\n        }\n        this.selection.addRange(newRange);\n        if (toRemove)\n            this.selection.substractPoint(toRemove);\n    };\n    this.transposeSelections = function (dir) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var all = sel.ranges;\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            if (range.isEmpty()) {\n                var tmp_1 = session.getWordRange(range.start.row, range.start.column);\n                range.start.row = tmp_1.start.row;\n                range.start.column = tmp_1.start.column;\n                range.end.row = tmp_1.end.row;\n                range.end.column = tmp_1.end.column;\n            }\n        }\n        sel.mergeOverlappingRanges();\n        var words = [];\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            words.unshift(session.getTextRange(range));\n        }\n        if (dir < 0)\n            words.unshift(words.pop());\n        else\n            words.push(words.shift());\n        for (var i = all.length; i--;) {\n            var range = all[i];\n            var tmp = range.clone();\n            session.replace(range, words[i]);\n            range.start.row = tmp.start.row;\n            range.start.column = tmp.start.column;\n        }\n        sel.fromOrientedRange(sel.ranges[0]);\n    };\n    this.selectMore = function (dir, skip, stopAtFirst) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var range = sel.toOrientedRange();\n        if (range.isEmpty()) {\n            range = session.getWordRange(range.start.row, range.start.column);\n            range.cursor = dir == -1 ? range.start : range.end;\n            this.multiSelect.addRange(range);\n            if (stopAtFirst)\n                return;\n        }\n        var needle = session.getTextRange(range);\n        var newRange = find(session, needle, dir);\n        if (newRange) {\n            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n            this.session.unfold(newRange);\n            this.multiSelect.addRange(newRange);\n            this.renderer.scrollCursorIntoView(null, 0.5);\n        }\n        if (skip)\n            this.multiSelect.substractPoint(range.cursor);\n    };\n    this.alignCursors = function () {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var ranges = sel.ranges;\n        var row = -1;\n        var sameRowRanges = ranges.filter(function (r) {\n            if (r.cursor.row == row)\n                return true;\n            row = r.cursor.row;\n        });\n        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n            var range = this.selection.getRange();\n            var fr = range.start.row, lr = range.end.row;\n            var guessRange = fr == lr;\n            if (guessRange) {\n                var max = this.session.getLength();\n                var line;\n                do {\n                    line = this.session.getLine(lr);\n                } while (/[=:]/.test(line) && ++lr < max);\n                do {\n                    line = this.session.getLine(fr);\n                } while (/[=:]/.test(line) && --fr > 0);\n                if (fr < 0)\n                    fr = 0;\n                if (lr >= max)\n                    lr = max - 1;\n            }\n            var lines = this.session.removeFullLines(fr, lr);\n            lines = this.$reAlignText(lines, guessRange);\n            this.session.insert({ row: fr, column: 0 }, lines.join(\"\\n\") + \"\\n\");\n            if (!guessRange) {\n                range.start.column = 0;\n                range.end.column = lines[lines.length - 1].length;\n            }\n            this.selection.setRange(range);\n        }\n        else {\n            sameRowRanges.forEach(function (r) {\n                sel.substractPoint(r.cursor);\n            });\n            var maxCol = 0;\n            var minSpace = Infinity;\n            var spaceOffsets = ranges.map(function (r) {\n                var p = r.cursor;\n                var line = session.getLine(p.row);\n                var spaceOffset = line.substr(p.column).search(/\\S/g);\n                if (spaceOffset == -1)\n                    spaceOffset = 0;\n                if (p.column > maxCol)\n                    maxCol = p.column;\n                if (spaceOffset < minSpace)\n                    minSpace = spaceOffset;\n                return spaceOffset;\n            });\n            ranges.forEach(function (r, i) {\n                var p = r.cursor;\n                var l = maxCol - p.column;\n                var d = spaceOffsets[i] - minSpace;\n                if (l > d)\n                    session.insert(p, lang.stringRepeat(\" \", l - d));\n                else\n                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n                r.start.column = r.end.column = maxCol;\n                r.start.row = r.end.row = p.row;\n                r.cursor = r.end;\n            });\n            sel.fromOrientedRange(ranges[0]);\n            this.renderer.updateCursor();\n            this.renderer.updateBackMarkers();\n        }\n    };\n    this.$reAlignText = function (lines, forceLeft) {\n        var isLeftAligned = true, isRightAligned = true;\n        var startW, textW, endW;\n        return lines.map(function (line) {\n            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n            if (!m)\n                return [line];\n            if (startW == null) {\n                startW = m[1].length;\n                textW = m[2].length;\n                endW = m[3].length;\n                return m;\n            }\n            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n                isRightAligned = false;\n            if (startW != m[1].length)\n                isLeftAligned = false;\n            if (startW > m[1].length)\n                startW = m[1].length;\n            if (textW < m[2].length)\n                textW = m[2].length;\n            if (endW > m[3].length)\n                endW = m[3].length;\n            return m;\n        }).map(forceLeft ? alignLeft :\n            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n        function spaces(n) {\n            return lang.stringRepeat(\" \", n);\n        }\n        function alignLeft(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(textW - m[2].length + endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function alignRight(m) {\n            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function unAlign(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n    };\n}).call(Editor.prototype);\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nexports.onSessionChange = function (e) {\n    var session = e.session;\n    if (session && !session.multiSelect) {\n        session.$selectionMarkers = [];\n        session.selection.$initRangeList();\n        session.multiSelect = session.selection;\n    }\n    this.multiSelect = session && session.multiSelect;\n    var oldSession = e.oldSession;\n    if (oldSession) {\n        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n        oldSession.multiSelect.lead.off(\"change\", this.$checkMultiselectChange);\n        oldSession.multiSelect.anchor.off(\"change\", this.$checkMultiselectChange);\n    }\n    if (session) {\n        session.multiSelect.on(\"addRange\", this.$onAddRange);\n        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n        session.multiSelect.lead.on(\"change\", this.$checkMultiselectChange);\n        session.multiSelect.anchor.on(\"change\", this.$checkMultiselectChange);\n    }\n    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n        if (session.selection.inMultiSelectMode)\n            this.$onMultiSelect();\n        else\n            this.$onSingleSelect();\n    }\n};\nfunction MultiSelect(editor) {\n    if (editor.$multiselectOnSessionChange)\n        return;\n    editor.$onAddRange = editor.$onAddRange.bind(editor);\n    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n    editor.$multiselectOnSessionChange(editor);\n    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n    editor.on(\"mousedown\", onMouseDown);\n    editor.commands.addCommands(commands.defaultCommands);\n    addAltCursorListeners(editor);\n}\nfunction addAltCursorListeners(editor) {\n    if (!editor.textInput)\n        return;\n    var el = editor.textInput.getElement();\n    var altCursor = false;\n    event.addListener(el, \"keydown\", function (e) {\n        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);\n        if (editor.$blockSelectEnabled && altDown) {\n            if (!altCursor) {\n                editor.renderer.setMouseCursor(\"crosshair\");\n                altCursor = true;\n            }\n        }\n        else if (altCursor) {\n            reset();\n        }\n    }, editor);\n    event.addListener(el, \"keyup\", reset, editor);\n    event.addListener(el, \"blur\", reset, editor);\n    function reset(e) {\n        if (altCursor) {\n            editor.renderer.setMouseCursor(\"\");\n            altCursor = false;\n        }\n    }\n}\nexports.MultiSelect = MultiSelect;\nrequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    enableMultiselect: {\n        set: function (val) {\n            MultiSelect(this);\n            if (val) {\n                this.on(\"mousedown\", onMouseDown);\n            }\n            else {\n                this.off(\"mousedown\", onMouseDown);\n            }\n        },\n        value: true\n    },\n    enableBlockSelect: {\n        set: function (val) {\n            this.$blockSelectEnabled = val;\n        },\n        value: true\n    }\n});\n\n});\n\nace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../../range\").Range;\nvar FoldMode = exports.FoldMode = function () { };\n(function () {\n    this.foldingStartMarker = null;\n    this.foldingStopMarker = null;\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (this.foldingStartMarker.test(line))\n            return \"start\";\n        if (foldStyle == \"markbeginend\"\n            && this.foldingStopMarker\n            && this.foldingStopMarker.test(line))\n            return \"end\";\n        return \"\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        return null;\n    };\n    this.indentationBlock = function (session, row, column) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1)\n            return;\n        var startColumn = column || line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        while (++row < maxRow) {\n            var level = session.getLine(row).search(re);\n            if (level == -1)\n                continue;\n            if (level <= startLevel) {\n                var token = session.getTokenAt(row, 0);\n                if (!token || token.type !== \"string\")\n                    break;\n            }\n            endRow = row;\n        }\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {\n        var start = { row: row, column: column + 1 };\n        var end = session.$findClosingBracket(bracket, start, typeRe);\n        if (!end)\n            return;\n        var fw = session.foldWidgets[end.row];\n        if (fw == null)\n            fw = session.getFoldWidget(end.row);\n        if (fw == \"start\" && end.row > start.row) {\n            end.row--;\n            end.column = session.getLine(end.row).length;\n        }\n        return Range.fromPoints(start, end);\n    };\n    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {\n        var end = { row: row, column: column };\n        var start = session.$findOpeningBracket(bracket, end);\n        if (!start)\n            return;\n        start.column++;\n        end.column--;\n        return Range.fromPoints(start, end);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/range\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar Range = require(\"../range\").Range;\nvar nls = require(\"../config\").nls;\nfunction binarySearch(array, needle, comparator) {\n    var first = 0;\n    var last = array.length - 1;\n    while (first <= last) {\n        var mid = (first + last) >> 1;\n        var c = comparator(needle, array[mid]);\n        if (c > 0)\n            first = mid + 1;\n        else if (c < 0)\n            last = mid - 1;\n        else\n            return mid;\n    }\n    return -(first + 1);\n}\nfunction findAnnotations(session, row, dir) {\n    var annotations = session.getAnnotations().sort(Range.comparePoints);\n    if (!annotations.length)\n        return;\n    var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);\n    if (i < 0)\n        i = -i - 1;\n    if (i >= annotations.length)\n        i = dir > 0 ? 0 : annotations.length - 1;\n    else if (i === 0 && dir < 0)\n        i = annotations.length - 1;\n    var annotation = annotations[i];\n    if (!annotation || !dir)\n        return;\n    if (annotation.row === row) {\n        do {\n            annotation = annotations[i += dir];\n        } while (annotation && annotation.row === row);\n        if (!annotation)\n            return annotations.slice();\n    }\n    var matched = [];\n    row = annotation.row;\n    do {\n        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n        annotation = annotations[i += dir];\n    } while (annotation && annotation.row == row);\n    return matched.length && matched;\n}\nexports.showErrorMarker = function (editor, dir) {\n    var session = editor.session;\n    var pos = editor.getCursorPosition();\n    var row = pos.row;\n    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {\n        return w.type == \"errorMarker\";\n    })[0];\n    if (oldWidget) {\n        oldWidget.destroy();\n    }\n    else {\n        row -= dir;\n    }\n    var annotations = findAnnotations(session, row, dir);\n    var gutterAnno;\n    if (annotations) {\n        var annotation = annotations[0];\n        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n            ? annotation.pos.sc\n            : annotation.column) || 0;\n        pos.row = annotation.row;\n        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n    }\n    else if (oldWidget) {\n        return;\n    }\n    else {\n        gutterAnno = {\n            displayText: [nls(\"error-marker.good-state\", \"Looks good!\")],\n            className: \"ace_ok\"\n        };\n    }\n    editor.session.unfold(pos.row);\n    editor.selection.moveToPosition(pos);\n    var w = {\n        row: pos.row,\n        fixedWidth: true,\n        coverGutter: true,\n        el: dom.createElement(\"div\"),\n        type: \"errorMarker\"\n    };\n    var el = w.el.appendChild(dom.createElement(\"div\"));\n    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n    var left = editor.renderer.$cursorLayer\n        .getPixelPosition(pos).left;\n    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n    w.el.className = \"error_widget_wrapper\";\n    el.className = \"error_widget \" + gutterAnno.className;\n    gutterAnno.displayText.forEach(function (annoTextLine, i) {\n        el.appendChild(dom.createTextNode(annoTextLine));\n        if (i < gutterAnno.displayText.length - 1) {\n            el.appendChild(dom.createElement(\"br\"));\n        }\n    });\n    el.appendChild(dom.createElement(\"div\"));\n    var kb = function (_, hashId, keyString) {\n        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n            w.destroy();\n            return { command: \"null\" };\n        }\n    };\n    w.destroy = function () {\n        if (editor.$mouseHandler.isMousePressed)\n            return;\n        editor.keyBinding.removeKeyboardHandler(kb);\n        session.widgetManager.removeLineWidget(w);\n        editor.off(\"changeSelection\", w.destroy);\n        editor.off(\"changeSession\", w.destroy);\n        editor.off(\"mouseup\", w.destroy);\n        editor.off(\"change\", w.destroy);\n    };\n    editor.keyBinding.addKeyboardHandler(kb);\n    editor.on(\"changeSelection\", w.destroy);\n    editor.on(\"changeSession\", w.destroy);\n    editor.on(\"mouseup\", w.destroy);\n    editor.on(\"change\", w.destroy);\n    editor.session.widgetManager.addLineWidget(w);\n    w.el.onmousedown = editor.focus.bind(editor);\n    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });\n};\ndom.importCssString(\"\\n    .error_widget_wrapper {\\n        background: inherit;\\n        color: inherit;\\n        border:none\\n    }\\n    .error_widget {\\n        border-top: solid 2px;\\n        border-bottom: solid 2px;\\n        margin: 5px 0;\\n        padding: 10px 40px;\\n        white-space: pre-wrap;\\n    }\\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\\n        border-color: #ff5a5a\\n    }\\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\n        border-color: #F1D817\\n    }\\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\\n        border-color: #5a5a5a\\n    }\\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\n        border-color: #5aaa5a\\n    }\\n    .error_widget_arrow {\\n        position: absolute;\\n        border: solid 5px;\\n        border-top-color: transparent!important;\\n        border-right-color: transparent!important;\\n        border-left-color: transparent!important;\\n        top: -5px;\\n    }\\n\", \"error_marker.css\", false);\n\n});\n\nace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/range\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\",\"ace/loader_build\"], function(require, exports, module){/**\n * The main class required to set up an Ace instance in the browser.\n *\n * @namespace Ace\n **/\n\"use strict\";\nrequire(\"./loader_build\")(exports)\nvar dom = require(\"./lib/dom\");\nvar Range = require(\"./range\").Range;\nvar Editor = require(\"./editor\").Editor;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nrequire(\"./worker/worker_client\");\nrequire(\"./keyboard/hash_handler\");\nrequire(\"./placeholder\");\nrequire(\"./multi_select\");\nrequire(\"./mode/folding/fold_mode\");\nrequire(\"./theme/textmate\");\nrequire(\"./ext/error_marker\");\nexports.config = require(\"./config\");\nexports.edit = function (el, options) {\n    if (typeof el == \"string\") {\n        var _id = el;\n        el = document.getElementById(_id);\n        if (!el)\n            throw new Error(\"ace.edit can't find div #\" + _id);\n    }\n    if (el && el.env && el.env.editor instanceof Editor)\n        return el.env.editor;\n    var value = \"\";\n    if (el && /input|textarea/i.test(el.tagName)) {\n        var oldNode = el;\n        value = oldNode.value;\n        el = dom.createElement(\"pre\");\n        oldNode.parentNode.replaceChild(el, oldNode);\n    }\n    else if (el) {\n        value = el.textContent;\n        el.innerHTML = \"\";\n    }\n    var doc = exports.createEditSession(value);\n    var editor = new Editor(new Renderer(el), doc, options);\n    var env = {\n        document: doc,\n        editor: editor,\n        onResize: editor.resize.bind(editor, null)\n    };\n    if (oldNode)\n        env.textarea = oldNode;\n    editor.on(\"destroy\", function () {\n        env.editor.container.env = null; // prevent memory leak on old ie\n    });\n    editor.container.env = editor.env = env;\n    return editor;\n};\nexports.createEditSession = function (text, mode) {\n    var doc = new EditSession(text, mode);\n    doc.setUndoManager(new UndoManager());\n    return doc;\n};\nexports.Range = Range;\nexports.Editor = Editor;\nexports.EditSession = EditSession;\nexports.UndoManager = UndoManager;\nexports.VirtualRenderer = Renderer;\nvar version = exports.config.version;\nexports.version = version;\n\n});            (function() {\n                ace.require([\"ace/ace\"], function(a) {\n                    if (a) {\n                        a.config.init(true);\n                        a.define = ace.define;\n                    }\n                    var global = (function () {\n                        return this;\n                    })();\n                    if (!global && typeof window != \"undefined\") global = window; // can happen in strict mode\n                    if (!global && typeof self != \"undefined\") global = self; // can happen in webworker\n                    \n                    if (!global.ace)\n                        global.ace = a;\n                    for (var key in a) if (a.hasOwnProperty(key))\n                        global.ace[key] = a[key];\n                    global.ace[\"default\"] = global.ace;\n                    if ( true && module) {\n                        module.exports = global.ace;\n                    }\n                });\n            })();\n        //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9hY2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDLDhEQUE4RDs7O0FBRzlEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRCxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDOztBQUVELDBIQUEwSDtBQUMxSDtBQUNBOztBQUVBLENBQUM7O0FBRUQsa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCLHVCQUF1Qix1QkFBdUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSwyREFBMkQscUNBQXFDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELHNHQUFzRztBQUN0RztBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2Qzs7QUFFQSxDQUFDOztBQUVELGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxtTUFBbU07QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbURBQW1ELEtBQUssS0FBSztBQUM3RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsdUdBQXVHLHVDQUF1Qyx3QkFBd0IsZ0JBQWdCLEdBQUcsK0JBQStCLGVBQWUsd0JBQXdCLEdBQUcsdUJBQXVCLGdDQUFnQyxHQUFHLGFBQWEsOEJBQThCLGlCQUFpQixHQUFHLHlCQUF5QixpQkFBaUIsR0FBRyxvQ0FBb0MsOEJBQThCLEdBQUcsaURBQWlELGdCQUFnQixHQUFHLDJCQUEyQiwyQkFBMkIsR0FBRyx1Q0FBdUMsNEJBQTRCLEdBQUcsd0NBQXdDLDRCQUE0QixHQUFHLHVDQUF1QywyQkFBMkIsR0FBRywwQkFBMEIsMkNBQTJDLGVBQWUsR0FBRyx1Q0FBdUMsNEJBQTRCLEdBQUcsdUNBQXVDLDJCQUEyQixHQUFHLG9FQUFvRSw4QkFBOEIsR0FBRyx1Q0FBdUMsOEJBQThCLEdBQUcseUJBQXlCLDBCQUEwQixHQUFHLDBCQUEwQiw2QkFBNkIsR0FBRyxrQ0FBa0MsNEJBQTRCLEdBQUcsMENBQTBDLDhCQUE4QixHQUFHLHVDQUF1QywwQkFBMEIsR0FBRywyQkFBMkIsNkJBQTZCLEdBQUcseUJBQXlCLDZCQUE2QixHQUFHLCtDQUErQyxtQkFBbUIsR0FBRyw0QkFBNEIsMkJBQTJCLEdBQUcsdUJBQXVCLDJCQUEyQixHQUFHLCtCQUErQiwwQkFBMEIsR0FBRyxtQ0FBbUMsNEJBQTRCLDhDQUE4QyxtQ0FBbUMsR0FBRyxvREFBb0Qsa0NBQWtDLEdBQUcsdUNBQXVDLGlDQUFpQyxHQUFHLDBDQUEwQyxtQ0FBbUMsR0FBRyw0Q0FBNEMsMEJBQTBCLHlDQUF5QyxHQUFHLGdEQUFnRCxvQ0FBb0MsR0FBRyxxQ0FBcUMsaUNBQWlDLEdBQUcsa0RBQWtELG1DQUFtQyx5Q0FBeUMsR0FBRywrQkFBK0IscUNBQXFDLGtJQUFrSSxHQUFHLHNDQUFzQyxxQ0FBcUMsOE5BQThOLEdBQUc7O0FBRTluRyxDQUFDOztBQUVELDBJQUEwSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxnTEFBZ0w7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0NBQWtDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsSUFBNEI7QUFDcEMscUJBQXFCLHdCQUFNO0FBQzNCO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csd0JBQU07O0FBRXRHO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSxDQUFDOztBQUVELDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxpSUFBaUksY0FBYztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELG9OQUFvTjtBQUNwTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUIsd0JBQXdCLDRCQUE0QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBdUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCw2Q0FBNkM7QUFDN0Msb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCwrSEFBK0g7QUFDL0g7QUFDQSxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsQ0FBQzs7QUFFRCwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCx1SkFBdUo7QUFDdko7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLHlCQUF5QjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOztBQUVELDBLQUEwSztBQUMxSztBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakM7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3Q0FBd0M7QUFDakcsNERBQTRELHdDQUF3QztBQUNwRywyREFBMkQsd0NBQXdDO0FBQ25HLHdEQUF3RCx3Q0FBd0M7QUFDaEcsd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILDJCQUEyQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZLGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOztBQUVELDZKQUE2SjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCLG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDhKQUE4SjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpREFBaUQ7QUFDM0gsb0VBQW9FLDRDQUE0QztBQUNoSCxtRUFBbUUsMkNBQTJDO0FBQzlHLHNFQUFzRSw2Q0FBNkM7QUFDbkgsbUVBQW1FLDRDQUE0QztBQUMvRyx3REFBd0QsNENBQTRDO0FBQ3BHLHNFQUFzRSwwREFBMEQ7QUFDaEk7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCx3U0FBd1M7QUFDeFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQixtQkFBbUIsa0JBQWtCLGlCQUFpQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLGlCQUFpQiwyQ0FBMkM7QUFDNUQsbUJBQW1CLG9CQUFvQjtBQUN2QyxvQkFBb0IsaUJBQWlCO0FBQ3JDLDJCQUEyQjtBQUMzQixDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCxxSEFBcUg7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlDQUFpQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0MsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFzRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFzRDtBQUNwRjtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCwrSkFBK0o7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELHFIQUFxSDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsdUJBQXVCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUM7O0FBRUQsa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCxpTEFBaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsd0VBQXdFO0FBQ3hFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw2REFBNkQsS0FBSyw0Q0FBNEM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlFQUFpRSw0Q0FBNEMsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRDQUE0QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw0Q0FBNEM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQywyQ0FBMkMsR0FBRztBQUM5QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELHFQQUFxUDtBQUNyUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEUsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLFNBQVMsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxTQUFTLGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRLFNBQVMsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9DQUFvQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsOEtBQThLO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsK0lBQStJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDOztBQUVELGdJQUFnSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDOztBQUVELDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQyx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsdUhBQXVIO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBLHlDQUF5Qyx3QkFBd0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDOztBQUVELHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsdU5BQXVOO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEJBQThCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0Q0FBNEM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsZ0pBQWdKO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2YsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0xBQWtMO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTEFBc0w7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxxTUFBcU07QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU1BQXVNO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxvTUFBb007QUFDcE07QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxrTUFBa007QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsbVlBQW1ZO0FBQ25ZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRCxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNLDBCQUEwQixNQUFNO0FBQ2xHO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0QsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2RUFBNkUsRUFBRTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0MsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsK0ZBQStGLEVBQUUsSUFBSSxFQUFFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLElBQUksRUFBRTtBQUNoRCxpQ0FBaUMsRUFBRSxJQUFJLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDZJQUE2STtBQUM3STtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUMsS0FBSztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNERBQTRELE9BQU8sVUFBVSxHQUFHO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixXQUFXO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsK0tBQStLO0FBQy9LO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUM7O0FBRUQsc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsbUJBQW1CO0FBQ3JGLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNDQUFzQztBQUN4RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFpRTtBQUM5RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWdFO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQsK0NBQStDLGdDQUFnQztBQUMvRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0MsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5Q0FBeUM7QUFDM0U7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDOztBQUVELDhKQUE4SjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsK2VBQStlO0FBQy9lO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQztBQUNsRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixxQkFBcUI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBMEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEUsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsb0JBQW9CO0FBQzdDLDZCQUE2QixvQkFBb0I7QUFDakQsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBLDhCQUE4QjtBQUM5QixLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdELDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNELDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdDQUFnQyxZQUFZLHFCQUFxQixPQUFPO0FBQ3hFO0FBQ0EsS0FBSztBQUNMLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0EsS0FBSztBQUNMLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsbU1BQW1NO0FBQ25NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxTQUFTO0FBQzdHO0FBQ0E7QUFDQSxvRkFBb0YsU0FBUztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNkJBQTZCLHVCQUF1QixvQkFBb0I7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsdUNBQXVDO0FBQ3ZDLG1DQUFtQztBQUNuQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsbUNBQW1DO0FBQ25DLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx3RUFBd0U7QUFDeEUsbUNBQW1DO0FBQ25DLDJEQUEyRDtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELCtCQUErQjtBQUMvQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwrQkFBK0I7QUFDL0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsdU5BQXVOO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csU0FBUztBQUM3RztBQUNBO0FBQ0Esa0dBQWtHLFNBQVM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxrS0FBa0s7QUFDbEs7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLENBQUM7O0FBRUQseUtBQXlLO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVCQUF1Qix5Q0FBeUMsZ0NBQWdDLDJCQUEyQiwyQkFBMkIsdUJBQXVCLGVBQWUsR0FBRyxnREFBZ0QsdUJBQXVCLGVBQWUscUJBQXFCLCtCQUErQixHQUFHLHlCQUF5QixlQUFlLGFBQWEsV0FBVyxnQkFBZ0IsR0FBRyw2QkFBNkIsZUFBZSxhQUFhLGdCQUFnQixHQUFHLHlCQUF5QixjQUFjLFlBQVksaUJBQWlCLEdBQUcsNkJBQTZCLGNBQWMsaUJBQWlCLEdBQUcsK0JBQStCLGVBQWUscUJBQXFCLEdBQUc7QUFDandCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsQ0FBQzs7QUFFRCw4TUFBOE07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0IsaUJBQWlCO0FBQ2hGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxtR0FBbUc7QUFDbkc7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxLQUFLLGdDQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDLFlBQVksaUNBQWlDLFlBQVksaUNBQWlDLGlDQUFpQyxZQUFZLGlDQUFpQyxZQUFZLGlDQUFpQyxpQ0FBaUMsWUFBWSxpQ0FBaUMsaUNBQWlDLFlBQVksaUNBQWlDLGlDQUFpQyxpQ0FBaUMsWUFBWSxpQ0FBaUMsWUFBWSxpQ0FBaUMsaUNBQWlDLFlBQVksaUNBQWlDLGlDQUFpQyxZQUFZLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLFlBQVksaUNBQWlDLGlDQUFpQyxZQUFZLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLFlBQVksaUNBQWlDLGlDQUFpQyxpQ0FBaUMsWUFBWSxpQ0FBaUMsaUNBQWlDLGlDQUFpQyxnQ0FBZ0MsbUJBQW1CLHlCQUF5Qix1QkFBdUIsaUJBQWlCLHNIQUFzSCxxQkFBcUIsdUJBQXVCLG9EQUFvRCxnQ0FBZ0MsR0FBRyxtQkFBbUIseUJBQXlCLHVCQUF1QixhQUFhLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLG1CQUFtQixHQUFHLGtCQUFrQix5QkFBeUIsNkJBQTZCLHNCQUFzQixpQ0FBaUMsa0RBQWtELEdBQUcsK0JBQStCLDBDQUEwQyxvQkFBb0IsR0FBRyx1Q0FBdUMseUJBQXlCLGFBQWEsY0FBYyxlQUFlLGdCQUFnQixrQkFBa0IsNENBQTRDLG9CQUFvQixHQUFHLDhDQUE4QyxzQ0FBc0MsR0FBRyxpQkFBaUIseUJBQXlCLHdCQUF3QixrQkFBa0IsYUFBYSxnQkFBZ0IsY0FBYyxzQkFBc0IsaUJBQWlCLDRCQUE0Qiw2QkFBNkIsZ0NBQWdDLHdCQUF3QixpQ0FBaUMsR0FBRyw2QkFBNkIseUJBQXlCLGNBQWMsZUFBZSxHQUFHLHlDQUF5QyxvQkFBb0IseUJBQXlCLGFBQWEsZUFBZSxnQkFBZ0IsY0FBYyw2REFBNkQsMkJBQTJCLEdBQUcsa0RBQWtELHlCQUF5QixhQUFhLGNBQWMsZUFBZSx5QkFBeUIseUJBQXlCLG1DQUFtQyxHQUFHLHVEQUF1RCx5QkFBeUIsa0JBQWtCLEdBQUcsNkNBQTZDLHlCQUF5QixrQkFBa0IsR0FBRyxtS0FBbUssNkNBQTZDLDI2QkFBMjZCLG1DQUFtQyxzQ0FBc0MsR0FBRyxxRkFBcUYsNkNBQTZDLHVrQkFBdWtCLG1DQUFtQyxzQ0FBc0MsR0FBRyxrR0FBa0csNkNBQTZDLCtPQUErTyxtQ0FBbUMsc0NBQXNDLEdBQUcsMElBQTBJLDZDQUE2QywrTkFBK04sR0FBRyw2QkFBNkIsbURBQW1ELHVZQUF1WSxnQ0FBZ0MsR0FBRyw4QkFBOEIsbURBQW1ELDI0QkFBMjRCLGdDQUFnQyxHQUFHLDZCQUE2QixtREFBbUQsMmFBQTJhLG1DQUFtQyxHQUFHLDBCQUEwQixtREFBbUQsdWVBQXVlLGtDQUFrQyxHQUFHLDBCQUEwQixtREFBbUQsbW1CQUFtbUIsK0JBQStCLEdBQUcsa0NBQWtDLG1EQUFtRCwycURBQTJxRCxnQ0FBZ0MsR0FBRyxtQ0FBbUMsbURBQW1ELDI3R0FBMjdHLGdDQUFnQyxHQUFHLGtDQUFrQyxtREFBbUQsMmhDQUEyaEMsbUNBQW1DLEdBQUcsb0JBQW9CLHNCQUFzQix5QkFBeUIsZUFBZSxnQkFBZ0IsaUJBQWlCLEdBQUcsMEJBQTBCLHlCQUF5QixtQkFBbUIsY0FBYyxhQUFhLEdBQUcscUJBQXFCLHlCQUF5Qix5QkFBeUIsYUFBYSxHQUFHLHNCQUFzQix5QkFBeUIseUJBQXlCLGNBQWMsR0FBRyx1QkFBdUIseUJBQXlCLG1CQUFtQixHQUFHLHFCQUFxQix5QkFBeUIsaUJBQWlCLG1CQUFtQixrQkFBa0IsaUJBQWlCLDhCQUE4Qiw0QkFBNEIsdUJBQXVCLG1CQUFtQixtQkFBbUIsb0JBQW9CLHVCQUF1QixvQkFBb0IscUJBQXFCLHFCQUFxQixzQkFBc0IsNEJBQTRCLDZCQUE2QixnQ0FBZ0Msd0JBQXdCLDhDQUE4QyxtREFBbUQsR0FBRyxtQ0FBbUMsOEJBQThCLHFCQUFxQixvQkFBb0IsaUJBQWlCLEdBQUcsaUNBQWlDLG9CQUFvQiw0QkFBNEIsK0JBQStCLHlCQUF5Qix1QkFBdUIsc0JBQXNCLEdBQUcsMEJBQTBCLGdDQUFnQyw2QkFBNkIsZ0NBQWdDLDRCQUE0Qiw4QkFBOEIsa0NBQWtDLHdDQUF3QyxvQkFBb0IsR0FBRyxnQkFBZ0IsaUJBQWlCLHlCQUF5Qix1QkFBdUIsdUdBQXVHLHVCQUF1QixtQkFBbUIsa0JBQWtCLDZCQUE2Qix1Q0FBdUMsdUlBQXVJLEdBQUcsdUJBQXVCLHlCQUF5QixrQkFBa0Isd0JBQXdCLDJCQUEyQix3QkFBd0IsaUNBQWlDLEdBQUcscUJBQXFCLCtCQUErQix5QkFBeUIsd0JBQXdCLHVCQUF1QixpQ0FBaUMsR0FBRyxvRUFBb0UsaUNBQWlDLHlCQUF5QixhQUFhLGNBQWMsZUFBZSxHQUFHLGtIQUFrSCxzQkFBc0IsR0FBRywwRkFBMEYsc0JBQXNCLEdBQUcsY0FBYyw0QkFBNEIseUJBQXlCLEdBQUcsdUJBQXVCLGlCQUFpQixHQUFHLGlCQUFpQixpQkFBaUIseUJBQXlCLDZCQUE2Qiw2QkFBNkIsd0dBQXdHLEdBQUcsa0NBQWtDLDZCQUE2QixHQUFHLG1DQUFtQyw2QkFBNkIsR0FBRyx3Q0FBd0MsMkJBQTJCLCtCQUErQixHQUFHLHFDQUFxQyxtQkFBbUIsR0FBRyx5REFBeUQsaUJBQWlCLEdBQUcsc0NBQXNDLGdDQUFnQyxHQUFHLHVDQUF1QyxpQ0FBaUMsMENBQTBDLHdDQUF3QywwQ0FBMEMsR0FBRywyREFBMkQsaUNBQWlDLDZDQUE2QywrQ0FBK0MsR0FBRyxzQ0FBc0MsaUJBQWlCLGFBQWEsWUFBWSxhQUFhLEdBQUcseUNBQXlDLGlCQUFpQixhQUFhLFlBQVksYUFBYSxZQUFZLGFBQWEsWUFBWSxhQUFhLEdBQUcsK0RBQStELHlCQUF5QixpQkFBaUIsR0FBRyxzQ0FBc0MseUJBQXlCLGlCQUFpQixHQUFHLG9DQUFvQyx5QkFBeUIsaUJBQWlCLEdBQUcsMENBQTBDLHlCQUF5Qix1Q0FBdUMsdUJBQXVCLEdBQUcsd0NBQXdDLHlCQUF5QixpQkFBaUIsR0FBRywwQ0FBMEMseUJBQXlCLGlCQUFpQiw2QkFBNkIsR0FBRyx5QkFBeUIsNkJBQTZCLDhCQUE4QixtQkFBbUIsdUJBQXVCLDZCQUE2Qix3REFBd0Qsc1hBQXNYLHVMQUF1TCw2Q0FBNkMsbURBQW1ELHlCQUF5QixnQ0FBZ0MseUJBQXlCLHdCQUF3QiwyQkFBMkIsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0Isc0RBQXNELHNYQUFzWCxtTEFBbUwsR0FBRyxrQkFBa0IsZ0NBQWdDLDZCQUE2Qix5QkFBeUIsK0NBQStDLG1CQUFtQixzQkFBc0IsdUJBQXVCLHNCQUFzQixzQkFBc0IsNkJBQTZCLHNCQUFzQiw0QkFBNEIsNEJBQTRCLDBCQUEwQix5QkFBeUIsMEJBQTBCLDZCQUE2QiwyQkFBMkIscUJBQXFCLGlDQUFpQyxtQ0FBbUMsR0FBRyxvQkFBb0IsNEJBQTRCLEdBQUcsMkJBQTJCLGdDQUFnQyxrQkFBa0IsR0FBRyx3QkFBd0IsaUNBQWlDLEdBQUcsZUFBZSw0QkFBNEIsa0JBQWtCLDBCQUEwQixHQUFHLG1CQUFtQiw0QkFBNEIsa0JBQWtCLDBCQUEwQixxQ0FBcUMsOEJBQThCLG9DQUFvQyxHQUFHLGdHQUFnRywwQkFBMEIsR0FBRyxzQkFBc0IsNkJBQTZCLDhCQUE4QixvQkFBb0Isa0JBQWtCLDBCQUEwQiwrQ0FBK0MsK0pBQStKLG1DQUFtQyxrQ0FBa0MsMkJBQTJCLDBDQUEwQyxzQkFBc0IsR0FBRywyQ0FBMkMsK0JBQStCLEdBQUcsOEJBQThCLDZDQUE2QywrSkFBK0osR0FBRyxpQ0FBaUMsNkNBQTZDLHVLQUF1SyxHQUFHLDRCQUE0QiwyQ0FBMkMsaURBQWlELHFEQUFxRCxHQUFHLDZCQUE2QiwyQ0FBMkMsNENBQTRDLHFEQUFxRCxHQUFHLDBFQUEwRSw2Q0FBNkMsK0hBQStILEdBQUcsc0NBQXNDLDZDQUE2QyxtSUFBbUksR0FBRyx5Q0FBeUMsNkNBQTZDLCtIQUErSCxHQUFHLG9DQUFvQyxxREFBcUQsaURBQWlELEdBQUcscUNBQXFDLHFEQUFxRCxHQUFHLHdCQUF3QixrQ0FBa0MsNEJBQTRCLHVCQUF1QixxQkFBcUIsMkJBQTJCLHNCQUFzQixHQUFHLDRCQUE0Qix5QkFBeUIsd0NBQXdDLDRCQUE0QiwyQkFBMkIsR0FBRyxrQ0FBa0MsZ0NBQWdDLDRCQUE0QixHQUFHLDZDQUE2QywwQ0FBMEMsaUJBQWlCLEdBQUcsbURBQW1ELDJDQUEyQyxnQkFBZ0IsR0FBRyxvQkFBb0IsaUNBQWlDLEdBQUcsZUFBZSx3QkFBd0IsR0FBRywyQkFBMkIsMEJBQTBCLEdBQUcsaUJBQWlCLHlCQUF5QixHQUFHLHlCQUF5Qiw0Q0FBNEMseUJBQXlCLGlCQUFpQixHQUFHLDJCQUEyQiw4Q0FBOEMseUJBQXlCLGlCQUFpQixHQUFHLHNCQUFzQix5QkFBeUIsdUJBQXVCLHlCQUF5Qiw0QkFBNEIsNkJBQTZCLGdDQUFnQyx3QkFBd0Isd0JBQXdCLG1DQUFtQyxnQ0FBZ0MsbUJBQW1CLEdBQUcsZ0NBQWdDLHVCQUF1QixrQkFBa0IsbUNBQW1DLDZCQUE2QixLQUFLLHNCQUFzQixtQkFBbUIsc0JBQXNCLHVCQUF1QixHQUFHLDRCQUE0Qiw2QkFBNkIsZ0JBQWdCLEdBQUcsNkJBQTZCLDZCQUE2QixHQUFHLHNCQUFzQix5QkFBeUIseUJBQXlCLDRCQUE0Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQixxQkFBcUIsaUJBQWlCLEdBQUcscUJBQXFCLG1CQUFtQix5QkFBeUIsR0FBRyxxQ0FBcUMsdUJBQXVCLEdBQUcscUNBQXFDLDBCQUEwQix5QkFBeUIsR0FBRyw2Q0FBNkMsd0JBQXdCLDRCQUE0Qix3QkFBd0Isb0JBQW9CLGVBQWUsZ0JBQWdCLGlCQUFpQixzQkFBc0IsR0FBRyx1QkFBdUIsb0JBQW9CLEdBQUc7O0FBRTFzNEIsQ0FBQzs7QUFFRCx5SkFBeUo7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDOztBQUVELDZjQUE2YztBQUM3YztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUNBQWlDLGNBQWMsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25ELDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEUsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsMERBQTBELHFCQUFxQixpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlDQUFpQyxRQUFRO0FBQ3pDOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBLDBCQUEwQix5Q0FBeUM7QUFDbkU7QUFDQTtBQUNBLDBCQUEwQixzQ0FBc0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxDQUFDOztBQUVELGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxtSkFBbUo7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELCtJQUErSTtBQUMvSTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0QsbUJBQW1CLHdDQUF3QztBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlELG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRSxtQkFBbUIsb0RBQW9EO0FBQ3ZFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEUsbUJBQW1CLHdEQUF3RDtBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxtQkFBbUIsOENBQThDO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEUsbUJBQW1CLHdEQUF3RDtBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9ELG1CQUFtQiwwREFBMEQ7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msc0NBQXNDO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7O0FBRUQsNlNBQTZTO0FBQzdTLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOztBQUVELHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7O0FBRUQsNElBQTRJO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGO0FBQ0Esa0RBQWtELDhCQUE4Qix5QkFBeUIsNEJBQTRCLHFCQUFxQixnQ0FBZ0MsbUNBQW1DLHdCQUF3Qiw2QkFBNkIsZ0NBQWdDLE9BQU8sNkRBQTZELHNDQUFzQyxpRUFBaUUsc0NBQXNDLDJEQUEyRCxzQ0FBc0MsdURBQXVELHNDQUFzQywyQkFBMkIsNkJBQTZCLDRCQUE0QixrREFBa0Qsb0RBQW9ELG1EQUFtRCxvQkFBb0IsT0FBTzs7QUFFejhCLENBQUM7O0FBRUQsZ1lBQWdZO0FBQ2hZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGNBQWM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrRkFBa0Y7QUFDbEYsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUF1RDtBQUMvRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zhc3QtdXRpbHMvLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9hY2UuanM/ZWU1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLCBBamF4Lm9yZyBCLlYuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEFqYXgub3JnIEIuVi4gbm9yIHRoZVxuICogICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAqICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFKQVguT1JHIEIuVi4gQkUgTElBQkxFIEZPUiBBTllcbiAqIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAqIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKiogKi9cblxuLyoqXG4gKiBEZWZpbmUgYSBtb2R1bGUgYWxvbmcgd2l0aCBhIHBheWxvYWRcbiAqIEBwYXJhbSBtb2R1bGUgYSBuYW1lIGZvciB0aGUgcGF5bG9hZFxuICogQHBhcmFtIHBheWxvYWQgYSBmdW5jdGlvbiB0byBjYWxsIHdpdGggKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkgcGFyYW1zXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG52YXIgQUNFX05BTUVTUEFDRSA9IFwiYWNlXCI7XG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuaWYgKCFnbG9iYWwgJiYgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSBnbG9iYWwgPSB3aW5kb3c7IC8vIHN0cmljdCBtb2RlXG5cblxuaWYgKCFBQ0VfTkFNRVNQQUNFICYmIHR5cGVvZiByZXF1aXJlanMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuXG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihtb2R1bGUsIGRlcHMsIHBheWxvYWQpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZGVmaW5lLm9yaWdpbmFsKVxuICAgICAgICAgICAgZGVmaW5lLm9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImRyb3BwaW5nIG1vZHVsZSBiZWNhdXNlIGRlZmluZSB3YXNuXFwndCBhIHN0cmluZy5cIik7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKVxuICAgICAgICBwYXlsb2FkID0gZGVwcztcbiAgICBpZiAoIWRlZmluZS5tb2R1bGVzW21vZHVsZV0pIHtcbiAgICAgICAgZGVmaW5lLnBheWxvYWRzW21vZHVsZV0gPSBwYXlsb2FkO1xuICAgICAgICBkZWZpbmUubW9kdWxlc1ttb2R1bGVdID0gbnVsbDtcbiAgICB9XG59O1xuXG5kZWZpbmUubW9kdWxlcyA9IHt9O1xuZGVmaW5lLnBheWxvYWRzID0ge307XG5cbi8qKlxuICogR2V0IGF0IGZ1bmN0aW9uYWxpdHkgZGVmaW5lKCllZCB1c2luZyB0aGUgZnVuY3Rpb24gYWJvdmVcbiAqL1xudmFyIF9yZXF1aXJlID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGxvb2t1cChwYXJlbnRJZCwgbW9kdWxlKTtcbiAgICAgICAgaWYgKHBheWxvYWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtb2R1bGUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vZHVsZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBkZXAgPSBsb29rdXAocGFyZW50SWQsIG1vZHVsZVtpXSk7XG4gICAgICAgICAgICBpZiAoZGVwID09IHVuZGVmaW5lZCAmJiByZXF1aXJlLm9yaWdpbmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGRlcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrLmFwcGx5KG51bGwsIHBhcmFtcykgfHwgdHJ1ZTtcbiAgICB9XG59O1xuXG52YXIgcmVxdWlyZSA9IGZ1bmN0aW9uKG1vZHVsZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFja2FnZWRNb2R1bGUgPSBfcmVxdWlyZShcIlwiLCBtb2R1bGUsIGNhbGxiYWNrKTtcbiAgICBpZiAocGFja2FnZWRNb2R1bGUgPT0gdW5kZWZpbmVkICYmIHJlcXVpcmUub3JpZ2luYWwpXG4gICAgICAgIHJldHVybiByZXF1aXJlLm9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHBhY2thZ2VkTW9kdWxlO1xufTtcblxudmFyIG5vcm1hbGl6ZU1vZHVsZSA9IGZ1bmN0aW9uKHBhcmVudElkLCBtb2R1bGVOYW1lKSB7XG4gICAgLy8gbm9ybWFsaXplIHBsdWdpbiByZXF1aXJlc1xuICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoXCIhXCIpICE9PSAtMSkge1xuICAgICAgICB2YXIgY2h1bmtzID0gbW9kdWxlTmFtZS5zcGxpdChcIiFcIik7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVNb2R1bGUocGFyZW50SWQsIGNodW5rc1swXSkgKyBcIiFcIiArIG5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgY2h1bmtzWzFdKTtcbiAgICB9XG4gICAgLy8gbm9ybWFsaXplIHJlbGF0aXZlIHJlcXVpcmVzXG4gICAgaWYgKG1vZHVsZU5hbWUuY2hhckF0KDApID09IFwiLlwiKSB7XG4gICAgICAgIHZhciBiYXNlID0gcGFyZW50SWQuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbiAgICAgICAgbW9kdWxlTmFtZSA9IGJhc2UgKyBcIi9cIiArIG1vZHVsZU5hbWU7XG5cbiAgICAgICAgd2hpbGUobW9kdWxlTmFtZS5pbmRleE9mKFwiLlwiKSAhPT0gLTEgJiYgcHJldmlvdXMgIT0gbW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gbW9kdWxlTmFtZTtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lLnJlcGxhY2UoL1xcL1xcLlxcLy8sIFwiL1wiKS5yZXBsYWNlKC9bXlxcL10rXFwvXFwuXFwuXFwvLywgXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZU5hbWU7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGxvb2t1cCBtb2R1bGVOYW1lcyBhbmQgcmVzb2x2ZSB0aGVtIGJ5IGNhbGxpbmcgdGhlXG4gKiBkZWZpbml0aW9uIGZ1bmN0aW9uIGlmIG5lZWRlZC5cbiAqL1xudmFyIGxvb2t1cCA9IGZ1bmN0aW9uKHBhcmVudElkLCBtb2R1bGVOYW1lKSB7XG4gICAgbW9kdWxlTmFtZSA9IG5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgbW9kdWxlTmFtZSk7XG5cbiAgICB2YXIgbW9kdWxlID0gZGVmaW5lLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlID0gZGVmaW5lLnBheWxvYWRzW21vZHVsZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBtb2QgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgdXJpOiAnJyxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzLFxuICAgICAgICAgICAgICAgIHBhY2thZ2VkOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVxID0gZnVuY3Rpb24obW9kdWxlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVxdWlyZShtb2R1bGVOYW1lLCBtb2R1bGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG1vZHVsZShyZXEsIGV4cG9ydHMsIG1vZCk7XG4gICAgICAgICAgICBleHBvcnRzID0gcmV0dXJuVmFsdWUgfHwgbW9kLmV4cG9ydHM7XG4gICAgICAgICAgICBkZWZpbmUubW9kdWxlc1ttb2R1bGVOYW1lXSA9IGV4cG9ydHM7XG4gICAgICAgICAgICBkZWxldGUgZGVmaW5lLnBheWxvYWRzW21vZHVsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZSA9IGRlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdID0gZXhwb3J0cyB8fCBtb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBtb2R1bGU7XG59O1xuXG5mdW5jdGlvbiBleHBvcnRBY2UobnMpIHtcbiAgICB2YXIgcm9vdCA9IGdsb2JhbDtcbiAgICBpZiAobnMpIHtcbiAgICAgICAgaWYgKCFnbG9iYWxbbnNdKVxuICAgICAgICAgICAgZ2xvYmFsW25zXSA9IHt9O1xuICAgICAgICByb290ID0gZ2xvYmFsW25zXTtcbiAgICB9XG5cbiAgICBpZiAoIXJvb3QuZGVmaW5lIHx8ICFyb290LmRlZmluZS5wYWNrYWdlZCkge1xuICAgICAgICBkZWZpbmUub3JpZ2luYWwgPSByb290LmRlZmluZTtcbiAgICAgICAgcm9vdC5kZWZpbmUgPSBkZWZpbmU7XG4gICAgICAgIHJvb3QuZGVmaW5lLnBhY2thZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXJvb3QucmVxdWlyZSB8fCAhcm9vdC5yZXF1aXJlLnBhY2thZ2VkKSB7XG4gICAgICAgIHJlcXVpcmUub3JpZ2luYWwgPSByb290LnJlcXVpcmU7XG4gICAgICAgIHJvb3QucmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgIHJvb3QucmVxdWlyZS5wYWNrYWdlZCA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnRBY2UoQUNFX05BTUVTUEFDRSk7XG5cbn0pKCk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2VzNi1zaGltXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe2Z1bmN0aW9uIGRlZmluZVByb3Aob2JqLCBuYW1lLCB2YWwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICAgIGRlZmluZVByb3AoU3RyaW5nLnByb3RvdHlwZSwgXCJzdGFydHNXaXRoXCIsIGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT09IHBvc2l0aW9uO1xuICAgIH0pO1xufVxuaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XG4gICAgZGVmaW5lUHJvcChTdHJpbmcucHJvdG90eXBlLCBcImVuZHNXaXRoXCIsIGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xuICAgIH0pO1xufVxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuICAgIGRlZmluZVByb3AoU3RyaW5nLnByb3RvdHlwZSwgXCJyZXBlYXRcIiwgZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgaWYgKGNvdW50ICYgMSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICAgICAgaWYgKChjb3VudCA+Pj0gMSkpXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuaWYgKCFTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgZGVmaW5lUHJvcChTdHJpbmcucHJvdG90eXBlLCBcImluY2x1ZGVzXCIsIGZ1bmN0aW9uIChzdHIsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc3RyLCBwb3NpdGlvbikgIT0gLTE7XG4gICAgfSk7XG59XG5pZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuaWYgKCFPYmplY3QudmFsdWVzKSB7XG4gICAgT2JqZWN0LnZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBvW2tdO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIGRlZmluZVByb3AoQXJyYXkucHJvdG90eXBlLCBcImZpbmRcIiwgZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gdGhpc1trXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCBrVmFsdWUsIGssIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgZGVmaW5lUHJvcChBcnJheS5wcm90b3R5cGUsIFwiZmluZEluZGV4XCIsIGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IHRoaXNba107XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuICAgIGRlZmluZVByb3AoQXJyYXkucHJvdG90eXBlLCBcImluY2x1ZGVzXCIsIGZ1bmN0aW9uIChpdGVtLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKGl0ZW0sIHBvc2l0aW9uKSAhPSAtMTtcbiAgICB9KTtcbn1cbmlmICghQXJyYXkucHJvdG90eXBlLmZpbGwpIHtcbiAgICBkZWZpbmVQcm9wKEFycmF5LnByb3RvdHlwZSwgXCJmaWxsXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgTyA9IHRoaXM7XG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IHN0YXJ0ID4+IDA7XG4gICAgICAgIHZhciBrID0gcmVsYXRpdmVTdGFydCA8IDBcbiAgICAgICAgICAgID8gTWF0aC5tYXgobGVuICsgcmVsYXRpdmVTdGFydCwgMClcbiAgICAgICAgICAgIDogTWF0aC5taW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgdmFyIGVuZCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIHJlbGF0aXZlRW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQgPj4gMDtcbiAgICAgICAgdmFyIGZpbmFsID0gcmVsYXRpdmVFbmQgPCAwXG4gICAgICAgICAgICA/IE1hdGgubWF4KGxlbiArIHJlbGF0aXZlRW5kLCAwKVxuICAgICAgICAgICAgOiBNYXRoLm1pbihyZWxhdGl2ZUVuZCwgbGVuKTtcbiAgICAgICAgd2hpbGUgKGsgPCBmaW5hbCkge1xuICAgICAgICAgICAgT1trXSA9IHZhbHVlO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPO1xuICAgIH0pO1xufVxuaWYgKCFBcnJheS5vZikge1xuICAgIGRlZmluZVByb3AoQXJyYXksIFwib2ZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9KTtcbn1cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2ZpeG9sZGJyb3dzZXJzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2VzNi1zaGltXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8vIHZpbTpzZXQgdHM9NCBzdHM9NCBzdz00IHN0OlxuXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKFwiLi9lczYtc2hpbVwiKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2RlZXBfY29weVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtleHBvcnRzLmRlZXBDb3B5ID0gZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgIW9iailcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB2YXIgY29weTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvcHkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMDsga2V5IDwgb2JqLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGRlZXBDb3B5KG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGNvcHkgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICBjb3B5W2tleV0gPSBkZWVwQ29weShvYmpba2V5XSk7XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvbGFuZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kZWVwX2NvcHlcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmxhc3QgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59O1xuZXhwb3J0cy5zdHJpbmdSZXZlcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG59O1xuZXhwb3J0cy5zdHJpbmdSZXBlYXQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjb3VudCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGlmIChjb3VudCAmIDEpXG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICBpZiAoY291bnQgPj49IDEpXG4gICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciB0cmltQmVnaW5SZWdleHAgPSAvXlxcc1xccyovO1xudmFyIHRyaW1FbmRSZWdleHAgPSAvXFxzXFxzKiQvO1xuZXhwb3J0cy5zdHJpbmdUcmltTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodHJpbUJlZ2luUmVnZXhwLCAnJyk7XG59O1xuZXhwb3J0cy5zdHJpbmdUcmltUmlnaHQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbn07XG5leHBvcnRzLmNvcHlPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG5leHBvcnRzLmNvcHlBcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb3B5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldICYmIHR5cGVvZiBhcnJheVtpXSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgY29weVtpXSA9IHRoaXMuY29weU9iamVjdChhcnJheVtpXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvcHlbaV0gPSBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuZXhwb3J0cy5kZWVwQ29weSA9IHJlcXVpcmUoXCIuL2RlZXBfY29weVwiKS5kZWVwQ29weTtcbmV4cG9ydHMuYXJyYXlUb01hcCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2FycltpXV0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufTtcbmV4cG9ydHMuY3JlYXRlTWFwID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgaSBpbiBwcm9wcykge1xuICAgICAgICBtYXBbaV0gPSBwcm9wc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn07XG5leHBvcnRzLmFycmF5UmVtb3ZlID0gZnVuY3Rpb24gKGFycmF5LCB2YWx1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlbaV0pIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbn07XG5leHBvcnRzLmVzY2FwZUhUTUwgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIChcIlwiICsgc3RyKS5yZXBsYWNlKC8mL2csIFwiJiMzODtcIikucmVwbGFjZSgvXCIvZywgXCImIzM0O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIikucmVwbGFjZSgvPC9nLCBcIiYjNjA7XCIpO1xufTtcbmV4cG9ydHMuZ2V0TWF0Y2hPZmZzZXRzID0gZnVuY3Rpb24gKHN0cmluZywgcmVnRXhwKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICBzdHJpbmcucmVwbGFjZShyZWdFeHAsIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RyLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hlcztcbn07XG5leHBvcnRzLmRlZmVycmVkQ2FsbCA9IGZ1bmN0aW9uIChmY24pIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBmY24oKTtcbiAgICB9O1xuICAgIHZhciBkZWZlcnJlZCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIGRlZmVycmVkLmNhbmNlbCgpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgMCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIGRlZmVycmVkLnNjaGVkdWxlID0gZGVmZXJyZWQ7XG4gICAgZGVmZXJyZWQuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgZmNuKCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIGRlZmVycmVkLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9O1xuICAgIHJldHVybiBkZWZlcnJlZDtcbn07XG5leHBvcnRzLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gKGZjbiwgZGVmYXVsdFRpbWVvdXQpIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBmY24oKTtcbiAgICB9O1xuICAgIHZhciBfc2VsZiA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lciA9PSBudWxsKVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0IHx8IGRlZmF1bHRUaW1lb3V0KTtcbiAgICB9O1xuICAgIF9zZWxmLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0IHx8IGRlZmF1bHRUaW1lb3V0KTtcbiAgICB9O1xuICAgIF9zZWxmLnNjaGVkdWxlID0gX3NlbGY7XG4gICAgX3NlbGYuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgZmNuKCk7XG4gICAgfTtcbiAgICBfc2VsZi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9O1xuICAgIF9zZWxmLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZWxmO1xufTtcbmV4cG9ydHMuc3VwcG9ydHNMb29rYmVoaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoJyg/PD0uKScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydHMuc2tpcEVtcHR5TWF0Y2ggPSBmdW5jdGlvbiAobGluZSwgbGFzdCwgc3VwcG9ydHNVbmljb2RlRmxhZykge1xuICAgIHJldHVybiBzdXBwb3J0c1VuaWNvZGVGbGFnICYmIGxpbmUuY29kZVBvaW50QXQobGFzdCkgPiAweGZmZmYgPyAyIDogMTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi91c2VyYWdlbnRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLk9TID0ge1xuICAgIExJTlVYOiBcIkxJTlVYXCIsXG4gICAgTUFDOiBcIk1BQ1wiLFxuICAgIFdJTkRPV1M6IFwiV0lORE9XU1wiXG59O1xuZXhwb3J0cy5nZXRPUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwb3J0cy5pc01hYykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PUy5NQUM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cG9ydHMuaXNMaW51eCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PUy5MSU5VWDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9TLldJTkRPV1M7XG4gICAgfVxufTtcbnZhciBfbmF2aWdhdG9yID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiID8gbmF2aWdhdG9yIDoge307XG52YXIgb3MgPSAoL21hY3x3aW58bGludXgvaS5leGVjKF9uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IFtcIm90aGVyXCJdKVswXS50b0xvd2VyQ2FzZSgpO1xudmFyIHVhID0gX25hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIjtcbnZhciBhcHBOYW1lID0gX25hdmlnYXRvci5hcHBOYW1lIHx8IFwiXCI7XG5leHBvcnRzLmlzV2luID0gKG9zID09IFwid2luXCIpO1xuZXhwb3J0cy5pc01hYyA9IChvcyA9PSBcIm1hY1wiKTtcbmV4cG9ydHMuaXNMaW51eCA9IChvcyA9PSBcImxpbnV4XCIpO1xuZXhwb3J0cy5pc0lFID1cbiAgICAoYXBwTmFtZSA9PSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiIHx8IGFwcE5hbWUuaW5kZXhPZihcIk1TQXBwSG9zdFwiKSA+PSAwKVxuICAgICAgICA/IHBhcnNlRmxvYXQoKHVhLm1hdGNoKC8oPzpNU0lFIHxUcmlkZW50XFwvWzAtOV0rW1xcLjAtOV0rOy4qcnY6KShbMC05XStbXFwuMC05XSspLykgfHwgW10pWzFdKVxuICAgICAgICA6IHBhcnNlRmxvYXQoKHVhLm1hdGNoKC8oPzpUcmlkZW50XFwvWzAtOV0rW1xcLjAtOV0rOy4qcnY6KShbMC05XStbXFwuMC05XSspLykgfHwgW10pWzFdKTsgLy8gZm9yIGllXG5leHBvcnRzLmlzT2xkSUUgPSBleHBvcnRzLmlzSUUgJiYgZXhwb3J0cy5pc0lFIDwgOTtcbmV4cG9ydHMuaXNHZWNrbyA9IGV4cG9ydHMuaXNNb3ppbGxhID0gdWEubWF0Y2goLyBHZWNrb1xcL1xcZCsvKTtcbmV4cG9ydHMuaXNPcGVyYSA9IHR5cGVvZiBvcGVyYSA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3dbXCJvcGVyYVwiXSkgPT0gXCJbb2JqZWN0IE9wZXJhXVwiO1xuZXhwb3J0cy5pc1dlYktpdCA9IHBhcnNlRmxvYXQodWEuc3BsaXQoXCJXZWJLaXQvXCIpWzFdKSB8fCB1bmRlZmluZWQ7XG5leHBvcnRzLmlzQ2hyb21lID0gcGFyc2VGbG9hdCh1YS5zcGxpdChcIiBDaHJvbWUvXCIpWzFdKSB8fCB1bmRlZmluZWQ7XG5leHBvcnRzLmlzU2FmYXJpID0gcGFyc2VGbG9hdCh1YS5zcGxpdChcIiBTYWZhcmkvXCIpWzFdKSAmJiAhZXhwb3J0cy5pc0Nocm9tZSB8fCB1bmRlZmluZWQ7XG5leHBvcnRzLmlzRWRnZSA9IHBhcnNlRmxvYXQodWEuc3BsaXQoXCIgRWRnZS9cIilbMV0pIHx8IHVuZGVmaW5lZDtcbmV4cG9ydHMuaXNBSVIgPSB1YS5pbmRleE9mKFwiQWRvYmVBSVJcIikgPj0gMDtcbmV4cG9ydHMuaXNBbmRyb2lkID0gdWEuaW5kZXhPZihcIkFuZHJvaWRcIikgPj0gMDtcbmV4cG9ydHMuaXNDaHJvbWVPUyA9IHVhLmluZGV4T2YoXCIgQ3JPUyBcIikgPj0gMDtcbmV4cG9ydHMuaXNJT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdCh1YSkgJiYgIXdpbmRvd1tcIk1TU3RyZWFtXCJdO1xuaWYgKGV4cG9ydHMuaXNJT1MpXG4gICAgZXhwb3J0cy5pc01hYyA9IHRydWU7XG5leHBvcnRzLmlzTW9iaWxlID0gZXhwb3J0cy5pc0lPUyB8fCBleHBvcnRzLmlzQW5kcm9pZDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2RvbVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXNlcmFnZW50ID0gcmVxdWlyZShcIi4vdXNlcmFnZW50XCIpO1xudmFyIFhIVE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5leHBvcnRzLmJ1aWxkRG9tID0gZnVuY3Rpb24gYnVpbGREb20oYXJyLCBwYXJlbnQsIHJlZnMpIHtcbiAgICBpZiAodHlwZW9mIGFyciA9PSBcInN0cmluZ1wiICYmIGFycikge1xuICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXJyKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0eHQpO1xuICAgICAgICByZXR1cm4gdHh0O1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBpZiAoYXJyICYmIGFyci5hcHBlbmRDaGlsZCAmJiBwYXJlbnQpXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoYXJyKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gIT0gXCJzdHJpbmdcIiB8fCAhYXJyWzBdKSB7XG4gICAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGJ1aWxkRG9tKGFycltpXSwgcGFyZW50LCByZWZzKTtcbiAgICAgICAgICAgIGNoICYmIGVscy5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxzO1xuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFyclswXSk7XG4gICAgdmFyIG9wdGlvbnMgPSBhcnJbMV07XG4gICAgdmFyIGNoaWxkSW5kZXggPSAxO1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucykpXG4gICAgICAgIGNoaWxkSW5kZXggPSAyO1xuICAgIGZvciAodmFyIGkgPSBjaGlsZEluZGV4OyBpIDwgYXJyLmxlbmd0aDsgaSsrKVxuICAgICAgICBidWlsZERvbShhcnJbaV0sIGVsLCByZWZzKTtcbiAgICBpZiAoY2hpbGRJbmRleCA9PSAyKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvcHRpb25zW25dO1xuICAgICAgICAgICAgaWYgKG4gPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5qb2luKFwiIFwiKSA6IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiIHx8IG4gPT0gXCJ2YWx1ZVwiIHx8IG5bMF0gPT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICBlbFtuXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG4gPT09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmcylcbiAgICAgICAgICAgICAgICAgICAgcmVmc1t2YWxdID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUobiwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJlbnQpXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xufTtcbmV4cG9ydHMuZ2V0RG9jdW1lbnRIZWFkID0gZnVuY3Rpb24gKGRvYykge1xuICAgIGlmICghZG9jKVxuICAgICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xufTtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWcsIG5zKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyA/XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucyB8fCBYSFRNTF9OUywgdGFnKSA6XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbn07XG5leHBvcnRzLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG59O1xuZXhwb3J0cy5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0Q29udGVudCwgZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0Q29udGVudCk7XG59O1xuZXhwb3J0cy5jcmVhdGVGcmFnbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn07XG5leHBvcnRzLmhhc0Nzc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgdmFyIGNsYXNzZXMgPSAoZWwuY2xhc3NOYW1lICsgXCJcIikuc3BsaXQoL1xccysvZyk7XG4gICAgcmV0dXJuIGNsYXNzZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG59O1xuZXhwb3J0cy5hZGRDc3NDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgIGlmICghZXhwb3J0cy5oYXNDc3NDbGFzcyhlbCwgbmFtZSkpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgbmFtZTtcbiAgICB9XG59O1xuZXhwb3J0cy5yZW1vdmVDc3NDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIik7XG59O1xuZXhwb3J0cy50b2dnbGVDc3NDbGFzcyA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLCBhZGQgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhZGQgPSBmYWxzZTtcbiAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpZiAoYWRkKVxuICAgICAgICBjbGFzc2VzLnB1c2gobmFtZSk7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gYWRkO1xufTtcbmV4cG9ydHMuc2V0Q3NzQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSwgY2xhc3NOYW1lLCBpbmNsdWRlKSB7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgZXhwb3J0cy5hZGRDc3NDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwb3J0cy5yZW1vdmVDc3NDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgIH1cbn07XG5leHBvcnRzLmhhc0Nzc1N0cmluZyA9IGZ1bmN0aW9uIChpZCwgZG9jKSB7XG4gICAgdmFyIGluZGV4ID0gMCwgc2hlZXRzO1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICBpZiAoKHNoZWV0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIikpKSB7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHNoZWV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzaGVldHNbaW5kZXgrK10uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5yZW1vdmVFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpZCwgZG9jKSB7XG4gICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgIGlmIChkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKSB7XG4gICAgICAgIGRvYy5nZXRFbGVtZW50QnlJZChpZCkucmVtb3ZlKCk7XG4gICAgfVxufTtcbnZhciBzdHJpY3RDU1A7XG52YXIgY3NzQ2FjaGUgPSBbXTtcbmV4cG9ydHMudXNlU3RyaWN0Q1NQID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgc3RyaWN0Q1NQID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09IGZhbHNlKVxuICAgICAgICBpbnNlcnRQZW5kaW5nU3R5bGVzKCk7XG4gICAgZWxzZSBpZiAoIWNzc0NhY2hlKVxuICAgICAgICBjc3NDYWNoZSA9IFtdO1xufTtcbmZ1bmN0aW9uIGluc2VydFBlbmRpbmdTdHlsZXMoKSB7XG4gICAgdmFyIGNhY2hlID0gY3NzQ2FjaGU7XG4gICAgY3NzQ2FjaGUgPSBudWxsO1xuICAgIGNhY2hlICYmIGNhY2hlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaW1wb3J0Q3NzU3RyaW5nKGl0ZW1bMF0sIGl0ZW1bMV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW1wb3J0Q3NzU3RyaW5nKGNzc1RleHQsIGlkLCB0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoY3NzQ2FjaGUpIHtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaW5zZXJ0UGVuZGluZ1N0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NDYWNoZS5wdXNoKFtjc3NUZXh0LCBpZF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJpY3RDU1ApXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgY29udGFpbmVyID0gdGFyZ2V0O1xuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuZ2V0Um9vdE5vZGUpIHtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250YWluZXIgPSB0YXJnZXQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgY29udGFpbmVyID09IHRhcmdldClcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgfHwgY29udGFpbmVyO1xuICAgIGlmIChpZCAmJiBleHBvcnRzLmhhc0Nzc1N0cmluZyhpZCwgY29udGFpbmVyKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlkKVxuICAgICAgICBjc3NUZXh0ICs9IFwiXFxuLyojIHNvdXJjZVVSTD1hY2UvY3NzL1wiICsgaWQgKyBcIiAqL1wiO1xuICAgIHZhciBzdHlsZSA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgaWYgKGlkKVxuICAgICAgICBzdHlsZS5pZCA9IGlkO1xuICAgIGlmIChjb250YWluZXIgPT0gZG9jKVxuICAgICAgICBjb250YWluZXIgPSBleHBvcnRzLmdldERvY3VtZW50SGVhZChkb2MpO1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3R5bGUsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbn1cbmV4cG9ydHMuaW1wb3J0Q3NzU3RyaW5nID0gaW1wb3J0Q3NzU3RyaW5nO1xuZXhwb3J0cy5pbXBvcnRDc3NTdHlsc2hlZXQgPSBmdW5jdGlvbiAodXJpLCBkb2MpIHtcbiAgICBleHBvcnRzLmJ1aWxkRG9tKFtcImxpbmtcIiwgeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiB1cmkgfV0sIGV4cG9ydHMuZ2V0RG9jdW1lbnRIZWFkKGRvYykpO1xufTtcbmV4cG9ydHMuc2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgdmFyIGlubmVyID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50KFwiYWNlX2lubmVyXCIpO1xuICAgIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgaW5uZXIuc3R5bGUubWluV2lkdGggPSBcIjBweFwiO1xuICAgIGlubmVyLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcbiAgICBpbm5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHZhciBvdXRlciA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudChcImFjZV9vdXRlclwiKTtcbiAgICB2YXIgc3R5bGUgPSBvdXRlci5zdHlsZTtcbiAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBzdHlsZS5sZWZ0ID0gXCItMTAwMDBweFwiO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBzdHlsZS53aWR0aCA9IFwiMjAwcHhcIjtcbiAgICBzdHlsZS5taW5XaWR0aCA9IFwiMHB4XCI7XG4gICAgc3R5bGUuaGVpZ2h0ID0gXCIxNTBweFwiO1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgIHZhciBib2R5ID0gKGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50KSB8fCAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBpZiAoIWJvZHkpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuICAgIHZhciBub1Njcm9sbGJhciA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcbiAgICB2YXIgd2l0aFNjcm9sbGJhciA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIGlmIChub1Njcm9sbGJhciA9PT0gd2l0aFNjcm9sbGJhcikge1xuICAgICAgICB3aXRoU2Nyb2xsYmFyID0gb3V0ZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIGJvZHkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICAgIHJldHVybiBub1Njcm9sbGJhciAtIHdpdGhTY3JvbGxiYXI7XG59O1xuZXhwb3J0cy5jb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIFwiXCIpIHx8IHt9O1xufTtcbmV4cG9ydHMuc2V0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAoc3R5bGVzW3Byb3BlcnR5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgc3R5bGVzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLkhBU19DU1NfQU5JTUFUSU9OID0gZmFsc2U7XG5leHBvcnRzLkhBU19DU1NfVFJBTlNGT1JNUyA9IGZhbHNlO1xuZXhwb3J0cy5ISV9EUEkgPSB1c2VyYWdlbnQuaXNXaW5cbiAgICA/IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMS41XG4gICAgOiB0cnVlO1xuaWYgKHVzZXJhZ2VudC5pc0Nocm9tZU9TKVxuICAgIGV4cG9ydHMuSElfRFBJID0gZmFsc2U7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaWYgKGV4cG9ydHMuSElfRFBJICYmIGRpdi5zdHlsZS50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgZXhwb3J0cy5IQVNfQ1NTX1RSQU5TRk9STVMgPSB0cnVlO1xuICAgIGlmICghdXNlcmFnZW50LmlzRWRnZSAmJiB0eXBlb2YgZGl2LnN0eWxlLmFuaW1hdGlvbk5hbWUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIGV4cG9ydHMuSEFTX0NTU19BTklNQVRJT04gPSB0cnVlO1xuICAgIGRpdiA9IG51bGw7XG59XG5pZiAoZXhwb3J0cy5IQVNfQ1NTX1RSQU5TRk9STVMpIHtcbiAgICBleHBvcnRzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eCwgdHkpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIE1hdGgucm91bmQodHgpICsgXCJweCwgXCIgKyBNYXRoLnJvdW5kKHR5KSArIFwicHgpXCI7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIGV4cG9ydHMudHJhbnNsYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR4LCB0eSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IE1hdGgucm91bmQodHkpICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBNYXRoLnJvdW5kKHR4KSArIFwicHhcIjtcbiAgICB9O1xufVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvbmV0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXsvKlxuICogYmFzZWQgb24gY29kZSBmcm9tOlxuICpcbiAqIEBsaWNlbnNlIFJlcXVpcmVKUyB0ZXh0IDAuMjUuMCBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMSwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMgZm9yIGRldGFpbHNcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vZG9tXCIpO1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChudWxsKTtcbn07XG5leHBvcnRzLmxvYWRTY3JpcHQgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaGVhZCA9IGRvbS5nZXREb2N1bWVudEhlYWQoKTtcbiAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHMuc3JjID0gcGF0aDtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHMpO1xuICAgIHMub25sb2FkID0gcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoXywgaXNBYm9ydCkge1xuICAgICAgICBpZiAoaXNBYm9ydCB8fCAhcy5yZWFkeVN0YXRlIHx8IHMucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHMucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIHMgPSBzLm9ubG9hZCA9IHMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaXNBYm9ydClcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLnF1YWxpZnlVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIHJldHVybiBhLmhyZWY7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvb29wXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLm1peGluID0gZnVuY3Rpb24gKG9iaiwgbWl4aW4pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWl4aW4pIHtcbiAgICAgICAgb2JqW2tleV0gPSBtaXhpbltrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcbmV4cG9ydHMuaW1wbGVtZW50ID0gZnVuY3Rpb24gKHByb3RvLCBtaXhpbikge1xuICAgIGV4cG9ydHMubWl4aW4ocHJvdG8sIG1peGluKTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIEV2ZW50RW1pdHRlciA9IHt9O1xudmFyIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlOyB9O1xudmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9O1xuRXZlbnRFbWl0dGVyLl9lbWl0ID1cbiAgICBFdmVudEVtaXR0ZXIuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwgKHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB7fSk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRIYW5kbGVycyB8fCAodGhpcy5fZGVmYXVsdEhhbmRsZXJzID0ge30pO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdEhhbmRsZXIgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMubGVuZ3RoICYmICFkZWZhdWx0SGFuZGxlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgICAgICAgICBlID0ge307XG4gICAgICAgIGlmICghZS50eXBlKVxuICAgICAgICAgICAgZS50eXBlID0gZXZlbnROYW1lO1xuICAgICAgICBpZiAoIWUuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG4gICAgICAgIGlmICghZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0oZSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRIYW5kbGVyICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhhbmRsZXIoZSwgdGhpcyk7XG4gICAgfTtcbkV2ZW50RW1pdHRlci5fc2lnbmFsID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZSkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSAodGhpcy5fZXZlbnRSZWdpc3RyeSB8fCB7fSlbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBsaXN0ZW5lcnNbaV0oZSwgdGhpcyk7XG59O1xuRXZlbnRFbWl0dGVyLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vbihldmVudE5hbWUsIGZ1bmN0aW9uIG5ld0NhbGxiYWNrKCkge1xuICAgICAgICBfc2VsZi5vZmYoZXZlbnROYW1lLCBuZXdDYWxsYmFjayk7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbkV2ZW50RW1pdHRlci5zZXREZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzO1xuICAgIGlmICghaGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXJzID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzID0geyBfZGlzYWJsZWRfOiB7fSB9O1xuICAgIGlmIChoYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBvbGQgPSBoYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICB2YXIgZGlzYWJsZWQgPSBoYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghZGlzYWJsZWQpXG4gICAgICAgICAgICBoYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV0gPSBkaXNhYmxlZCA9IFtdO1xuICAgICAgICBkaXNhYmxlZC5wdXNoKG9sZCk7XG4gICAgICAgIHZhciBpID0gZGlzYWJsZWQuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgZGlzYWJsZWQuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICBoYW5kbGVyc1tldmVudE5hbWVdID0gY2FsbGJhY2s7XG59O1xuRXZlbnRFbWl0dGVyLnJlbW92ZURlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9kZWZhdWx0SGFuZGxlcnM7XG4gICAgaWYgKCFoYW5kbGVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBkaXNhYmxlZCA9IGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSA9PSBjYWxsYmFjaykge1xuICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICB0aGlzLnNldERlZmF1bHRIYW5kbGVyKGV2ZW50TmFtZSwgZGlzYWJsZWQucG9wKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB2YXIgaSA9IGRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaSAhPSAtMSlcbiAgICAgICAgICAgIGRpc2FibGVkLnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuRXZlbnRFbWl0dGVyLm9uID1cbiAgICBFdmVudEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrLCBjYXB0dXJpbmcpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRSZWdpc3RyeSA9IHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwge307XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdID0gW107XG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPT0gLTEpXG4gICAgICAgICAgICBsaXN0ZW5lcnNbY2FwdHVyaW5nID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcbkV2ZW50RW1pdHRlci5vZmYgPVxuICAgIEV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9XG4gICAgICAgIEV2ZW50RW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG5FdmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIGlmICghZXZlbnROYW1lKVxuICAgICAgICB0aGlzLl9ldmVudFJlZ2lzdHJ5ID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLl9ldmVudFJlZ2lzdHJ5KVxuICAgICAgICB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuX2RlZmF1bHRIYW5kbGVycylcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJzW2V2ZW50TmFtZV0gPSB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9yZXBvcnRfZXJyb3JcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7ZXhwb3J0cy5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIHJlcG9ydEVycm9yKG1zZywgZGF0YSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyk7XG4gICAgZVtcImRhdGFcIl0gPSBkYXRhO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSA9PSBcIm9iamVjdFwiICYmIGNvbnNvbGUuZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2RlZmF1bHRfZW5nbGlzaF9tZXNzYWdlc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXt2YXIgZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcyA9IHtcbiAgICBcImF1dG9jb21wbGV0ZS5wb3B1cC5hcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcIkF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1wiLFxuICAgIFwiYXV0b2NvbXBsZXRlLnBvcHVwLmFyaWEtbGFiZWxcIjogXCJBdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcIixcbiAgICBcImF1dG9jb21wbGV0ZS5wb3B1cC5pdGVtLmFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwiaXRlbVwiLFxuICAgIFwiYXV0b2NvbXBsZXRlLmxvYWRpbmdcIjogXCJMb2FkaW5nLi4uXCIsXG4gICAgXCJlZGl0b3Iuc2Nyb2xsZXIuYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJlZGl0b3JcIixcbiAgICBcImVkaXRvci5zY3JvbGxlci5hcmlhLWxhYmVsXCI6IFwiRWRpdG9yIGNvbnRlbnQsIHByZXNzIEVudGVyIHRvIHN0YXJ0IGVkaXRpbmcsIHByZXNzIEVzY2FwZSB0byBleGl0XCIsXG4gICAgXCJlZGl0b3IuZ3V0dGVyLmFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwiZWRpdG9yIGd1dHRlclwiLFxuICAgIFwiZWRpdG9yLmd1dHRlci5hcmlhLWxhYmVsXCI6IFwiRWRpdG9yIGd1dHRlciwgcHJlc3MgRW50ZXIgdG8gaW50ZXJhY3Qgd2l0aCBjb250cm9scyB1c2luZyBhcnJvdyBrZXlzLCBwcmVzcyBFc2NhcGUgdG8gZXhpdFwiLFxuICAgIFwiZXJyb3ItbWFya2VyLmdvb2Qtc3RhdGVcIjogXCJMb29rcyBnb29kIVwiLFxuICAgIFwicHJvbXB0LnJlY2VudGx5LXVzZWRcIjogXCJSZWNlbnRseSB1c2VkXCIsXG4gICAgXCJwcm9tcHQub3RoZXItY29tbWFuZHNcIjogXCJPdGhlciBjb21tYW5kc1wiLFxuICAgIFwicHJvbXB0Lm5vLW1hdGNoaW5nLWNvbW1hbmRzXCI6IFwiTm8gbWF0Y2hpbmcgY29tbWFuZHNcIixcbiAgICBcInNlYXJjaC1ib3guZmluZC5wbGFjZWhvbGRlclwiOiBcIlNlYXJjaCBmb3JcIixcbiAgICBcInNlYXJjaC1ib3guZmluZC1hbGwudGV4dFwiOiBcIkFsbFwiLFxuICAgIFwic2VhcmNoLWJveC5yZXBsYWNlLnBsYWNlaG9sZGVyXCI6IFwiUmVwbGFjZSB3aXRoXCIsXG4gICAgXCJzZWFyY2gtYm94LnJlcGxhY2UtbmV4dC50ZXh0XCI6IFwiUmVwbGFjZVwiLFxuICAgIFwic2VhcmNoLWJveC5yZXBsYWNlLWFsbC50ZXh0XCI6IFwiQWxsXCIsXG4gICAgXCJzZWFyY2gtYm94LnRvZ2dsZS1yZXBsYWNlLnRpdGxlXCI6IFwiVG9nZ2xlIFJlcGxhY2UgbW9kZVwiLFxuICAgIFwic2VhcmNoLWJveC50b2dnbGUtcmVnZXhwLnRpdGxlXCI6IFwiUmVnRXhwIFNlYXJjaFwiLFxuICAgIFwic2VhcmNoLWJveC50b2dnbGUtY2FzZS50aXRsZVwiOiBcIkNhc2VTZW5zaXRpdmUgU2VhcmNoXCIsXG4gICAgXCJzZWFyY2gtYm94LnRvZ2dsZS13aG9sZS13b3JkLnRpdGxlXCI6IFwiV2hvbGUgV29yZCBTZWFyY2hcIixcbiAgICBcInNlYXJjaC1ib3gudG9nZ2xlLWluLXNlbGVjdGlvbi50aXRsZVwiOiBcIlNlYXJjaCBJbiBTZWxlY3Rpb25cIixcbiAgICBcInNlYXJjaC1ib3guc2VhcmNoLWNvdW50ZXJcIjogXCIkMCBvZiAkMVwiLFxuICAgIFwidGV4dC1pbnB1dC5hcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImVkaXRvclwiLFxuICAgIFwidGV4dC1pbnB1dC5hcmlhLWxhYmVsXCI6IFwiQ3Vyc29yIGF0IHJvdyAkMFwiLFxuICAgIFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5yYW5nZS5hcmlhLWxhYmVsXCI6IFwiVG9nZ2xlIGNvZGUgZm9sZGluZywgcm93cyAkMCB0aHJvdWdoICQxXCIsXG4gICAgXCJndXR0ZXIuY29kZS1mb2xkaW5nLmNsb3NlZC5hcmlhLWxhYmVsXCI6IFwiVG9nZ2xlIGNvZGUgZm9sZGluZywgcm93cyAkMCB0aHJvdWdoICQxXCIsXG4gICAgXCJndXR0ZXIuY29kZS1mb2xkaW5nLm9wZW4uYXJpYS1sYWJlbFwiOiBcIlRvZ2dsZSBjb2RlIGZvbGRpbmcsIHJvdyAkMFwiLFxuICAgIFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5jbG9zZWQudGl0bGVcIjogXCJVbmZvbGQgY29kZVwiLFxuICAgIFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5vcGVuLnRpdGxlXCI6IFwiRm9sZCBjb2RlXCIsXG4gICAgXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLmVycm9yXCI6IFwiRXJyb3IsIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsXG4gICAgXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLndhcm5pbmdcIjogXCJXYXJuaW5nLCByZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLFxuICAgIFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC5pbmZvXCI6IFwiSW5mbywgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIixcbiAgICBcImlubGluZS1mb2xkLmNsb3NlZC50aXRsZVwiOiBcIlVuZm9sZCBjb2RlXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmVycm9yLnNpbmd1bGFyXCI6IFwiZXJyb3JcIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuZXJyb3IucGx1cmFsXCI6IFwiZXJyb3JzXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLndhcm5pbmcuc2luZ3VsYXJcIjogXCJ3YXJuaW5nXCIsXG4gICAgXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLndhcm5pbmcucGx1cmFsXCI6IFwid2FybmluZ3NcIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuaW5mby5zaW5ndWxhclwiOiBcImluZm9ybWF0aW9uIG1lc3NhZ2VcIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuaW5mby5wbHVyYWxcIjogXCJpbmZvcm1hdGlvbiBtZXNzYWdlc1wiLFxuICAgIFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC5zZWN1cml0eVwiOiBcIlNlY3VyaXR5IGZpbmRpbmcsIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsXG4gICAgXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLmhpbnRcIjogXCJTdWdnZXN0aW9uLCByZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLFxuICAgIFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC5zZWN1cml0eS5zaW5ndWxhclwiOiBcInNlY3VyaXR5IGZpbmRpbmdcIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuc2VjdXJpdHkucGx1cmFsXCI6IFwic2VjdXJpdHkgZmluZGluZ3NcIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuaGludC5zaW5ndWxhclwiOiBcInN1Z2dlc3Rpb25cIixcbiAgICBcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuaGludC5wbHVyYWxcIjogXCJzdWdnZXN0aW9uc1wiXG59O1xuZXhwb3J0cy5kZWZhdWx0RW5nbGlzaE1lc3NhZ2VzID0gZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2FwcF9jb25maWdcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9saWIvcmVwb3J0X2Vycm9yXCIsXCJhY2UvbGliL2RlZmF1bHRfZW5nbGlzaF9tZXNzYWdlc1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcIm5vIHVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9vb3BcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgcmVwb3J0RXJyb3IgPSByZXF1aXJlKFwiLi9yZXBvcnRfZXJyb3JcIikucmVwb3J0RXJyb3I7XG52YXIgZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRfZW5nbGlzaF9tZXNzYWdlc1wiKS5kZWZhdWx0RW5nbGlzaE1lc3NhZ2VzO1xudmFyIG9wdGlvbnNQcm92aWRlciA9IHtcbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0TGlzdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uKGtleSwgb3B0TGlzdFtrZXldKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9uTmFtZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvcHRpb25zW2tleV0uaGlkZGVuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9uTmFtZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvcHRpb25OYW1lcztcbiAgICAgICAgICAgIG9wdGlvbk5hbWVzID0gT2JqZWN0LmtleXMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5nZXRPcHRpb24oa2V5KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpc1tcIiRcIiArIG5hbWVdID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9wdCA9IHRoaXMuJG9wdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICghb3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2FybignbWlzc3BlbGxlZCBvcHRpb24gXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQuZm9yd2FyZFRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbb3B0LmZvcndhcmRUb10gJiYgdGhpc1tvcHQuZm9yd2FyZFRvXS5zZXRPcHRpb24obmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIW9wdC5oYW5kbGVzU2V0KVxuICAgICAgICAgICAgdGhpc1tcIiRcIiArIG5hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmIChvcHQgJiYgb3B0LnNldClcbiAgICAgICAgICAgIG9wdC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRPcHRpb246IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBvcHQgPSB0aGlzLiRvcHRpb25zW25hbWVdO1xuICAgICAgICBpZiAoIW9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIHdhcm4oJ21pc3NwZWxsZWQgb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LmZvcndhcmRUbylcbiAgICAgICAgICAgIHJldHVybiB0aGlzW29wdC5mb3J3YXJkVG9dICYmIHRoaXNbb3B0LmZvcndhcmRUb10uZ2V0T3B0aW9uKG5hbWUpO1xuICAgICAgICByZXR1cm4gb3B0ICYmIG9wdC5nZXQgPyBvcHQuZ2V0LmNhbGwodGhpcykgOiB0aGlzW1wiJFwiICsgbmFtZV07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybilcbiAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG52YXIgbWVzc2FnZXM7XG52YXIgbmxzUGxhY2Vob2xkZXJzO1xudmFyIEFwcENvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHBDb25maWcoKSB7XG4gICAgICAgIHRoaXMuJGRlZmF1bHRPcHRpb25zID0ge307XG4gICAgICAgIG1lc3NhZ2VzID0gZGVmYXVsdEVuZ2xpc2hNZXNzYWdlcztcbiAgICAgICAgbmxzUGxhY2Vob2xkZXJzID0gXCJkb2xsYXJTaWduc1wiO1xuICAgIH1cbiAgICBBcHBDb25maWcucHJvdG90eXBlLmRlZmluZU9wdGlvbnMgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb2JqLiRvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy4kZGVmYXVsdE9wdGlvbnNbcGF0aF0gPSBvYmouJG9wdGlvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBvcHQgPSB7IGZvcndhcmRUbzogb3B0IH07XG4gICAgICAgICAgICBvcHQubmFtZSB8fCAob3B0Lm5hbWUgPSBrZXkpO1xuICAgICAgICAgICAgb2JqLiRvcHRpb25zW29wdC5uYW1lXSA9IG9wdDtcbiAgICAgICAgICAgIGlmIChcImluaXRpYWxWYWx1ZVwiIGluIG9wdClcbiAgICAgICAgICAgICAgICBvYmpbXCIkXCIgKyBvcHQubmFtZV0gPSBvcHQuaW5pdGlhbFZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgb29wLmltcGxlbWVudChvYmosIG9wdGlvbnNQcm92aWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwQ29uZmlnLnByb3RvdHlwZS5yZXNldE9wdGlvbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iai4kb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gb2JqLiRvcHRpb25zW2tleV07XG4gICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIG9wdClcbiAgICAgICAgICAgICAgICBvYmouc2V0T3B0aW9uKGtleSwgb3B0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcHBDb25maWcucHJvdG90eXBlLnNldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChwYXRoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIGZvciAocGF0aCBpbiB0aGlzLiRkZWZhdWx0T3B0aW9ucylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kZGVmYXVsdE9wdGlvbnNbcGF0aF1bbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRkZWZhdWx0T3B0aW9uc1twYXRoXVtuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLiRkZWZhdWx0T3B0aW9uc1twYXRoXSB8fCAodGhpcy4kZGVmYXVsdE9wdGlvbnNbcGF0aF0gPSB7fSk7XG4gICAgICAgIGlmIChvcHRzW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5mb3J3YXJkVG8pXG4gICAgICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0VmFsdWUob3B0cy5mb3J3YXJkVG8sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcHRzW25hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFwcENvbmZpZy5wcm90b3R5cGUuc2V0RGVmYXVsdFZhbHVlcyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25IYXNoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbkhhc2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0VmFsdWUocGF0aCwga2V5LCBvcHRpb25IYXNoW2tleV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIEFwcENvbmZpZy5wcm90b3R5cGUuc2V0TWVzc2FnZXMgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZXMgPSB2YWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFjZWhvbGRlcnMpIHtcbiAgICAgICAgICAgIG5sc1BsYWNlaG9sZGVycyA9IG9wdGlvbnMucGxhY2Vob2xkZXJzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcHBDb25maWcucHJvdG90eXBlLm5scyA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRTdHJpbmcsIHBhcmFtcykge1xuICAgICAgICBpZiAoIW1lc3NhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oXCJObyBtZXNzYWdlIGZvdW5kIGZvciB0aGUga2V5ICdcIiArIGtleSArIFwiJyBpbiBtZXNzYWdlcyB3aXRoIGlkIFwiICsgbWVzc2FnZXMuJGlkICsgXCIsIHRyeWluZyB0byBmaW5kIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBkZWZhdWx0IHN0cmluZyAnXCIgKyBkZWZhdWx0U3RyaW5nICsgXCInLlwiKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXNbZGVmYXVsdFN0cmluZ10pIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiTm8gbWVzc2FnZSBmb3VuZCBmb3IgdGhlIGRlZmF1bHQgc3RyaW5nICdcIiArIGRlZmF1bHRTdHJpbmcgKyBcIicgaW4gdGhlIHByb3ZpZGVkIG1lc3NhZ2VzLiBGYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgRW5nbGlzaCBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNsYXRlZCA9IG1lc3NhZ2VzW2tleV0gfHwgbWVzc2FnZXNbZGVmYXVsdFN0cmluZ10gfHwgZGVmYXVsdFN0cmluZztcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG5sc1BsYWNlaG9sZGVycyA9PT0gXCJkb2xsYXJTaWduc1wiKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZWQucmVwbGFjZSgvXFwkKFxcJHxbXFxkXSspL2csIGZ1bmN0aW9uIChfLCBkb2xsYXJNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9sbGFyTWF0Y2ggPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXNbZG9sbGFyTWF0Y2hdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sc1BsYWNlaG9sZGVycyA9PT0gXCJjdXJseUJyYWNrZXRzXCIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkID0gdHJhbnNsYXRlZC5yZXBsYWNlKC9cXHsoW15cXH1dKylcXH0vZywgZnVuY3Rpb24gKF8sIGN1cmx5QnJhY2tldE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXNbY3VybHlCcmFja2V0TWF0Y2hdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcENvbmZpZztcbn0oKSk7XG5BcHBDb25maWcucHJvdG90eXBlLndhcm4gPSB3YXJuO1xuQXBwQ29uZmlnLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xub29wLmltcGxlbWVudChBcHBDb25maWcucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5BcHBDb25maWcgPSBBcHBDb25maWc7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3RoZW1lL3RleHRtYXRlLWNzc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXttb2R1bGUuZXhwb3J0cyA9IFwiLmFjZS10bSAuYWNlX2d1dHRlciB7XFxuICBiYWNrZ3JvdW5kOiAjZjBmMGYwO1xcbiAgY29sb3I6ICMzMzM7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9wcmludC1tYXJnaW4ge1xcbiAgd2lkdGg6IDFweDtcXG4gIGJhY2tncm91bmQ6ICNlOGU4ZTg7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9mb2xkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzZCNzJFNjtcXG59XFxuXFxuLmFjZS10bSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY3Vyc29yIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuICAgICAgICBcXG4uYWNlLXRtIC5hY2VfaW52aXNpYmxlIHtcXG4gIGNvbG9yOiByZ2IoMTkxLCAxOTEsIDE5MSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9zdG9yYWdlLFxcbi5hY2UtdG0gLmFjZV9rZXl3b3JkIHtcXG4gIGNvbG9yOiBibHVlO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29uc3RhbnQge1xcbiAgY29sb3I6IHJnYigxOTcsIDYsIDExKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9idWlsZGluIHtcXG4gIGNvbG9yOiByZ2IoODgsIDcyLCAyNDYpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29uc3RhbnQuYWNlX2xhbmd1YWdlIHtcXG4gIGNvbG9yOiByZ2IoODgsIDkyLCAyNDYpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29uc3RhbnQuYWNlX2xpYnJhcnkge1xcbiAgY29sb3I6IHJnYig2LCAxNTAsIDE0KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2ludmFsaWQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDAsIDAsIDAuMSk7XFxuICBjb2xvcjogcmVkO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfZnVuY3Rpb24ge1xcbiAgY29sb3I6IHJnYig2MCwgNzYsIDExNCk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9zdXBwb3J0LmFjZV9jb25zdGFudCB7XFxuICBjb2xvcjogcmdiKDYsIDE1MCwgMTQpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfdHlwZSxcXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfY2xhc3Mge1xcbiAgY29sb3I6IHJnYigxMDksIDEyMSwgMjIyKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2tleXdvcmQuYWNlX29wZXJhdG9yIHtcXG4gIGNvbG9yOiByZ2IoMTA0LCAxMTgsIDEzNSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9zdHJpbmcge1xcbiAgY29sb3I6IHJnYigzLCAxMDYsIDcpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29tbWVudCB7XFxuICBjb2xvcjogcmdiKDc2LCAxMzYsIDEwNyk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9jb21tZW50LmFjZV9kb2Mge1xcbiAgY29sb3I6IHJnYigwLCAxMDIsIDI1NSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9jb21tZW50LmFjZV9kb2MuYWNlX3RhZyB7XFxuICBjb2xvcjogcmdiKDEyOCwgMTU5LCAxOTEpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfY29uc3RhbnQuYWNlX251bWVyaWMge1xcbiAgY29sb3I6IHJnYigwLCAwLCAyMDUpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfdmFyaWFibGUge1xcbiAgY29sb3I6IHJnYig0OSwgMTMyLCAxNDkpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfeG1sLXBlIHtcXG4gIGNvbG9yOiByZ2IoMTA0LCAxMDQsIDkxKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2VudGl0eS5hY2VfbmFtZS5hY2VfZnVuY3Rpb24ge1xcbiAgY29sb3I6ICMwMDAwQTI7XFxufVxcblxcblxcbi5hY2UtdG0gLmFjZV9oZWFkaW5nIHtcXG4gIGNvbG9yOiByZ2IoMTIsIDcsIDI1NSk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9saXN0IHtcXG4gIGNvbG9yOnJnYigxODUsIDYsIDE0NCk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9tZXRhLmFjZV90YWcge1xcbiAgY29sb3I6cmdiKDAsIDIyLCAxNDIpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2Vfc3RyaW5nLmFjZV9yZWdleCB7XFxuICBjb2xvcjogcmdiKDI1NSwgMCwgMClcXG59XFxuXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3NlbGVjdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiByZ2IoMTgxLCAyMTMsIDI1NSk7XFxufVxcbi5hY2UtdG0uYWNlX211bHRpc2VsZWN0IC5hY2Vfc2VsZWN0aW9uLmFjZV9zdGFydCB7XFxuICBib3gtc2hhZG93OiAwIDAgM3B4IDBweCB3aGl0ZTtcXG59XFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3N0ZXAge1xcbiAgYmFja2dyb3VuZDogcmdiKDI1MiwgMjU1LCAwKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3N0YWNrIHtcXG4gIGJhY2tncm91bmQ6IHJnYigxNjQsIDIyOSwgMTAxKTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX2JyYWNrZXQge1xcbiAgbWFyZ2luOiAtMXB4IDAgMCAtMXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYWN0aXZlLWxpbmUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA3KTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3IgOiAjZGNkY2RjO1xcbn1cXG5cXG4uYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxuICBiYWNrZ3JvdW5kOiByZ2IoMjUwLCAyNTAsIDI1NSk7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2IoMjAwLCAyMDAsIDI1MCk7XFxufVxcblxcbi5hY2UtdG0gLmFjZV9pbmRlbnQtZ3VpZGUge1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUNDQVlBQUFDWmdiWW5BQUFBRTBsRVFWUUltV1A0Ly8vL2Y0YkxseS8vQndBbVZnZDEvdzExL2dBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKSByaWdodCByZXBlYXQteTtcXG59XFxuXFxuLmFjZS10bSAuYWNlX2luZGVudC1ndWlkZS1hY3RpdmUge1xcbiAgYmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUNDQVlBQUFDWmdiWW5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFBWlNVUkJWSGphWXZqLy8vOS9oaXZLeXY4QkFBQUEvLzhEQUNMcUJoYnZrKy9lQUFBQUFFbEZUa1N1UW1DQ1xcXCIpIHJpZ2h0IHJlcGVhdC15O1xcbn1cXG5cIjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdGhlbWUvdGV4dG1hdGVcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS90aGVtZS90ZXh0bWF0ZS1jc3NcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0RhcmsgPSBmYWxzZTtcbmV4cG9ydHMuY3NzQ2xhc3MgPSBcImFjZS10bVwiO1xuZXhwb3J0cy5jc3NUZXh0ID0gcmVxdWlyZShcIi4vdGV4dG1hdGUtY3NzXCIpO1xuZXhwb3J0cy4kaWQgPSBcImFjZS90aGVtZS90ZXh0bWF0ZVwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xuZG9tLmltcG9ydENzc1N0cmluZyhleHBvcnRzLmNzc1RleHQsIGV4cG9ydHMuY3NzQ2xhc3MsIGZhbHNlKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvY29uZmlnXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvbmV0XCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9hcHBfY29uZmlnXCIsXCJhY2UvdGhlbWUvdGV4dG1hdGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJubyB1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIG5ldCA9IHJlcXVpcmUoXCIuL2xpYi9uZXRcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBBcHBDb25maWcgPSByZXF1aXJlKFwiLi9saWIvYXBwX2NvbmZpZ1wiKS5BcHBDb25maWc7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgQXBwQ29uZmlnKCk7XG52YXIgb3B0aW9ucyA9IHtcbiAgICBwYWNrYWdlZDogZmFsc2UsXG4gICAgd29ya2VyUGF0aDogbnVsbCxcbiAgICBtb2RlUGF0aDogbnVsbCxcbiAgICB0aGVtZVBhdGg6IG51bGwsXG4gICAgYmFzZVBhdGg6IFwiXCIsXG4gICAgc3VmZml4OiBcIi5qc1wiLFxuICAgICRtb2R1bGVVcmxzOiB7fSxcbiAgICBsb2FkV29ya2VyRnJvbUJsb2I6IHRydWUsXG4gICAgc2hhcmVkUG9wdXBzOiBmYWxzZSxcbiAgICB1c2VTdHJpY3RDU1A6IG51bGxcbn07XG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb25maWcga2V5OiBcIiArIGtleSk7XG4gICAgcmV0dXJuIG9wdGlvbnNba2V5XTtcbn07XG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBpZiAodGhpcy5zZXREZWZhdWx0VmFsdWUoXCJcIiwga2V5LCB2YWx1ZSkgPT0gZmFsc2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29uZmlnIGtleTogXCIgKyBrZXkpO1xuICAgIGlmIChrZXkgPT0gXCJ1c2VTdHJpY3RDU1BcIilcbiAgICAgICAgZG9tLnVzZVN0cmljdENTUCh2YWx1ZSk7XG59O1xuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhbmcuY29weU9iamVjdChvcHRpb25zKTtcbn07XG5leHBvcnRzLiRtb2RlcyA9IHt9O1xuZXhwb3J0cy5tb2R1bGVVcmwgPSBmdW5jdGlvbiAobmFtZSwgY29tcG9uZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuJG1vZHVsZVVybHNbbmFtZV0pXG4gICAgICAgIHJldHVybiBvcHRpb25zLiRtb2R1bGVVcmxzW25hbWVdO1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudCB8fCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXSB8fCBcIlwiO1xuICAgIHZhciBzZXAgPSBjb21wb25lbnQgPT0gXCJzbmlwcGV0c1wiID8gXCIvXCIgOiBcIi1cIjtcbiAgICB2YXIgYmFzZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjb21wb25lbnQgPT0gXCJ3b3JrZXJcIiAmJiBzZXAgPT0gXCItXCIpIHtcbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5cIiArIGNvbXBvbmVudCArIFwiW1xcXFwtX118W1xcXFwtX11cIiArIGNvbXBvbmVudCArIFwiJFwiLCBcImdcIik7XG4gICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UocmUsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoKCFiYXNlIHx8IGJhc2UgPT0gY29tcG9uZW50KSAmJiBwYXJ0cy5sZW5ndGggPiAxKVxuICAgICAgICBiYXNlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMl07XG4gICAgdmFyIHBhdGggPSBvcHRpb25zW2NvbXBvbmVudCArIFwiUGF0aFwiXTtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHBhdGggPSBvcHRpb25zLmJhc2VQYXRoO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXAgPT0gXCIvXCIpIHtcbiAgICAgICAgY29tcG9uZW50ID0gc2VwID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHBhdGggJiYgcGF0aC5zbGljZSgtMSkgIT0gXCIvXCIpXG4gICAgICAgIHBhdGggKz0gXCIvXCI7XG4gICAgcmV0dXJuIHBhdGggKyBjb21wb25lbnQgKyBzZXAgKyBiYXNlICsgdGhpcy5nZXQoXCJzdWZmaXhcIik7XG59O1xuZXhwb3J0cy5zZXRNb2R1bGVVcmwgPSBmdW5jdGlvbiAobmFtZSwgc3Vic3QpIHtcbiAgICByZXR1cm4gb3B0aW9ucy4kbW9kdWxlVXJsc1tuYW1lXSA9IHN1YnN0O1xufTtcbnZhciBsb2FkZXIgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSwgY2IpIHtcbiAgICBpZiAobW9kdWxlTmFtZSA9PT0gXCJhY2UvdGhlbWUvdGV4dG1hdGVcIiB8fCBtb2R1bGVOYW1lID09PSBcIi4vdGhlbWUvdGV4dG1hdGVcIilcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlcXVpcmUoXCIuL3RoZW1lL3RleHRtYXRlXCIpKTtcbiAgICBpZiAoY3VzdG9tTG9hZGVyKVxuICAgICAgICByZXR1cm4gY3VzdG9tTG9hZGVyKG1vZHVsZU5hbWUsIGNiKTtcbiAgICBjb25zb2xlLmVycm9yKFwibG9hZGVyIGlzIG5vdCBjb25maWd1cmVkXCIpO1xufTtcbnZhciBjdXN0b21Mb2FkZXI7XG5leHBvcnRzLnNldExvYWRlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIGN1c3RvbUxvYWRlciA9IGNiO1xufTtcbmV4cG9ydHMuZHluYW1pY01vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy4kbG9hZGluZyA9IHt9O1xuZXhwb3J0cy4kbG9hZGVkID0ge307XG5leHBvcnRzLmxvYWRNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9uTG9hZCkge1xuICAgIHZhciBsb2FkZWRNb2R1bGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlSWQpKSB7XG4gICAgICAgIHZhciBtb2R1bGVUeXBlID0gbW9kdWxlSWRbMF07XG4gICAgICAgIHZhciBtb2R1bGVOYW1lID0gbW9kdWxlSWRbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGVJZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBtb2R1bGVOYW1lID0gbW9kdWxlSWQ7XG4gICAgfVxuICAgIHZhciBsb2FkID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICBpZiAobW9kdWxlICYmICFleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuIG9uTG9hZCAmJiBvbkxvYWQobW9kdWxlKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdKVxuICAgICAgICAgICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSA9IFtdO1xuICAgICAgICBleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdLnB1c2gob25Mb2FkKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV0ubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGFmdGVyTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvYWRlcihtb2R1bGVOYW1lLCBmdW5jdGlvbiAoZXJyLCBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlKVxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLiRsb2FkZWRbbW9kdWxlTmFtZV0gPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fZW1pdChcImxvYWQubW9kdWxlXCIsIHsgbmFtZTogbW9kdWxlTmFtZSwgbW9kdWxlOiBtb2R1bGUgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV07XG4gICAgICAgICAgICAgICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFleHBvcnRzLmdldChcInBhY2thZ2VkXCIpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyTG9hZCgpO1xuICAgICAgICBuZXQubG9hZFNjcmlwdChleHBvcnRzLm1vZHVsZVVybChtb2R1bGVOYW1lLCBtb2R1bGVUeXBlKSwgYWZ0ZXJMb2FkKTtcbiAgICAgICAgcmVwb3J0RXJyb3JJZlBhdGhJc05vdENvbmZpZ3VyZWQoKTtcbiAgICB9O1xuICAgIGlmIChleHBvcnRzLmR5bmFtaWNNb2R1bGVzW21vZHVsZU5hbWVdKSB7XG4gICAgICAgIGV4cG9ydHMuZHluYW1pY01vZHVsZXNbbW9kdWxlTmFtZV0oKS50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGxvYWQobW9kdWxlLmRlZmF1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9hZChtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2FkZWRNb2R1bGUgPSB0aGlzLiRyZXF1aXJlKG1vZHVsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgbG9hZChsb2FkZWRNb2R1bGUgfHwgZXhwb3J0cy4kbG9hZGVkW21vZHVsZU5hbWVdKTtcbiAgICB9XG59O1xuZXhwb3J0cy4kcmVxdWlyZSA9IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVbXCJyZXF1aXJlXCJdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgcmVxID0gXCJyZXF1aXJlXCI7XG4gICAgICAgIHJldHVybiBtb2R1bGVbcmVxXShtb2R1bGVOYW1lKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRNb2R1bGVMb2FkZXIgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSwgb25Mb2FkKSB7XG4gICAgZXhwb3J0cy5keW5hbWljTW9kdWxlc1ttb2R1bGVOYW1lXSA9IG9uTG9hZDtcbn07XG52YXIgcmVwb3J0RXJyb3JJZlBhdGhJc05vdENvbmZpZ3VyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFvcHRpb25zLmJhc2VQYXRoICYmICFvcHRpb25zLndvcmtlclBhdGhcbiAgICAgICAgJiYgIW9wdGlvbnMubW9kZVBhdGggJiYgIW9wdGlvbnMudGhlbWVQYXRoXG4gICAgICAgICYmICFPYmplY3Qua2V5cyhvcHRpb25zLiRtb2R1bGVVcmxzKS5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbmZlciBwYXRoIHRvIGFjZSBmcm9tIHNjcmlwdCBzcmMsXCIsIFwidXNlIGFjZS5jb25maWcuc2V0KCdiYXNlUGF0aCcsICdwYXRoJykgdG8gZW5hYmxlIGR5bmFtaWMgbG9hZGluZyBvZiBtb2RlcyBhbmQgdGhlbWVzXCIsIFwib3Igd2l0aCB3ZWJwYWNrIHVzZSBhY2Uvd2VicGFjay1yZXNvbHZlclwiKTtcbiAgICAgICAgcmVwb3J0RXJyb3JJZlBhdGhJc05vdENvbmZpZ3VyZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMS4zOS4wXCI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xvYWRlcl9idWlsZFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9maXhvbGRicm93c2Vyc1wiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcIi4vbGliL2ZpeG9sZGJyb3dzZXJzXCIpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbmNvbmZpZy5zZXRMb2FkZXIoZnVuY3Rpb24obW9kdWxlTmFtZSwgY2IpIHtcbiAgICByZXF1aXJlKFttb2R1bGVOYW1lXSwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgIGNiKG51bGwsIG1vZHVsZSk7XG4gICAgfSk7XG59KTtcblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyB8fCB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgd2luZG93O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhY2UpIHtcbiAgICBjb25maWcuaW5pdCA9IGluaXQ7XG4gICAgY29uZmlnLiRyZXF1aXJlID0gcmVxdWlyZTtcbiAgICBhY2UucmVxdWlyZSA9IHJlcXVpcmU7XG5cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBhY2UuZGVmaW5lID0gZGVmaW5lO1xufTtcbmluaXQodHJ1ZSk7ZnVuY3Rpb24gaW5pdChwYWNrYWdlZCkge1xuXG4gICAgaWYgKCFnbG9iYWwgfHwgIWdsb2JhbC5kb2N1bWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbmZpZy5zZXQoXCJwYWNrYWdlZFwiLCBwYWNrYWdlZCB8fCByZXF1aXJlLnBhY2thZ2VkIHx8IG1vZHVsZS5wYWNrYWdlZCB8fCAoZ2xvYmFsLmRlZmluZSAmJiBkZWZpbmUucGFja2FnZWQpKTtcblxuICAgIHZhciBzY3JpcHRPcHRpb25zID0ge307XG4gICAgdmFyIHNjcmlwdFVybCA9IFwiXCI7XG4gICAgdmFyIGN1cnJlbnRTY3JpcHQgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCBkb2N1bWVudC5fY3VycmVudFNjcmlwdCApOyAvLyBuYXRpdmUgb3IgcG9seWZpbGxcbiAgICB2YXIgY3VycmVudERvY3VtZW50ID0gY3VycmVudFNjcmlwdCAmJiBjdXJyZW50U2NyaXB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgXG4gICAgaWYgKGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5zcmMpIHtcbiAgICAgICAgc2NyaXB0VXJsID0gY3VycmVudFNjcmlwdC5zcmMuc3BsaXQoL1s/I10vKVswXS5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpIHx8IFwiXCI7XG4gICAgfVxuICAgIFxuICAgIHZhciBzY3JpcHRzID0gY3VycmVudERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgIGZvciAodmFyIGk9MDsgaTxzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuXG4gICAgICAgIHZhciBzcmMgPSBzY3JpcHQuc3JjIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgIGlmICghc3JjKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzY3JpcHQuYXR0cmlidXRlcztcbiAgICAgICAgZm9yICh2YXIgaj0wLCBsPWF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lLmluZGV4T2YoXCJkYXRhLWFjZS1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRPcHRpb25zW2RlSHlwaGVuYXRlKGF0dHIubmFtZS5yZXBsYWNlKC9eZGF0YS1hY2UtLywgXCJcIikpXSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHNyYy5tYXRjaCgvXiguKilcXC9hY2UoW1xcLS5dXFx3Kyk/XFwuanMoXFw/fCQpLyk7XG4gICAgICAgIGlmIChtKVxuICAgICAgICAgICAgc2NyaXB0VXJsID0gbVsxXTtcbiAgICB9XG5cbiAgICBpZiAoc2NyaXB0VXJsKSB7XG4gICAgICAgIHNjcmlwdE9wdGlvbnMuYmFzZSA9IHNjcmlwdE9wdGlvbnMuYmFzZSB8fCBzY3JpcHRVcmw7XG4gICAgICAgIHNjcmlwdE9wdGlvbnMucGFja2FnZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNjcmlwdE9wdGlvbnMuYmFzZVBhdGggPSBzY3JpcHRPcHRpb25zLmJhc2U7XG4gICAgc2NyaXB0T3B0aW9ucy53b3JrZXJQYXRoID0gc2NyaXB0T3B0aW9ucy53b3JrZXJQYXRoIHx8IHNjcmlwdE9wdGlvbnMuYmFzZTtcbiAgICBzY3JpcHRPcHRpb25zLm1vZGVQYXRoID0gc2NyaXB0T3B0aW9ucy5tb2RlUGF0aCB8fCBzY3JpcHRPcHRpb25zLmJhc2U7XG4gICAgc2NyaXB0T3B0aW9ucy50aGVtZVBhdGggPSBzY3JpcHRPcHRpb25zLnRoZW1lUGF0aCB8fCBzY3JpcHRPcHRpb25zLmJhc2U7XG4gICAgZGVsZXRlIHNjcmlwdE9wdGlvbnMuYmFzZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzY3JpcHRPcHRpb25zKVxuICAgICAgICBpZiAodHlwZW9mIHNjcmlwdE9wdGlvbnNba2V5XSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIGNvbmZpZy5zZXQoa2V5LCBzY3JpcHRPcHRpb25zW2tleV0pO1xufVxuXG5mdW5jdGlvbiBkZUh5cGhlbmF0ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24obSwgbTEpIHsgcmV0dXJuIG0xLnRvVXBwZXJDYXNlKCk7IH0pO1xufVxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcmFuZ2VcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBlbmRSb3csIGVuZENvbHVtbikge1xuICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgcm93OiBzdGFydFJvdyxcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnRDb2x1bW5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmQgPSB7XG4gICAgICAgICAgICByb3c6IGVuZFJvdyxcbiAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uXG4gICAgICAgIH07XG4gICAgfVxuICAgIFJhbmdlLnByb3RvdHlwZS5pc0VxdWFsID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvdyA9PT0gcmFuZ2Uuc3RhcnQucm93ICYmXG4gICAgICAgICAgICB0aGlzLmVuZC5yb3cgPT09IHJhbmdlLmVuZC5yb3cgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID09PSByYW5nZS5zdGFydC5jb2x1bW4gJiZcbiAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiA9PT0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcIlJhbmdlOiBbXCIgKyB0aGlzLnN0YXJ0LnJvdyArIFwiL1wiICsgdGhpcy5zdGFydC5jb2x1bW4gK1xuICAgICAgICAgICAgXCJdIC0+IFtcIiArIHRoaXMuZW5kLnJvdyArIFwiL1wiICsgdGhpcy5lbmQuY29sdW1uICsgXCJdXCIpO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDA7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcGFyZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBjbXAsIGVuZCA9IHJhbmdlLmVuZCwgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgY21wID0gdGhpcy5jb21wYXJlKGVuZC5yb3csIGVuZC5jb2x1bW4pO1xuICAgICAgICBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBhcmVQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocC5yb3csIHAuY29sdW1uKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb250YWluc1JhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5zdGFydCkgPT0gMCAmJiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5lbmQpID09IDA7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgY21wID0gdGhpcy5jb21wYXJlUmFuZ2UocmFuZ2UpO1xuICAgICAgICByZXR1cm4gKGNtcCA9PSAtMSB8fCBjbXAgPT0gMCB8fCBjbXAgPT0gMSk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaXNFbmQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnJvdyA9PSByb3cgJiYgdGhpcy5lbmQuY29sdW1uID09IGNvbHVtbjtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5pc1N0YXJ0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLnNldFN0YXJ0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gcm93LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93LnJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93O1xuICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5zZXRFbmQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByb3cgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gcm93LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IHJvdy5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSByb3c7XG4gICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5pbnNpZGUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQocm93LCBjb2x1bW4pIHx8IHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaW5zaWRlU3RhcnQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQocm93LCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmluc2lkZUVuZCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlKHJvdywgY29sdW1uKSA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KHJvdywgY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICBpZiAocm93ID09PSB0aGlzLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPCB0aGlzLnN0YXJ0LmNvbHVtbiA/IC0xIDogKGNvbHVtbiA+IHRoaXMuZW5kLmNvbHVtbiA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93IDwgdGhpcy5zdGFydC5yb3cpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChyb3cgPiB0aGlzLmVuZC5yb3cpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnQucm93ID09PSByb3cpXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uID49IHRoaXMuc3RhcnQuY29sdW1uID8gMCA6IC0xO1xuICAgICAgICBpZiAodGhpcy5lbmQucm93ID09PSByb3cpXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uIDw9IHRoaXMuZW5kLmNvbHVtbiA/IDAgOiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wYXJlU3RhcnQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnQucm93ID09IHJvdyAmJiB0aGlzLnN0YXJ0LmNvbHVtbiA9PSBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcGFyZUVuZCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5lbmQucm93ID09IHJvdyAmJiB0aGlzLmVuZC5jb2x1bW4gPT0gY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcGFyZUluc2lkZSA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5lbmQucm93ID09IHJvdyAmJiB0aGlzLmVuZC5jb2x1bW4gPT0gY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNsaXBSb3dzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIGlmICh0aGlzLmVuZC5yb3cgPiBsYXN0Um93KVxuICAgICAgICAgICAgdmFyIGVuZCA9IHsgcm93OiBsYXN0Um93ICsgMSwgY29sdW1uOiAwIH07XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kLnJvdyA8IGZpcnN0Um93KVxuICAgICAgICAgICAgdmFyIGVuZCA9IHsgcm93OiBmaXJzdFJvdywgY29sdW1uOiAwIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA+IGxhc3RSb3cpXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB7IHJvdzogbGFzdFJvdyArIDEsIGNvbHVtbjogMCB9O1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXJ0LnJvdyA8IGZpcnN0Um93KVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0geyByb3c6IGZpcnN0Um93LCBjb2x1bW46IDAgfTtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQgfHwgdGhpcy5zdGFydCwgZW5kIHx8IHRoaXMuZW5kKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGNtcCA9IHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7XG4gICAgICAgIGlmIChjbXAgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChjbXAgPT0gLTEpXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB7IHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YXIgZW5kID0geyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQgfHwgdGhpcy5zdGFydCwgZW5kIHx8IHRoaXMuZW5kKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQucm93ID09PSB0aGlzLmVuZC5yb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT09IHRoaXMuZW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuaXNNdWx0aUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydC5yb3cgIT09IHRoaXMuZW5kLnJvdyk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb2xsYXBzZVJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZC5jb2x1bW4gPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csIDAsIE1hdGgubWF4KHRoaXMuc3RhcnQucm93LCB0aGlzLmVuZC5yb3cgLSAxKSwgMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csIDAsIHRoaXMuZW5kLnJvdywgMCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUudG9TY3JlZW5SYW5nZSA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHZhciBzY3JlZW5Qb3NTdGFydCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuc3RhcnQpO1xuICAgICAgICB2YXIgc2NyZWVuUG9zRW5kID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5lbmQpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHNjcmVlblBvc1N0YXJ0LnJvdywgc2NyZWVuUG9zU3RhcnQuY29sdW1uLCBzY3JlZW5Qb3NFbmQucm93LCBzY3JlZW5Qb3NFbmQuY29sdW1uKTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zdGFydC5yb3cgKz0gcm93O1xuICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiArPSBjb2x1bW47XG4gICAgICAgIHRoaXMuZW5kLnJvdyArPSByb3c7XG4gICAgICAgIHRoaXMuZW5kLmNvbHVtbiArPSBjb2x1bW47XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2U7XG59KCkpO1xuUmFuZ2UuZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbiwgZW5kLnJvdywgZW5kLmNvbHVtbik7XG59O1xuUmFuZ2UuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjtcbn07XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9rZXlzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9vb3BcIik7XG52YXIgS2V5cyA9IHtcbiAgICBNT0RJRklFUl9LRVlTOiB7XG4gICAgICAgIDE2OiAnU2hpZnQnLCAxNzogJ0N0cmwnLCAxODogJ0FsdCcsIDIyNDogJ01ldGEnLFxuICAgICAgICA5MTogJ01ldGFMZWZ0JywgOTI6ICdNZXRhUmlnaHQnLCA5MzogJ0NvbnRleHRNZW51J1xuICAgIH0sXG4gICAgS0VZX01PRFM6IHtcbiAgICAgICAgXCJjdHJsXCI6IDEsIFwiYWx0XCI6IDIsIFwib3B0aW9uXCI6IDIsIFwic2hpZnRcIjogNCxcbiAgICAgICAgXCJzdXBlclwiOiA4LCBcIm1ldGFcIjogOCwgXCJjb21tYW5kXCI6IDgsIFwiY21kXCI6IDgsXG4gICAgICAgIFwiY29udHJvbFwiOiAxXG4gICAgfSxcbiAgICBGVU5DVElPTl9LRVlTOiB7XG4gICAgICAgIDg6IFwiQmFja3NwYWNlXCIsXG4gICAgICAgIDk6IFwiVGFiXCIsXG4gICAgICAgIDEzOiBcIlJldHVyblwiLFxuICAgICAgICAxOTogXCJQYXVzZVwiLFxuICAgICAgICAyNzogXCJFc2NcIixcbiAgICAgICAgMzI6IFwiU3BhY2VcIixcbiAgICAgICAgMzM6IFwiUGFnZVVwXCIsXG4gICAgICAgIDM0OiBcIlBhZ2VEb3duXCIsXG4gICAgICAgIDM1OiBcIkVuZFwiLFxuICAgICAgICAzNjogXCJIb21lXCIsXG4gICAgICAgIDM3OiBcIkxlZnRcIixcbiAgICAgICAgMzg6IFwiVXBcIixcbiAgICAgICAgMzk6IFwiUmlnaHRcIixcbiAgICAgICAgNDA6IFwiRG93blwiLFxuICAgICAgICA0NDogXCJQcmludFwiLFxuICAgICAgICA0NTogXCJJbnNlcnRcIixcbiAgICAgICAgNDY6IFwiRGVsZXRlXCIsXG4gICAgICAgICctMTMnOiBcIk51bXBhZEVudGVyXCIsXG4gICAgICAgIDE0NDogXCJOdW1sb2NrXCIsXG4gICAgICAgIDE0NTogXCJTY3JvbGxsb2NrXCJcbiAgICB9LFxuICAgIFBSSU5UQUJMRV9LRVlTOiB7XG4gICAgICAgIDMyOiAnICcsIDU5OiAnOycsIDYxOiAnPScsIDEwNzogJysnLCAxMDk6ICctJywgMTEwOiAnLicsXG4gICAgICAgIDE4NjogJzsnLCAxODc6ICc9JywgMTg4OiAnLCcsIDE4OTogJy0nLCAxOTA6ICcuJywgMTkxOiAnLycsIDE5MjogJ2AnLFxuICAgICAgICAyMTk6ICdbJywgMjIwOiAnXFxcXCcsIDIyMTogJ10nLCAyMjI6IFwiJ1wiLCAxMTE6ICcvJywgMTA2OiAnKidcbiAgICB9XG59O1xudmFyIGNvZGVUb0tleUNvZGUgPSB7XG4gICAgQ29tbWFuZDogMjI0LFxuICAgIEJhY2tzcGFjZTogOCxcbiAgICBUYWI6IDksXG4gICAgUmV0dXJuOiAxMyxcbiAgICBFbnRlcjogMTMsXG4gICAgUGF1c2U6IDE5LFxuICAgIEVzY2FwZTogMjcsXG4gICAgUGFnZVVwOiAzMyxcbiAgICBQYWdlRG93bjogMzQsXG4gICAgRW5kOiAzNSxcbiAgICBIb21lOiAzNixcbiAgICBJbnNlcnQ6IDQ1LFxuICAgIERlbGV0ZTogNDYsXG4gICAgQXJyb3dMZWZ0OiAzNyxcbiAgICBBcnJvd1VwOiAzOCxcbiAgICBBcnJvd1JpZ2h0OiAzOSxcbiAgICBBcnJvd0Rvd246IDQwLFxuICAgIEJhY2txdW90ZTogMTkyLFxuICAgIE1pbnVzOiAxODksXG4gICAgRXF1YWw6IDE4NyxcbiAgICBCcmFja2V0TGVmdDogMjE5LFxuICAgIEJhY2tzbGFzaDogMjIwLFxuICAgIEJyYWNrZXRSaWdodDogMjIxLFxuICAgIFNlbWljb2xvbjogMTg2LFxuICAgIFF1b3RlOiAyMjIsXG4gICAgQ29tbWE6IDE4OCxcbiAgICBQZXJpb2Q6IDE5MCxcbiAgICBTbGFzaDogMTkxLFxuICAgIFNwYWNlOiAzMixcbiAgICBOdW1wYWRBZGQ6IDEwNyxcbiAgICBOdW1wYWREZWNpbWFsOiAxMTAsXG4gICAgTnVtcGFkU3VidHJhY3Q6IDEwOSxcbiAgICBOdW1wYWREaXZpZGU6IDExMSxcbiAgICBOdW1wYWRNdWx0aXBseTogMTA2XG59O1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgY29kZVRvS2V5Q29kZVtcIkRpZ2l0XCIgKyBpXSA9IDQ4ICsgaTtcbiAgICBjb2RlVG9LZXlDb2RlW1wiTnVtcGFkXCIgKyBpXSA9IDk2ICsgaTtcbiAgICBLZXlzLlBSSU5UQUJMRV9LRVlTWzQ4ICsgaV0gPSBcIlwiICsgaTtcbiAgICBLZXlzLkZVTkNUSU9OX0tFWVNbOTYgKyBpXSA9IFwiTnVtcGFkXCIgKyBpO1xufVxuZm9yICh2YXIgaSA9IDY1OyBpIDwgOTE7IGkrKykge1xuICAgIHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMik7XG4gICAgY29kZVRvS2V5Q29kZVtcIktleVwiICsgY2hyLnRvVXBwZXJDYXNlKCldID0gaTtcbiAgICBLZXlzLlBSSU5UQUJMRV9LRVlTW2ldID0gY2hyO1xufVxuZm9yICh2YXIgaSA9IDE7IGkgPCAxMzsgaSsrKSB7XG4gICAgY29kZVRvS2V5Q29kZVtcIkZcIiArIGldID0gMTExICsgaTtcbiAgICBLZXlzLkZVTkNUSU9OX0tFWVNbMTExICsgaV0gPSBcIkZcIiArIGk7XG59XG52YXIgbW9kaWZpZXJzID0ge1xuICAgIFNoaWZ0OiAxNixcbiAgICBDb250cm9sOiAxNyxcbiAgICBBbHQ6IDE4LFxuICAgIE1ldGE6IDIyNFxufTtcbmZvciAodmFyIG1vZCBpbiBtb2RpZmllcnMpIHtcbiAgICBjb2RlVG9LZXlDb2RlW21vZF0gPSBjb2RlVG9LZXlDb2RlW21vZCArIFwiTGVmdFwiXVxuICAgICAgICA9IGNvZGVUb0tleUNvZGVbbW9kICsgXCJSaWdodFwiXSA9IG1vZGlmaWVyc1ttb2RdO1xufVxuZXhwb3J0cy4kY29kZVRvS2V5Q29kZSA9IGNvZGVUb0tleUNvZGU7XG5LZXlzLlBSSU5UQUJMRV9LRVlTWzE3M10gPSAnLSc7XG5mb3IgKHZhciBqIGluIEtleXMuRlVOQ1RJT05fS0VZUykge1xuICAgIHZhciBuYW1lID0gS2V5cy5GVU5DVElPTl9LRVlTW2pdLnRvTG93ZXJDYXNlKCk7XG4gICAgS2V5c1tuYW1lXSA9IHBhcnNlSW50KGosIDEwKTtcbn1cbmZvciAodmFyIGogaW4gS2V5cy5QUklOVEFCTEVfS0VZUykge1xuICAgIHZhciBuYW1lID0gS2V5cy5QUklOVEFCTEVfS0VZU1tqXS50b0xvd2VyQ2FzZSgpO1xuICAgIEtleXNbbmFtZV0gPSBwYXJzZUludChqLCAxMCk7XG59XG5vb3AubWl4aW4oS2V5cywgS2V5cy5NT0RJRklFUl9LRVlTKTtcbm9vcC5taXhpbihLZXlzLCBLZXlzLlBSSU5UQUJMRV9LRVlTKTtcbm9vcC5taXhpbihLZXlzLCBLZXlzLkZVTkNUSU9OX0tFWVMpO1xuS2V5cy5lbnRlciA9IEtleXNbXCJyZXR1cm5cIl07XG5LZXlzLmVzY2FwZSA9IEtleXMuZXNjO1xuS2V5cy5kZWwgPSBLZXlzW1wiZGVsZXRlXCJdO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kcyA9IFtcImNtZFwiLCBcImN0cmxcIiwgXCJhbHRcIiwgXCJzaGlmdFwiXTtcbiAgICBmb3IgKHZhciBpID0gTWF0aC5wb3coMiwgbW9kcy5sZW5ndGgpOyBpLS07KSB7XG4gICAgICAgIEtleXMuS0VZX01PRFNbaV0gPSBtb2RzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGkgJiBLZXlzLktFWV9NT0RTW3hdO1xuICAgICAgICB9KS5qb2luKFwiLVwiKSArIFwiLVwiO1xuICAgIH1cbn0pKCk7XG5LZXlzLktFWV9NT0RTWzBdID0gXCJcIjtcbktleXMuS0VZX01PRFNbLTFdID0gXCJpbnB1dC1cIjtcbm9vcC5taXhpbihleHBvcnRzLCBLZXlzKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHM7XG5leHBvcnRzLmtleUNvZGVUb1N0cmluZyA9IGZ1bmN0aW9uIChrZXlDb2RlKSB7XG4gICAgdmFyIGtleVN0cmluZyA9IEtleXNba2V5Q29kZV07XG4gICAgaWYgKHR5cGVvZiBrZXlTdHJpbmcgIT0gXCJzdHJpbmdcIilcbiAgICAgICAga2V5U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICByZXR1cm4ga2V5U3RyaW5nLnRvTG93ZXJDYXNlKCk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZXZlbnRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIva2V5c1wiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7IHZhciBrZXlzID0gcmVxdWlyZShcIi4va2V5c1wiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi91c2VyYWdlbnRcIik7XG52YXIgcHJlc3NlZEtleXMgPSBudWxsO1xudmFyIHRzID0gMDtcbnZhciBhY3RpdmVMaXN0ZW5lck9wdGlvbnM7XG5mdW5jdGlvbiBkZXRlY3RMaXN0ZW5lck9wdGlvbnNTdXBwb3J0KCkge1xuICAgIGFjdGl2ZUxpc3RlbmVyT3B0aW9ucyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgZnVuY3Rpb24gKCkgeyB9LCB7XG4gICAgICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVMaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG59XG5mdW5jdGlvbiBnZXRMaXN0ZW5lck9wdGlvbnMoKSB7XG4gICAgaWYgKGFjdGl2ZUxpc3RlbmVyT3B0aW9ucyA9PSB1bmRlZmluZWQpXG4gICAgICAgIGRldGVjdExpc3RlbmVyT3B0aW9uc1N1cHBvcnQoKTtcbiAgICByZXR1cm4gYWN0aXZlTGlzdGVuZXJPcHRpb25zO1xufVxuZnVuY3Rpb24gRXZlbnRMaXN0ZW5lcihlbGVtLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5FdmVudExpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMuZWxlbSwgdGhpcy50eXBlLCB0aGlzLmNhbGxiYWNrKTtcbiAgICB0aGlzLmVsZW0gPSB0aGlzLnR5cGUgPSB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xufTtcbnZhciBhZGRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgY2FsbGJhY2ssIGRlc3Ryb3llcikge1xuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgZ2V0TGlzdGVuZXJPcHRpb25zKCkpO1xuICAgIGlmIChkZXN0cm95ZXIpXG4gICAgICAgIGRlc3Ryb3llci4kdG9EZXN0cm95LnB1c2gobmV3IEV2ZW50TGlzdGVuZXIoZWxlbSwgdHlwZSwgY2FsbGJhY2spKTtcbn07XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBnZXRMaXN0ZW5lck9wdGlvbnMoKSk7XG59O1xuZXhwb3J0cy5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGV4cG9ydHMuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIGV4cG9ydHMucHJldmVudERlZmF1bHQoZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5leHBvcnRzLmdldEJ1dHRvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudHlwZSA9PSBcImRibGNsaWNrXCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmIChlLnR5cGUgPT0gXCJjb250ZXh0bWVudVwiIHx8ICh1c2VyYWdlbnQuaXNNYWMgJiYgKGUuY3RybEtleSAmJiAhZS5hbHRLZXkgJiYgIWUuc2hpZnRLZXkpKSlcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgcmV0dXJuIGUuYnV0dG9uO1xufTtcbmV4cG9ydHMuY2FwdHVyZSA9IGZ1bmN0aW9uIChlbCwgZXZlbnRIYW5kbGVyLCByZWxlYXNlQ2FwdHVyZUhhbmRsZXIpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IGVsICYmIGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyICYmIGV2ZW50SGFuZGxlcihlKTtcbiAgICAgICAgcmVsZWFzZUNhcHR1cmVIYW5kbGVyICYmIHJlbGVhc2VDYXB0dXJlSGFuZGxlcihlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKG93bmVyRG9jdW1lbnQsIFwiZHJhZ3N0YXJ0XCIsIG9uTW91c2VVcCk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKG93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGV2ZW50SGFuZGxlcik7XG4gICAgYWRkTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgYWRkTGlzdGVuZXIob3duZXJEb2N1bWVudCwgXCJkcmFnc3RhcnRcIiwgb25Nb3VzZVVwKTtcbiAgICByZXR1cm4gb25Nb3VzZVVwO1xufTtcbmV4cG9ydHMuYWRkTW91c2VXaGVlbExpc3RlbmVyID0gZnVuY3Rpb24gKGVsLCBjYWxsYmFjaywgZGVzdHJveWVyKSB7XG4gICAgYWRkTGlzdGVuZXIoZWwsIFwid2hlZWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDAuMTU7XG4gICAgICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWCB8fCAwO1xuICAgICAgICB2YXIgZGVsdGFZID0gZS5kZWx0YVkgfHwgMDtcbiAgICAgICAgc3dpdGNoIChlLmRlbHRhTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBlLkRPTV9ERUxUQV9QSVhFTDpcbiAgICAgICAgICAgICAgICBlLndoZWVsWCA9IGRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IGRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZS5ET01fREVMVEFfTElORTpcbiAgICAgICAgICAgICAgICB2YXIgbGluZVBpeGVscyA9IDE1O1xuICAgICAgICAgICAgICAgIGUud2hlZWxYID0gZGVsdGFYICogbGluZVBpeGVscztcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IGRlbHRhWSAqIGxpbmVQaXhlbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGUuRE9NX0RFTFRBX1BBR0U6XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VQaXhlbHMgPSAxNTA7XG4gICAgICAgICAgICAgICAgZS53aGVlbFggPSBkZWx0YVggKiBwYWdlUGl4ZWxzO1xuICAgICAgICAgICAgICAgIGUud2hlZWxZID0gZGVsdGFZICogcGFnZVBpeGVscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9LCBkZXN0cm95ZXIpO1xufTtcbmV4cG9ydHMuYWRkTXVsdGlNb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50cywgdGltZW91dHMsIGV2ZW50SGFuZGxlciwgY2FsbGJhY2tOYW1lLCBkZXN0cm95ZXIpIHtcbiAgICB2YXIgY2xpY2tzID0gMDtcbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIHRpbWVyO1xuICAgIHZhciBldmVudE5hbWVzID0ge1xuICAgICAgICAyOiBcImRibGNsaWNrXCIsXG4gICAgICAgIDM6IFwidHJpcGxlY2xpY2tcIixcbiAgICAgICAgNDogXCJxdWFkY2xpY2tcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gb25Nb3VzZWRvd24oZSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5nZXRCdXR0b24oZSkgIT09IDApIHtcbiAgICAgICAgICAgIGNsaWNrcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICBjbGlja3MrKztcbiAgICAgICAgICAgIGlmIChjbGlja3MgPiA0KVxuICAgICAgICAgICAgICAgIGNsaWNrcyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGlja3MgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSkge1xuICAgICAgICAgICAgdmFyIGlzTmV3Q2xpY2sgPSBNYXRoLmFicyhlLmNsaWVudFggLSBzdGFydFgpID4gNSB8fCBNYXRoLmFicyhlLmNsaWVudFkgLSBzdGFydFkpID4gNTtcbiAgICAgICAgICAgIGlmICghdGltZXIgfHwgaXNOZXdDbGljaylcbiAgICAgICAgICAgICAgICBjbGlja3MgPSAxO1xuICAgICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aW1lciA9IG51bGw7IH0sIHRpbWVvdXRzW2NsaWNrcyAtIDFdIHx8IDYwMCk7XG4gICAgICAgICAgICBpZiAoY2xpY2tzID09IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUuX2NsaWNrcyA9IGNsaWNrcztcbiAgICAgICAgZXZlbnRIYW5kbGVyW2NhbGxiYWNrTmFtZV0oXCJtb3VzZWRvd25cIiwgZSk7XG4gICAgICAgIGlmIChjbGlja3MgPiA0KVxuICAgICAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgZWxzZSBpZiAoY2xpY2tzID4gMSlcbiAgICAgICAgICAgIHJldHVybiBldmVudEhhbmRsZXJbY2FsbGJhY2tOYW1lXShldmVudE5hbWVzW2NsaWNrc10sIGUpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWwsIFwibW91c2Vkb3duXCIsIG9uTW91c2Vkb3duLCBkZXN0cm95ZXIpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGdldE1vZGlmaWVySGFzaChlKSB7XG4gICAgcmV0dXJuIDAgfCAoZS5jdHJsS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5tZXRhS2V5ID8gOCA6IDApO1xufVxuZXhwb3J0cy5nZXRNb2RpZmllclN0cmluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGtleXMuS0VZX01PRFNbZ2V0TW9kaWZpZXJIYXNoKGUpXTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb21tYW5kS2V5cyhjYWxsYmFjaywgZSwga2V5Q29kZSkge1xuICAgIHZhciBoYXNoSWQgPSBnZXRNb2RpZmllckhhc2goZSk7XG4gICAgaWYgKCFrZXlDb2RlICYmIGUuY29kZSkge1xuICAgICAgICBrZXlDb2RlID0ga2V5cy4kY29kZVRvS2V5Q29kZVtlLmNvZGVdIHx8IGtleUNvZGU7XG4gICAgfVxuICAgIGlmICghdXNlcmFnZW50LmlzTWFjICYmIHByZXNzZWRLZXlzKSB7XG4gICAgICAgIGlmIChlLmdldE1vZGlmaWVyU3RhdGUgJiYgKGUuZ2V0TW9kaWZpZXJTdGF0ZShcIk9TXCIpIHx8IGUuZ2V0TW9kaWZpZXJTdGF0ZShcIldpblwiKSkpXG4gICAgICAgICAgICBoYXNoSWQgfD0gODtcbiAgICAgICAgaWYgKHByZXNzZWRLZXlzLmFsdEdyKSB7XG4gICAgICAgICAgICBpZiAoKDMgJiBoYXNoSWQpICE9IDMpXG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuYWx0R3IgPSAwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTggfHwga2V5Q29kZSA9PT0gMTcpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGUubG9jYXRpb247XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTcgJiYgbG9jYXRpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3NlZEtleXNba2V5Q29kZV0gPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgdHMgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IDE4ICYmIGhhc2hJZCA9PT0gMyAmJiBsb2NhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGUudGltZVN0YW1wIC0gdHM7XG4gICAgICAgICAgICAgICAgaWYgKGR0IDwgNTApXG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFsdEdyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5Q29kZSBpbiBrZXlzLk1PRElGSUVSX0tFWVMpIHtcbiAgICAgICAga2V5Q29kZSA9IC0xO1xuICAgIH1cbiAgICBpZiAoIWhhc2hJZCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgICBpZiAoZS5sb2NhdGlvbiA9PT0gMykge1xuICAgICAgICAgICAgY2FsbGJhY2soZSwgaGFzaElkLCAta2V5Q29kZSk7XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlcmFnZW50LmlzQ2hyb21lT1MgJiYgaGFzaElkICYgOCkge1xuICAgICAgICBjYWxsYmFjayhlLCBoYXNoSWQsIGtleUNvZGUpO1xuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoYXNoSWQgJj0gfjg7XG4gICAgfVxuICAgIGlmICghaGFzaElkICYmICEoa2V5Q29kZSBpbiBrZXlzLkZVTkNUSU9OX0tFWVMpICYmICEoa2V5Q29kZSBpbiBrZXlzLlBSSU5UQUJMRV9LRVlTKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjayhlLCBoYXNoSWQsIGtleUNvZGUpO1xufVxuZXhwb3J0cy5hZGRDb21tYW5kS2V5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWwsIGNhbGxiYWNrLCBkZXN0cm95ZXIpIHtcbiAgICB2YXIgbGFzdERlZmF1bHRQcmV2ZW50ZWQgPSBudWxsO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJlc3NlZEtleXNbZS5rZXlDb2RlXSA9IChwcmVzc2VkS2V5c1tlLmtleUNvZGVdIHx8IDApICsgMTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5vcm1hbGl6ZUNvbW1hbmRLZXlzKGNhbGxiYWNrLCBlLCBlLmtleUNvZGUpO1xuICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IGUuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBkZXN0cm95ZXIpO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXByZXNzXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChsYXN0RGVmYXVsdFByZXZlbnRlZCAmJiAoZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgICAgICAgZXhwb3J0cy5zdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCBkZXN0cm95ZXIpO1xuICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHByZXNzZWRLZXlzW2Uua2V5Q29kZV0gPSBudWxsO1xuICAgIH0sIGRlc3Ryb3llcik7XG4gICAgaWYgKCFwcmVzc2VkS2V5cykge1xuICAgICAgICByZXNldFByZXNzZWRLZXlzKCk7XG4gICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgXCJmb2N1c1wiLCByZXNldFByZXNzZWRLZXlzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmVzZXRQcmVzc2VkS2V5cygpIHtcbiAgICBwcmVzc2VkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5pZiAodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiAhdXNlcmFnZW50LmlzT2xkSUUpIHtcbiAgICB2YXIgcG9zdE1lc3NhZ2VJZCA9IDE7XG4gICAgZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgd2luKSB7XG4gICAgICAgIHdpbiA9IHdpbiB8fCB3aW5kb3c7XG4gICAgICAgIHZhciBtZXNzYWdlTmFtZSA9IFwiemVyby10aW1lb3V0LW1lc3NhZ2UtXCIgKyAocG9zdE1lc3NhZ2VJZCsrKTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEgPT0gbWVzc2FnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcih3aW4sIFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkTGlzdGVuZXIod2luLCBcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsIFwiKlwiKTtcbiAgICB9O1xufVxuZXhwb3J0cy4kaWRsZUJsb2NrZWQgPSBmYWxzZTtcbmV4cG9ydHMub25JZGxlID0gZnVuY3Rpb24gKGNiLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLiRpZGxlQmxvY2tlZCkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMTAwKTtcbiAgICAgICAgfVxuICAgIH0sIHRpbWVvdXQpO1xufTtcbmV4cG9ydHMuJGlkbGVCbG9ja0lkID0gbnVsbDtcbmV4cG9ydHMuYmxvY2tJZGxlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgaWYgKGV4cG9ydHMuJGlkbGVCbG9ja0lkKVxuICAgICAgICBjbGVhclRpbWVvdXQoZXhwb3J0cy4kaWRsZUJsb2NrSWQpO1xuICAgIGV4cG9ydHMuJGlkbGVCbG9ja2VkID0gdHJ1ZTtcbiAgICBleHBvcnRzLiRpZGxlQmxvY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLiRpZGxlQmxvY2tlZCA9IGZhbHNlO1xuICAgIH0sIGRlbGF5IHx8IDEwMCk7XG59O1xuZXhwb3J0cy5uZXh0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCB3aW5kb3dbXCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl1cbiAgICB8fCB3aW5kb3dbXCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl1cbiAgICB8fCB3aW5kb3dbXCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZVwiXVxuICAgIHx8IHdpbmRvd1tcIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0pO1xuaWYgKGV4cG9ydHMubmV4dEZyYW1lKVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZXhwb3J0cy5uZXh0RnJhbWUuYmluZCh3aW5kb3cpO1xuZWxzZVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE3KTtcbiAgICB9O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jbGlwYm9hcmRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgJGNhbmNlbFQ7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsaW5lTW9kZTogZmFsc2UsXG4gICAgcGFzdGVDYW5jZWxsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRjYW5jZWxUICYmICRjYW5jZWxUID4gRGF0ZS5ub3coKSAtIDUwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAkY2FuY2VsVCA9IGZhbHNlO1xuICAgIH0sXG4gICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRjYW5jZWxUID0gRGF0ZS5ub3coKTtcbiAgICB9XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9jb25maWdcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvY2xpcGJvYXJkXCIsXCJhY2UvbGliL2tleXNcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIikubmxzO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgY2xpcGJvYXJkID0gcmVxdWlyZShcIi4uL2NsaXBib2FyZFwiKTtcbnZhciBCUk9LRU5fU0VUREFUQSA9IHVzZXJhZ2VudC5pc0Nocm9tZSA8IDE4O1xudmFyIFVTRV9JRV9NSU1FX1RZUEUgPSB1c2VyYWdlbnQuaXNJRTtcbnZhciBIQVNfRk9DVVNfQVJHUyA9IHVzZXJhZ2VudC5pc0Nocm9tZSA+IDYzO1xudmFyIE1BWF9MSU5FX0xFTkdUSCA9IDQwMDtcbnZhciBLRVlTID0gcmVxdWlyZShcIi4uL2xpYi9rZXlzXCIpO1xudmFyIE1PRFMgPSBLRVlTLktFWV9NT0RTO1xudmFyIGlzSU9TID0gdXNlcmFnZW50LmlzSU9TO1xudmFyIHZhbHVlUmVzZXRSZWdleCA9IGlzSU9TID8gL1xccy8gOiAvXFxuLztcbnZhciBpc01vYmlsZSA9IHVzZXJhZ2VudC5pc01vYmlsZTtcbnZhciBUZXh0SW5wdXQ7XG5UZXh0SW5wdXQgPSBmdW5jdGlvbiAoLyoqQHR5cGV7SFRNTFRleHRBcmVhRWxlbWVudH0gKi8gcGFyZW50Tm9kZSwgLyoqQHR5cGV7aW1wb3J0KFwiLi4vZWRpdG9yXCIpLkVkaXRvcn0gKi8gaG9zdCkge1xuICAgIHZhciB0ZXh0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICB0ZXh0LmNsYXNzTmFtZSA9IFwiYWNlX3RleHQtaW5wdXRcIjtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIFwib2ZmXCIpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCBcImZhbHNlXCIpO1xuICAgIHRleHQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHQsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7IHZhciBjb3BpZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFzdGVkID0gZmFsc2U7XG4gICAgdmFyIGluQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgc2VuZGluZ1RleHQgPSBmYWxzZTtcbiAgICB2YXIgdGVtcFN0eWxlID0gJyc7XG4gICAgaWYgKCFpc01vYmlsZSlcbiAgICAgICAgdGV4dC5zdHlsZS5mb250U2l6ZSA9IFwiMXB4XCI7XG4gICAgdmFyIGNvbW1hbmRNb2RlID0gZmFsc2U7XG4gICAgdmFyIGlnbm9yZUZvY3VzRXZlbnRzID0gZmFsc2U7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IFwiXCI7XG4gICAgdmFyIGxhc3RTZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgdmFyIGxhc3RTZWxlY3Rpb25FbmQgPSAwO1xuICAgIHZhciBsYXN0UmVzdG9yZUVuZCA9IDA7XG4gICAgdmFyIHJvd1N0YXJ0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgdmFyIHJvd0VuZCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIHZhciBudW1iZXJPZkV4dHJhTGluZXMgPSAwO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpc0ZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0ZXh0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgdGhpcy5zZXROdW1iZXJPZkV4dHJhTGluZXMgPSBmdW5jdGlvbiAoLyoqQHR5cGV7bnVtYmVyfSovIG51bWJlcikge1xuICAgICAgICByb3dTdGFydCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICByb3dFbmQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIG51bWJlck9mRXh0cmFMaW5lcyA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyT2ZFeHRyYUxpbmVzID0gbnVtYmVyO1xuICAgIH07XG4gICAgdGhpcy5zZXRBcmlhTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmlhTGFiZWwgPSBcIlwiO1xuICAgICAgICBpZiAoaG9zdC4kdGV4dElucHV0QXJpYUxhYmVsKSB7XG4gICAgICAgICAgICBhcmlhTGFiZWwgKz0gXCJcIi5jb25jYXQoaG9zdC4kdGV4dElucHV0QXJpYUxhYmVsLCBcIiwgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0LnNlc3Npb24pIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBob3N0LnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvci5yb3c7XG4gICAgICAgICAgICBhcmlhTGFiZWwgKz0gbmxzKFwidGV4dC1pbnB1dC5hcmlhLWxhYmVsXCIsIFwiQ3Vyc29yIGF0IHJvdyAkMFwiLCBbcm93ICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICAgIH07XG4gICAgdGhpcy5zZXRBcmlhT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFjdGl2ZURlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtYXV0b2NvbXBsZXRlXCIsIG9wdGlvbnMuaW5saW5lID8gXCJib3RoXCIgOiBcImxpc3RcIik7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBvcHRpb25zLmFjdGl2ZURlc2NlbmRhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtYXV0b2NvbXBsZXRlXCIsIFwiYm90aFwiKTtcbiAgICAgICAgICAgIHRleHQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJvbGUpIHtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBvcHRpb25zLnJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNldExhYmVsKSB7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIG5scyhcInRleHQtaW5wdXQuYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJlZGl0b3JcIikpO1xuICAgICAgICAgICAgdGhpcy5zZXRBcmlhTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZXRBcmlhT3B0aW9ucyh7IHJvbGU6IFwidGV4dGJveFwiIH0pO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiYmx1clwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaWdub3JlRm9jdXNFdmVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhvc3Qub25CbHVyKGUpO1xuICAgICAgICBpc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICB9LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImZvY3VzXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpZ25vcmVGb2N1c0V2ZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0VkZ2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cygpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaG9zdC5vbkZvY3VzKGUpO1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzRWRnZSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzZXRTZWxlY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgIH0sIGhvc3QpO1xuICAgIHRoaXMuJGZvY3VzU2Nyb2xsID0gZmFsc2U7XG4gICAgdGhpcy5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRBcmlhT3B0aW9ucyh7XG4gICAgICAgICAgICBzZXRMYWJlbDogaG9zdC5yZW5kZXJlci5lbmFibGVLZXlib2FyZEFjY2Vzc2liaWxpdHlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZW1wU3R5bGUgfHwgSEFTX0ZPQ1VTX0FSR1MgfHwgdGhpcy4kZm9jdXNTY3JvbGwgPT0gXCJicm93c2VyXCIpXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgIHZhciB0b3AgPSB0ZXh0LnN0eWxlLnRvcDtcbiAgICAgICAgdGV4dC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgdGV4dC5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGlzVHJhbnNmb3JtZWQgPSB0ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0ZXh0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB3aGlsZSAodCAmJiB0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB0LnNldEF0dHJpYnV0ZShcImFjZV9ub2NvbnRleHRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIGlmICghdC5wYXJlbnRFbGVtZW50ICYmIHQuZ2V0Um9vdE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0LmdldFJvb3ROb2RlKClbXCJob3N0XCJdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIGFuY2VzdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcC5yZW1vdmVBdHRyaWJ1dGUoXCJhY2Vfbm9jb250ZXh0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0ZXh0LnN0eWxlLnBvc2l0aW9uID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0ZXh0LnN0eWxlLnRvcCA9PSBcIjBweFwiKVxuICAgICAgICAgICAgICAgIHRleHQuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIHRoaXMuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGV4dC5ibHVyKCk7XG4gICAgfTtcbiAgICB0aGlzLmlzRm9jdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzRm9jdXNlZDtcbiAgICB9O1xuICAgIGhvc3Qub24oXCJiZWZvcmVFbmRPcGVyYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyT3AgPSBob3N0LmN1ck9wO1xuICAgICAgICB2YXIgY29tbWFuZE5hbWUgPSBjdXJPcCAmJiBjdXJPcC5jb21tYW5kICYmIGN1ck9wLmNvbW1hbmQubmFtZTtcbiAgICAgICAgaWYgKGNvbW1hbmROYW1lID09IFwiaW5zZXJ0c3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpc1VzZXJBY3Rpb24gPSBjb21tYW5kTmFtZSAmJiAoY3VyT3AuZG9jQ2hhbmdlZCB8fCBjdXJPcC5zZWxlY3Rpb25DaGFuZ2VkKTtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24gJiYgaXNVc2VyQWN0aW9uKSB7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB0ZXh0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIG9uQ29tcG9zaXRpb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgIH0pO1xuICAgIGhvc3Qub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy5zZXRBcmlhTGFiZWwpO1xuICAgIHZhciBwb3NpdGlvblRvU2VsZWN0aW9uID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBjb2x1bW47XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHJvdyAtIHJvd1N0YXJ0ICYmIGkgPCAyICogbnVtYmVyT2ZFeHRyYUxpbmVzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gKz0gaG9zdC5zZXNzaW9uLmdldExpbmUocm93IC0gaSkubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG4gICAgdmFyIHJlc2V0U2VsZWN0aW9uID0gaXNJT1NcbiAgICAgICAgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghaXNGb2N1c2VkIHx8IChjb3BpZWQgJiYgIXZhbHVlKSB8fCBzZW5kaW5nVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IFwiXFxuIGFiXCIgKyB2YWx1ZSArIFwiY2RlIGZnXFxuXCI7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT0gdGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0ZXh0LnZhbHVlID0gbGFzdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSA0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IDQgKyAodmFsdWUubGVuZ3RoIHx8IChob3N0LnNlbGVjdGlvbi5pc0VtcHR5KCkgPyAwIDogMSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3Rpb25TdGFydCAhPSBzZWxlY3Rpb25TdGFydCB8fCBsYXN0U2VsZWN0aW9uRW5kICE9IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5Db21wb3NpdGlvbiB8fCBzZW5kaW5nVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWlzRm9jdXNlZCAmJiAhYWZ0ZXJDb250ZXh0TWVudSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpbkNvbXBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgICAgICAgIHZhciBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChob3N0LnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gaG9zdC5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHNlbGVjdGlvbi5jdXJzb3Iucm93O1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPT09IHJvd0VuZCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQgKyAxO1xuICAgICAgICAgICAgICAgICAgICByb3dFbmQgPSByb3dTdGFydCArIDIgKiBudW1iZXJPZkV4dHJhTGluZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdyA9PT0gcm93U3RhcnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0VuZCA9IHJvd1N0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQgLSAyICogbnVtYmVyT2ZFeHRyYUxpbmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3cgPCByb3dTdGFydCAtIDEgfHwgcm93ID4gcm93RW5kICsgMSkge1xuICAgICAgICAgICAgICAgICAgICByb3dTdGFydCA9IHJvdyA+IG51bWJlck9mRXh0cmFMaW5lcyA/IHJvdyAtIG51bWJlck9mRXh0cmFMaW5lcyA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJvd0VuZCA9IHJvdyA+IG51bWJlck9mRXh0cmFMaW5lcyA/IHJvdyArIG51bWJlck9mRXh0cmFMaW5lcyA6IDIgKiBudW1iZXJPZkV4dHJhTGluZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByb3dTdGFydDsgaSA8PSByb3dFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGhvc3Quc2Vzc2lvbi5nZXRMaW5lKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gcG9zaXRpb25Ub1NlbGVjdGlvbihyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gcG9zaXRpb25Ub1NlbGVjdGlvbihyYW5nZS5lbmQucm93LCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93IDwgcm93U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZMaW5lID0gaG9zdC5zZXNzaW9uLmdldExpbmUocm93U3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSByYW5nZS5zdGFydC5yb3cgPCByb3dTdGFydCAtIDEgPyAwIDogc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZCArPSBwcmV2TGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gcHJldkxpbmUgKyBcIlxcblwiICsgbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2UuZW5kLnJvdyA+IHJvd0VuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dExpbmUgPSBob3N0LnNlc3Npb24uZ2V0TGluZShyb3dFbmQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gcmFuZ2UuZW5kLnJvdyA+IHJvd0VuZCArIDEgPyBuZXh0TGluZS5sZW5ndGggOiByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIFwiXFxuXCIgKyBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNb2JpbGUgJiYgcm93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gXCJcXG5cIiArIGxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiBNQVhfTElORV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDwgTUFYX0xJTkVfTEVOR1RIICYmIHNlbGVjdGlvbkVuZCA8IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgTUFYX0xJTkVfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGxpbmUgKyBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC52YWx1ZSA9IGxhc3RWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSBsYXN0U2VsZWN0aW9uRW5kID0gbmV3VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZnRlckNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGlvblN0YXJ0ID0gdGV4dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uRW5kID0gdGV4dC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdFNlbGVjdGlvbkVuZCAhPSBzZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB8fCBsYXN0U2VsZWN0aW9uU3RhcnQgIT0gc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgICAgICB8fCB0ZXh0LnNlbGVjdGlvbkVuZCAhPSBsYXN0U2VsZWN0aW9uRW5kIC8vIG9uIGllIGVkZ2Ugc2VsZWN0aW9uRW5kIGNoYW5nZXMgc2lsZW50bHkgYWZ0ZXIgdGhlIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5Db21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIHRoaXMucmVzZXRTZWxlY3Rpb24gPSByZXNldFNlbGVjdGlvbjtcbiAgICBpZiAoaXNGb2N1c2VkKVxuICAgICAgICBob3N0Lm9uRm9jdXMoKTtcbiAgICB2YXIgaXNBbGxTZWxlY3RlZCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRleHQuc2VsZWN0aW9uRW5kID49IGxhc3RWYWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICYmIHRleHQudmFsdWUgPT09IGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVcbiAgICAgICAgICAgICYmIHRleHQuc2VsZWN0aW9uRW5kICE9PSBsYXN0U2VsZWN0aW9uRW5kO1xuICAgIH07XG4gICAgdmFyIG9uU2VsZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjb3BpZWQpIHtcbiAgICAgICAgICAgIGNvcGllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQWxsU2VsZWN0ZWQodGV4dCkpIHtcbiAgICAgICAgICAgIGhvc3Quc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTW9iaWxlICYmIHRleHQuc2VsZWN0aW9uU3RhcnQgIT0gbGFzdFNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5wdXRIYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLnNldElucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChjYikgeyBpbnB1dEhhbmRsZXIgPSBjYjsgfTtcbiAgICB0aGlzLmdldElucHV0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0SGFuZGxlcjsgfTtcbiAgICB2YXIgYWZ0ZXJDb250ZXh0TWVudSA9IGZhbHNlO1xuICAgIHZhciBzZW5kVGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgZnJvbUlucHV0KSB7XG4gICAgICAgIGlmIChhZnRlckNvbnRleHRNZW51KVxuICAgICAgICAgICAgYWZ0ZXJDb250ZXh0TWVudSA9IGZhbHNlO1xuICAgICAgICBpZiAocGFzdGVkKSB7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIGhvc3Qub25QYXN0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBwYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGV4dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0ZXh0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciBleHRlbmRMZWZ0ID0gbGFzdFNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIGV4dGVuZFJpZ2h0ID0gbGFzdFZhbHVlLmxlbmd0aCAtIGxhc3RTZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciByZXN0b3JlU3RhcnQgPSB2YWx1ZS5sZW5ndGggLSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHZhciByZXN0b3JlRW5kID0gdmFsdWUubGVuZ3RoIC0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGV4dGVuZExlZnQgPiAwICYmIGxhc3RWYWx1ZVtpXSA9PSB2YWx1ZVtpXSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBleHRlbmRMZWZ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGluc2VydGVkLnNsaWNlKGkpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ZW5kUmlnaHQgPiAwICYmIGxhc3RWYWx1ZS5sZW5ndGggLSBpID4gbGFzdFNlbGVjdGlvblN0YXJ0IC0gMSAmJiBsYXN0VmFsdWVbbGFzdFZhbHVlLmxlbmd0aCAtIGldID09IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIGldKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGV4dGVuZFJpZ2h0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0b3JlU3RhcnQgLT0gaSAtIDE7XG4gICAgICAgICAgICByZXN0b3JlRW5kIC09IGkgLSAxO1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gaW5zZXJ0ZWQubGVuZ3RoIC0gaSArIDE7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGVmdCA9IC1lbmRJbmRleDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGluc2VydGVkLnNsaWNlKDAsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIGlmICghZnJvbUlucHV0ICYmICFpbnNlcnRlZCAmJiAhcmVzdG9yZVN0YXJ0ICYmICFleHRlbmRMZWZ0ICYmICFleHRlbmRSaWdodCAmJiAhcmVzdG9yZUVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHNlbmRpbmdUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0FuZHJvaWQgJiYgaW5zZXJ0ZWQgPT0gXCIuIFwiKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBcIiAgXCI7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc2VydGVkICYmICFleHRlbmRMZWZ0ICYmICFleHRlbmRSaWdodCAmJiAhcmVzdG9yZVN0YXJ0ICYmICFyZXN0b3JlRW5kIHx8IGNvbW1hbmRNb2RlKSB7XG4gICAgICAgICAgICAgICAgaG9zdC5vblRleHRJbnB1dChpbnNlcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBob3N0Lm9uVGV4dElucHV0KGluc2VydGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZExlZnQ6IGV4dGVuZExlZnQsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZFJpZ2h0OiBleHRlbmRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZVN0YXJ0OiByZXN0b3JlU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVFbmQ6IHJlc3RvcmVFbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRpbmdUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIGxhc3RSZXN0b3JlRW5kID0gcmVzdG9yZUVuZDtcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRSZXNldCA/IFwiXFxuXCIgOiBpbnNlcnRlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbilcbiAgICAgICAgICAgIHJldHVybiBvbkNvbXBvc2l0aW9uVXBkYXRlKCk7XG4gICAgICAgIGlmIChlICYmIGUuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiBob3N0LmV4ZWNDb21tYW5kKFwidW5kb1wiKTtcbiAgICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3QuZXhlY0NvbW1hbmQoXCJyZWRvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGV4dC52YWx1ZTtcbiAgICAgICAgdmFyIGluc2VydGVkID0gc2VuZFRleHQoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCArIDEwMFxuICAgICAgICAgICAgfHwgdmFsdWVSZXNldFJlZ2V4LnRlc3QoaW5zZXJ0ZWQpXG4gICAgICAgICAgICB8fCBpc01vYmlsZSAmJiBsYXN0U2VsZWN0aW9uU3RhcnQgPCAxICYmIGxhc3RTZWxlY3Rpb25TdGFydCA9PSBsYXN0U2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlQ2xpcGJvYXJkRGF0YSA9IGZ1bmN0aW9uIChlLCBkYXRhLCBmb3JjZUlFTWltZSkge1xuICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3dbXCJjbGlwYm9hcmREYXRhXCJdO1xuICAgICAgICBpZiAoIWNsaXBib2FyZERhdGEgfHwgQlJPS0VOX1NFVERBVEEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtaW1lID0gVVNFX0lFX01JTUVfVFlQRSB8fCBmb3JjZUlFTWltZSA/IFwiVGV4dFwiIDogXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGlwYm9hcmREYXRhLnNldERhdGEobWltZSwgZGF0YSkgIT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaXBib2FyZERhdGEuZ2V0RGF0YShtaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZUlFTWltZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xpcGJvYXJkRGF0YShlLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRvQ29weSA9IGZ1bmN0aW9uIChlLCBpc0N1dCkge1xuICAgICAgICB2YXIgZGF0YSA9IGhvc3QuZ2V0Q29weVRleHQoKTtcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBpZiAoaGFuZGxlQ2xpcGJvYXJkRGF0YShlLCBkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgICAgICAgY29waWVkID0gZGF0YTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29waWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNDdXQgPyBob3N0Lm9uQ3V0KCkgOiBob3N0Lm9uQ29weSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3BpZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGV4dC52YWx1ZSA9IGRhdGE7XG4gICAgICAgICAgICB0ZXh0LnNlbGVjdCgpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29waWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpc0N1dCA/IGhvc3Qub25DdXQoKSA6IGhvc3Qub25Db3B5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uQ3V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZG9Db3B5KGUsIHRydWUpO1xuICAgIH07XG4gICAgdmFyIG9uQ29weSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvQ29weShlLCBmYWxzZSk7XG4gICAgfTtcbiAgICB2YXIgb25QYXN0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkYXRhID0gaGFuZGxlQ2xpcGJvYXJkRGF0YShlKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZC5wYXN0ZUNhbmNlbGxlZCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgaG9zdC5vblBhc3RlKGRhdGEsIGUpO1xuICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzZXRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHBhc3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV2ZW50LmFkZENvbW1hbmRLZXlMaXN0ZW5lcih0ZXh0LCBmdW5jdGlvbiAoZSwgaGFzaElkLCBrZXlDb2RlKSB7XG4gICAgICAgIGlmIChpbkNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gaG9zdC5vbkNvbW1hbmRLZXkoZSwgaGFzaElkLCBrZXlDb2RlKTtcbiAgICB9LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcInNlbGVjdFwiLCBvblNlbGVjdCwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJpbnB1dFwiLCBvbklucHV0LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImN1dFwiLCBvbkN1dCwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJjb3B5XCIsIG9uQ29weSwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJwYXN0ZVwiLCBvblBhc3RlLCBob3N0KTtcbiAgICBpZiAoISgnb25jdXQnIGluIHRleHQpIHx8ICEoJ29uY29weScgaW4gdGV4dCkgfHwgISgnb25wYXN0ZScgaW4gdGV4dCkpIHtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIocGFyZW50Tm9kZSwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoKHVzZXJhZ2VudC5pc01hYyAmJiAhZS5tZXRhS2V5KSB8fCAhZS5jdHJsS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgb25Db3B5KGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg2OlxuICAgICAgICAgICAgICAgICAgICBvblBhc3RlKGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICBvbkN1dChlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhvc3QpO1xuICAgIH1cbiAgICB2YXIgb25Db21wb3NpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24gfHwgIWhvc3Qub25Db21wb3NpdGlvblN0YXJ0IHx8IGhvc3QuJHJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbkNvbXBvc2l0aW9uID0ge307XG4gICAgICAgIGlmIChjb21tYW5kTW9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUuZGF0YSlcbiAgICAgICAgICAgIGluQ29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChvbkNvbXBvc2l0aW9uVXBkYXRlLCAwKTtcbiAgICAgICAgaG9zdC5fc2lnbmFsKFwiY29tcG9zaXRpb25TdGFydFwiKTtcbiAgICAgICAgaG9zdC5vbihcIm1vdXNlZG93blwiLCBjYW5jZWxDb21wb3NpdGlvbik7XG4gICAgICAgIHZhciByYW5nZSA9IGhvc3QuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgaW5Db21wb3NpdGlvbi5tYXJrZXJSYW5nZSA9IHJhbmdlO1xuICAgICAgICBpbkNvbXBvc2l0aW9uLnNlbGVjdGlvblN0YXJ0ID0gbGFzdFNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBob3N0Lm9uQ29tcG9zaXRpb25TdGFydChpbkNvbXBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUpIHtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHRleHQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRleHQubXNHZXRJbnB1dENvbnRleHQpXG4gICAgICAgICAgICAgICAgaW5Db21wb3NpdGlvbi5jb250ZXh0ID0gdGV4dC5tc0dldElucHV0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRleHQuZ2V0SW5wdXRDb250ZXh0KVxuICAgICAgICAgICAgICAgIGluQ29tcG9zaXRpb24uY29udGV4dCA9IHRleHQuZ2V0SW5wdXRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbkNvbXBvc2l0aW9uVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluQ29tcG9zaXRpb24gfHwgIWhvc3Qub25Db21wb3NpdGlvblVwZGF0ZSB8fCBob3N0LiRyZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNvbW1hbmRNb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbENvbXBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChpbkNvbXBvc2l0aW9uLnVzZVRleHRhcmVhRm9ySU1FKSB7XG4gICAgICAgICAgICBob3N0Lm9uQ29tcG9zaXRpb25VcGRhdGUodGV4dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRleHQudmFsdWU7XG4gICAgICAgICAgICBzZW5kVGV4dChkYXRhKTtcbiAgICAgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uLm1hcmtlclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQ29tcG9zaXRpb24uY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpbkNvbXBvc2l0aW9uLm1hcmtlclJhbmdlLnN0YXJ0LmNvbHVtbiA9IGluQ29tcG9zaXRpb24uc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gaW5Db21wb3NpdGlvbi5jb250ZXh0LmNvbXBvc2l0aW9uU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluQ29tcG9zaXRpb24ubWFya2VyUmFuZ2UuZW5kLmNvbHVtbiA9IGluQ29tcG9zaXRpb24ubWFya2VyUmFuZ2Uuc3RhcnQuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICsgbGFzdFNlbGVjdGlvbkVuZCAtIGluQ29tcG9zaXRpb24uc2VsZWN0aW9uU3RhcnQgKyBsYXN0UmVzdG9yZUVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWhvc3Qub25Db21wb3NpdGlvbkVuZCB8fCBob3N0LiRyZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5Db21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICBob3N0Lm9uQ29tcG9zaXRpb25FbmQoKTtcbiAgICAgICAgaG9zdC5vZmYoXCJtb3VzZWRvd25cIiwgY2FuY2VsQ29tcG9zaXRpb24pO1xuICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIG9uSW5wdXQoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNhbmNlbENvbXBvc2l0aW9uKCkge1xuICAgICAgICBpZ25vcmVGb2N1c0V2ZW50cyA9IHRydWU7XG4gICAgICAgIHRleHQuYmx1cigpO1xuICAgICAgICB0ZXh0LmZvY3VzKCk7XG4gICAgICAgIGlnbm9yZUZvY3VzRXZlbnRzID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzeW5jQ29tcG9zaXRpb24gPSBsYW5nLmRlbGF5ZWRDYWxsKG9uQ29tcG9zaXRpb25VcGRhdGUsIDUwKS5zY2hlZHVsZS5iaW5kKG51bGwsIG51bGwpO1xuICAgIGZ1bmN0aW9uIG9uS2V5dXAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3ICYmIHRleHQudmFsdWUubGVuZ3RoIDwgdGV4dC5zZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgaWYgKCFpbkNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHRleHQudmFsdWU7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uU3RhcnQgPSBsYXN0U2VsZWN0aW9uRW5kID0gLTE7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNDb21wb3NpdGlvbigpO1xuICAgIH1cbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIG9uQ29tcG9zaXRpb25VcGRhdGUsIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwia2V5dXBcIiwgb25LZXl1cCwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJrZXlkb3duXCIsIHN5bmNDb21wb3NpdGlvbiwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kLCBob3N0KTtcbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgdGhpcy5zZXRDb21tYW5kTW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb21tYW5kTW9kZSA9IHZhbHVlO1xuICAgICAgICB0ZXh0LnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKHJlYWRPbmx5KSB7XG4gICAgICAgIGlmICghY29tbWFuZE1vZGUpXG4gICAgICAgICAgICB0ZXh0LnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgfTtcbiAgICB0aGlzLnNldENvcHlXaXRoRW1wdHlTZWxlY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB9O1xuICAgIHRoaXMub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGFmdGVyQ29udGV4dE1lbnUgPSB0cnVlO1xuICAgICAgICByZXNldFNlbGVjdGlvbigpO1xuICAgICAgICBob3N0Ll9lbWl0KFwibmF0aXZlY29udGV4dG1lbnVcIiwgeyB0YXJnZXQ6IGhvc3QsIGRvbUV2ZW50OiBlIH0pO1xuICAgICAgICB0aGlzLm1vdmVUb01vdXNlKGUsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlVG9Nb3VzZSA9IGZ1bmN0aW9uIChlLCBicmluZ1RvRnJvbnQpIHtcbiAgICAgICAgaWYgKCF0ZW1wU3R5bGUpXG4gICAgICAgICAgICB0ZW1wU3R5bGUgPSB0ZXh0LnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIHRleHQuc3R5bGUuY3NzVGV4dCA9IChicmluZ1RvRnJvbnQgPyBcInotaW5kZXg6MTAwMDAwO1wiIDogXCJcIilcbiAgICAgICAgICAgICsgKHVzZXJhZ2VudC5pc0lFID8gXCJvcGFjaXR5OjAuMTtcIiA6IFwiXCIpXG4gICAgICAgICAgICArIFwidGV4dC1pbmRlbnQ6IC1cIiArIChsYXN0U2VsZWN0aW9uU3RhcnQgKyBsYXN0U2VsZWN0aW9uRW5kKSAqIGhvc3QucmVuZGVyZXIuY2hhcmFjdGVyV2lkdGggKiAwLjUgKyBcInB4O1wiO1xuICAgICAgICB2YXIgcmVjdCA9IGhvc3QuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZShob3N0LmNvbnRhaW5lcik7XG4gICAgICAgIHZhciB0b3AgPSByZWN0LnRvcCArIChwYXJzZUludChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMCk7XG4gICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgKHBhcnNlSW50KHN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMCk7XG4gICAgICAgIHZhciBtYXhUb3AgPSByZWN0LmJvdHRvbSAtIHRvcCAtIHRleHQuY2xpZW50SGVpZ2h0IC0gMjtcbiAgICAgICAgdmFyIG1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9tLnRyYW5zbGF0ZSh0ZXh0LCBlLmNsaWVudFggLSBsZWZ0IC0gMiwgTWF0aC5taW4oZS5jbGllbnRZIC0gdG9wIC0gMiwgbWF4VG9wKSk7XG4gICAgICAgIH07XG4gICAgICAgIG1vdmUoZSk7XG4gICAgICAgIGlmIChlLnR5cGUgIT0gXCJtb3VzZWRvd25cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaG9zdC5yZW5kZXJlci4kaXNNb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0KTtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc1dpbilcbiAgICAgICAgICAgIGV2ZW50LmNhcHR1cmUoaG9zdC5jb250YWluZXIsIG1vdmUsIG9uQ29udGV4dE1lbnVDbG9zZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ29udGV4dE1lbnVDbG9zZSA9IG9uQ29udGV4dE1lbnVDbG9zZTtcbiAgICB2YXIgY2xvc2VUaW1lb3V0O1xuICAgIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnVDbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dCk7XG4gICAgICAgIGNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRlbXBTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRleHQuc3R5bGUuY3NzVGV4dCA9IHRlbXBTdHlsZTtcbiAgICAgICAgICAgICAgICB0ZW1wU3R5bGUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3QucmVuZGVyZXIuJGlzTW91c2VQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaG9zdC5yZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IpXG4gICAgICAgICAgICAgICAgaG9zdC5yZW5kZXJlci4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHZhciBvbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaG9zdC50ZXh0SW5wdXQub25Db250ZXh0TWVudShlKTtcbiAgICAgICAgb25Db250ZXh0TWVudUNsb3NlKCk7XG4gICAgfTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcIm1vdXNldXBcIiwgb25Db250ZXh0TWVudSwgaG9zdCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvbkNvbnRleHRNZW51Q2xvc2UoKTtcbiAgICB9LCBob3N0KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihob3N0LnJlbmRlcmVyLnNjcm9sbGVyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUsIGhvc3QpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSwgaG9zdCk7XG4gICAgaWYgKGlzSU9TKVxuICAgICAgICBhZGRJb3NTZWxlY3Rpb25IYW5kbGVyKHBhcmVudE5vZGUsIGhvc3QsIHRleHQpO1xuICAgIGZ1bmN0aW9uIGFkZElvc1NlbGVjdGlvbkhhbmRsZXIocGFyZW50Tm9kZSwgaG9zdCwgdGV4dCkge1xuICAgICAgICB2YXIgdHlwaW5nUmVzZXRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHR5cGluZyA9IGZhbHNlO1xuICAgICAgICB0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodHlwaW5nUmVzZXRUaW1lb3V0KVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0eXBpbmdSZXNldFRpbWVvdXQpO1xuICAgICAgICAgICAgdHlwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0eXBpbmdSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0eXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB2YXIgZGV0ZWN0QXJyb3dLZXlzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBpbmcgfHwgaW5Db21wb3NpdGlvbiB8fCBob3N0LiRtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNvcGllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHRleHQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gdGV4dC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IDA7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMudXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25TdGFydCA9PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gS0VZUy5ob21lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uRW5kID4gbGFzdFNlbGVjdGlvbkVuZCAmJiBsYXN0VmFsdWVbc2VsZWN0aW9uRW5kXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gS0VZUy5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25TdGFydCA8IGxhc3RTZWxlY3Rpb25TdGFydCAmJiBsYXN0VmFsdWVbc2VsZWN0aW9uU3RhcnQgLSAxXSA9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMubGVmdDtcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IE1PRFMub3B0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uU3RhcnQgPCBsYXN0U2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgICAgICB8fCAoc2VsZWN0aW9uU3RhcnQgPT0gbGFzdFNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIGxhc3RTZWxlY3Rpb25FbmQgIT0gbGFzdFNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGVjdGlvblN0YXJ0ID09IHNlbGVjdGlvbkVuZCkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25FbmQgPiBsYXN0U2VsZWN0aW9uRW5kICYmIGxhc3RWYWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25FbmQpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLmRvd247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25FbmQgPiBsYXN0U2VsZWN0aW9uRW5kICYmIGxhc3RWYWx1ZVtzZWxlY3Rpb25FbmQgLSAxXSA9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMucmlnaHQ7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBNT0RTLm9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkVuZCA+IGxhc3RTZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB8fCAoc2VsZWN0aW9uRW5kID09IGxhc3RTZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICAgICAgJiYgbGFzdFNlbGVjdGlvbkVuZCAhPSBsYXN0U2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZWN0aW9uU3RhcnQgPT0gc2VsZWN0aW9uRW5kKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IEtFWVMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZClcbiAgICAgICAgICAgICAgICBtb2RpZmllciB8PSBNT0RTLnNoaWZ0O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBob3N0Lm9uQ29tbWFuZEtleSh7fSwgbW9kaWZpZXIsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgaG9zdC5jb21tYW5kcykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBLRVlTLmtleUNvZGVUb1N0cmluZyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGhvc3QuY29tbWFuZHMuZmluZEtleUNvbW1hbmQobW9kaWZpZXIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdC5leGVjQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICByZXNldFNlbGVjdGlvbihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCBkZXRlY3RBcnJvd0tleXMpO1xuICAgICAgICBob3N0Lm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIGRldGVjdEFycm93S2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0ZXh0LnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICB0ZXh0LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGV4dCk7XG4gICAgfTtcbn07XG5leHBvcnRzLlRleHRJbnB1dCA9IFRleHRJbnB1dDtcbmV4cG9ydHMuJHNldFVzZXJBZ2VudEZvclRlc3RzID0gZnVuY3Rpb24gKF9pc01vYmlsZSwgX2lzSU9TKSB7XG4gICAgaXNNb2JpbGUgPSBfaXNNb2JpbGU7XG4gICAgaXNJT1MgPSBfaXNJT1M7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9kZWZhdWx0X2hhbmRsZXJzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBEUkFHX09GRlNFVCA9IDA7IC8vIHBpeGVsc1xudmFyIFNDUk9MTF9DT09MRE9XTl9UID0gNTUwOyAvLyBtaWxsaXNlY29uZHNcbnZhciBEZWZhdWx0SGFuZGxlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEhhbmRsZXJzKG1vdXNlSGFuZGxlcikge1xuICAgICAgICBtb3VzZUhhbmRsZXIuJGNsaWNrU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIGVkaXRvciA9IG1vdXNlSGFuZGxlci5lZGl0b3I7XG4gICAgICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLmJpbmQobW91c2VIYW5kbGVyKSk7XG4gICAgICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcImRibGNsaWNrXCIsIHRoaXMub25Eb3VibGVDbGljay5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgICAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJ0cmlwbGVjbGlja1wiLCB0aGlzLm9uVHJpcGxlQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICAgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwicXVhZGNsaWNrXCIsIHRoaXMub25RdWFkQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICAgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwibW91c2V3aGVlbFwiLCB0aGlzLm9uTW91c2VXaGVlbC5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgICAgICB2YXIgZXhwb3J0cyA9IFtcInNlbGVjdFwiLCBcInN0YXJ0U2VsZWN0XCIsIFwic2VsZWN0RW5kXCIsIFwic2VsZWN0QWxsRW5kXCIsIFwic2VsZWN0QnlXb3Jkc0VuZFwiLFxuICAgICAgICAgICAgXCJzZWxlY3RCeUxpbmVzRW5kXCIsIFwiZHJhZ1dhaXRcIiwgXCJkcmFnV2FpdEVuZFwiLCBcImZvY3VzV2FpdFwiXTtcbiAgICAgICAgZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBtb3VzZUhhbmRsZXJbeF0gPSB0aGlzW3hdO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgbW91c2VIYW5kbGVyW1wic2VsZWN0QnlMaW5lc1wiXSA9IHRoaXMuZXh0ZW5kU2VsZWN0aW9uQnkuYmluZChtb3VzZUhhbmRsZXIsIFwiZ2V0TGluZVJhbmdlXCIpO1xuICAgICAgICBtb3VzZUhhbmRsZXJbXCJzZWxlY3RCeVdvcmRzXCJdID0gdGhpcy5leHRlbmRTZWxlY3Rpb25CeS5iaW5kKG1vdXNlSGFuZGxlciwgXCJnZXRXb3JkUmFuZ2VcIik7XG4gICAgfVxuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gZXYuaW5TZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd25FdmVudCA9IGV2O1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBidXR0b24gPSBldi5nZXRCdXR0b24oKTtcbiAgICAgICAgaWYgKGJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW1wdHkgPSBzZWxlY3Rpb25SYW5nZS5pc0VtcHR5KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRW1wdHkgfHwgYnV0dG9uID09IDEpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnRleHRJbnB1dC5vbkNvbnRleHRNZW51KGV2LmRvbUV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXJhZ2VudC5pc01vemlsbGEpXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZWRvd25FdmVudC50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGluU2VsZWN0aW9uICYmICFlZGl0b3IuaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGZvY3VzVGltZW91dCAmJiAhdGhpcy4kY2xpY2tTZWxlY3Rpb24gJiYgIWVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXCJmb2N1c1dhaXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcHR1cmVNb3VzZShldik7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3QocG9zLCBldi5kb21FdmVudC5fY2xpY2tzID4gMSk7XG4gICAgICAgIHJldHVybiBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zdGFydFNlbGVjdCA9IGZ1bmN0aW9uIChwb3MsIHdhaXRGb3JDbGlja1NlbGVjdGlvbikge1xuICAgICAgICBwb3MgPSBwb3MgfHwgdGhpcy5lZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd25FdmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0U2hpZnRLZXkoKSlcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICBlbHNlIGlmICghd2FpdEZvckNsaWNrU2VsZWN0aW9uKVxuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICBpZiAoIXdhaXRGb3JDbGlja1NlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIGVkaXRvci5zZXRTdHlsZShcImFjZV9zZWxlY3RpbmdcIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJzZWxlY3RcIik7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuY2hvciwgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBpZiAodGhpcy4kY2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQoY3Vyc29yKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT0gMSkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGVkUmFuZ2UgPSBjYWxjUmFuZ2VPcmllbnRhdGlvbih0aGlzLiRjbGlja1NlbGVjdGlvbiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBvcmllbnRlZFJhbmdlLmN1cnNvcjtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBvcmllbnRlZFJhbmdlLmFuY2hvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICB9O1xuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuZXh0ZW5kU2VsZWN0aW9uQnkgPSBmdW5jdGlvbiAodW5pdE5hbWUpIHtcbiAgICAgICAgdmFyIGFuY2hvciwgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uW3VuaXROYW1lXShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgaWYgKHRoaXMuJGNsaWNrU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY21wU3RhcnQgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGNtcEVuZCA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLmNvbXBhcmVQb2ludChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGNtcFN0YXJ0ID09IC0xICYmIGNtcEVuZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uZW5kO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQucm93ICE9IGN1cnNvci5yb3cgfHwgcmFuZ2UuZW5kLmNvbHVtbiAhPSBjdXJzb3IuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcEVuZCA9PSAxICYmIGNtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ICE9IGN1cnNvci5yb3cgfHwgcmFuZ2Uuc3RhcnQuY29sdW1uICE9IGN1cnNvci5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFN0YXJ0ID09IC0xICYmIGNtcEVuZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGVkUmFuZ2UgPSBjYWxjUmFuZ2VPcmllbnRhdGlvbih0aGlzLiRjbGlja1NlbGVjdGlvbiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBvcmllbnRlZFJhbmdlLmN1cnNvcjtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBvcmllbnRlZFJhbmdlLmFuY2hvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICB9O1xuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuc2VsZWN0QnlMaW5lc0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRvci51bnNldFN0eWxlKFwiYWNlX3NlbGVjdGluZ1wiKTtcbiAgICB9O1xuICAgIERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuZm9jdXNXYWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UodGhpcy5tb3VzZWRvd25FdmVudC54LCB0aGlzLm1vdXNlZG93bkV2ZW50LnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPiBEUkFHX09GRlNFVCB8fCB0aW1lIC0gdGhpcy5tb3VzZWRvd25FdmVudC50aW1lID4gdGhpcy4kZm9jdXNUaW1lb3V0KVxuICAgICAgICAgICAgdGhpcy5zdGFydFNlbGVjdCh0aGlzLm1vdXNlZG93bkV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZXNzaW9uLmdldEJyYWNrZXRSYW5nZShwb3MpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFdvcmRSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXCJzZWxlY3RCeVdvcmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uID0gcmFuZ2U7XG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLm9uVHJpcGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0QnlMaW5lc1wiKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZS5pc011bHRpTGluZSgpICYmIHJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbi5lbmQgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyYW5nZS5lbmQucm93KS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKHBvcy5yb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfTtcbiAgICBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLm9uUXVhZENsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgZWRpdG9yLnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0QWxsXCIpO1xuICAgIH07XG4gICAgRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGV2LmdldEFjY2VsS2V5KCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldi5nZXRTaGlmdEtleSgpICYmIGV2LndoZWVsWSAmJiAhZXYud2hlZWxYKSB7XG4gICAgICAgICAgICBldi53aGVlbFggPSBldi53aGVlbFk7XG4gICAgICAgICAgICBldi53aGVlbFkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgaWYgKCF0aGlzLiRsYXN0U2Nyb2xsKVxuICAgICAgICAgICAgdGhpcy4kbGFzdFNjcm9sbCA9IHsgdDogMCwgdng6IDAsIHZ5OiAwLCBhbGxvd2VkOiAwIH07XG4gICAgICAgIHZhciBwcmV2U2Nyb2xsID0gdGhpcy4kbGFzdFNjcm9sbDtcbiAgICAgICAgdmFyIHQgPSBldi5kb21FdmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZhciBkdCA9IHQgLSBwcmV2U2Nyb2xsLnQ7XG4gICAgICAgIHZhciB2eCA9IGR0ID8gZXYud2hlZWxYIC8gZHQgOiBwcmV2U2Nyb2xsLnZ4O1xuICAgICAgICB2YXIgdnkgPSBkdCA/IGV2LndoZWVsWSAvIGR0IDogcHJldlNjcm9sbC52eTtcbiAgICAgICAgaWYgKGR0IDwgU0NST0xMX0NPT0xET1dOX1QpIHtcbiAgICAgICAgICAgIHZ4ID0gKHZ4ICsgcHJldlNjcm9sbC52eCkgLyAyO1xuICAgICAgICAgICAgdnkgPSAodnkgKyBwcmV2U2Nyb2xsLnZ5KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IE1hdGguYWJzKHZ4IC8gdnkpO1xuICAgICAgICB2YXIgY2FuU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPj0gMSAmJiBlZGl0b3IucmVuZGVyZXIuaXNTY3JvbGxhYmxlQnkoZXYud2hlZWxYICogZXYuc3BlZWQsIDApKVxuICAgICAgICAgICAgY2FuU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA8PSAxICYmIGVkaXRvci5yZW5kZXJlci5pc1Njcm9sbGFibGVCeSgwLCBldi53aGVlbFkgKiBldi5zcGVlZCkpXG4gICAgICAgICAgICBjYW5TY3JvbGwgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgICBwcmV2U2Nyb2xsLmFsbG93ZWQgPSB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgLSBwcmV2U2Nyb2xsLmFsbG93ZWQgPCBTQ1JPTExfQ09PTERPV05fVCkge1xuICAgICAgICAgICAgdmFyIGlzU2xvd2VyID0gTWF0aC5hYnModngpIDw9IDEuNSAqIE1hdGguYWJzKHByZXZTY3JvbGwudngpXG4gICAgICAgICAgICAgICAgJiYgTWF0aC5hYnModnkpIDw9IDEuNSAqIE1hdGguYWJzKHByZXZTY3JvbGwudnkpO1xuICAgICAgICAgICAgaWYgKGlzU2xvd2VyKSB7XG4gICAgICAgICAgICAgICAgY2FuU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2U2Nyb2xsLmFsbG93ZWQgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldlNjcm9sbC5hbGxvd2VkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2U2Nyb2xsLnQgPSB0O1xuICAgICAgICBwcmV2U2Nyb2xsLnZ4ID0gdng7XG4gICAgICAgIHByZXZTY3JvbGwudnkgPSB2eTtcbiAgICAgICAgaWYgKGNhblNjcm9sbCkge1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJ5KGV2LndoZWVsWCAqIGV2LnNwZWVkLCBldi53aGVlbFkgKiBldi5zcGVlZCk7XG4gICAgICAgICAgICByZXR1cm4gZXYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdEhhbmRsZXJzO1xufSgpKTtcbkRlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUuc2VsZWN0RW5kID0gRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3RCeUxpbmVzRW5kO1xuRGVmYXVsdEhhbmRsZXJzLnByb3RvdHlwZS5zZWxlY3RBbGxFbmQgPSBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdEJ5TGluZXNFbmQ7XG5EZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdEJ5V29yZHNFbmQgPSBEZWZhdWx0SGFuZGxlcnMucHJvdG90eXBlLnNlbGVjdEJ5TGluZXNFbmQ7XG5leHBvcnRzLkRlZmF1bHRIYW5kbGVycyA9IERlZmF1bHRIYW5kbGVycztcbmZ1bmN0aW9uIGNhbGNEaXN0YW5jZShheCwgYXksIGJ4LCBieSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYnggLSBheCwgMikgKyBNYXRoLnBvdyhieSAtIGF5LCAyKSk7XG59XG5mdW5jdGlvbiBjYWxjUmFuZ2VPcmllbnRhdGlvbihyYW5nZSwgY3Vyc29yKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93KVxuICAgICAgICB2YXIgY21wID0gMiAqIGN1cnNvci5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW4gLSByYW5nZS5lbmQuY29sdW1uO1xuICAgIGVsc2UgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93IC0gMSAmJiAhcmFuZ2Uuc3RhcnQuY29sdW1uICYmICFyYW5nZS5lbmQuY29sdW1uKVxuICAgICAgICB2YXIgY21wID0gY3Vyc29yLmNvbHVtbiAtIDQ7XG4gICAgZWxzZVxuICAgICAgICB2YXIgY21wID0gMiAqIGN1cnNvci5yb3cgLSByYW5nZS5zdGFydC5yb3cgLSByYW5nZS5lbmQucm93O1xuICAgIGlmIChjbXAgPCAwKVxuICAgICAgICByZXR1cm4geyBjdXJzb3I6IHJhbmdlLnN0YXJ0LCBhbmNob3I6IHJhbmdlLmVuZCB9O1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHsgY3Vyc29yOiByYW5nZS5lbmQsIGFuY2hvcjogcmFuZ2Uuc3RhcnQgfTtcbn1cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL3Njcm9sbFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtleHBvcnRzLnByZXZlbnRQYXJlbnRTY3JvbGwgPSBmdW5jdGlvbiBwcmV2ZW50UGFyZW50U2Nyb2xsKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgdmFyIGNvbnRlbnRPdmVyZmxvd3MgPSB0YXJnZXQuc2Nyb2xsSGVpZ2h0ID4gdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICBpZiAoIWNvbnRlbnRPdmVyZmxvd3MpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS90b29sdGlwXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGliL3Njcm9sbFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIHByZXZlbnRQYXJlbnRTY3JvbGwgPSByZXF1aXJlKFwiLi9saWIvc2Nyb2xsXCIpLnByZXZlbnRQYXJlbnRTY3JvbGw7XG52YXIgQ0xBU1NOQU1FID0gXCJhY2VfdG9vbHRpcFwiO1xudmFyIFRvb2x0aXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9vbHRpcChwYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRwYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB9XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuJGluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jbGFzc05hbWUgPSBDTEFTU05BTUU7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLiRwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudDtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50IHx8IHRoaXMuJGluaXQoKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY2xhc3NOYW1lID0gQ0xBU1NOQU1FICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoZW1lLmlzRGFyayA/IFwiYWNlX2RhcmsgXCIgOiBcIlwiKSArICh0aGVtZS5jc3NDbGFzcyB8fCBcIlwiKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSkge1xuICAgICAgICBpZiAodGV4dCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLmNsYXNzTmFtZSA9IENMQVNTTkFNRTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudCgpLm9mZnNldEhlaWdodDtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50KCkub2Zmc2V0V2lkdGg7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudCAmJiB0aGlzLiRlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRvb2x0aXA7XG59KCkpO1xudmFyIFBvcHVwTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3B1cE1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMucG9wdXBzID0gW107XG4gICAgfVxuICAgIFBvcHVwTWFuYWdlci5wcm90b3R5cGUuYWRkUG9wdXAgPSBmdW5jdGlvbiAocG9wdXApIHtcbiAgICAgICAgdGhpcy5wb3B1cHMucHVzaChwb3B1cCk7XG4gICAgICAgIHRoaXMudXBkYXRlUG9wdXBzKCk7XG4gICAgfTtcbiAgICBQb3B1cE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVBvcHVwID0gZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucG9wdXBzLmluZGV4T2YocG9wdXApO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3B1cHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXBNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQb3B1cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICB0aGlzLnBvcHVwcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTsgfSk7XG4gICAgICAgIHZhciB2aXNpYmxlcG9wdXBzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMucG9wdXBzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2aXNpYmxlcG9wdXBzXzEgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyh2aXNpYmxlcG9wdXBzKSksIHZpc2libGVwb3B1cHNfMV8xID0gdmlzaWJsZXBvcHVwc18xLm5leHQoKTsgIXZpc2libGVwb3B1cHNfMV8xLmRvbmU7IHZpc2libGVwb3B1cHNfMV8xID0gdmlzaWJsZXBvcHVwc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2libGVQb3B1cCA9IHZpc2libGVwb3B1cHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9Qb3B1cHNPdmVybGFwKHZpc2libGVQb3B1cCwgcG9wdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkRGlzcGxheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZXBvcHVwc18xXzEgJiYgIXZpc2libGVwb3B1cHNfMV8xLmRvbmUgJiYgKF9iID0gdmlzaWJsZXBvcHVwc18xLnJldHVybikpIF9iLmNhbGwodmlzaWJsZXBvcHVwc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVwb3B1cHMucHVzaChwb3B1cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3B1cC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwTWFuYWdlci5wcm90b3R5cGUuZG9Qb3B1cHNPdmVybGFwID0gZnVuY3Rpb24gKHBvcHVwQSwgcG9wdXBCKSB7XG4gICAgICAgIHZhciByZWN0QSA9IHBvcHVwQS5nZXRFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciByZWN0QiA9IHBvcHVwQi5nZXRFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiAocmVjdEEubGVmdCA8IHJlY3RCLnJpZ2h0ICYmIHJlY3RBLnJpZ2h0ID4gcmVjdEIubGVmdCAmJiByZWN0QS50b3AgPCByZWN0Qi5ib3R0b20gJiYgcmVjdEEuYm90dG9tXG4gICAgICAgICAgICA+IHJlY3RCLnRvcCk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdXBNYW5hZ2VyO1xufSgpKTtcbnZhciBwb3B1cE1hbmFnZXIgPSBuZXcgUG9wdXBNYW5hZ2VyKCk7XG5leHBvcnRzLnBvcHVwTWFuYWdlciA9IHBvcHVwTWFuYWdlcjtcbmV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG52YXIgSG92ZXJUb29sdGlwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIb3ZlclRvb2x0aXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSG92ZXJUb29sdGlwKHBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkgeyBwYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnROb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5sYXN0VCA9IDA7XG4gICAgICAgIF90aGlzLmlkbGVUaW1lID0gMzUwO1xuICAgICAgICBfdGhpcy5sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLm9uTW91c2VPdXQgPSBfdGhpcy5vbk1vdXNlT3V0LmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IF90aGlzLm9uTW91c2VNb3ZlLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy53YWl0Rm9ySG92ZXIgPSBfdGhpcy53YWl0Rm9ySG92ZXIuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmhpZGUgPSBfdGhpcy5oaWRlLmJpbmQoX3RoaXMpO1xuICAgICAgICB2YXIgZWwgPSBfdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgIGVsLnN0eWxlLndoaXRlU3BhY2UgPSBcInByZS13cmFwXCI7XG4gICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIF90aGlzLm9uTW91c2VPdXQpO1xuICAgICAgICBlbC50YWJJbmRleCA9IC0xO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9LmJpbmQoX3RoaXMpKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHByZXZlbnRQYXJlbnRTY3JvbGwpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUuYWRkVG9FZGl0b3IgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgZWRpdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuaGlkZSk7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5nZXRNb3VzZUV2ZW50VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMub25Nb3VzZU91dCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLnJlbW92ZUZyb21FZGl0b3IgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5vZmYoXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIGVkaXRvci5vZmYoXCJtb3VzZWRvd25cIiwgdGhpcy5oaWRlKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLmdldE1vdXNlRXZlbnRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vbk1vdXNlT3V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUsIGVkaXRvcikge1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IGU7XG4gICAgICAgIHRoaXMubGFzdFQgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgaXNNb3VzZVByZXNzZWQgPSBlZGl0b3IuJG1vdXNlSGFuZGxlci5pc01vdXNlUHJlc3NlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5sYXN0RXZlbnQgJiYgdGhpcy5sYXN0RXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlXG4gICAgICAgICAgICAgICAgfHwgIXRoaXMucmFuZ2UuY29udGFpbnMocG9zLnJvdywgcG9zLmNvbHVtbilcbiAgICAgICAgICAgICAgICB8fCBpc01vdXNlUHJlc3NlZFxuICAgICAgICAgICAgICAgIHx8IHRoaXMuaXNPdXRzaWRlT2ZUZXh0KHRoaXMubGFzdEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQgfHwgaXNNb3VzZVByZXNzZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gZTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLndhaXRGb3JIb3ZlciwgdGhpcy5pZGxlVGltZSk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLndhaXRGb3JIb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dClcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB2YXIgZHQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VDtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWUgLSBkdCA+IDEwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMud2FpdEZvckhvdmVyLCB0aGlzLmlkbGVUaW1lIC0gZHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFdmVudCAmJiAhdGhpcy5pc091dHNpZGVPZlRleHQodGhpcy5sYXN0RXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLiRnYXRoZXJEYXRhKHRoaXMubGFzdEV2ZW50LCB0aGlzLmxhc3RFdmVudC5lZGl0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLmlzT3V0c2lkZU9mVGV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSBlLmVkaXRvcjtcbiAgICAgICAgdmFyIGRvY1BvcyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgICAgICB2YXIgbGluZSA9IGVkaXRvci5zZXNzaW9uLmdldExpbmUoZG9jUG9zLnJvdyk7XG4gICAgICAgIGlmIChkb2NQb3MuY29sdW1uID09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuUG9zID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcyhlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgICB2YXIgY2xpcHBlZFBvcyA9IGVkaXRvci5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihkb2NQb3Mucm93LCBkb2NQb3MuY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbGlwcGVkUG9zLmNvbHVtbiAhPSBzY3JlZW5Qb3MuY29sdW1uXG4gICAgICAgICAgICAgICAgfHwgY2xpcHBlZFBvcy5yb3cgIT0gc2NyZWVuUG9zLnJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUuc2V0RGF0YVByb3ZpZGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGdhdGhlckRhdGEgPSB2YWx1ZTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUuc2hvd0ZvclJhbmdlID0gZnVuY3Rpb24gKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGUsIHN0YXJ0aW5nRXZlbnQpIHtcbiAgICAgICAgdmFyIE1BUkdJTiA9IDEwO1xuICAgICAgICBpZiAoc3RhcnRpbmdFdmVudCAmJiBzdGFydGluZ0V2ZW50ICE9IHRoaXMubGFzdEV2ZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmdldEVsZW1lbnQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZWRpdG9yLnJlbmRlcmVyO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICBwb3B1cE1hbmFnZXIuYWRkUG9wdXAodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRyZWdpc3RlckNsb3NlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRoZW1lKHJlbmRlcmVyLnRoZW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkTWFya2VyKHJhbmdlLCBlZGl0b3Iuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMucmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSByZW5kZXJlci50ZXh0VG9TY3JlZW5Db29yZGluYXRlcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIHZhciByZWN0ID0gcmVuZGVyZXIuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5wYWdlWCA8IHJlY3QubGVmdClcbiAgICAgICAgICAgIHBvc2l0aW9uLnBhZ2VYID0gcmVjdC5sZWZ0O1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9tTm9kZSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWF4SGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgc3BhY2VCZWxvdyA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHBvc2l0aW9uLnBhZ2VZIC0gcmVuZGVyZXIubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGlzQWJvdmUgPSB0cnVlO1xuICAgICAgICBpZiAocG9zaXRpb24ucGFnZVkgLSBsYWJlbEhlaWdodCA8IDAgJiYgcG9zaXRpb24ucGFnZVkgPCBzcGFjZUJlbG93KSB7XG4gICAgICAgICAgICBpc0Fib3ZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSAoaXNBYm92ZSA/IHBvc2l0aW9uLnBhZ2VZIDogc3BhY2VCZWxvdykgLSBNQVJHSU4gKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gaXNBYm92ZSA/IFwiXCIgOiBwb3NpdGlvbi5wYWdlWSArIHJlbmRlcmVyLmxpbmVIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuYm90dG9tID0gaXNBYm92ZSA/IHdpbmRvdy5pbm5lckhlaWdodCAtIHBvc2l0aW9uLnBhZ2VZICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gTWF0aC5taW4ocG9zaXRpb24ucGFnZVgsIHdpbmRvdy5pbm5lcldpZHRoIC0gbGFiZWxXaWR0aCAtIE1BUkdJTikgKyBcInB4XCI7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uIChyYW5nZSwgc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJG1hcmtlclNlc3Npb24ucmVtb3ZlTWFya2VyKHRoaXMubWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRtYXJrZXJTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBzZXNzaW9uICYmIHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9oaWdobGlnaHQtbWFya2VyXCIsIFwidGV4dFwiKTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZ2V0RWxlbWVudCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAmJiAoZS50eXBlICE9IFwia2V5ZG93blwiIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIHRoaXMuJGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZGRNYXJrZXIobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy4kcmVtb3ZlQ2xvc2VFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICBwb3B1cE1hbmFnZXIucmVtb3ZlUG9wdXAodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUuJHJlZ2lzdGVyQ2xvc2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhpZGUsIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuaGlkZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGlkZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBIb3ZlclRvb2x0aXAucHJvdG90eXBlLiRyZW1vdmVDbG9zZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGlkZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5oaWRlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oaWRlLCB0cnVlKTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbHRpcC5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0IHx8IHRoaXMuZ2V0RWxlbWVudCgpLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWUucmVsYXRlZFRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhY2VfY29udGVudFwiKSlcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEhvdmVyVG9vbHRpcDtcbn0oVG9vbHRpcCkpO1xuZXhwb3J0cy5Ib3ZlclRvb2x0aXAgPSBIb3ZlclRvb2x0aXA7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vdXNlL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvdG9vbHRpcFwiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIFRvb2x0aXAgPSByZXF1aXJlKFwiLi4vdG9vbHRpcFwiKS5Ub29sdGlwO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIikubmxzO1xudmFyIEdVVFRFUl9UT09MVElQX0xFRlRfT0ZGU0VUID0gNTtcbnZhciBHVVRURVJfVE9PTFRJUF9UT1BfT0ZGU0VUID0gMztcbmV4cG9ydHMuR1VUVEVSX1RPT0xUSVBfTEVGVF9PRkZTRVQgPSBHVVRURVJfVE9PTFRJUF9MRUZUX09GRlNFVDtcbmV4cG9ydHMuR1VUVEVSX1RPT0xUSVBfVE9QX09GRlNFVCA9IEdVVFRFUl9UT09MVElQX1RPUF9PRkZTRVQ7XG5mdW5jdGlvbiBHdXR0ZXJIYW5kbGVyKG1vdXNlSGFuZGxlcikge1xuICAgIHZhciBlZGl0b3IgPSBtb3VzZUhhbmRsZXIuZWRpdG9yO1xuICAgIHZhciBndXR0ZXIgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyO1xuICAgIHZhciB0b29sdGlwID0gbmV3IEd1dHRlclRvb2x0aXAoZWRpdG9yLCB0cnVlKTtcbiAgICBtb3VzZUhhbmRsZXIuZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwiZ3V0dGVybW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRm9jdXNlZCgpIHx8IGUuZ2V0QnV0dG9uKCkgIT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGd1dHRlci5nZXRSZWdpb24oZSk7XG4gICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcm93ID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlc3Npb24uc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZS5nZXRTaGlmdEtleSgpKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdFRvKHJvdywgMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGUuZG9tRXZlbnQuZGV0YWlsID09IDIpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyb3cpO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlSGFuZGxlci5zZXRTdGF0ZShcInNlbGVjdEJ5TGluZXNcIik7XG4gICAgICAgIG1vdXNlSGFuZGxlci5jYXB0dXJlTW91c2UoZSk7XG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgdmFyIHRvb2x0aXBUaW1lb3V0LCBtb3VzZUV2ZW50O1xuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICAgICB2YXIgcm93ID0gbW91c2VFdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICB2YXIgbWF4Um93ID0gZWRpdG9yLnNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyb3cgPT0gbWF4Um93KSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuUm93ID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcygwLCBtb3VzZUV2ZW50LnkpLnJvdztcbiAgICAgICAgICAgIHZhciBwb3MgPSBtb3VzZUV2ZW50LiRwb3M7XG4gICAgICAgICAgICBpZiAoc2NyZWVuUm93ID4gZWRpdG9yLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhwb3Mucm93LCBwb3MuY29sdW1uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwLnNob3dUb29sdGlwKHJvdyk7XG4gICAgICAgIGlmICghdG9vbHRpcC5pc09wZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNld2hlZWxcIiwgaGlkZVRvb2x0aXApO1xuICAgICAgICBlZGl0b3Iub24oXCJjaGFuZ2VTZXNzaW9uXCIsIGhpZGVUb29sdGlwKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhpZGVUb29sdGlwLCB0cnVlKTtcbiAgICAgICAgaWYgKG1vdXNlSGFuZGxlci4kdG9vbHRpcEZvbGxvd3NNb3VzZSkge1xuICAgICAgICAgICAgbW92ZVRvb2x0aXAobW91c2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyUm93ID0gbW91c2VFdmVudC5nZXRHdXR0ZXJSb3coKTtcbiAgICAgICAgICAgIHZhciBndXR0ZXJDZWxsID0gZ3V0dGVyLiRsaW5lcy5nZXQoZ3V0dGVyUm93KTtcbiAgICAgICAgICAgIGlmIChndXR0ZXJDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1dHRlckVsZW1lbnQgPSBndXR0ZXJDZWxsLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5hY2VfZ3V0dGVyX2Fubm90YXRpb25cIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBndXR0ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRvb2x0aXAuZ2V0RWxlbWVudCgpLnN0eWxlO1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSAocmVjdC5yaWdodCAtIEdVVFRFUl9UT09MVElQX0xFRlRfT0ZGU0VUKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSAocmVjdC5ib3R0b20gLSBHVVRURVJfVE9PTFRJUF9UT1BfT0ZGU0VUKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdmVUb29sdGlwKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgZS50eXBlID09PSBcImtleWRvd25cIiAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlICYmIGUudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmICghZS5yZWxhdGVkVGFyZ2V0IHx8IHRvb2x0aXAuZ2V0RWxlbWVudCgpLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXG4gICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IGNsZWFyVGltZW91dCh0b29sdGlwVGltZW91dCk7XG4gICAgICAgIGlmICh0b29sdGlwLmlzT3Blbikge1xuICAgICAgICAgICAgdG9vbHRpcC5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgZWRpdG9yLm9mZihcIm1vdXNld2hlZWxcIiwgaGlkZVRvb2x0aXApO1xuICAgICAgICAgICAgZWRpdG9yLm9mZihcImNoYW5nZVNlc3Npb25cIiwgaGlkZVRvb2x0aXApO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhpZGVUb29sdGlwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlVG9vbHRpcChlKSB7XG4gICAgICAgIHRvb2x0aXAuc2V0UG9zaXRpb24oZS54LCBlLnkpO1xuICAgIH1cbiAgICBtb3VzZUhhbmRsZXIuZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwiZ3V0dGVybW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgIGlmIChkb20uaGFzQ3NzQ2xhc3ModGFyZ2V0LCBcImFjZV9mb2xkLXdpZGdldFwiKSlcbiAgICAgICAgICAgIHJldHVybiBoaWRlVG9vbHRpcCgpO1xuICAgICAgICBpZiAodG9vbHRpcC5pc09wZW4gJiYgbW91c2VIYW5kbGVyLiR0b29sdGlwRm9sbG93c01vdXNlKVxuICAgICAgICAgICAgbW92ZVRvb2x0aXAoZSk7XG4gICAgICAgIG1vdXNlRXZlbnQgPSBlO1xuICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobW91c2VFdmVudCAmJiAhbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuJGd1dHRlciwgXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBtb3VzZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0b29sdGlwLmlzT3BlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGhpZGVUb29sdGlwKGUpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfSwgZWRpdG9yKTtcbn1cbmV4cG9ydHMuR3V0dGVySGFuZGxlciA9IEd1dHRlckhhbmRsZXI7XG52YXIgR3V0dGVyVG9vbHRpcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3V0dGVyVG9vbHRpcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHdXR0ZXJUb29sdGlwKGVkaXRvciwgaXNIb3Zlcikge1xuICAgICAgICBpZiAoaXNIb3ZlciA9PT0gdm9pZCAwKSB7IGlzSG92ZXIgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlZGl0b3IuY29udGFpbmVyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIF90aGlzLnZpc2libGVUb29sdGlwUm93O1xuICAgICAgICB2YXIgZWwgPSBfdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgIGlmIChpc0hvdmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5vbk1vdXNlT3V0ID0gX3RoaXMub25Nb3VzZU91dC5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBfdGhpcy5vbk1vdXNlT3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEd1dHRlclRvb2x0aXAucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWUucmVsYXRlZFRhcmdldCB8fCB0aGlzLmdldEVsZW1lbnQoKS5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZSAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgIH07XG4gICAgR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgeCArPSAxNTtcbiAgICAgICAgeSArPSAxNTtcbiAgICAgICAgaWYgKHggKyB3aWR0aCA+IHdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICB4IC09ICh4ICsgd2lkdGgpIC0gd2luZG93V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgKyBoZWlnaHQgPiB3aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHkgLT0gMjAgKyBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0UG9zaXRpb24uY2FsbCh0aGlzLCB4LCB5KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHdXR0ZXJUb29sdGlwLCBcImFubm90YXRpb25MYWJlbHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXI6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuZXJyb3Iuc2luZ3VsYXJcIiwgXCJlcnJvclwiKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsOiBubHMoXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmVycm9yLnBsdXJhbFwiLCBcImVycm9yc1wiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VjdXJpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXI6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuc2VjdXJpdHkuc2luZ3VsYXJcIiwgXCJzZWN1cml0eSBmaW5kaW5nXCIpLFxuICAgICAgICAgICAgICAgICAgICBwbHVyYWw6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuc2VjdXJpdHkucGx1cmFsXCIsIFwic2VjdXJpdHkgZmluZGluZ3NcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXI6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwud2FybmluZy5zaW5ndWxhclwiLCBcIndhcm5pbmdcIiksXG4gICAgICAgICAgICAgICAgICAgIHBsdXJhbDogbmxzKFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC53YXJuaW5nLnBsdXJhbFwiLCBcIndhcm5pbmdzXCIpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmd1bGFyOiBubHMoXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmluZm8uc2luZ3VsYXJcIiwgXCJpbmZvcm1hdGlvbiBtZXNzYWdlXCIpLFxuICAgICAgICAgICAgICAgICAgICBwbHVyYWw6IG5scyhcImd1dHRlci10b29sdGlwLmFyaWEtbGFiZWwuaW5mby5wbHVyYWxcIiwgXCJpbmZvcm1hdGlvbiBtZXNzYWdlc1wiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGludDoge1xuICAgICAgICAgICAgICAgICAgICBzaW5ndWxhcjogbmxzKFwiZ3V0dGVyLXRvb2x0aXAuYXJpYS1sYWJlbC5oaW50LnNpbmd1bGFyXCIsIFwic3VnZ2VzdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsOiBubHMoXCJndXR0ZXItdG9vbHRpcC5hcmlhLWxhYmVsLmhpbnQucGx1cmFsXCIsIFwic3VnZ2VzdGlvbnNcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGd1dHRlciA9IHRoaXMuZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllcjtcbiAgICAgICAgdmFyIGFubm90YXRpb25zSW5Sb3cgPSBndXR0ZXIuJGFubm90YXRpb25zW3Jvd107XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbnNJblJvdylcbiAgICAgICAgICAgIGFubm90YXRpb24gPSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IEFycmF5LmZyb20oYW5ub3RhdGlvbnNJblJvdy5kaXNwbGF5VGV4dCksXG4gICAgICAgICAgICAgICAgdHlwZTogQXJyYXkuZnJvbShhbm5vdGF0aW9uc0luUm93LnR5cGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhbm5vdGF0aW9uID0geyBkaXNwbGF5VGV4dDogW10sIHR5cGU6IFtdIH07XG4gICAgICAgIHZhciBmb2xkID0gZ3V0dGVyLnNlc3Npb24uZ2V0Rm9sZExpbmUocm93KTtcbiAgICAgICAgaWYgKGZvbGQgJiYgZ3V0dGVyLiRzaG93Rm9sZGVkQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uc0luRm9sZCA9IHsgZXJyb3I6IFtdLCBzZWN1cml0eTogW10sIHdhcm5pbmc6IFtdLCBpbmZvOiBbXSwgaGludDogW10gfTtcbiAgICAgICAgICAgIHZhciBzZXZlcml0eVJhbmsgPSB7IGVycm9yOiAxLCBzZWN1cml0eTogMiwgd2FybmluZzogMywgaW5mbzogNCwgaGludDogNSB9O1xuICAgICAgICAgICAgdmFyIG1vc3RTZXZlcmVBbm5vdGF0aW9uVHlwZUluRm9sZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByb3cgKyAxOyBpIDw9IGZvbGQuZW5kLnJvdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFndXR0ZXIuJGFubm90YXRpb25zW2ldKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGd1dHRlci4kYW5ub3RhdGlvbnNbaV0udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvblR5cGUgPSBndXR0ZXIuJGFubm90YXRpb25zW2ldLnR5cGVbal07XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zSW5Gb2xkW2Fubm90YXRpb25UeXBlXS5wdXNoKGd1dHRlci4kYW5ub3RhdGlvbnNbaV0udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9zdFNldmVyZUFubm90YXRpb25UeXBlSW5Gb2xkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXZlcml0eVJhbmtbYW5ub3RhdGlvblR5cGVdIDwgc2V2ZXJpdHlSYW5rW21vc3RTZXZlcmVBbm5vdGF0aW9uVHlwZUluRm9sZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RTZXZlcmVBbm5vdGF0aW9uVHlwZUluRm9sZCA9IGFubm90YXRpb25UeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFtcImVycm9yXCIsIFwic2VjdXJpdHlcIiwgXCJ3YXJuaW5nXCJdLmluY2x1ZGVzKG1vc3RTZXZlcmVBbm5vdGF0aW9uVHlwZUluRm9sZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeUZvbGRlZEFubm90YXRpb25zID0gXCJcIi5jb25jYXQoR3V0dGVyVG9vbHRpcC5hbm5vdGF0aW9uc1RvU3VtbWFyeVN0cmluZyhhbm5vdGF0aW9uc0luRm9sZCksIFwiIGluIGZvbGRlZCBjb2RlLlwiKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmRpc3BsYXlUZXh0LnB1c2goc3VtbWFyeUZvbGRlZEFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLnR5cGUucHVzaChtb3N0U2V2ZXJlQW5ub3RhdGlvblR5cGVJbkZvbGQgKyBcIl9mb2xkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uLmRpc3BsYXlUZXh0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVUb29sdGlwKCk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9uTWVzc2FnZXMgPSB7IGVycm9yOiBbXSwgc2VjdXJpdHk6IFtdLCB3YXJuaW5nOiBbXSwgaW5mbzogW10sIGhpbnQ6IFtdIH07XG4gICAgICAgIHZhciBpY29uQ2xhc3NOYW1lID0gZ3V0dGVyLiR1c2VTdmdHdXR0ZXJJY29ucyA/IFwiYWNlX2ljb25fc3ZnXCIgOiBcImFjZV9pY29uXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbi5kaXNwbGF5VGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVFbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgdmFyIGljb25FbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgKF9hID0gaWNvbkVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIFtcImFjZV9cIi5jb25jYXQoYW5ub3RhdGlvbi50eXBlW2ldKSwgaWNvbkNsYXNzTmFtZV0pO1xuICAgICAgICAgICAgaWNvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlwiLmNvbmNhdChHdXR0ZXJUb29sdGlwLmFubm90YXRpb25MYWJlbHNbYW5ub3RhdGlvbi50eXBlW2ldLnJlcGxhY2UoXCJfZm9sZFwiLCBcIlwiKV0uc2luZ3VsYXIpKTtcbiAgICAgICAgICAgIGljb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlVGV4dE5vZGUoXCIgXCIpKTtcbiAgICAgICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgICAgIGxpbmVFbGVtZW50LmFwcGVuZENoaWxkKGRvbS5jcmVhdGVUZXh0Tm9kZShhbm5vdGF0aW9uLmRpc3BsYXlUZXh0W2ldKSk7XG4gICAgICAgICAgICBsaW5lRWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgICAgIGFubm90YXRpb25NZXNzYWdlc1thbm5vdGF0aW9uLnR5cGVbaV0ucmVwbGFjZShcIl9mb2xkXCIsIFwiXCIpXS5wdXNoKGxpbmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9vbHRpcEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgZG9tLnJlbW92ZUNoaWxkcmVuKHRvb2x0aXBFbGVtZW50KTtcbiAgICAgICAgYW5ub3RhdGlvbk1lc3NhZ2VzLmVycm9yLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiB0b29sdGlwRWxlbWVudC5hcHBlbmRDaGlsZChlbCk7IH0pO1xuICAgICAgICBhbm5vdGF0aW9uTWVzc2FnZXMuc2VjdXJpdHkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRvb2x0aXBFbGVtZW50LmFwcGVuZENoaWxkKGVsKTsgfSk7XG4gICAgICAgIGFubm90YXRpb25NZXNzYWdlcy53YXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiB0b29sdGlwRWxlbWVudC5hcHBlbmRDaGlsZChlbCk7IH0pO1xuICAgICAgICBhbm5vdGF0aW9uTWVzc2FnZXMuaW5mby5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gdG9vbHRpcEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpOyB9KTtcbiAgICAgICAgYW5ub3RhdGlvbk1lc3NhZ2VzLmhpbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRvb2x0aXBFbGVtZW50LmFwcGVuZENoaWxkKGVsKTsgfSk7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXRUaGVtZSh0aGlzLmVkaXRvci5yZW5kZXJlci50aGVtZSk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZShcImFjZV9ndXR0ZXItdG9vbHRpcFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgdGhpcy52aXNpYmxlVG9vbHRpcFJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5lZGl0b3IuX3NpZ25hbChcInNob3dHdXR0ZXJUb29sdGlwXCIsIHRoaXMpO1xuICAgIH07XG4gICAgR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVRvb2x0aXBSb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZWRpdG9yLl9zaWduYWwoXCJoaWRlR3V0dGVyVG9vbHRpcFwiLCB0aGlzKTtcbiAgICB9O1xuICAgIEd1dHRlclRvb2x0aXAuYW5ub3RhdGlvbnNUb1N1bW1hcnlTdHJpbmcgPSBmdW5jdGlvbiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gW107XG4gICAgICAgIHZhciBhbm5vdGF0aW9uVHlwZXMgPSBbXCJlcnJvclwiLCBcInNlY3VyaXR5XCIsIFwid2FybmluZ1wiLCBcImluZm9cIiwgXCJoaW50XCJdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYW5ub3RhdGlvblR5cGVzXzEgPSBfX3ZhbHVlcyhhbm5vdGF0aW9uVHlwZXMpLCBhbm5vdGF0aW9uVHlwZXNfMV8xID0gYW5ub3RhdGlvblR5cGVzXzEubmV4dCgpOyAhYW5ub3RhdGlvblR5cGVzXzFfMS5kb25lOyBhbm5vdGF0aW9uVHlwZXNfMV8xID0gYW5ub3RhdGlvblR5cGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvblR5cGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFubm90YXRpb25zW2Fubm90YXRpb25UeXBlXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGFubm90YXRpb25zW2Fubm90YXRpb25UeXBlXS5sZW5ndGggPT09IDEgPyBHdXR0ZXJUb29sdGlwLmFubm90YXRpb25MYWJlbHNbYW5ub3RhdGlvblR5cGVdLnNpbmd1bGFyIDogR3V0dGVyVG9vbHRpcC5hbm5vdGF0aW9uTGFiZWxzW2Fubm90YXRpb25UeXBlXS5wbHVyYWw7XG4gICAgICAgICAgICAgICAgc3VtbWFyeS5wdXNoKFwiXCIuY29uY2F0KGFubm90YXRpb25zW2Fubm90YXRpb25UeXBlXS5sZW5ndGgsIFwiIFwiKS5jb25jYXQobGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25UeXBlc18xXzEgJiYgIWFubm90YXRpb25UeXBlc18xXzEuZG9uZSAmJiAoX2EgPSBhbm5vdGF0aW9uVHlwZXNfMS5yZXR1cm4pKSBfYS5jYWxsKGFubm90YXRpb25UeXBlc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtbWFyeS5qb2luKFwiLCBcIik7XG4gICAgfTtcbiAgICByZXR1cm4gR3V0dGVyVG9vbHRpcDtcbn0oVG9vbHRpcCkpO1xuZXhwb3J0cy5HdXR0ZXJUb29sdGlwID0gR3V0dGVyVG9vbHRpcDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvbW91c2VfZXZlbnRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBNb3VzZUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vdXNlRXZlbnQoZG9tRXZlbnQsIGVkaXRvcikgeyB0aGlzLnNwZWVkOyB0aGlzLndoZWVsWDsgdGhpcy53aGVlbFk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnQgPSBkb21FdmVudDtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuY2xpZW50WCA9IGRvbUV2ZW50LmNsaWVudFg7XG4gICAgICAgIHRoaXMueSA9IHRoaXMuY2xpZW50WSA9IGRvbUV2ZW50LmNsaWVudFk7XG4gICAgICAgIHRoaXMuJHBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJGluU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKHRoaXMuZG9tRXZlbnQpO1xuICAgICAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNb3VzZUV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQodGhpcy5kb21FdmVudCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNb3VzZUV2ZW50LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXREb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kcG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBvcztcbiAgICAgICAgdGhpcy4kcG9zID0gdGhpcy5lZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy5jbGllbnRYLCB0aGlzLmNsaWVudFkpO1xuICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xuICAgIH07XG4gICAgTW91c2VFdmVudC5wcm90b3R5cGUuZ2V0R3V0dGVyUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnRSb3cgPSB0aGlzLmdldERvY3VtZW50UG9zaXRpb24oKS5yb3c7XG4gICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLmVkaXRvci5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3coZG9jdW1lbnRSb3csIDApO1xuICAgICAgICB2YXIgc2NyZWVuVG9wUm93ID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KHRoaXMuZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllci4kbGluZXMuZ2V0KDApLnJvdywgMCk7XG4gICAgICAgIHJldHVybiBzY3JlZW5Sb3cgLSBzY3JlZW5Ub3BSb3c7XG4gICAgfTtcbiAgICBNb3VzZUV2ZW50LnByb3RvdHlwZS5pblNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGluU2VsZWN0aW9uICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluU2VsZWN0aW9uO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uUmFuZ2UuaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLiRpblNlbGVjdGlvbiA9IHNlbGVjdGlvblJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRpblNlbGVjdGlvbjtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLmdldEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmdldEJ1dHRvbih0aGlzLmRvbUV2ZW50KTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLmdldFNoaWZ0S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FdmVudC5zaGlmdEtleTtcbiAgICB9O1xuICAgIE1vdXNlRXZlbnQucHJvdG90eXBlLmdldEFjY2VsS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXNlcmFnZW50LmlzTWFjID8gdGhpcy5kb21FdmVudC5tZXRhS2V5IDogdGhpcy5kb21FdmVudC5jdHJsS2V5O1xuICAgIH07XG4gICAgcmV0dXJuIE1vdXNlRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvZHJhZ2Ryb3BfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBBVVRPU0NST0xMX0RFTEFZID0gMjAwO1xudmFyIFNDUk9MTF9DVVJTT1JfREVMQVkgPSAyMDA7XG52YXIgU0NST0xMX0NVUlNPUl9IWVNURVJFU0lTID0gNTtcbmZ1bmN0aW9uIERyYWdkcm9wSGFuZGxlcihtb3VzZUhhbmRsZXIpIHtcbiAgICB2YXIgZWRpdG9yID0gbW91c2VIYW5kbGVyLmVkaXRvcjtcbiAgICB2YXIgZHJhZ0ltYWdlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZHJhZ0ltYWdlLnN0eWxlLmNzc1RleHQgPSBcInRvcDotMTAwcHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoyMTQ3NDgzNjQ3O29wYWNpdHk6MC41XCI7XG4gICAgZHJhZ0ltYWdlLnRleHRDb250ZW50ID0gXCJcXHhhMFwiO1xuICAgIHZhciBleHBvcnRzID0gW1wiZHJhZ1dhaXRcIiwgXCJkcmFnV2FpdEVuZFwiLCBcInN0YXJ0RHJhZ1wiLCBcImRyYWdSZWFkeUVuZFwiLCBcIm9uTW91c2VEcmFnXCJdO1xuICAgIGV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBtb3VzZUhhbmRsZXJbeF0gPSB0aGlzW3hdO1xuICAgIH0sIHRoaXMpO1xuICAgIGVkaXRvci5vbihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLmJpbmQobW91c2VIYW5kbGVyKSk7XG4gICAgdmFyIG1vdXNlVGFyZ2V0ID0gZWRpdG9yLmNvbnRhaW5lcjtcbiAgICB2YXIgZHJhZ1NlbGVjdGlvbk1hcmtlciwgeCwgeTtcbiAgICB2YXIgdGltZXJJZCwgcmFuZ2U7XG4gICAgdmFyIGRyYWdDdXJzb3IsIGNvdW50ZXIgPSAwO1xuICAgIHZhciBkcmFnT3BlcmF0aW9uO1xuICAgIHZhciBpc0ludGVybmFsO1xuICAgIHZhciBhdXRvU2Nyb2xsU3RhcnRUaW1lO1xuICAgIHZhciBjdXJzb3JNb3ZlZFRpbWU7XG4gICAgdmFyIGN1cnNvclBvaW50T25DYXJldE1vdmVkO1xuICAgIHRoaXMub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxEcmFnIHx8ICFtb3VzZVRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhcnRTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhcHR1cmVNb3VzZShlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gZWRpdG9yLmdldFJlYWRPbmx5KCkgPyBcImNvcHlcIiA6IFwiY29weU1vdmVcIjtcbiAgICAgICAgZWRpdG9yLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkcmFnSW1hZ2UpO1xuICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlICYmIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0ltYWdlLCAwLCAwKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLnJlbW92ZUNoaWxkKGRyYWdJbWFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCBlZGl0b3Iuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoKSk7XG4gICAgICAgIGlzSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiZHJhZ1wiKTtcbiAgICB9O1xuICAgIHRoaXMub25EcmFnRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgbW91c2VUYXJnZXQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGlzSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShudWxsKTtcbiAgICAgICAgaWYgKCFlZGl0b3IuZ2V0UmVhZE9ubHkoKSkge1xuICAgICAgICAgICAgdmFyIGRyb3BFZmZlY3QgPSBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0O1xuICAgICAgICAgICAgaWYgKCFkcmFnT3BlcmF0aW9uICYmIGRyb3BFZmZlY3QgPT0gXCJtb3ZlXCIpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgICAgIGVkaXRvci4kcmVzZXRDdXJzb3JTdHlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yLnVuc2V0U3R5bGUoXCJhY2VfZHJhZ2dpbmdcIik7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKFwiXCIpO1xuICAgIH07XG4gICAgdGhpcy5vbkRyYWdFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlZGl0b3IuZ2V0UmVhZE9ubHkoKSB8fCAhY2FuQWNjZXB0KGUuZGF0YVRyYW5zZmVyKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgeCA9IGUuY2xpZW50WDtcbiAgICAgICAgeSA9IGUuY2xpZW50WTtcbiAgICAgICAgaWYgKCFkcmFnU2VsZWN0aW9uTWFya2VyKVxuICAgICAgICAgICAgYWRkRHJhZ01hcmtlcigpO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcmFnT3BlcmF0aW9uID0gZ2V0RHJvcEVmZmVjdChlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH07XG4gICAgdGhpcy5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGVkaXRvci5nZXRSZWFkT25seSgpIHx8ICFjYW5BY2NlcHQoZS5kYXRhVHJhbnNmZXIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgICB5ID0gZS5jbGllbnRZO1xuICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb25NYXJrZXIpIHtcbiAgICAgICAgICAgIGFkZERyYWdNYXJrZXIoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciAhPT0gbnVsbClcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlVGltZXIgPSBudWxsO1xuICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZHJhZ09wZXJhdGlvbiA9IGdldERyb3BFZmZlY3QoZSk7XG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICB9O1xuICAgIHRoaXMub25EcmFnTGVhdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChjb3VudGVyIDw9IDAgJiYgZHJhZ1NlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgY2xlYXJEcmFnTWFya2VyKCk7XG4gICAgICAgICAgICBkcmFnT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkRyb3AgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWRyYWdDdXJzb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgaWYgKGlzSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZHJhZ09wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb250YWlucyhkcmFnQ3Vyc29yLnJvdywgZHJhZ0N1cnNvci5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZHJhZ0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGRyYWdDdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGVkaXRvci5tb3ZlVGV4dChyYW5nZSwgZHJhZ0N1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3IubW92ZVRleHQocmFuZ2UsIGRyYWdDdXJzb3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkcm9wRGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdUZXh0Jyk7XG4gICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZHJhZ0N1cnNvcixcbiAgICAgICAgICAgICAgICBlbmQ6IGVkaXRvci5zZXNzaW9uLmluc2VydChkcmFnQ3Vyc29yLCBkcm9wRGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIGRyYWdPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyRHJhZ01hcmtlcigpO1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydC5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJhZ2VuZFwiLCB0aGlzLm9uRHJhZ0VuZC5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJhZ2VudGVyXCIsIHRoaXMub25EcmFnRW50ZXIuYmluZChtb3VzZUhhbmRsZXIpLCBlZGl0b3IpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyYWdvdmVyXCIsIHRoaXMub25EcmFnT3Zlci5iaW5kKG1vdXNlSGFuZGxlciksIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJhZ2xlYXZlXCIsIHRoaXMub25EcmFnTGVhdmUuYmluZChtb3VzZUhhbmRsZXIpLCBlZGl0b3IpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyb3BcIiwgdGhpcy5vbkRyb3AuYmluZChtb3VzZUhhbmRsZXIpLCBlZGl0b3IpO1xuICAgIGZ1bmN0aW9uIHNjcm9sbEN1cnNvckludG9WaWV3KGN1cnNvciwgcHJldkN1cnNvcikge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHZNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5yb3cgIT0gcHJldkN1cnNvci5yb3c7XG4gICAgICAgIHZhciBoTW92ZW1lbnQgPSAhcHJldkN1cnNvciB8fCBjdXJzb3IuY29sdW1uICE9IHByZXZDdXJzb3IuY29sdW1uO1xuICAgICAgICBpZiAoIWN1cnNvck1vdmVkVGltZSB8fCB2TW92ZW1lbnQgfHwgaE1vdmVtZW50KSB7XG4gICAgICAgICAgICBlZGl0b3IubW92ZUN1cnNvclRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICAgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG5vdztcbiAgICAgICAgICAgIGN1cnNvclBvaW50T25DYXJldE1vdmVkID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueCwgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueSwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBTQ1JPTExfQ1VSU09SX0hZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JNb3ZlZFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm93IC0gY3Vyc29yTW92ZWRUaW1lID49IFNDUk9MTF9DVVJTT1JfREVMQVkpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3JNb3ZlZFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF1dG9TY3JvbGwoY3Vyc29yLCBwcmV2Q3Vyc29yKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgY2hhcmFjdGVyV2lkdGggPSBlZGl0b3IucmVuZGVyZXIubGF5ZXJDb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIHZhciBlZGl0b3JSZWN0ID0gZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB4IC0gZWRpdG9yUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBlZGl0b3JSZWN0LnJpZ2h0IC0geFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHkgLSBlZGl0b3JSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IGVkaXRvclJlY3QuYm90dG9tIC0geVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmVhcmVzdFhPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXRzLngubGVmdCwgb2Zmc2V0cy54LnJpZ2h0KTtcbiAgICAgICAgdmFyIG5lYXJlc3RZT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0cy55LnRvcCwgb2Zmc2V0cy55LmJvdHRvbSk7XG4gICAgICAgIHZhciBzY3JvbGxDdXJzb3IgPSB7IHJvdzogY3Vyc29yLnJvdywgY29sdW1uOiBjdXJzb3IuY29sdW1uIH07XG4gICAgICAgIGlmIChuZWFyZXN0WE9mZnNldCAvIGNoYXJhY3RlcldpZHRoIDw9IDIpIHtcbiAgICAgICAgICAgIHNjcm9sbEN1cnNvci5jb2x1bW4gKz0gKG9mZnNldHMueC5sZWZ0IDwgb2Zmc2V0cy54LnJpZ2h0ID8gLTMgOiArMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXJlc3RZT2Zmc2V0IC8gbGluZUhlaWdodCA8PSAxKSB7XG4gICAgICAgICAgICBzY3JvbGxDdXJzb3Iucm93ICs9IChvZmZzZXRzLnkudG9wIDwgb2Zmc2V0cy55LmJvdHRvbSA/IC0xIDogKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2U2Nyb2xsID0gY3Vyc29yLnJvdyAhPSBzY3JvbGxDdXJzb3Iucm93O1xuICAgICAgICB2YXIgaFNjcm9sbCA9IGN1cnNvci5jb2x1bW4gIT0gc2Nyb2xsQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgdmFyIHZNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5yb3cgIT0gcHJldkN1cnNvci5yb3c7XG4gICAgICAgIGlmICh2U2Nyb2xsIHx8IChoU2Nyb2xsICYmICF2TW92ZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWF1dG9TY3JvbGxTdGFydFRpbWUpXG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbFN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vdyAtIGF1dG9TY3JvbGxTdGFydFRpbWUgPj0gQVVUT1NDUk9MTF9ERUxBWSlcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoc2Nyb2xsQ3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF1dG9TY3JvbGxTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRHJhZ0ludGVydmFsKCkge1xuICAgICAgICB2YXIgcHJldkN1cnNvciA9IGRyYWdDdXJzb3I7XG4gICAgICAgIGRyYWdDdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXMoeCwgeSk7XG4gICAgICAgIHNjcm9sbEN1cnNvckludG9WaWV3KGRyYWdDdXJzb3IsIHByZXZDdXJzb3IpO1xuICAgICAgICBhdXRvU2Nyb2xsKGRyYWdDdXJzb3IsIHByZXZDdXJzb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGREcmFnTWFya2VyKCkge1xuICAgICAgICByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgIGRyYWdTZWxlY3Rpb25NYXJrZXIgPSBlZGl0b3Iuc2Vzc2lvbi5hZGRNYXJrZXIocmFuZ2UsIFwiYWNlX3NlbGVjdGlvblwiLCBlZGl0b3IuZ2V0U2VsZWN0aW9uU3R5bGUoKSk7XG4gICAgICAgIGVkaXRvci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoZWRpdG9yLmlzRm9jdXNlZCgpKVxuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5zZXRCbGlua2luZyhmYWxzZSk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgIG9uRHJhZ0ludGVydmFsKCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRJbnRlcnZhbChvbkRyYWdJbnRlcnZhbCwgMjApO1xuICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJEcmFnTWFya2VyKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmVNYXJrZXIoZHJhZ1NlbGVjdGlvbk1hcmtlcik7XG4gICAgICAgIGRyYWdTZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc0ZvY3VzZWQoKSAmJiAhaXNJbnRlcm5hbClcbiAgICAgICAgICAgIGVkaXRvci4kcmVzZXRDdXJzb3JTdHlsZSgpO1xuICAgICAgICByYW5nZSA9IG51bGw7XG4gICAgICAgIGRyYWdDdXJzb3IgPSBudWxsO1xuICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgYXV0b1Njcm9sbFN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XG4gICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuICAgIHZhciBvbk1vdXNlTW92ZVRpbWVyID0gbnVsbDtcbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHtcbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlVGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlTW92ZVRpbWVyICE9IG51bGwgJiYgZHJhZ1NlbGVjdGlvbk1hcmtlcilcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJEcmFnTWFya2VyKCk7XG4gICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuQWNjZXB0KGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgdHlwZXMgPSBkYXRhVHJhbnNmZXIudHlwZXM7XG4gICAgICAgIHJldHVybiAhdHlwZXMgfHwgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09ICd0ZXh0L3BsYWluJyB8fCB0eXBlID09ICdUZXh0JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERyb3BFZmZlY3QoZSkge1xuICAgICAgICB2YXIgY29weUFsbG93ZWQgPSBbJ2NvcHknLCAnY29weW1vdmUnLCAnYWxsJywgJ3VuaW5pdGlhbGl6ZWQnXTtcbiAgICAgICAgdmFyIG1vdmVBbGxvd2VkID0gWydtb3ZlJywgJ2NvcHltb3ZlJywgJ2xpbmttb3ZlJywgJ2FsbCcsICd1bmluaXRpYWxpemVkJ107XG4gICAgICAgIHZhciBjb3B5TW9kaWZpZXJTdGF0ZSA9IHVzZXJhZ2VudC5pc01hYyA/IGUuYWx0S2V5IDogZS5jdHJsS2V5O1xuICAgICAgICB2YXIgZWZmZWN0QWxsb3dlZCA9IFwidW5pbml0aWFsaXplZFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWZmZWN0QWxsb3dlZCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIHZhciBkcm9wRWZmZWN0ID0gXCJub25lXCI7XG4gICAgICAgIGlmIChjb3B5TW9kaWZpZXJTdGF0ZSAmJiBjb3B5QWxsb3dlZC5pbmRleE9mKGVmZmVjdEFsbG93ZWQpID49IDApXG4gICAgICAgICAgICBkcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgIGVsc2UgaWYgKG1vdmVBbGxvd2VkLmluZGV4T2YoZWZmZWN0QWxsb3dlZCkgPj0gMClcbiAgICAgICAgICAgIGRyb3BFZmZlY3QgPSBcIm1vdmVcIjtcbiAgICAgICAgZWxzZSBpZiAoY29weUFsbG93ZWQuaW5kZXhPZihlZmZlY3RBbGxvd2VkKSA+PSAwKVxuICAgICAgICAgICAgZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgICByZXR1cm4gZHJvcEVmZmVjdDtcbiAgICB9XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZHJhZ1dhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IERhdGUubm93KCkgLSB0aGlzLm1vdXNlZG93bkV2ZW50LnRpbWU7XG4gICAgICAgIGlmIChpbnRlcnZhbCA+IHRoaXMuZWRpdG9yLmdldERyYWdEZWxheSgpKVxuICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoKTtcbiAgICB9O1xuICAgIHRoaXMuZHJhZ1dhaXRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmVkaXRvci5jb250YWluZXI7XG4gICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdCh0aGlzLm1vdXNlZG93bkV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0RW5kKCk7XG4gICAgfTtcbiAgICB0aGlzLmRyYWdSZWFkeUVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLiRyZXNldEN1cnNvclN0eWxlKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnVuc2V0U3R5bGUoXCJhY2VfZHJhZ2dpbmdcIik7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKFwiXCIpO1xuICAgICAgICB0aGlzLmRyYWdXYWl0RW5kKCk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxEcmFnID0gZmFsc2U7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGVkaXRvci5jb250YWluZXI7XG4gICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyLnNldEJsaW5raW5nKGZhbHNlKTtcbiAgICAgICAgZWRpdG9yLnNldFN0eWxlKFwiYWNlX2RyYWdnaW5nXCIpO1xuICAgICAgICB2YXIgY3Vyc29yU3R5bGUgPSB1c2VyYWdlbnQuaXNXaW4gPyBcImRlZmF1bHRcIiA6IFwibW92ZVwiO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiZHJhZ1JlYWR5XCIpO1xuICAgIH07XG4gICAgdGhpcy5vbk1vdXNlRHJhZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmVkaXRvci5jb250YWluZXI7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSAmJiB0aGlzLnN0YXRlID09IFwiZHJhZ1JlYWR5XCIpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZSh0aGlzLm1vdXNlZG93bkV2ZW50LngsIHRoaXMubW91c2Vkb3duRXZlbnQueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMylcbiAgICAgICAgICAgICAgICB0YXJnZXQuZHJhZ0Ryb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkcmFnV2FpdFwiKSB7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UodGhpcy5tb3VzZWRvd25FdmVudC54LCB0aGlzLm1vdXNlZG93bkV2ZW50LnksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNlbGVjdCh0aGlzLm1vdXNlZG93bkV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGRyYWdFbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1vdXNlZG93bkV2ZW50ID0gZTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgaW5TZWxlY3Rpb24gPSBlLmluU2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBidXR0b24gPSBlLmdldEJ1dHRvbigpO1xuICAgICAgICB2YXIgY2xpY2tDb3VudCA9IGUuZG9tRXZlbnQuZGV0YWlsIHx8IDE7XG4gICAgICAgIGlmIChjbGlja0NvdW50ID09PSAxICYmIGJ1dHRvbiA9PT0gMCAmJiBpblNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlICYmIChlLmdldEFjY2VsS2V5KCkgfHwgZS5nZXRTaGlmdEtleSgpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1vdXNlZG93bkV2ZW50LnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS5kb21FdmVudC50YXJnZXQgfHwgZS5kb21FdmVudC5zcmNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKFwidW5zZWxlY3RhYmxlXCIgaW4gZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQudW5zZWxlY3RhYmxlID0gXCJvblwiO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5nZXREcmFnRGVsYXkoKSkge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNXZWJLaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxEcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlVGFyZ2V0ID0gZWRpdG9yLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VUYXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShcImRyYWdXYWl0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZU1vdXNlKGUsIHRoaXMub25Nb3VzZURyYWcuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbn0pLmNhbGwoRHJhZ2Ryb3BIYW5kbGVyLnByb3RvdHlwZSk7XG5mdW5jdGlvbiBjYWxjRGlzdGFuY2UoYXgsIGF5LCBieCwgYnkpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGJ4IC0gYXgsIDIpICsgTWF0aC5wb3coYnkgLSBheSwgMikpO1xufVxuZXhwb3J0cy5EcmFnZHJvcEhhbmRsZXIgPSBEcmFnZHJvcEhhbmRsZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vdXNlL3RvdWNoX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9tb3VzZS9tb3VzZV9ldmVudFwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL21vdXNlX2V2ZW50XCIpLk1vdXNlRXZlbnQ7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xuZXhwb3J0cy5hZGRUb3VjaExpc3RlbmVycyA9IGZ1bmN0aW9uIChlbCwgZWRpdG9yKSB7XG4gICAgdmFyIG1vZGUgPSBcInNjcm9sbFwiO1xuICAgIHZhciBzdGFydFg7XG4gICAgdmFyIHN0YXJ0WTtcbiAgICB2YXIgdG91Y2hTdGFydFQ7XG4gICAgdmFyIGxhc3RUO1xuICAgIHZhciBsb25nVG91Y2hUaW1lcjtcbiAgICB2YXIgYW5pbWF0aW9uVGltZXI7XG4gICAgdmFyIGFuaW1hdGlvblN0ZXBzID0gMDtcbiAgICB2YXIgcG9zO1xuICAgIHZhciBjbGlja0NvdW50ID0gMDtcbiAgICB2YXIgdlggPSAwO1xuICAgIHZhciB2WSA9IDA7XG4gICAgdmFyIHByZXNzZWQ7XG4gICAgdmFyIGNvbnRleHRNZW51O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRNZW51KCkge1xuICAgICAgICB2YXIgY2xpcGJvYXJkID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZDtcbiAgICAgICAgdmFyIGlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB2YXIgdXBkYXRlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGVkaXRvci5nZXRDb3B5VGV4dCgpO1xuICAgICAgICAgICAgdmFyIGhhc1VuZG8gPSBlZGl0b3Iuc2Vzc2lvbi5nZXRVbmRvTWFuYWdlcigpLmhhc1VuZG8oKTtcbiAgICAgICAgICAgIGNvbnRleHRNZW51LnJlcGxhY2VDaGlsZChkb20uYnVpbGREb20oaXNPcGVuID8gW1wic3BhblwiLFxuICAgICAgICAgICAgICAgICFzZWxlY3RlZCAmJiBjYW5FeGVjdXRlQ29tbWFuZChcInNlbGVjdGFsbFwiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcInNlbGVjdGFsbFwiIH0sIFwiU2VsZWN0IEFsbFwiXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCAmJiBjYW5FeGVjdXRlQ29tbWFuZChcImNvcHlcIikgJiYgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJjb3B5XCIgfSwgXCJDb3B5XCJdLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkICYmIGNhbkV4ZWN1dGVDb21tYW5kKFwiY3V0XCIpICYmIFtcInNwYW5cIiwgeyBjbGFzczogXCJhY2VfbW9iaWxlLWJ1dHRvblwiLCBhY3Rpb246IFwiY3V0XCIgfSwgXCJDdXRcIl0sXG4gICAgICAgICAgICAgICAgY2xpcGJvYXJkICYmIGNhbkV4ZWN1dGVDb21tYW5kKFwicGFzdGVcIikgJiYgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJwYXN0ZVwiIH0sIFwiUGFzdGVcIl0sXG4gICAgICAgICAgICAgICAgaGFzVW5kbyAmJiBjYW5FeGVjdXRlQ29tbWFuZChcInVuZG9cIikgJiYgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJ1bmRvXCIgfSwgXCJVbmRvXCJdLFxuICAgICAgICAgICAgICAgIGNhbkV4ZWN1dGVDb21tYW5kKFwiZmluZFwiKSAmJiBbXCJzcGFuXCIsIHsgY2xhc3M6IFwiYWNlX21vYmlsZS1idXR0b25cIiwgYWN0aW9uOiBcImZpbmRcIiB9LCBcIkZpbmRcIl0sXG4gICAgICAgICAgICAgICAgY2FuRXhlY3V0ZUNvbW1hbmQoXCJvcGVuQ29tbWFuZFBhbGV0dGVcIikgJiYgW1wic3BhblwiLCB7IGNsYXNzOiBcImFjZV9tb2JpbGUtYnV0dG9uXCIsIGFjdGlvbjogXCJvcGVuQ29tbWFuZFBhbGV0dGVcIiB9LCBcIlBhbGV0dGVcIl1cbiAgICAgICAgICAgIF0gOiBbXCJzcGFuXCJdKSwgY29udGV4dE1lbnUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW5FeGVjdXRlQ29tbWFuZCA9IGZ1bmN0aW9uICgvKiogQHR5cGUge3N0cmluZ30gKi8gY21kKSB7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNhbkV4ZWN1dGUoY21kLCBlZGl0b3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJtb3JlXCIgfHwgIWlzT3Blbikge1xuICAgICAgICAgICAgICAgIGlzT3BlbiA9ICFpc09wZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJwYXN0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY2xpcGJvYXJkLnJlYWRUZXh0KCkudGhlbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoYWN0aW9uLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJjdXRcIiB8fCBhY3Rpb24gPT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBib2FyZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBib2FyZC53cml0ZVRleHQoZWRpdG9yLmdldENvcHlUZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dE1lbnUuZmlyc3RDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBpc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gIT0gXCJvcGVuQ29tbWFuZFBhbGV0dGVcIilcbiAgICAgICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dE1lbnUgPSBkb20uYnVpbGREb20oW1wiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiYWNlX21vYmlsZS1tZW51XCIsXG4gICAgICAgICAgICAgICAgb250b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gXCJtZW51XCI7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnRleHRJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb250b3VjaGVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGhhbmRsZUNsaWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1wic3BhblwiXSxcbiAgICAgICAgICAgIFtcInNwYW5cIiwgeyBjbGFzczogXCJhY2VfbW9iaWxlLWJ1dHRvblwiLCBhY3Rpb246IFwibW9yZVwiIH0sIFwiLi4uXCJdXG4gICAgICAgIF0sIGVkaXRvci5jb250YWluZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG93Q29udGV4dE1lbnUoKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmdldE9wdGlvbihcImVuYWJsZU1vYmlsZU1lbnVcIikpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0TWVudSkge1xuICAgICAgICAgICAgICAgIGhpZGVDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGV4dE1lbnUpXG4gICAgICAgICAgICBjcmVhdGVDb250ZXh0TWVudSgpO1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLnNlbGVjdGlvbi5jdXJzb3I7XG4gICAgICAgIHZhciBwYWdlUG9zID0gZWRpdG9yLnJlbmRlcmVyLnRleHRUb1NjcmVlbkNvb3JkaW5hdGVzKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB2YXIgbGVmdE9mZnNldCA9IGVkaXRvci5yZW5kZXJlci50ZXh0VG9TY3JlZW5Db29yZGluYXRlcygwLCAwKS5wYWdlWDtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHJlY3QgPSBlZGl0b3IuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb250ZXh0TWVudS5zdHlsZS50b3AgPSBwYWdlUG9zLnBhZ2VZIC0gcmVjdC50b3AgLSAzICsgXCJweFwiO1xuICAgICAgICBpZiAocGFnZVBvcy5wYWdlWCAtIHJlY3QubGVmdCA8IHJlY3Qud2lkdGggLSA3MCkge1xuICAgICAgICAgICAgY29udGV4dE1lbnUuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICAgICAgICBjb250ZXh0TWVudS5zdHlsZS5yaWdodCA9IFwiMTBweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dE1lbnUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgY29udGV4dE1lbnUuc3R5bGUubGVmdCA9IGxlZnRPZmZzZXQgKyBzY3JvbGxMZWZ0IC0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHRNZW51LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICBjb250ZXh0TWVudS5maXJzdENoaWxkLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZWRpdG9yLm9uKFwiaW5wdXRcIiwgaGlkZUNvbnRleHRNZW51KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGlkZUNvbnRleHRNZW51KGUpIHtcbiAgICAgICAgaWYgKGNvbnRleHRNZW51KVxuICAgICAgICAgICAgY29udGV4dE1lbnUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiaW5wdXRcIiwgaGlkZUNvbnRleHRNZW51KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTG9uZ1RhcCgpIHtcbiAgICAgICAgbG9uZ1RvdWNoVGltZXIgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQobG9uZ1RvdWNoVGltZXIpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgIHZhciBpblNlbGVjdGlvbiA9IHJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpIHx8ICFpblNlbGVjdGlvbikge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IFwid2FpdFwiO1xuICAgICAgICBzaG93Q29udGV4dE1lbnUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoVG9TZWxlY3Rpb25Nb2RlKCkge1xuICAgICAgICBsb25nVG91Y2hUaW1lciA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lcik7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgdmFyIHJhbmdlID0gY2xpY2tDb3VudCA+PSAyXG4gICAgICAgICAgICA/IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKHBvcy5yb3cpXG4gICAgICAgICAgICA6IGVkaXRvci5zZXNzaW9uLmdldEJyYWNrZXRSYW5nZShwb3MpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgIXJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlID0gXCJ3YWl0XCI7XG4gICAgfVxuICAgIGV2ZW50LmFkZExpc3RlbmVyKGVsLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghcHJlc3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRleHRhcmVhID0gZWRpdG9yLnRleHRJbnB1dC5nZXRFbGVtZW50KCk7XG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgfSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICBpZiAobG9uZ1RvdWNoVGltZXIgfHwgdG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobG9uZ1RvdWNoVGltZXIpO1xuICAgICAgICAgICAgbG9uZ1RvdWNoVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdG91Y2hTdGFydFQgPSAtMTtcbiAgICAgICAgICAgIG1vZGUgPSBcInpvb21cIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmVzc2VkID0gZWRpdG9yLiRtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICB2YXIgaCA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgdyA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgdCA9IGUudGltZVN0YW1wO1xuICAgICAgICBsYXN0VCA9IHQ7XG4gICAgICAgIHZhciB0b3VjaE9iaiA9IHRvdWNoZXNbMF07XG4gICAgICAgIHZhciB4ID0gdG91Y2hPYmouY2xpZW50WDtcbiAgICAgICAgdmFyIHkgPSB0b3VjaE9iai5jbGllbnRZO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnRYIC0geCkgKyBNYXRoLmFicyhzdGFydFkgLSB5KSA+IGgpXG4gICAgICAgICAgICB0b3VjaFN0YXJ0VCA9IC0xO1xuICAgICAgICBzdGFydFggPSBlLmNsaWVudFggPSB4O1xuICAgICAgICBzdGFydFkgPSBlLmNsaWVudFkgPSB5O1xuICAgICAgICB2WCA9IHZZID0gMDtcbiAgICAgICAgdmFyIGV2ID0gbmV3IE1vdXNlRXZlbnQoZSwgZWRpdG9yKTtcbiAgICAgICAgcG9zID0gZXYuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgICAgICBpZiAodCAtIHRvdWNoU3RhcnRUIDwgNTAwICYmIHRvdWNoZXMubGVuZ3RoID09IDEgJiYgIWFuaW1hdGlvblN0ZXBzKSB7XG4gICAgICAgICAgICBjbGlja0NvdW50Kys7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLmJ1dHRvbiA9IDA7XG4gICAgICAgICAgICBzd2l0Y2hUb1NlbGVjdGlvbk1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5zZWxlY3Rpb24uY3Vyc29yO1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpID8gY3Vyc29yIDogZWRpdG9yLnNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgICAgICB2YXIgY3Vyc29yUG9zID0gZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGN1cnNvciwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgYW5jaG9yUG9zID0gZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGFuY2hvciwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVkaXRvci5yZW5kZXJlci5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRUb3AgPSBlZGl0b3IucmVuZGVyZXIubGF5ZXJDb25maWcub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRlZERpc3RhbmNlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB4ID0geCAvIHc7XG4gICAgICAgICAgICAgICAgeSA9IHkgLyBoIC0gMC43NTtcbiAgICAgICAgICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZS5jbGllbnRYIDwgcmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IFwiem9vbVwiO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaWZmMSA9IHdlaWdodGVkRGlzdGFuY2UoZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY3Vyc29yUG9zLmxlZnQgKyBvZmZzZXRMZWZ0LCBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGN1cnNvclBvcy50b3AgKyBvZmZzZXRUb3ApO1xuICAgICAgICAgICAgdmFyIGRpZmYyID0gd2VpZ2h0ZWREaXN0YW5jZShlLmNsaWVudFggLSByZWN0LmxlZnQgLSBhbmNob3JQb3MubGVmdCArIG9mZnNldExlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gYW5jaG9yUG9zLnRvcCArIG9mZnNldFRvcCk7XG4gICAgICAgICAgICBpZiAoZGlmZjEgPCAzLjUgJiYgZGlmZjIgPCAzLjUpXG4gICAgICAgICAgICAgICAgbW9kZSA9IGRpZmYxID4gZGlmZjIgPyBcImN1cnNvclwiIDogXCJhbmNob3JcIjtcbiAgICAgICAgICAgIGlmIChkaWZmMiA8IDMuNSlcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJhbmNob3JcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpZmYxIDwgMy41KVxuICAgICAgICAgICAgICAgIG1vZGUgPSBcImN1cnNvclwiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1vZGUgPSBcInNjcm9sbFwiO1xuICAgICAgICAgICAgbG9uZ1RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZUxvbmdUYXAsIDQ1MCk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2hTdGFydFQgPSB0O1xuICAgIH0sIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJlc3NlZCA9IGVkaXRvci4kbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lcilcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoYW5pbWF0aW9uVGltZXIpO1xuICAgICAgICBpZiAobW9kZSA9PSBcInpvb21cIikge1xuICAgICAgICAgICAgbW9kZSA9IFwiXCI7XG4gICAgICAgICAgICBhbmltYXRpb25TdGVwcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG9uZ1RvdWNoVGltZXIpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgIGFuaW1hdGlvblN0ZXBzID0gMDtcbiAgICAgICAgICAgIHNob3dDb250ZXh0TWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJzY3JvbGxcIikge1xuICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgICAgaGlkZUNvbnRleHRNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaG93Q29udGV4dE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQobG9uZ1RvdWNoVGltZXIpO1xuICAgICAgICBsb25nVG91Y2hUaW1lciA9IG51bGw7XG4gICAgfSwgZWRpdG9yKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGxvbmdUb3VjaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobG9uZ1RvdWNoVGltZXIpO1xuICAgICAgICAgICAgbG9uZ1RvdWNoVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPiAxIHx8IG1vZGUgPT0gXCJ6b29tXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0b3VjaE9iaiA9IHRvdWNoZXNbMF07XG4gICAgICAgIHZhciB3aGVlbFggPSBzdGFydFggLSB0b3VjaE9iai5jbGllbnRYO1xuICAgICAgICB2YXIgd2hlZWxZID0gc3RhcnRZIC0gdG91Y2hPYmouY2xpZW50WTtcbiAgICAgICAgaWYgKG1vZGUgPT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIGlmICh3aGVlbFggKiB3aGVlbFggKyB3aGVlbFkgKiB3aGVlbFkgPiA0KVxuICAgICAgICAgICAgICAgIG1vZGUgPSBcImN1cnNvclwiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRYID0gdG91Y2hPYmouY2xpZW50WDtcbiAgICAgICAgc3RhcnRZID0gdG91Y2hPYmouY2xpZW50WTtcbiAgICAgICAgZS5jbGllbnRYID0gdG91Y2hPYmouY2xpZW50WDtcbiAgICAgICAgZS5jbGllbnRZID0gdG91Y2hPYmouY2xpZW50WTtcbiAgICAgICAgdmFyIHQgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgdmFyIGR0ID0gdCAtIGxhc3RUO1xuICAgICAgICBsYXN0VCA9IHQ7XG4gICAgICAgIGlmIChtb2RlID09IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQuc3BlZWQgPSAxO1xuICAgICAgICAgICAgbW91c2VFdmVudC53aGVlbFggPSB3aGVlbFg7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LndoZWVsWSA9IHdoZWVsWTtcbiAgICAgICAgICAgIGlmICgxMCAqIE1hdGguYWJzKHdoZWVsWCkgPCBNYXRoLmFicyh3aGVlbFkpKVxuICAgICAgICAgICAgICAgIHdoZWVsWCA9IDA7XG4gICAgICAgICAgICBpZiAoMTAgKiBNYXRoLmFicyh3aGVlbFkpIDwgTWF0aC5hYnMod2hlZWxYKSlcbiAgICAgICAgICAgICAgICB3aGVlbFkgPSAwO1xuICAgICAgICAgICAgaWYgKGR0ICE9IDApIHtcbiAgICAgICAgICAgICAgICB2WCA9IHdoZWVsWCAvIGR0O1xuICAgICAgICAgICAgICAgIHZZID0gd2hlZWxZIC8gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3IuX2VtaXQoXCJtb3VzZXdoZWVsXCIsIG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFtb3VzZUV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHZYID0gdlkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ID0gbmV3IE1vdXNlRXZlbnQoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAobW9kZSA9PSBcImN1cnNvclwiKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZUN1cnNvclRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJhbmNob3JcIilcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFNlbGVjdGlvbkFuY2hvcihwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhwb3MpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSwgZWRpdG9yKTtcbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICBhbmltYXRpb25TdGVwcyArPSA2MDtcbiAgICAgICAgYW5pbWF0aW9uVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uU3RlcHMtLSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhbmltYXRpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZYKSA8IDAuMDEpXG4gICAgICAgICAgICAgICAgdlggPSAwO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZZKSA8IDAuMDEpXG4gICAgICAgICAgICAgICAgdlkgPSAwO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblN0ZXBzIDwgMjApXG4gICAgICAgICAgICAgICAgdlggPSAwLjkgKiB2WDtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25TdGVwcyA8IDIwKVxuICAgICAgICAgICAgICAgIHZZID0gMC45ICogdlk7XG4gICAgICAgICAgICB2YXIgb2xkU2Nyb2xsVG9wID0gZWRpdG9yLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQnkoMTAgKiB2WCwgMTAgKiB2WSk7XG4gICAgICAgICAgICBpZiAob2xkU2Nyb2xsVG9wID09IGVkaXRvci5zZXNzaW9uLmdldFNjcm9sbFRvcCgpKVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblN0ZXBzID0gMDtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vdXNlL21vdXNlX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbW91c2UvZGVmYXVsdF9oYW5kbGVyc1wiLFwiYWNlL21vdXNlL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIixcImFjZS9tb3VzZS9tb3VzZV9ldmVudFwiLFwiYWNlL21vdXNlL2RyYWdkcm9wX2hhbmRsZXJcIixcImFjZS9tb3VzZS90b3VjaF9oYW5kbGVyXCIsXCJhY2UvY29uZmlnXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBEZWZhdWx0SGFuZGxlcnMgPSByZXF1aXJlKFwiLi9kZWZhdWx0X2hhbmRsZXJzXCIpLkRlZmF1bHRIYW5kbGVycztcbnZhciBEZWZhdWx0R3V0dGVySGFuZGxlciA9IHJlcXVpcmUoXCIuL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIikuR3V0dGVySGFuZGxlcjtcbnZhciBNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vbW91c2VfZXZlbnRcIikuTW91c2VFdmVudDtcbnZhciBEcmFnZHJvcEhhbmRsZXIgPSByZXF1aXJlKFwiLi9kcmFnZHJvcF9oYW5kbGVyXCIpLkRyYWdkcm9wSGFuZGxlcjtcbnZhciBhZGRUb3VjaExpc3RlbmVycyA9IHJlcXVpcmUoXCIuL3RvdWNoX2hhbmRsZXJcIikuYWRkVG91Y2hMaXN0ZW5lcnM7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBNb3VzZUhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW91c2VIYW5kbGVyKGVkaXRvcikgeyB0aGlzLiRkcmFnRGVsYXk7IHRoaXMuJGRyYWdFbmFibGVkOyB0aGlzLiRtb3VzZU1vdmVkOyB0aGlzLm1vdXNlRXZlbnQ7IHRoaXMuJGZvY3VzVGltZW91dDtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIG5ldyBEZWZhdWx0SGFuZGxlcnModGhpcyk7XG4gICAgICAgIG5ldyBEZWZhdWx0R3V0dGVySGFuZGxlcih0aGlzKTtcbiAgICAgICAgbmV3IERyYWdkcm9wSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdmFyIGZvY3VzRWRpdG9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB3aW5kb3dCbHVycmVkID0gIWRvY3VtZW50Lmhhc0ZvY3VzIHx8ICFkb2N1bWVudC5oYXNGb2N1cygpXG4gICAgICAgICAgICAgICAgfHwgIWVkaXRvci5pc0ZvY3VzZWQoKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IChlZGl0b3IudGV4dElucHV0ICYmIGVkaXRvci50ZXh0SW5wdXQuZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3dCbHVycmVkKVxuICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvci5pc0ZvY3VzZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1vdXNlVGFyZ2V0ID0gZWRpdG9yLnJlbmRlcmVyLmdldE1vdXNlRXZlbnRUYXJnZXQoKTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiY2xpY2tcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImNsaWNrXCIpLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMsIFwibW91c2Vtb3ZlXCIpLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRNdWx0aU1vdXNlRG93bkxpc3RlbmVyKFtcbiAgICAgICAgICAgIG1vdXNlVGFyZ2V0LFxuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhclYgJiYgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhclYuaW5uZXIsXG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFySCAmJiBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFySC5pbm5lcixcbiAgICAgICAgICAgIGVkaXRvci50ZXh0SW5wdXQgJiYgZWRpdG9yLnRleHRJbnB1dC5nZXRFbGVtZW50KClcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksIFs0MDAsIDMwMCwgMjUwXSwgdGhpcywgXCJvbk1vdXNlRXZlbnRcIiwgZWRpdG9yKTtcbiAgICAgICAgZXZlbnQuYWRkTW91c2VXaGVlbExpc3RlbmVyKGVkaXRvci5jb250YWluZXIsIHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcywgXCJtb3VzZXdoZWVsXCIpLCBlZGl0b3IpO1xuICAgICAgICBhZGRUb3VjaExpc3RlbmVycyhlZGl0b3IuY29udGFpbmVyLCBlZGl0b3IpO1xuICAgICAgICB2YXIgZ3V0dGVyRWwgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlcjtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZ3V0dGVyRWwsIFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZUV2ZW50LmJpbmQodGhpcywgXCJndXR0ZXJtb3VzZWRvd25cIiksIGVkaXRvcik7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcImNsaWNrXCIsIHRoaXMub25Nb3VzZUV2ZW50LmJpbmQodGhpcywgXCJndXR0ZXJjbGlja1wiKSwgZWRpdG9yKTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZ3V0dGVyRWwsIFwiZGJsY2xpY2tcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcmRibGNsaWNrXCIpLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcm1vdXNlbW92ZVwiKSwgZWRpdG9yKTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwibW91c2Vkb3duXCIsIGZvY3VzRWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJtb3VzZWRvd25cIiwgZm9jdXNFZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSAmJiBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyVikge1xuICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhclYuZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZm9jdXNFZGl0b3IsIGVkaXRvcik7XG4gICAgICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFySC5lbGVtZW50LCBcIm1vdXNlZG93blwiLCBmb2N1c0VkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfc2VsZi5zdGF0ZSB8fCBfc2VsZi4kZHJhZ0RlbGF5IHx8ICFfc2VsZi4kZHJhZ0VuYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IGVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyhlLngsIGUueSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciByZW5kZXJlciA9IGVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpICYmIHJhbmdlLmluc2lkZVN0YXJ0KGNoYXJhY3Rlci5yb3csIGNoYXJhY3Rlci5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0Q3Vyc29yU3R5bGUoXCJkZWZhdWx0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0Q3Vyc29yU3R5bGUoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIC8vQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBzZWVtcyBtaXN0eXBpbmcgLSBzaG91bGQgYmUgYm9vbGVhblxuICAgICAgICBlZGl0b3IpO1xuICAgIH1cbiAgICBNb3VzZUhhbmRsZXIucHJvdG90eXBlLm9uTW91c2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBlKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3Iuc2Vzc2lvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQobmFtZSwgbmV3IE1vdXNlRXZlbnQoZSwgdGhpcy5lZGl0b3IpKTtcbiAgICB9O1xuICAgIE1vdXNlSGFuZGxlci5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAobmFtZSwgZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkgJiYgdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkubW91c2Vtb3ZlO1xuICAgICAgICBpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQobmFtZSwgbmV3IE1vdXNlRXZlbnQoZSwgdGhpcy5lZGl0b3IpKTtcbiAgICB9O1xuICAgIE1vdXNlSGFuZGxlci5wcm90b3R5cGUub25Nb3VzZVdoZWVsID0gZnVuY3Rpb24gKG5hbWUsIGUpIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcik7XG4gICAgICAgIG1vdXNlRXZlbnQuc3BlZWQgPSB0aGlzLiRzY3JvbGxTcGVlZCAqIDI7XG4gICAgICAgIG1vdXNlRXZlbnQud2hlZWxYID0gZS53aGVlbFg7XG4gICAgICAgIG1vdXNlRXZlbnQud2hlZWxZID0gZS53aGVlbFk7XG4gICAgICAgIHRoaXMuZWRpdG9yLl9lbWl0KG5hbWUsIG1vdXNlRXZlbnQpO1xuICAgIH07XG4gICAgTW91c2VIYW5kbGVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfTtcbiAgICBNb3VzZUhhbmRsZXIucHJvdG90eXBlLmNhcHR1cmVNb3VzZSA9IGZ1bmN0aW9uIChldiwgbW91c2VNb3ZlSGFuZGxlcikge1xuICAgICAgICB0aGlzLnggPSBldi54O1xuICAgICAgICB0aGlzLnkgPSBldi55O1xuICAgICAgICB0aGlzLmlzTW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgcmVuZGVyZXIuJGlzTW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNXZWJLaXQgJiYgIWUud2hpY2ggJiYgc2VsZi5yZWxlYXNlTW91c2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVsZWFzZU1vdXNlKCk7XG4gICAgICAgICAgICBzZWxmLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBzZWxmLnkgPSBlLmNsaWVudFk7XG4gICAgICAgICAgICBtb3VzZU1vdmVIYW5kbGVyICYmIG1vdXNlTW92ZUhhbmRsZXIoZSk7XG4gICAgICAgICAgICBzZWxmLm1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudChlLCBzZWxmLmVkaXRvcik7XG4gICAgICAgICAgICBzZWxmLiRtb3VzZU1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2FwdHVyZUVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlZGl0b3Iub2ZmKFwiYmVmb3JlRW5kT3BlcmF0aW9uXCIsIG9uT3BlcmF0aW9uRW5kKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgb25DYXB0dXJlSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIHNlbGZbc2VsZi5zdGF0ZSArIFwiRW5kXCJdICYmIHNlbGZbc2VsZi5zdGF0ZSArIFwiRW5kXCJdKGUpO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLmlzTW91c2VQcmVzc2VkID0gcmVuZGVyZXIuJGlzTW91c2VQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yKVxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgICAgICAgICAgc2VsZi4kb25DYXB0dXJlTW91c2VNb3ZlID0gc2VsZi5yZWxlYXNlTW91c2UgPSBudWxsO1xuICAgICAgICAgICAgZSAmJiBzZWxmLm9uTW91c2VFdmVudChcIm1vdXNldXBcIiwgZSk7XG4gICAgICAgICAgICBlZGl0b3IuZW5kT3BlcmF0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNhcHR1cmVJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGZbc2VsZi5zdGF0ZV0gJiYgc2VsZltzZWxmLnN0YXRlXSgpO1xuICAgICAgICAgICAgc2VsZi4kbW91c2VNb3ZlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzT2xkSUUgJiYgZXYuZG9tRXZlbnQudHlwZSA9PSBcImRibGNsaWNrXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgb25DYXB0dXJlRW5kKGV2KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uT3BlcmF0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5yZWxlYXNlTW91c2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5jdXJPcC5jb21tYW5kLm5hbWUgJiYgZWRpdG9yLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmW3NlbGYuc3RhdGUgKyBcIkVuZFwiXSAmJiBzZWxmW3NlbGYuc3RhdGUgKyBcIkVuZFwiXSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNlbGYucmVsZWFzZU1vdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVkaXRvci5vbihcImJlZm9yZUVuZE9wZXJhdGlvblwiLCBvbk9wZXJhdGlvbkVuZCk7XG4gICAgICAgIGVkaXRvci5zdGFydE9wZXJhdGlvbih7IGNvbW1hbmQ6IHsgbmFtZTogXCJtb3VzZVwiIH0gfSk7XG4gICAgICAgIHNlbGYuJG9uQ2FwdHVyZU1vdXNlTW92ZSA9IG9uTW91c2VNb3ZlO1xuICAgICAgICBzZWxmLnJlbGVhc2VNb3VzZSA9IGV2ZW50LmNhcHR1cmUodGhpcy5lZGl0b3IuY29udGFpbmVyLCBvbk1vdXNlTW92ZSwgb25DYXB0dXJlRW5kKTtcbiAgICAgICAgdmFyIHRpbWVySWQgPSBzZXRJbnRlcnZhbChvbkNhcHR1cmVJbnRlcnZhbCwgMjApO1xuICAgIH07XG4gICAgTW91c2VIYW5kbGVyLnByb3RvdHlwZS5jYW5jZWxDb250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5kb21FdmVudCAmJiBlLmRvbUV2ZW50LnR5cGUgIT0gXCJjb250ZXh0bWVudVwiKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZihcIm5hdGl2ZWNvbnRleHRtZW51XCIsIHN0b3ApO1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5kb21FdmVudClcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wRXZlbnQoZS5kb21FdmVudCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgc2V0VGltZW91dChzdG9wLCAxMCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwibmF0aXZlY29udGV4dG1lbnVcIiwgc3RvcCk7XG4gICAgfTtcbiAgICBNb3VzZUhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VNb3VzZSlcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZU1vdXNlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTW91c2VIYW5kbGVyO1xufSgpKTtcbk1vdXNlSGFuZGxlci5wcm90b3R5cGUucmVsZWFzZU1vdXNlID0gbnVsbDtcbmNvbmZpZy5kZWZpbmVPcHRpb25zKE1vdXNlSGFuZGxlci5wcm90b3R5cGUsIFwibW91c2VIYW5kbGVyXCIsIHtcbiAgICBzY3JvbGxTcGVlZDogeyBpbml0aWFsVmFsdWU6IDIgfSxcbiAgICBkcmFnRGVsYXk6IHsgaW5pdGlhbFZhbHVlOiAodXNlcmFnZW50LmlzTWFjID8gMTUwIDogMCkgfSxcbiAgICBkcmFnRW5hYmxlZDogeyBpbml0aWFsVmFsdWU6IHRydWUgfSxcbiAgICBmb2N1c1RpbWVvdXQ6IHsgaW5pdGlhbFZhbHVlOiAwIH0sXG4gICAgdG9vbHRpcEZvbGxvd3NNb3VzZTogeyBpbml0aWFsVmFsdWU6IHRydWUgfVxufSk7XG5leHBvcnRzLk1vdXNlSGFuZGxlciA9IE1vdXNlSGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvZm9sZF9oYW5kbGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBGb2xkSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb2xkSGFuZGxlcihlZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgICAgIHZhciBmb2xkID0gc2Vzc2lvbi5nZXRGb2xkQXQocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4sIDEpO1xuICAgICAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5nZXRBY2NlbEtleSgpKVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmV4cGFuZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS5kb21FdmVudCAmJiBlLmRvbUV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgZG9tLmhhc0Nzc0NsYXNzKHRhcmdldCwgXCJhY2VfaW5saW5lX2J1dHRvblwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20uaGFzQ3NzQ2xhc3ModGFyZ2V0LCBcImFjZV90b2dnbGVfd3JhcFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldE9wdGlvbihcIndyYXBcIiwgIXNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbihcImd1dHRlcmNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyUmVnaW9uID0gZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllci5nZXRSZWdpb24oZSk7XG4gICAgICAgICAgICBpZiAoZ3V0dGVyUmVnaW9uID09IFwiZm9sZFdpZGdldHNcIikge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBlLmdldERvY3VtZW50UG9zaXRpb24oKS5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5mb2xkV2lkZ2V0cyAmJiBzZXNzaW9uLmZvbGRXaWRnZXRzW3Jvd10pXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLm9uRm9sZFdpZGdldENsaWNrKHJvdywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNGb2N1c2VkKCkpXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKFwiZ3V0dGVyZGJsY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBndXR0ZXJSZWdpb24gPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLmdldFJlZ2lvbihlKTtcbiAgICAgICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcbiAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2Vzc2lvbi5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZGF0YS5yYW5nZSB8fCBkYXRhLmZpcnN0UmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldEZvbGRBdChyb3csIHNlc3Npb24uZ2V0TGluZShyb3cpLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmFkZEZvbGQoXCIuLi5cIiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KHsgcm93OiByYW5nZS5zdGFydC5yb3csIGNvbHVtbjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBGb2xkSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkZvbGRIYW5kbGVyID0gRm9sZEhhbmRsZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2tleWJvYXJkL2tleWJpbmRpbmdcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIva2V5c1wiLFwiYWNlL2xpYi9ldmVudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBrZXlVdGlsID0gcmVxdWlyZShcIi4uL2xpYi9rZXlzXCIpO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciBLZXlCaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleUJpbmRpbmcoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuJGVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy4kZGF0YSA9IHsgZWRpdG9yOiBlZGl0b3IgfTtcbiAgICAgICAgdGhpcy4kaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0SGFuZGxlcihlZGl0b3IuY29tbWFuZHMpO1xuICAgIH1cbiAgICBLZXlCaW5kaW5nLnByb3RvdHlwZS5zZXREZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uIChrYikge1xuICAgICAgICB0aGlzLnJlbW92ZUtleWJvYXJkSGFuZGxlcih0aGlzLiRkZWZhdWx0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuJGRlZmF1bHRIYW5kbGVyID0ga2I7XG4gICAgICAgIHRoaXMuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiLCAwKTtcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLnNldEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uIChrYikge1xuICAgICAgICB2YXIgaCA9IHRoaXMuJGhhbmRsZXJzO1xuICAgICAgICBpZiAoaFtoLmxlbmd0aCAtIDFdID09IGtiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoaFtoLmxlbmd0aCAtIDFdICYmIGhbaC5sZW5ndGggLSAxXSAhPSB0aGlzLiRkZWZhdWx0SGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGhbaC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHRoaXMuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiLCAxKTtcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLmFkZEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uIChrYiwgcG9zKSB7XG4gICAgICAgIGlmICgha2IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Yga2IgPT0gXCJmdW5jdGlvblwiICYmICFrYi5oYW5kbGVLZXlib2FyZClcbiAgICAgICAgICAgIGtiLmhhbmRsZUtleWJvYXJkID0ga2I7XG4gICAgICAgIHZhciBpID0gdGhpcy4kaGFuZGxlcnMuaW5kZXhPZihrYik7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgdGhpcy4kaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpZiAocG9zID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuJGhhbmRsZXJzLnB1c2goa2IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UocG9zLCAwLCBrYik7XG4gICAgICAgIGlmIChpID09IC0xICYmIGtiLmF0dGFjaClcbiAgICAgICAgICAgIGtiLmF0dGFjaCh0aGlzLiRlZGl0b3IpO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24gKGtiKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy4kaGFuZGxlcnMuaW5kZXhPZihrYik7XG4gICAgICAgIGlmIChpID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGtiLmRldGFjaCAmJiBrYi5kZXRhY2godGhpcy4kZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBLZXlCaW5kaW5nLnByb3RvdHlwZS5nZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoYW5kbGVyc1t0aGlzLiRoYW5kbGVycy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLmdldFN0YXR1c1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy4kZGF0YTtcbiAgICAgICAgdmFyIGVkaXRvciA9IGRhdGEuZWRpdG9yO1xuICAgICAgICByZXR1cm4gdGhpcy4kaGFuZGxlcnMubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICByZXR1cm4gaC5nZXRTdGF0dXNUZXh0ICYmIGguZ2V0U3RhdHVzVGV4dChlZGl0b3IsIGRhdGEpIHx8IFwiXCI7XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLiRjYWxsS2V5Ym9hcmRIYW5kbGVycyA9IGZ1bmN0aW9uIChoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZSkge1xuICAgICAgICB2YXIgdG9FeGVjdXRlO1xuICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgY29tbWFuZHMgPSB0aGlzLiRlZGl0b3IuY29tbWFuZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLiRoYW5kbGVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHRvRXhlY3V0ZSA9IHRoaXMuJGhhbmRsZXJzW2ldLmhhbmRsZUtleWJvYXJkKFxuICAgICAgICAgICAgdGhpcy4kZGF0YSwgaGFzaElkLCBrZXlTdHJpbmcsIGtleUNvZGUsIGUpO1xuICAgICAgICAgICAgaWYgKCF0b0V4ZWN1dGUgfHwgIXRvRXhlY3V0ZS5jb21tYW5kKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRvRXhlY3V0ZS5jb21tYW5kID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gY29tbWFuZHMuZXhlYyh0b0V4ZWN1dGUuY29tbWFuZCwgdGhpcy4kZWRpdG9yLCB0b0V4ZWN1dGUuYXJncywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VjY2VzcyAmJiBlICYmIGhhc2hJZCAhPSAtMSAmJlxuICAgICAgICAgICAgICAgIHRvRXhlY3V0ZVtcInBhc3NFdmVudFwiXSAhPSB0cnVlICYmIHRvRXhlY3V0ZS5jb21tYW5kW1wicGFzc0V2ZW50XCJdICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1Y2Nlc3MgJiYgaGFzaElkID09IC0xKSB7XG4gICAgICAgICAgICB0b0V4ZWN1dGUgPSB7IGNvbW1hbmQ6IFwiaW5zZXJ0c3RyaW5nXCIgfTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBjb21tYW5kcy5leGVjKFwiaW5zZXJ0c3RyaW5nXCIsIHRoaXMuJGVkaXRvciwga2V5U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2VzcyAmJiB0aGlzLiRlZGl0b3IuX3NpZ25hbClcbiAgICAgICAgICAgIHRoaXMuJGVkaXRvci5fc2lnbmFsKFwia2V5Ym9hcmRBY3Rpdml0eVwiLCB0b0V4ZWN1dGUpO1xuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuICAgIEtleUJpbmRpbmcucHJvdG90eXBlLm9uQ29tbWFuZEtleSA9IGZ1bmN0aW9uIChlLCBoYXNoSWQsIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIGtleVN0cmluZyA9IGtleVV0aWwua2V5Q29kZVRvU3RyaW5nKGtleUNvZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy4kY2FsbEtleWJvYXJkSGFuZGxlcnMoaGFzaElkLCBrZXlTdHJpbmcsIGtleUNvZGUsIGUpO1xuICAgIH07XG4gICAgS2V5QmluZGluZy5wcm90b3R5cGUub25UZXh0SW5wdXQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2FsbEtleWJvYXJkSGFuZGxlcnMoLTEsIHRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleUJpbmRpbmc7XG59KCkpO1xuZXhwb3J0cy5LZXlCaW5kaW5nID0gS2V5QmluZGluZztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2JpZGl1dGlsXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIEFyYWJpY0FsZWZCZXRJbnRlcnZhbHNCZWdpbmUgPSBbJ1xcdTA2MjEnLCAnXFx1MDY0MSddO1xudmFyIEFyYWJpY0FsZWZCZXRJbnRlcnZhbHNFbmQgPSBbJ1xcdTA2M0EnLCAnXFx1MDY0YSddO1xudmFyIGRpciA9IDAsIGhpTGV2ZWwgPSAwO1xudmFyIGxhc3RBcmFiaWMgPSBmYWxzZSwgaGFzVUJBVF9BTCA9IGZhbHNlLCBoYXNVQkFUX0IgPSBmYWxzZSwgaGFzVUJBVF9TID0gZmFsc2UsIGhhc0Jsb2NrU2VwID0gZmFsc2UsIGhhc1NlZ1NlcCA9IGZhbHNlO1xudmFyIGltcFRhYl9MVFIgPSBbIFswLCAzLCAwLCAxLCAwLCAwLCAwXSwgWzAsIDMsIDAsIDEsIDIsIDIsIDBdLCBbMCwgMywgMCwgMHgxMSwgMiwgMCwgMV0sIFswLCAzLCA1LCA1LCA0LCAxLCAwXSwgWzAsIDMsIDB4MTUsIDB4MTUsIDQsIDAsIDFdLCBbMCwgMywgNSwgNSwgNCwgMiwgMF1cbl07XG52YXIgaW1wVGFiX1JUTCA9IFsgWzIsIDAsIDEsIDEsIDAsIDEsIDBdLCBbMiwgMCwgMSwgMSwgMCwgMiwgMF0sIFsyLCAwLCAyLCAxLCAzLCAyLCAwXSwgWzIsIDAsIDIsIDB4MjEsIDMsIDEsIDFdXG5dO1xudmFyIExUUiA9IDAsIFJUTCA9IDE7XG52YXIgTCA9IDA7XG52YXIgUiA9IDE7XG52YXIgRU4gPSAyO1xudmFyIEFOID0gMztcbnZhciBPTiA9IDQ7XG52YXIgQiA9IDU7XG52YXIgUyA9IDY7XG52YXIgQUwgPSA3O1xudmFyIFdTID0gODtcbnZhciBDUyA9IDk7XG52YXIgRVMgPSAxMDtcbnZhciBFVCA9IDExO1xudmFyIE5TTSA9IDEyO1xudmFyIExSRSA9IDEzO1xudmFyIFJMRSA9IDE0O1xudmFyIFBERiA9IDE1O1xudmFyIExSTyA9IDE2O1xudmFyIFJMTyA9IDE3O1xudmFyIEJOID0gMTg7XG52YXIgVW5pY29kZVRCTDAwID0gW1xuICAgIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIFMsIEIsIFMsIFdTLCBCLCBCTiwgQk4sXG4gICAgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQiwgQiwgQiwgUyxcbiAgICBXUywgT04sIE9OLCBFVCwgRVQsIEVULCBPTiwgT04sIE9OLCBPTiwgT04sIEVTLCBDUywgRVMsIENTLCBDUyxcbiAgICBFTiwgRU4sIEVOLCBFTiwgRU4sIEVOLCBFTiwgRU4sIEVOLCBFTiwgQ1MsIE9OLCBPTiwgT04sIE9OLCBPTixcbiAgICBPTiwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCxcbiAgICBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBMLCBPTiwgT04sIE9OLCBPTiwgT04sXG4gICAgT04sIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsIEwsXG4gICAgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgTCwgT04sIE9OLCBPTiwgT04sIEJOLFxuICAgIEJOLCBCTiwgQk4sIEJOLCBCTiwgQiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sXG4gICAgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sIEJOLCBCTiwgQk4sXG4gICAgQ1MsIE9OLCBFVCwgRVQsIEVULCBFVCwgT04sIE9OLCBPTiwgT04sIEwsIE9OLCBPTiwgQk4sIE9OLCBPTixcbiAgICBFVCwgRVQsIEVOLCBFTiwgT04sIEwsIE9OLCBPTiwgT04sIEVOLCBMLCBPTiwgT04sIE9OLCBPTiwgT05cbl07XG52YXIgVW5pY29kZVRCTDIwID0gW1xuICAgIFdTLCBXUywgV1MsIFdTLCBXUywgV1MsIFdTLCBXUywgV1MsIFdTLCBXUywgQk4sIEJOLCBCTiwgTCwgUixcbiAgICBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTixcbiAgICBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIFdTLCBCLCBMUkUsIFJMRSwgUERGLCBMUk8sIFJMTywgQ1MsXG4gICAgRVQsIEVULCBFVCwgRVQsIEVULCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sXG4gICAgT04sIE9OLCBPTiwgT04sIENTLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sXG4gICAgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgT04sIE9OLCBPTiwgV1Ncbl07XG5mdW5jdGlvbiBfY29tcHV0ZUxldmVscyhjaGFycywgbGV2ZWxzLCBsZW4sIGNoYXJUeXBlcykge1xuICAgIHZhciBpbXBUYWIgPSBkaXIgPyBpbXBUYWJfUlRMIDogaW1wVGFiX0xUUiwgcHJldlN0YXRlID0gbnVsbCwgbmV3Q2xhc3MgPSBudWxsLCBuZXdMZXZlbCA9IG51bGwsIG5ld1N0YXRlID0gMCwgYWN0aW9uID0gbnVsbCwgY29uZCA9IG51bGwsIGNvbmRQb3MgPSAtMSwgaSA9IG51bGwsIGl4ID0gbnVsbCwgY2xhc3NlcyA9IFtdO1xuICAgIGlmICghY2hhclR5cGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGNoYXJUeXBlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoYXJUeXBlc1tpXSA9IF9nZXRDaGFyYWN0ZXJUeXBlKGNoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaUxldmVsID0gZGlyO1xuICAgIGxhc3RBcmFiaWMgPSBmYWxzZTtcbiAgICBoYXNVQkFUX0FMID0gZmFsc2U7XG4gICAgaGFzVUJBVF9CID0gZmFsc2U7XG4gICAgaGFzVUJBVF9TID0gZmFsc2U7XG4gICAgZm9yIChpeCA9IDA7IGl4IDwgbGVuOyBpeCsrKSB7XG4gICAgICAgIHByZXZTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjbGFzc2VzW2l4XSA9IG5ld0NsYXNzID0gX2dldENoYXJDbGFzcyhjaGFycywgY2hhclR5cGVzLCBjbGFzc2VzLCBpeCk7XG4gICAgICAgIG5ld1N0YXRlID0gaW1wVGFiW3ByZXZTdGF0ZV1bbmV3Q2xhc3NdO1xuICAgICAgICBhY3Rpb24gPSBuZXdTdGF0ZSAmIDB4RjA7XG4gICAgICAgIG5ld1N0YXRlICY9IDB4MEY7XG4gICAgICAgIGxldmVsc1tpeF0gPSBuZXdMZXZlbCA9IGltcFRhYltuZXdTdGF0ZV1bNV07XG4gICAgICAgIGlmIChhY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDB4MTApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBjb25kUG9zOyBpIDwgaXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbaV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25kUG9zID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25kUG9zID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZCA9IGltcFRhYltuZXdTdGF0ZV1bNl07XG4gICAgICAgIGlmIChjb25kKSB7XG4gICAgICAgICAgICBpZiAoY29uZFBvcyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbmRQb3MgPSBpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb25kUG9zID4gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBjb25kUG9zOyBpIDwgaXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbHNbaV0gPSBuZXdMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZFBvcyA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZXNbaXhdID09IEIpIHtcbiAgICAgICAgICAgIGxldmVsc1tpeF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGhpTGV2ZWwgfD0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIGlmIChoYXNVQkFUX1MpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2ldID09IFMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbHNbaV0gPSBkaXI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2pdID09IFdTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHNbal0gPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9pbnZlcnRMZXZlbChsZXYsIGxldmVscywgX2FycmF5KSB7XG4gICAgaWYgKGhpTGV2ZWwgPCBsZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGV2ID09IDEgJiYgZGlyID09IFJUTCAmJiAhaGFzVUJBVF9CKSB7XG4gICAgICAgIF9hcnJheS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlbiA9IF9hcnJheS5sZW5ndGgsIHN0YXJ0ID0gMCwgZW5kLCBsbywgaGksIHRtcDtcbiAgICB3aGlsZSAoc3RhcnQgPCBsZW4pIHtcbiAgICAgICAgaWYgKGxldmVsc1tzdGFydF0gPj0gbGV2KSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuICYmIGxldmVsc1tlbmRdID49IGxldikge1xuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsbyA9IHN0YXJ0LCBoaSA9IGVuZCAtIDE7IGxvIDwgaGk7IGxvKyssIGhpLS0pIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBfYXJyYXlbbG9dO1xuICAgICAgICAgICAgICAgIF9hcnJheVtsb10gPSBfYXJyYXlbaGldO1xuICAgICAgICAgICAgICAgIF9hcnJheVtoaV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRDaGFyQ2xhc3MoY2hhcnMsIHR5cGVzLCBjbGFzc2VzLCBpeCkge1xuICAgIHZhciBjVHlwZSA9IHR5cGVzW2l4XSwgd1R5cGUsIG5UeXBlLCBsZW4sIGk7XG4gICAgc3dpdGNoIChjVHlwZSkge1xuICAgICAgICBjYXNlIEw6XG4gICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgIGxhc3RBcmFiaWMgPSBmYWxzZTtcbiAgICAgICAgY2FzZSBPTjpcbiAgICAgICAgY2FzZSBBTjpcbiAgICAgICAgICAgIHJldHVybiBjVHlwZTtcbiAgICAgICAgY2FzZSBFTjpcbiAgICAgICAgICAgIHJldHVybiBsYXN0QXJhYmljID8gQU4gOiBFTjtcbiAgICAgICAgY2FzZSBBTDpcbiAgICAgICAgICAgIGxhc3RBcmFiaWMgPSB0cnVlO1xuICAgICAgICAgICAgaGFzVUJBVF9BTCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gUjtcbiAgICAgICAgY2FzZSBXUzpcbiAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgY2FzZSBDUzpcbiAgICAgICAgICAgIGlmIChpeCA8IDEgfHwgKGl4ICsgMSkgPj0gdHlwZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgKCh3VHlwZSA9IGNsYXNzZXNbaXggLSAxXSkgIT0gRU4gJiYgd1R5cGUgIT0gQU4pIHx8XG4gICAgICAgICAgICAgICAgKChuVHlwZSA9IHR5cGVzW2l4ICsgMV0pICE9IEVOICYmIG5UeXBlICE9IEFOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0QXJhYmljKSB7XG4gICAgICAgICAgICAgICAgblR5cGUgPSBBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuVHlwZSA9PSB3VHlwZSA/IG5UeXBlIDogT047XG4gICAgICAgIGNhc2UgRVM6XG4gICAgICAgICAgICB3VHlwZSA9IGl4ID4gMCA/IGNsYXNzZXNbaXggLSAxXSA6IEI7XG4gICAgICAgICAgICBpZiAod1R5cGUgPT0gRU4gJiYgKGl4ICsgMSkgPCB0eXBlcy5sZW5ndGggJiYgdHlwZXNbaXggKyAxXSA9PSBFTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgY2FzZSBFVDpcbiAgICAgICAgICAgIGlmIChpeCA+IDAgJiYgY2xhc3Nlc1tpeCAtIDFdID09IEVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RBcmFiaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT047XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gaXggKyAxO1xuICAgICAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgdHlwZXNbaV0gPT0gRVQpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAmJiB0eXBlc1tpXSA9PSBFTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgY2FzZSBOU006XG4gICAgICAgICAgICBsZW4gPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICBpID0gaXggKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgdHlwZXNbaV0gPT0gTlNNKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNoYXJzW2l4XSwgcnRsQ2FuZGlkYXRlID0gKGMgPj0gMHgwNTkxICYmIGMgPD0gMHgwOEZGKSB8fCBjID09IDB4RkIxRTtcbiAgICAgICAgICAgICAgICB3VHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydGxDYW5kaWRhdGUgJiYgKHdUeXBlID09IFIgfHwgd1R5cGUgPT0gQUwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpeCA8IDEgfHwgKHdUeXBlID0gdHlwZXNbaXggLSAxXSkgPT0gQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzW2l4IC0gMV07XG4gICAgICAgIGNhc2UgQjpcbiAgICAgICAgICAgIGxhc3RBcmFiaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGhhc1VCQVRfQiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICBjYXNlIFM6XG4gICAgICAgICAgICBoYXNVQkFUX1MgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIE9OO1xuICAgICAgICBjYXNlIExSRTpcbiAgICAgICAgY2FzZSBSTEU6XG4gICAgICAgIGNhc2UgTFJPOlxuICAgICAgICBjYXNlIFJMTzpcbiAgICAgICAgY2FzZSBQREY6XG4gICAgICAgICAgICBsYXN0QXJhYmljID0gZmFsc2U7XG4gICAgICAgIGNhc2UgQk46XG4gICAgICAgICAgICByZXR1cm4gT047XG4gICAgfVxufVxuZnVuY3Rpb24gX2dldENoYXJhY3RlclR5cGUoY2gpIHtcbiAgICB2YXIgdWMgPSBjaC5jaGFyQ29kZUF0KDApLCBoaSA9IHVjID4+IDg7XG4gICAgaWYgKGhpID09IDApIHtcbiAgICAgICAgcmV0dXJuICgodWMgPiAweDAwQkYpID8gTCA6IFVuaWNvZGVUQkwwMFt1Y10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChoaSA9PSA1KSB7XG4gICAgICAgIHJldHVybiAoL1tcXHUwNTkxLVxcdTA1ZjRdLy50ZXN0KGNoKSA/IFIgOiBMKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGkgPT0gNikge1xuICAgICAgICBpZiAoL1tcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWZcXHUwNmQ2LVxcdTA2ZTRcXHUwNmU3LVxcdTA2ZWRdLy50ZXN0KGNoKSlcbiAgICAgICAgICAgIHJldHVybiBOU007XG4gICAgICAgIGVsc2UgaWYgKC9bXFx1MDY2MC1cXHUwNjY5XFx1MDY2Yi1cXHUwNjZjXS8udGVzdChjaCkpXG4gICAgICAgICAgICByZXR1cm4gQU47XG4gICAgICAgIGVsc2UgaWYgKHVjID09IDB4MDY2QSlcbiAgICAgICAgICAgIHJldHVybiBFVDtcbiAgICAgICAgZWxzZSBpZiAoL1tcXHUwNmYwLVxcdTA2ZjldLy50ZXN0KGNoKSlcbiAgICAgICAgICAgIHJldHVybiBFTjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIEFMO1xuICAgIH1cbiAgICBlbHNlIGlmIChoaSA9PSAweDIwICYmIHVjIDw9IDB4MjA1Rikge1xuICAgICAgICByZXR1cm4gVW5pY29kZVRCTDIwW3VjICYgMHhGRl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpID09IDB4RkUpIHtcbiAgICAgICAgcmV0dXJuICh1YyA+PSAweEZFNzAgPyBBTCA6IE9OKTtcbiAgICB9XG4gICAgcmV0dXJuIE9OO1xufVxuZnVuY3Rpb24gX2lzQXJhYmljRGlhY3JpdGljcyhjaCkge1xuICAgIHJldHVybiAoY2ggPj0gJ1xcdTA2NGInICYmIGNoIDw9ICdcXHUwNjU1Jyk7XG59XG5leHBvcnRzLkwgPSBMO1xuZXhwb3J0cy5SID0gUjtcbmV4cG9ydHMuRU4gPSBFTjtcbmV4cG9ydHMuT05fUiA9IDM7XG5leHBvcnRzLkFOID0gNDtcbmV4cG9ydHMuUl9IID0gNTtcbmV4cG9ydHMuQiA9IDY7XG5leHBvcnRzLlJMRSA9IDc7XG5leHBvcnRzLkRPVCA9IFwiXFx4QjdcIjtcbmV4cG9ydHMuZG9CaWRpUmVvcmRlciA9IGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Q2hhclR5cGVzLCBpc1J0bCkge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgY2hhcnMgPSB0ZXh0LnNwbGl0KFwiXCIpLCBsb2dpY2FsRnJvbVZpc3VhbCA9IG5ldyBBcnJheShjaGFycy5sZW5ndGgpLCBiaWRpTGV2ZWxzID0gbmV3IEFycmF5KGNoYXJzLmxlbmd0aCksIGxldmVscyA9IFtdO1xuICAgIGRpciA9IGlzUnRsID8gUlRMIDogTFRSO1xuICAgIF9jb21wdXRlTGV2ZWxzKGNoYXJzLCBsZXZlbHMsIGNoYXJzLmxlbmd0aCwgdGV4dENoYXJUeXBlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dpY2FsRnJvbVZpc3VhbC5sZW5ndGg7IGxvZ2ljYWxGcm9tVmlzdWFsW2ldID0gaSwgaSsrKVxuICAgICAgICA7XG4gICAgX2ludmVydExldmVsKDIsIGxldmVscywgbG9naWNhbEZyb21WaXN1YWwpO1xuICAgIF9pbnZlcnRMZXZlbCgxLCBsZXZlbHMsIGxvZ2ljYWxGcm9tVmlzdWFsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ2ljYWxGcm9tVmlzdWFsLmxlbmd0aCAtIDE7IGkrKykgeyAvL2ZpeCBsZXZlbHMgdG8gcmVmbGVjdCBjaGFyYWN0ZXIgd2lkdGhcbiAgICAgICAgaWYgKHRleHRDaGFyVHlwZXNbaV0gPT09IEFOKSB7XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBleHBvcnRzLkFOO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxldmVsc1tpXSA9PT0gUiAmJiAoKHRleHRDaGFyVHlwZXNbaV0gPiBBTCAmJiB0ZXh0Q2hhclR5cGVzW2ldIDwgTFJFKVxuICAgICAgICAgICAgfHwgdGV4dENoYXJUeXBlc1tpXSA9PT0gT04gfHwgdGV4dENoYXJUeXBlc1tpXSA9PT0gQk4pKSB7XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBleHBvcnRzLk9OX1I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGkgPiAwICYmIGNoYXJzW2kgLSAxXSA9PT0gJ1xcdTA2NDQnKSAmJiAvXFx1MDYyMnxcXHUwNjIzfFxcdTA2MjV8XFx1MDYyNy8udGVzdChjaGFyc1tpXSkpIHtcbiAgICAgICAgICAgIGxldmVsc1tpIC0gMV0gPSBsZXZlbHNbaV0gPSBleHBvcnRzLlJfSDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0gPT09IGV4cG9ydHMuRE9UKVxuICAgICAgICBsZXZlbHNbY2hhcnMubGVuZ3RoIC0gMV0gPSBleHBvcnRzLkI7XG4gICAgaWYgKGNoYXJzWzBdID09PSAnXFx1MjAyQicpXG4gICAgICAgIGxldmVsc1swXSA9IGV4cG9ydHMuUkxFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9naWNhbEZyb21WaXN1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmlkaUxldmVsc1tpXSA9IGxldmVsc1tsb2dpY2FsRnJvbVZpc3VhbFtpXV07XG4gICAgfVxuICAgIHJldHVybiB7ICdsb2dpY2FsRnJvbVZpc3VhbCc6IGxvZ2ljYWxGcm9tVmlzdWFsLCAnYmlkaUxldmVscyc6IGJpZGlMZXZlbHMgfTtcbn07XG5leHBvcnRzLmhhc0JpZGlDaGFyYWN0ZXJzID0gZnVuY3Rpb24gKHRleHQsIHRleHRDaGFyVHlwZXMpIHtcbiAgICB2YXIgcmV0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHRDaGFyVHlwZXNbaV0gPSBfZ2V0Q2hhcmFjdGVyVHlwZSh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICAgIGlmICghcmV0ICYmICh0ZXh0Q2hhclR5cGVzW2ldID09IFIgfHwgdGV4dENoYXJUeXBlc1tpXSA9PSBBTCB8fCB0ZXh0Q2hhclR5cGVzW2ldID09IEFOKSlcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5nZXRWaXN1YWxGcm9tTG9naWNhbElkeCA9IGZ1bmN0aW9uIChsb2dJZHgsIHJvd01hcCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93TWFwLmxvZ2ljYWxGcm9tVmlzdWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3dNYXAubG9naWNhbEZyb21WaXN1YWxbaV0gPT0gbG9nSWR4KVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYmlkaWhhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvYmlkaXV0aWxcIixcImFjZS9saWIvbGFuZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBiaWRpVXRpbCA9IHJlcXVpcmUoXCIuL2xpYi9iaWRpdXRpbFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHUyMDJCXS87XG52YXIgQmlkaUhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmlkaUhhbmRsZXIoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmJpZGlNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Um93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iaWRpVXRpbCA9IGJpZGlVdGlsO1xuICAgICAgICB0aGlzLmNoYXJXaWR0aHMgPSBbXTtcbiAgICAgICAgdGhpcy5FT0wgPSBcIlxceEFDXCI7XG4gICAgICAgIHRoaXMuc2hvd0ludmlzaWJsZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzUnRsRGlyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGlzUnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZSA9IFwiXCI7XG4gICAgICAgIHRoaXMud3JhcEluZGVudCA9IDA7XG4gICAgICAgIHRoaXMuRU9GID0gXCJcXHhCNlwiO1xuICAgICAgICB0aGlzLlJMRSA9IFwiXFx1MjAyQlwiO1xuICAgICAgICB0aGlzLmNvbnRlbnRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuZm9udE1ldHJpY3MgPSBudWxsO1xuICAgICAgICB0aGlzLnJ0bExpbmVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLndyYXBPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmlzTW92ZUxlZnRPcGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWVuQmlkaSA9IGJpZGlSRS50ZXN0KHNlc3Npb24uZ2V0VmFsdWUoKSk7XG4gICAgfVxuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5pc0JpZGlSb3cgPSBmdW5jdGlvbiAoc2NyZWVuUm93LCBkb2NSb3csIHNwbGl0SW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZW5CaWRpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc2NyZWVuUm93ICE9PSB0aGlzLmN1cnJlbnRSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdyA9IHNjcmVlblJvdztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUm93TGluZShkb2NSb3csIHNwbGl0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCaWRpTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmlkaU1hcC5iaWRpTGV2ZWxzO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWVuQmlkaSkge1xuICAgICAgICAgICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiICYmIGJpZGlSRS50ZXN0KGRlbHRhLmxpbmVzLmpvaW4oXCJcXG5cIikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVuQmlkaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um93ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5nZXREb2N1bWVudFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvY1JvdyA9IDA7XG4gICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuc2Vzc2lvbi4kc2NyZWVuUm93Q2FjaGU7XG4gICAgICAgIGlmIChyb3dDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuc2Vzc2lvbi4kZ2V0Um93Q2FjaGVJbmRleChyb3dDYWNoZSwgdGhpcy5jdXJyZW50Um93KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGRvY1JvdyA9IHRoaXMuc2Vzc2lvbi4kZG9jUm93Q2FjaGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2NSb3c7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuZ2V0U3BsaXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcm93Q2FjaGUgPSB0aGlzLnNlc3Npb24uJHNjcmVlblJvd0NhY2hlO1xuICAgICAgICBpZiAocm93Q2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4LCBwcmV2SW5kZXggPSB0aGlzLnNlc3Npb24uJGdldFJvd0NhY2hlSW5kZXgocm93Q2FjaGUsIHRoaXMuY3VycmVudFJvdyk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jdXJyZW50Um93IC0gc3BsaXRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSB0aGlzLnNlc3Npb24uJGdldFJvd0NhY2hlSW5kZXgocm93Q2FjaGUsIHRoaXMuY3VycmVudFJvdyAtIHNwbGl0SW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ICE9PSBwcmV2SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBzcGxpdEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGxpdEluZGV4ID0gdGhpcy5jdXJyZW50Um93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdEluZGV4O1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVJvd0xpbmUgPSBmdW5jdGlvbiAoZG9jUm93LCBzcGxpdEluZGV4KSB7XG4gICAgICAgIGlmIChkb2NSb3cgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRvY1JvdyA9IHRoaXMuZ2V0RG9jdW1lbnRSb3coKTtcbiAgICAgICAgdmFyIGlzTGFzdFJvdyA9IChkb2NSb3cgPT09IHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEpLCBlbmRPZkxpbmUgPSBpc0xhc3RSb3cgPyB0aGlzLkVPRiA6IHRoaXMuRU9MO1xuICAgICAgICB0aGlzLndyYXBJbmRlbnQgPSAwO1xuICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TGluZShkb2NSb3cpO1xuICAgICAgICB0aGlzLmlzUnRsRGlyID0gdGhpcy4kaXNSdGwgfHwgdGhpcy5saW5lLmNoYXJBdCgwKSA9PT0gdGhpcy5STEU7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy5zZXNzaW9uLiR3cmFwRGF0YVtkb2NSb3ddO1xuICAgICAgICAgICAgaWYgKHNwbGl0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdEluZGV4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0SW5kZXggPSB0aGlzLmdldFNwbGl0SW5kZXgoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRJbmRleCA+IDAgJiYgc3BsaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBJbmRlbnQgPSBzcGxpdHMuaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBPZmZzZXQgPSB0aGlzLndyYXBJbmRlbnQgKiB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuTF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZSA9IChzcGxpdEluZGV4IDwgc3BsaXRzLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lLnN1YnN0cmluZyhzcGxpdHNbc3BsaXRJbmRleCAtIDFdLCBzcGxpdHNbc3BsaXRJbmRleF0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZS5zdWJzdHJpbmcoc3BsaXRzW3NwbGl0cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLmxpbmUuc3Vic3RyaW5nKDAsIHNwbGl0c1tzcGxpdEluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGxpdEluZGV4ID09IHNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lICs9ICh0aGlzLnNob3dJbnZpc2libGVzKSA/IGVuZE9mTGluZSA6IGJpZGlVdGlsLkRPVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmUgKz0gdGhpcy5zaG93SW52aXNpYmxlcyA/IGVuZE9mTGluZSA6IGJpZGlVdGlsLkRPVDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbiwgc2hpZnQgPSAwLCBzaXplO1xuICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLmxpbmUucmVwbGFjZSgvXFx0fFtcXHUxMTAwLVxcdTIwMjksIFxcdTIwMkYtXFx1RkZFNl0vZywgZnVuY3Rpb24gKGNoLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHQnIHx8IHNlc3Npb24uaXNGdWxsV2lkdGgoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gKGNoID09PSAnXFx0JykgPyBzZXNzaW9uLmdldFNjcmVlblRhYlNpemUoaSArIHNoaWZ0KSA6IDI7XG4gICAgICAgICAgICAgICAgc2hpZnQgKz0gc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmcuc3RyaW5nUmVwZWF0KGJpZGlVdGlsLkRPVCwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pc1J0bERpcikge1xuICAgICAgICAgICAgdGhpcy5mb250TWV0cmljcy4kbWFpbi50ZXh0Q29udGVudCA9ICh0aGlzLmxpbmUuY2hhckF0KHRoaXMubGluZS5sZW5ndGggLSAxKSA9PSBiaWRpVXRpbC5ET1QpID8gdGhpcy5saW5lLnN1YnN0cigwLCB0aGlzLmxpbmUubGVuZ3RoIC0gMSkgOiB0aGlzLmxpbmU7XG4gICAgICAgICAgICB0aGlzLnJ0bExpbmVPZmZzZXQgPSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuZm9udE1ldHJpY3MuJG1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVCaWRpTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dENoYXJUeXBlcyA9IFtdO1xuICAgICAgICBpZiAoYmlkaVV0aWwuaGFzQmlkaUNoYXJhY3RlcnModGhpcy5saW5lLCB0ZXh0Q2hhclR5cGVzKSB8fCB0aGlzLmlzUnRsRGlyKSB7XG4gICAgICAgICAgICB0aGlzLmJpZGlNYXAgPSBiaWRpVXRpbC5kb0JpZGlSZW9yZGVyKHRoaXMubGluZSwgdGV4dENoYXJUeXBlcywgdGhpcy5pc1J0bERpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpZGlNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLm1hcmtBc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRSb3cgPSBudWxsO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUNoYXJhY3RlcldpZHRocyA9IGZ1bmN0aW9uIChmb250TWV0cmljcykge1xuICAgICAgICBpZiAodGhpcy5jaGFyYWN0ZXJXaWR0aCA9PT0gZm9udE1ldHJpY3MuJGNoYXJhY3RlclNpemUud2lkdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZm9udE1ldHJpY3MgPSBmb250TWV0cmljcztcbiAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gdGhpcy5jaGFyYWN0ZXJXaWR0aCA9IGZvbnRNZXRyaWNzLiRjaGFyYWN0ZXJTaXplLndpZHRoO1xuICAgICAgICB2YXIgYmlkaUNoYXJXaWR0aCA9IGZvbnRNZXRyaWNzLiRtZWFzdXJlQ2hhcldpZHRoKFwiXFx1MDVkNFwiKTtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLkxdID0gdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLkVOXSA9IHRoaXMuY2hhcldpZHRoc1tiaWRpVXRpbC5PTl9SXSA9IGNoYXJhY3RlcldpZHRoO1xuICAgICAgICB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuUl0gPSB0aGlzLmNoYXJXaWR0aHNbYmlkaVV0aWwuQU5dID0gYmlkaUNoYXJXaWR0aDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLlJfSF0gPSBiaWRpQ2hhcldpZHRoICogMC40NTtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLkJdID0gdGhpcy5jaGFyV2lkdGhzW2JpZGlVdGlsLlJMRV0gPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRSb3cgPSBudWxsO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24gKHNob3dJbnZpc2libGVzKSB7XG4gICAgICAgIHRoaXMuc2hvd0ludmlzaWJsZXMgPSBzaG93SW52aXNpYmxlcztcbiAgICAgICAgdGhpcy5jdXJyZW50Um93ID0gbnVsbDtcbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5zZXRFb2xDaGFyID0gZnVuY3Rpb24gKGVvbENoYXIpIHtcbiAgICAgICAgdGhpcy5FT0wgPSBlb2xDaGFyO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnNldENvbnRlbnRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRXaWR0aCA9IHdpZHRoO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLmlzUnRsTGluZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzUnRsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChyb3cgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNlc3Npb24uZ2V0TGluZShyb3cpLmNoYXJBdCgwKSA9PSB0aGlzLlJMRSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUnRsRGlyO1xuICAgIH07XG4gICAgQmlkaUhhbmRsZXIucHJvdG90eXBlLnNldFJ0bERpcmVjdGlvbiA9IGZ1bmN0aW9uIChlZGl0b3IsIGlzUnRsRGlyKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25BbmNob3IoKS5yb3c7IHJvdyA8PSBjdXJzb3Iucm93OyByb3crKykge1xuICAgICAgICAgICAgaWYgKCFpc1J0bERpciAmJiBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKHJvdykuY2hhckF0KDApID09PSBlZGl0b3Iuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuUkxFKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLmRvYy5yZW1vdmVJbkxpbmUocm93LCAwLCAxKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUnRsRGlyICYmIGVkaXRvci5zZXNzaW9uLmdldExpbmUocm93KS5jaGFyQXQoMCkgIT09IGVkaXRvci5zZXNzaW9uLiRiaWRpSGFuZGxlci5STEUpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24uZG9jLmluc2VydCh7IGNvbHVtbjogMCwgcm93OiByb3cgfSwgZWRpdG9yLnNlc3Npb24uJGJpZGlIYW5kbGVyLlJMRSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5nZXRQb3NMZWZ0ID0gZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICBjb2wgLT0gdGhpcy53cmFwSW5kZW50O1xuICAgICAgICB2YXIgbGVmdEJvdW5kYXJ5ID0gKHRoaXMubGluZS5jaGFyQXQoMCkgPT09IHRoaXMuUkxFKSA/IDEgOiAwO1xuICAgICAgICB2YXIgbG9naWNhbElkeCA9IChjb2wgPiBsZWZ0Qm91bmRhcnkpID8gKHRoaXMuc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKSA/IGNvbCA6IGNvbCAtIDEpIDogbGVmdEJvdW5kYXJ5O1xuICAgICAgICB2YXIgdmlzdWFsSWR4ID0gYmlkaVV0aWwuZ2V0VmlzdWFsRnJvbUxvZ2ljYWxJZHgobG9naWNhbElkeCwgdGhpcy5iaWRpTWFwKSwgbGV2ZWxzID0gdGhpcy5iaWRpTWFwLmJpZGlMZXZlbHMsIGxlZnQgPSAwO1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKSAmJiBjb2wgPD0gbGVmdEJvdW5kYXJ5ICYmIGxldmVsc1t2aXN1YWxJZHhdICUgMiAhPT0gMClcbiAgICAgICAgICAgIHZpc3VhbElkeCsrO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc3VhbElkeDsgaSsrKSB7XG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMuY2hhcldpZHRoc1tsZXZlbHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpICYmIChjb2wgPiBsZWZ0Qm91bmRhcnkpICYmIChsZXZlbHNbdmlzdWFsSWR4XSAlIDIgPT09IDApKVxuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmNoYXJXaWR0aHNbbGV2ZWxzW3Zpc3VhbElkeF1dO1xuICAgICAgICBpZiAodGhpcy53cmFwSW5kZW50KVxuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmlzUnRsRGlyID8gKC0xICogdGhpcy53cmFwT2Zmc2V0KSA6IHRoaXMud3JhcE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMuaXNSdGxEaXIpXG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMucnRsTGluZU9mZnNldDtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcbiAgICBCaWRpSGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChzdGFydENvbCwgZW5kQ29sKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLmJpZGlNYXAsIGxldmVscyA9IG1hcC5iaWRpTGV2ZWxzLCBsZXZlbCwgc2VsZWN0aW9ucyA9IFtdLCBvZmZzZXQgPSAwLCBzZWxDb2xNaW4gPSBNYXRoLm1pbihzdGFydENvbCwgZW5kQ29sKSAtIHRoaXMud3JhcEluZGVudCwgc2VsQ29sTWF4ID0gTWF0aC5tYXgoc3RhcnRDb2wsIGVuZENvbCkgLSB0aGlzLndyYXBJbmRlbnQsIGlzU2VsZWN0ZWQgPSBmYWxzZSwgaXNTZWxlY3RlZFByZXYgPSBmYWxzZSwgc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICBpZiAodGhpcy53cmFwSW5kZW50KVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuaXNSdGxEaXIgPyAoLTEgKiB0aGlzLndyYXBPZmZzZXQpIDogdGhpcy53cmFwT2Zmc2V0O1xuICAgICAgICBmb3IgKHZhciBsb2dJZHgsIHZpc0lkeCA9IDA7IHZpc0lkeCA8IGxldmVscy5sZW5ndGg7IHZpc0lkeCsrKSB7XG4gICAgICAgICAgICBsb2dJZHggPSBtYXAubG9naWNhbEZyb21WaXN1YWxbdmlzSWR4XTtcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzW3Zpc0lkeF07XG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gKGxvZ0lkeCA+PSBzZWxDb2xNaW4pICYmIChsb2dJZHggPCBzZWxDb2xNYXgpO1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQgJiYgIWlzU2VsZWN0ZWRQcmV2KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNTZWxlY3RlZCAmJiBpc1NlbGVjdGVkUHJldikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaCh7IGxlZnQ6IHNlbGVjdGlvblN0YXJ0LCB3aWR0aDogb2Zmc2V0IC0gc2VsZWN0aW9uU3RhcnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5jaGFyV2lkdGhzW2xldmVsXTtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWRQcmV2ID0gaXNTZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiAodmlzSWR4ID09PSBsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHsgbGVmdDogc2VsZWN0aW9uU3RhcnQsIHdpZHRoOiBvZmZzZXQgLSBzZWxlY3Rpb25TdGFydCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1J0bERpcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uc1tpXS5sZWZ0ICs9IHRoaXMucnRsTGluZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9ucztcbiAgICB9O1xuICAgIEJpZGlIYW5kbGVyLnByb3RvdHlwZS5vZmZzZXRUb0NvbCA9IGZ1bmN0aW9uIChwb3NYKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnRsRGlyKVxuICAgICAgICAgICAgcG9zWCAtPSB0aGlzLnJ0bExpbmVPZmZzZXQ7XG4gICAgICAgIHZhciBsb2dpY2FsSWR4ID0gMCwgcG9zWCA9IE1hdGgubWF4KHBvc1gsIDApLCBvZmZzZXQgPSAwLCB2aXN1YWxJZHggPSAwLCBsZXZlbHMgPSB0aGlzLmJpZGlNYXAuYmlkaUxldmVscywgY2hhcldpZHRoID0gdGhpcy5jaGFyV2lkdGhzW2xldmVsc1t2aXN1YWxJZHhdXTtcbiAgICAgICAgaWYgKHRoaXMud3JhcEluZGVudClcbiAgICAgICAgICAgIHBvc1ggLT0gdGhpcy5pc1J0bERpciA/ICgtMSAqIHRoaXMud3JhcE9mZnNldCkgOiB0aGlzLndyYXBPZmZzZXQ7XG4gICAgICAgIHdoaWxlIChwb3NYID4gb2Zmc2V0ICsgY2hhcldpZHRoIC8gMikge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoYXJXaWR0aDtcbiAgICAgICAgICAgIGlmICh2aXN1YWxJZHggPT09IGxldmVscy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IHRoaXMuY2hhcldpZHRoc1tsZXZlbHNbKyt2aXN1YWxJZHhdXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzdWFsSWR4ID4gMCAmJiAobGV2ZWxzW3Zpc3VhbElkeCAtIDFdICUgMiAhPT0gMCkgJiYgKGxldmVsc1t2aXN1YWxJZHhdICUgMiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlmIChwb3NYIDwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgIHZpc3VhbElkeC0tO1xuICAgICAgICAgICAgbG9naWNhbElkeCA9IHRoaXMuYmlkaU1hcC5sb2dpY2FsRnJvbVZpc3VhbFt2aXN1YWxJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpc3VhbElkeCA+IDAgJiYgKGxldmVsc1t2aXN1YWxJZHggLSAxXSAlIDIgPT09IDApICYmIChsZXZlbHNbdmlzdWFsSWR4XSAlIDIgIT09IDApKSB7XG4gICAgICAgICAgICBsb2dpY2FsSWR4ID0gMSArICgocG9zWCA+IG9mZnNldCkgPyB0aGlzLmJpZGlNYXAubG9naWNhbEZyb21WaXN1YWxbdmlzdWFsSWR4XVxuICAgICAgICAgICAgICAgIDogdGhpcy5iaWRpTWFwLmxvZ2ljYWxGcm9tVmlzdWFsW3Zpc3VhbElkeCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5pc1J0bERpciAmJiB2aXN1YWxJZHggPT09IGxldmVscy5sZW5ndGggLSAxICYmIGNoYXJXaWR0aCA9PT0gMCAmJiAobGV2ZWxzW3Zpc3VhbElkeCAtIDFdICUgMiA9PT0gMCkpXG4gICAgICAgICAgICB8fCAoIXRoaXMuaXNSdGxEaXIgJiYgdmlzdWFsSWR4ID09PSAwICYmIChsZXZlbHNbdmlzdWFsSWR4XSAlIDIgIT09IDApKSkge1xuICAgICAgICAgICAgbG9naWNhbElkeCA9IDEgKyB0aGlzLmJpZGlNYXAubG9naWNhbEZyb21WaXN1YWxbdmlzdWFsSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aXN1YWxJZHggPiAwICYmIChsZXZlbHNbdmlzdWFsSWR4IC0gMV0gJSAyICE9PSAwKSAmJiBjaGFyV2lkdGggIT09IDApXG4gICAgICAgICAgICAgICAgdmlzdWFsSWR4LS07XG4gICAgICAgICAgICBsb2dpY2FsSWR4ID0gdGhpcy5iaWRpTWFwLmxvZ2ljYWxGcm9tVmlzdWFsW3Zpc3VhbElkeF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2ljYWxJZHggPT09IDAgJiYgdGhpcy5pc1J0bERpcilcbiAgICAgICAgICAgIGxvZ2ljYWxJZHgrKztcbiAgICAgICAgcmV0dXJuIChsb2dpY2FsSWR4ICsgdGhpcy53cmFwSW5kZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBCaWRpSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkJpZGlIYW5kbGVyID0gQmlkaUhhbmRsZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3NlbGVjdGlvblwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgU2VsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZG9jID0gc2Vzc2lvbi5nZXREb2N1bWVudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5sZWFkID0gdGhpcy5kb2MuY3JlYXRlQW5jaG9yKDAsIDApO1xuICAgICAgICB0aGlzLmFuY2hvciA9IHRoaXMuZG9jLmNyZWF0ZUFuY2hvcigwLCAwKTtcbiAgICAgICAgdGhpcy4kc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5jdXJzb3Iub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlbGYuJGN1cnNvckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFzZWxmLiRzaWxlbnQpXG4gICAgICAgICAgICAgICAgc2VsZi5fZW1pdChcImNoYW5nZUN1cnNvclwiKTtcbiAgICAgICAgICAgIGlmICghc2VsZi4kaXNFbXB0eSAmJiAhc2VsZi4kc2lsZW50KVxuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoIXNlbGYuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgJiYgZS5vbGQuY29sdW1uICE9IGUudmFsdWUuY29sdW1uKVxuICAgICAgICAgICAgICAgIHNlbGYuJGRlc2lyZWRDb2x1bW4gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbmNob3Iub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi4kYW5jaG9yQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXNlbGYuJGlzRW1wdHkgJiYgIXNlbGYuJHNpbGVudClcbiAgICAgICAgICAgICAgICBzZWxmLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaXNFbXB0eSB8fCAodGhpcy5hbmNob3Iucm93ID09IHRoaXMubGVhZC5yb3cgJiZcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLmNvbHVtbiA9PSB0aGlzLmxlYWQuY29sdW1uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuaXNNdWx0aUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy4kaXNFbXB0eSAmJiB0aGlzLmFuY2hvci5yb3cgIT0gdGhpcy5jdXJzb3Iucm93O1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2V0QW5jaG9yID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuJGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmNob3Iuc2V0UG9zaXRpb24ocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRBbmNob3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTGVhZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uTGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZC5nZXRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5pc0JhY2t3YXJkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICB2YXIgbGVhZCA9IHRoaXMubGVhZDtcbiAgICAgICAgcmV0dXJuIChhbmNob3Iucm93ID4gbGVhZC5yb3cgfHwgKGFuY2hvci5yb3cgPT0gbGVhZC5yb3cgJiYgYW5jaG9yLmNvbHVtbiA+IGxlYWQuY29sdW1uKSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKGxlYWQsIGxlYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhY2t3YXJkcygpXG4gICAgICAgICAgICA/IFJhbmdlLmZyb21Qb2ludHMobGVhZCwgYW5jaG9yKVxuICAgICAgICAgICAgOiBSYW5nZS5mcm9tUG9pbnRzKGFuY2hvciwgbGVhZCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuJGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJHNldFNlbGVjdGlvbigwLCAwLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmV2ZXJzZSA/IHJhbmdlLmVuZCA6IHJhbmdlLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gcmV2ZXJzZSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xuICAgICAgICB0aGlzLiRzZXRTZWxlY3Rpb24oc3RhcnQucm93LCBzdGFydC5jb2x1bW4sIGVuZC5yb3csIGVuZC5jb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS4kc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGFuY2hvclJvdywgYW5jaG9yQ29sdW1uLCBjdXJzb3JSb3csIGN1cnNvckNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy4kc2lsZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgd2FzRW1wdHkgPSB0aGlzLiRpc0VtcHR5O1xuICAgICAgICB2YXIgd2FzTXVsdGlzZWxlY3QgPSB0aGlzLmluTXVsdGlTZWxlY3RNb2RlO1xuICAgICAgICB0aGlzLiRzaWxlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRjdXJzb3JDaGFuZ2VkID0gdGhpcy4kYW5jaG9yQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuY2hvci5zZXRQb3NpdGlvbihhbmNob3JSb3csIGFuY2hvckNvbHVtbik7XG4gICAgICAgIHRoaXMuY3Vyc29yLnNldFBvc2l0aW9uKGN1cnNvclJvdywgY3Vyc29yQ29sdW1uKTtcbiAgICAgICAgdGhpcy4kaXNFbXB0eSA9ICFSYW5nZS5jb21wYXJlUG9pbnRzKHRoaXMuYW5jaG9yLCB0aGlzLmN1cnNvcik7XG4gICAgICAgIHRoaXMuJHNpbGVudCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kY3Vyc29yQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJjaGFuZ2VDdXJzb3JcIik7XG4gICAgICAgIGlmICh0aGlzLiRjdXJzb3JDaGFuZ2VkIHx8IHRoaXMuJGFuY2hvckNoYW5nZWQgfHwgd2FzRW1wdHkgIT0gdGhpcy4kaXNFbXB0eSB8fCB3YXNNdWx0aXNlbGVjdClcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLiRtb3ZlU2VsZWN0aW9uID0gZnVuY3Rpb24gKG1vdmVyKSB7XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSlcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uQW5jaG9yKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XG4gICAgICAgIG1vdmVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdFRvID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHBvcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24ocG9zKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0VXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yVXApO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3REb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckRvd24pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JSaWdodCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yTGVmdCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdExpbmVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JMaW5lU3RhcnQpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RMaW5lRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckxpbmVFbmQpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RGaWxlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckZpbGVFbmQpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RGaWxlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yRmlsZVN0YXJ0KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0V29yZFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvcldvcmRSaWdodCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdFdvcmRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvcldvcmRMZWZ0KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0V29yZFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSByb3cgfHwgdGhpcy5sZWFkO1xuICAgICAgICAgICAgcm93ID0gY3Vyc29yLnJvdztcbiAgICAgICAgICAgIGNvbHVtbiA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRXb3JkUmFuZ2Uocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RXb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHRoaXMuZ2V0V29yZFJhbmdlKCkpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RBV29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRBV29yZFJhbmdlKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0TGluZVJhbmdlID0gZnVuY3Rpb24gKHJvdywgZXhjbHVkZUxhc3RDaGFyKSB7XG4gICAgICAgIHZhciByb3dTdGFydCA9IHR5cGVvZiByb3cgPT0gXCJudW1iZXJcIiA/IHJvdyA6IHRoaXMubGVhZC5yb3c7XG4gICAgICAgIHZhciByb3dFbmQ7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkTGluZShyb3dTdGFydCk7XG4gICAgICAgIGlmIChmb2xkTGluZSkge1xuICAgICAgICAgICAgcm93U3RhcnQgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgICAgICByb3dFbmQgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93RW5kID0gcm93U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2x1ZGVMYXN0Q2hhciA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93U3RhcnQsIDAsIHJvd0VuZCwgdGhpcy5zZXNzaW9uLmdldExpbmUocm93RW5kKS5sZW5ndGgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJvd1N0YXJ0LCAwLCByb3dFbmQgKyAxLCAwKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmdldExpbmVSYW5nZSgpKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvclVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeSgtMSwgMCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeSgxLCAwKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUud291bGRNb3ZlSW50b1NvZnRUYWIgPSBmdW5jdGlvbiAoY3Vyc29yLCB0YWJTaXplLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY3Vyc29yLmNvbHVtbjtcbiAgICAgICAgdmFyIGVuZCA9IGN1cnNvci5jb2x1bW4gKyB0YWJTaXplO1xuICAgICAgICBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBjdXJzb3IuY29sdW1uIC0gdGFiU2l6ZTtcbiAgICAgICAgICAgIGVuZCA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5pc1RhYlN0b3AoY3Vyc29yKSAmJiB0aGlzLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpLnNsaWNlKHN0YXJ0LCBlbmQpLnNwbGl0KFwiIFwiKS5sZW5ndGggLSAxID09IHRhYlNpemU7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5sZWFkLmdldFBvc2l0aW9uKCksIGZvbGQ7XG4gICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uLCAtMSkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci5yb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oY3Vyc29yLnJvdyAtIDEsIHRoaXMuZG9jLmdldExpbmUoY3Vyc29yLnJvdyAtIDEpLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuc2Vzc2lvbi5nZXRUYWJTaXplKCk7XG4gICAgICAgICAgICBpZiAodGhpcy53b3VsZE1vdmVJbnRvU29mdFRhYihjdXJzb3IsIHRhYlNpemUsIC0xKSAmJiAhdGhpcy5zZXNzaW9uLmdldE5hdmlnYXRlV2l0aGluU29mdFRhYnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIC10YWJTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKSwgZm9sZDtcbiAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIDEpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhmb2xkLmVuZC5yb3csIGZvbGQuZW5kLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWFkLmNvbHVtbiA9PSB0aGlzLmRvYy5nZXRMaW5lKHRoaXMubGVhZC5yb3cpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVhZC5yb3cgPCB0aGlzLmRvYy5nZXRMZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyh0aGlzLmxlYWQucm93ICsgMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuc2Vzc2lvbi5nZXRUYWJTaXplKCk7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5sZWFkO1xuICAgICAgICAgICAgaWYgKHRoaXMud291bGRNb3ZlSW50b1NvZnRUYWIoY3Vyc29yLCB0YWJTaXplLCAxKSAmJiAhdGhpcy5zZXNzaW9uLmdldE5hdmlnYXRlV2l0aGluU29mdFRhYnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIHRhYlNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckxpbmVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxlYWQuY29sdW1uO1xuICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3cocm93LCBjb2x1bW4pO1xuICAgICAgICB2YXIgZmlyc3RDb2x1bW5Qb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCAwKTtcbiAgICAgICAgdmFyIGJlZm9yZUN1cnNvciA9IHRoaXMuc2Vzc2lvbi5nZXREaXNwbGF5TGluZShyb3csIG51bGwsIGZpcnN0Q29sdW1uUG9zaXRpb24ucm93LCBmaXJzdENvbHVtblBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgIHZhciBsZWFkaW5nU3BhY2UgPSBiZWZvcmVDdXJzb3IubWF0Y2goL15cXHMqLyk7XG4gICAgICAgIGlmIChsZWFkaW5nU3BhY2VbMF0ubGVuZ3RoICE9IGNvbHVtbiAmJiAhdGhpcy5zZXNzaW9uLiR1c2VFbWFjc1N0eWxlTGluZVN0YXJ0KVxuICAgICAgICAgICAgZmlyc3RDb2x1bW5Qb3NpdGlvbi5jb2x1bW4gKz0gbGVhZGluZ1NwYWNlWzBdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihmaXJzdENvbHVtblBvc2l0aW9uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckxpbmVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICB2YXIgbGluZUVuZCA9IHRoaXMuc2Vzc2lvbi5nZXREb2N1bWVudExhc3RSb3dDb2x1bW5Qb3NpdGlvbihsZWFkLnJvdywgbGVhZC5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy5sZWFkLmNvbHVtbiA9PSBsaW5lRW5kLmNvbHVtbikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TGluZShsaW5lRW5kLnJvdyk7XG4gICAgICAgICAgICBpZiAobGluZUVuZC5jb2x1bW4gPT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEVuZCA9IGxpbmUuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgbGluZUVuZC5jb2x1bW4gPSB0ZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGxpbmVFbmQucm93LCBsaW5lRW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JGaWxlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yRmlsZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbygwLCAwKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckxvbmdXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciByaWdodE9mQ3Vyc29yID0gbGluZS5zdWJzdHJpbmcoY29sdW1uKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAxKTtcbiAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLm5vblRva2VuUmUuZXhlYyhyaWdodE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgY29sdW1uICs9IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByaWdodE9mQ3Vyc29yID0gbGluZS5zdWJzdHJpbmcoY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uID49IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclJpZ2h0KCk7XG4gICAgICAgICAgICBpZiAocm93IDwgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcldvcmRSaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKHJpZ2h0T2ZDdXJzb3IpKSB7XG4gICAgICAgICAgICBjb2x1bW4gKz0gdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JMb25nV29yZExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcbiAgICAgICAgdmFyIGZvbGQ7XG4gICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgLTEpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZFN0cmluZ0F0KHJvdywgY29sdW1uLCAtMSk7XG4gICAgICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpLnN1YnN0cmluZygwLCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0T2ZDdXJzb3IgPSBsYW5nLnN0cmluZ1JldmVyc2Uoc3RyKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmV4ZWMobGVmdE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgY29sdW1uIC09IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIGxlZnRPZkN1cnNvciA9IGxlZnRPZkN1cnNvci5zbGljZSh0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgMCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JMZWZ0KCk7XG4gICAgICAgICAgICBpZiAocm93ID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JXb3JkTGVmdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKGxlZnRPZkN1cnNvcikpIHtcbiAgICAgICAgICAgIGNvbHVtbiAtPSB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuJHNob3J0V29yZEVuZEluZGV4ID0gZnVuY3Rpb24gKHJpZ2h0T2ZDdXJzb3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgY2g7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlUmUgPSAvXFxzLztcbiAgICAgICAgdmFyIHRva2VuUmUgPSB0aGlzLnNlc3Npb24udG9rZW5SZTtcbiAgICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLnRva2VuUmUuZXhlYyhyaWdodE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoKGNoID0gcmlnaHRPZkN1cnNvcltpbmRleF0pICYmIHdoaXRlc3BhY2VSZS50ZXN0KGNoKSlcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMSkge1xuICAgICAgICAgICAgICAgIHRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNoID0gcmlnaHRPZkN1cnNvcltpbmRleF0pICYmICF0b2tlblJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2VSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNoID0gcmlnaHRPZkN1cnNvcltpbmRleF0pICYmIHdoaXRlc3BhY2VSZS50ZXN0KGNoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvclNob3J0V29yZFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XG4gICAgICAgIHZhciBmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgaWYgKGNvbHVtbiA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmRvYy5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgICAgICByaWdodE9mQ3Vyc29yID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgfSB3aGlsZSAocm93IDwgbCAmJiAvXlxccyokLy50ZXN0KHJpZ2h0T2ZDdXJzb3IpKTtcbiAgICAgICAgICAgIGlmICghL15cXHMrLy50ZXN0KHJpZ2h0T2ZDdXJzb3IpKVxuICAgICAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRzaG9ydFdvcmRFbmRJbmRleChyaWdodE9mQ3Vyc29yKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4gKyBpbmRleCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JTaG9ydFdvcmRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBmb2xkO1xuICAgICAgICBpZiAoZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIC0xKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVDdXJzb3JUbyhmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4pO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKDAsIGNvbHVtbik7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByb3ctLTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgfSB3aGlsZSAocm93ID4gMCAmJiAvXlxccyokLy50ZXN0KGxpbmUpKTtcbiAgICAgICAgICAgIGNvbHVtbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCEvXFxzKyQvLnRlc3QobGluZSkpXG4gICAgICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnRPZkN1cnNvciA9IGxhbmcuc3RyaW5nUmV2ZXJzZShsaW5lKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy4kc2hvcnRXb3JkRW5kSW5kZXgobGVmdE9mQ3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uIC0gaW5kZXgpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yV29yZFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRzZWxlY3RMb25nV29yZHMpXG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JMb25nV29yZFJpZ2h0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclNob3J0V29yZFJpZ2h0KCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVDdXJzb3JXb3JkTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kc2VsZWN0TG9uZ1dvcmRzKVxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yTG9uZ1dvcmRMZWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclNob3J0V29yZExlZnQoKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvckJ5ID0gZnVuY3Rpb24gKHJvd3MsIGNoYXJzKSB7XG4gICAgICAgIHZhciBzY3JlZW5Qb3MgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMubGVhZC5yb3csIHRoaXMubGVhZC5jb2x1bW4pO1xuICAgICAgICB2YXIgb2Zmc2V0WDtcbiAgICAgICAgaWYgKGNoYXJzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocm93cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmlzQmlkaVJvdyhzY3JlZW5Qb3Mucm93LCB0aGlzLmxlYWQucm93KSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYID0gdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5nZXRQb3NMZWZ0KHNjcmVlblBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb3MuY29sdW1uID0gTWF0aC5yb3VuZChvZmZzZXRYIC8gdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5jaGFyV2lkdGhzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBzY3JlZW5Qb3MuY29sdW1uICogdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5jaGFyV2lkdGhzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRkZXNpcmVkQ29sdW1uKVxuICAgICAgICAgICAgICAgIHNjcmVlblBvcy5jb2x1bW4gPSB0aGlzLiRkZXNpcmVkQ29sdW1uO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGRlc2lyZWRDb2x1bW4gPSBzY3JlZW5Qb3MuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dzICE9IDAgJiYgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzICYmIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t0aGlzLmxlYWQucm93XSkge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t0aGlzLmxlYWQucm93XTtcbiAgICAgICAgICAgIGlmIChyb3dzIDwgMClcbiAgICAgICAgICAgICAgICByb3dzIC09IHdpZGdldC5yb3dzQWJvdmUgfHwgMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJvd3MgPiAwKVxuICAgICAgICAgICAgICAgIHJvd3MgKz0gd2lkZ2V0LnJvd0NvdW50IC0gKHdpZGdldC5yb3dzQWJvdmUgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvY1BvcyA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUG9zLnJvdyArIHJvd3MsIHNjcmVlblBvcy5jb2x1bW4sIG9mZnNldFgpO1xuICAgICAgICBpZiAocm93cyAhPT0gMCAmJiBjaGFycyA9PT0gMCAmJiBkb2NQb3Mucm93ID09PSB0aGlzLmxlYWQucm93ICYmIGRvY1Bvcy5jb2x1bW4gPT09IHRoaXMubGVhZC5jb2x1bW4pIHtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhkb2NQb3Mucm93LCBkb2NQb3MuY29sdW1uICsgY2hhcnMsIGNoYXJzID09PSAwKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUubW92ZUN1cnNvclRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICByb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIGlmICgvW1xcdURDMDAtXFx1REZGRl0vLnRlc3QobGluZS5jaGFyQXQoY29sdW1uKSkgJiYgbGluZS5jaGFyQXQoY29sdW1uIC0gMSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYWQucm93ID09IHJvdyAmJiB0aGlzLmxlYWQuY29sdW1uID09IGNvbHVtbiArIDEpXG4gICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW4gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVhZC5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgICAgIHRoaXMuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFrZWVwRGVzaXJlZENvbHVtbilcbiAgICAgICAgICAgIHRoaXMuJGRlc2lyZWRDb2x1bW4gPSBudWxsO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9TY3JlZW4gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHJvdywgY29sdW1uKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocG9zLnJvdywgcG9zLmNvbHVtbiwga2VlcERlc2lyZWRDb2x1bW4pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGVhZC5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5hbmNob3IuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmZyb21PcmllbnRlZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UsIHJhbmdlLmN1cnNvciA9PSByYW5nZS5zdGFydCk7XG4gICAgICAgIHRoaXMuJGRlc2lyZWRDb2x1bW4gPSByYW5nZS5kZXNpcmVkQ29sdW1uIHx8IHRoaXMuJGRlc2lyZWRDb2x1bW47XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnRvT3JpZW50ZWRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSByLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyA9IHIuc3RhcnQucm93O1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IHIuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSByLmVuZC5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UuY3Vyc29yID0gdGhpcy5pc0JhY2t3YXJkcygpID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XG4gICAgICAgIHJhbmdlLmRlc2lyZWRDb2x1bW4gPSB0aGlzLiRkZXNpcmVkQ29sdW1uO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmdldFJhbmdlT2ZNb3ZlbWVudHMgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldEN1cnNvcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuYyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHsgdmFyIGRhdGEgPSB0aGlzLnJhbmdlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcjEgPSByLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcjEuaXNCYWNrd2FyZHMgPSByLmN1cnNvciA9PSByLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiByMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyB2YXIgZGF0YSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIGRhdGEuaXNCYWNrd2FyZHMgPSB0aGlzLmlzQmFja3dhcmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b1NpbmdsZVJhbmdlKGRhdGFbMF0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFJhbmdlLmZyb21Qb2ludHMoZGF0YVtpXS5zdGFydCwgZGF0YVtpXS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5pc0JhY2t3YXJkcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuY3Vyc29yID0gci5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmFuZ2VMaXN0KVxuICAgICAgICAgICAgdGhpcy50b1NpbmdsZVJhbmdlKGRhdGEpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKGRhdGEsIGRhdGEuaXNCYWNrd2FyZHMpO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5pc0VxdWFsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKChkYXRhLmxlbmd0aCB8fCB0aGlzLnJhbmdlQ291bnQpICYmIGRhdGEubGVuZ3RoICE9IHRoaXMucmFuZ2VDb3VudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCB8fCAhdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZSgpLmlzRXF1YWwoZGF0YSk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uaXNFcXVhbChkYXRhW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0aW9uO1xufSgpKTtcblNlbGVjdGlvbi5wcm90b3R5cGUuc2V0U2VsZWN0aW9uQW5jaG9yID0gU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRBbmNob3I7XG5TZWxlY3Rpb24ucHJvdG90eXBlLmdldFNlbGVjdGlvbkFuY2hvciA9IFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0QW5jaG9yO1xuU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25SYW5nZSA9IFNlbGVjdGlvbi5wcm90b3R5cGUuc2V0UmFuZ2U7XG5vb3AuaW1wbGVtZW50KFNlbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLlNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdG9rZW5pemVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL3JlcG9ydF9lcnJvclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciByZXBvcnRFcnJvciA9IHJlcXVpcmUoXCIuL2xpYi9yZXBvcnRfZXJyb3JcIikucmVwb3J0RXJyb3I7XG52YXIgTUFYX1RPS0VOX0NPVU5UID0gMjAwMDtcbnZhciBUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemVyKHJ1bGVzKSB7XG4gICAgICAgIHRoaXMuc3BsaXRSZWdleDtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy5yZWdFeHBzID0ge307XG4gICAgICAgIHRoaXMubWF0Y2hNYXBwaW5ncyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVzW2tleV07XG4gICAgICAgICAgICB2YXIgcnVsZVJlZ0V4cHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXRjaFRvdGFsID0gMDtcbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5tYXRjaE1hcHBpbmdzW2tleV0gPSB7IGRlZmF1bHRUb2tlbjogXCJ0ZXh0XCIgfTtcbiAgICAgICAgICAgIHZhciBmbGFnID0gXCJnXCI7XG4gICAgICAgICAgICB2YXIgc3BsaXR0ZXJSdXJsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHN0YXRlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmRlZmF1bHRUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5kZWZhdWx0VG9rZW4gPSBydWxlLmRlZmF1bHRUb2tlbjtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jYXNlSW5zZW5zaXRpdmUgJiYgZmxhZy5pbmRleE9mKFwiaVwiKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgKz0gXCJpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUudW5pY29kZSAmJiBmbGFnLmluZGV4T2YoXCJ1XCIpID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZmxhZyArPSBcInVcIjtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5yZWdleCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5yZWdleCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5yZWdleCA9IHJ1bGUucmVnZXgudG9TdHJpbmcoKS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkcmVnZXggPSBydWxlLnJlZ2V4O1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGNvdW50ID0gbmV3IFJlZ0V4cChcIig/OihcIiArIGFkanVzdGVkcmVnZXggKyBcIil8KC4pKVwiKS5leGVjKFwiYVwiKS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnRva2VuLmxlbmd0aCA9PSAxIHx8IG1hdGNoY291bnQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IHJ1bGUudG9rZW5bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hjb3VudCAtIDEgIT0gcnVsZS50b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCJudW1iZXIgb2YgY2xhc3NlcyBhbmQgcmVnZXhwIGdyb3VwcyBkb2Vzbid0IG1hdGNoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IG1hdGNoY291bnQgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSBydWxlLnRva2VuWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbkFycmF5ID0gcnVsZS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gdGhpcy4kYXJyYXlUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUudG9rZW4gPT0gXCJmdW5jdGlvblwiICYmICFydWxlLm9uTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoY291bnQgPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gdGhpcy4kYXBwbHlUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gcnVsZS50b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXFxcXFxcZC8udGVzdChydWxlLnJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRyZWdleCA9IHJ1bGUucmVnZXgucmVwbGFjZSgvXFxcXChbMC05XSspL2csIGZ1bmN0aW9uIChtYXRjaCwgZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyAocGFyc2VJbnQoZGlnaXQsIDEwKSArIG1hdGNoVG90YWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZHJlZ2V4ID0gdGhpcy5yZW1vdmVDYXB0dXJpbmdHcm91cHMocnVsZS5yZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlLnNwbGl0UmVnZXggJiYgdHlwZW9mIHJ1bGUudG9rZW4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0dGVyUnVybGVzLnB1c2gocnVsZSk7IC8vIGZsYWcgd2lsbCBiZSBrbm93biBvbmx5IGF0IHRoZSB2ZXJ5IGVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBwaW5nW21hdGNoVG90YWxdID0gaTtcbiAgICAgICAgICAgICAgICBtYXRjaFRvdGFsICs9IG1hdGNoY291bnQ7XG4gICAgICAgICAgICAgICAgcnVsZVJlZ0V4cHMucHVzaChhZGp1c3RlZHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUub25NYXRjaClcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZVJlZ0V4cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZ1swXSA9IDA7XG4gICAgICAgICAgICAgICAgcnVsZVJlZ0V4cHMucHVzaChcIiRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGxpdHRlclJ1cmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5zcGxpdFJlZ2V4ID0gdGhpcy5jcmVhdGVTcGxpdHRlclJlZ2V4cChydWxlLnJlZ2V4LCBmbGFnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWdFeHBzW2tleV0gPSBuZXcgUmVnRXhwKFwiKFwiICsgcnVsZVJlZ0V4cHMuam9pbihcIil8KFwiKSArIFwiKXwoJClcIiwgZmxhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS4kc2V0TWF4VG9rZW5Db3VudCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIE1BWF9UT0tFTl9DT1VOVCA9IG0gfCAwO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS4kYXBwbHlUb2tlbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuc3BsaXRSZWdleC5leGVjKHN0cikuc2xpY2UoMSk7XG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXMudG9rZW4uYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBbeyB0eXBlOiB0eXBlcywgdmFsdWU6IHN0ciB9XTtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSlcbiAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS4kYXJyYXlUb2tlbnMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5zcGxpdFJlZ2V4LmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCF2YWx1ZXMpXG4gICAgICAgICAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbkFycmF5O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpICsgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnJlbW92ZUNhcHR1cmluZ0dyb3VwcyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgdmFyIHIgPSBzcmMucmVwbGFjZSgvXFxcXC58XFxbKD86XFxcXC58W15cXFxcXFxdXSkqfFxcKFxcP1s6PSE8XXwoXFwoKS9nLCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geSA/IFwiKD86XCIgOiB4OyB9KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNyZWF0ZVNwbGl0dGVyUmVnZXhwID0gZnVuY3Rpb24gKHNyYywgZmxhZykge1xuICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIoPz1cIikgIT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IDA7XG4gICAgICAgICAgICB2YXIgaW5DaENsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbGFzdENhcHR1cmUgPSB7fTtcbiAgICAgICAgICAgIHNyYy5yZXBsYWNlKC8oXFxcXC4pfChcXCgoPzpcXD9bPSFdKT8pfChcXCkpfChbXFxbXFxdXSkvZywgZnVuY3Rpb24gKG0sIGVzYywgcGFyZW5PcGVuLCBwYXJlbkNsb3NlLCBzcXVhcmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQ2hDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpbkNoQ2xhc3MgPSBzcXVhcmUgIT0gXCJdXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICBpbkNoQ2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayA9PSBsYXN0Q2FwdHVyZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuZW5kID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuc3RhY2sgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFjay0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbk9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2srKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVuT3Blbi5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDYXB0dXJlLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2FwdHVyZS5lbmQgIT0gbnVsbCAmJiAvXlxcKSokLy50ZXN0KHNyYy5zdWJzdHIobGFzdENhcHR1cmUuZW5kKSkpXG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZygwLCBsYXN0Q2FwdHVyZS5zdGFydCkgKyBzcmMuc3Vic3RyKGxhc3RDYXB0dXJlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5jaGFyQXQoMCkgIT0gXCJeXCIpXG4gICAgICAgICAgICBzcmMgPSBcIl5cIiArIHNyYztcbiAgICAgICAgaWYgKHNyYy5jaGFyQXQoc3JjLmxlbmd0aCAtIDEpICE9IFwiJFwiKVxuICAgICAgICAgICAgc3JjICs9IFwiJFwiO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzcmMsIChmbGFnIHx8IFwiXCIpLnJlcGxhY2UoXCJnXCIsIFwiXCIpKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0TGluZVRva2VucyA9IGZ1bmN0aW9uIChsaW5lLCBzdGFydFN0YXRlKSB7XG4gICAgICAgIGlmIChzdGFydFN0YXRlICYmIHR5cGVvZiBzdGFydFN0YXRlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHN0YXJ0U3RhdGUuc2xpY2UoMCk7XG4gICAgICAgICAgICBzdGFydFN0YXRlID0gc3RhY2tbMF07XG4gICAgICAgICAgICBpZiAoc3RhcnRTdGF0ZSA9PT0gXCIjdG1wXCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U3RhdGUgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gLyoqQHR5cGV7c3RyaW5nfSovIChzdGFydFN0YXRlKSB8fCBcInN0YXJ0XCI7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZXNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMubWF0Y2hNYXBwaW5nc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICB2YXIgcmUgPSB0aGlzLnJlZ0V4cHNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1hdGNoLCB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXRjaEF0dGVtcHRzID0gMDtcbiAgICAgICAgdmFyIHRva2VuID0geyB0eXBlOiBudWxsLCB2YWx1ZTogXCJcIiB9O1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGxpbmUpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hcHBpbmcuZGVmYXVsdFRva2VuO1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICBpZiAoaW5kZXggLSB2YWx1ZS5sZW5ndGggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXggLSB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgKz0gc2tpcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHsgdHlwZTogdHlwZSwgdmFsdWU6IHNraXBwZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpICsgMV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcnVsZSA9IHN0YXRlW21hcHBpbmdbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLm9uTWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBydWxlLm9uTWF0Y2godmFsdWUsIGN1cnJlbnRTdGF0ZSwgc3RhY2ssIGxpbmUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJ1bGUudG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUubmV4dCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBydWxlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBydWxlLm5leHQoY3VycmVudFN0YXRlLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwic3RhdGUgZG9lc24ndCBleGlzdFwiLCBjdXJyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLm1hdGNoTWFwcGluZ3NbY3VycmVudFN0YXRlXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlID0gdGhpcy5yZWdFeHBzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1lTGluZUVuZClcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghcnVsZSB8fCBydWxlLm1lcmdlICE9PSBmYWxzZSkgJiYgdG9rZW4udHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHsgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7IHR5cGU6IG51bGwsIHZhbHVlOiBcIlwiIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHR5cGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPT0gbGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChtYXRjaEF0dGVtcHRzKysgPiBNQVhfVE9LRU5fQ09VTlQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hBdHRlbXB0cyA+IDIgKiBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwiaW5maW5pdGUgbG9vcCB3aXRoIGluIGFjZSB0b2tlbml6ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTdGF0ZTogc3RhcnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChsYXN0SW5kZXggPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGluZS5zdWJzdHJpbmcobGFzdEluZGV4LCBsYXN0SW5kZXggKz0gNTAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib3ZlcmZsb3dcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChzdGFja1swXSAhPT0gY3VycmVudFN0YXRlKVxuICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoXCIjdG1wXCIsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgICAgICAgc3RhdGU6IHN0YWNrLmxlbmd0aCA/IHN0YWNrIDogY3VycmVudFN0YXRlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW5pemVyO1xufSgpKTtcblRva2VuaXplci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RlZXBfY29weVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkZWVwQ29weSA9IHJlcXVpcmUoXCIuLi9saWIvZGVlcF9jb3B5XCIpLmRlZXBDb3B5O1xudmFyIFRleHRIaWdobGlnaHRSdWxlcztcblRleHRIaWdobGlnaHRSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRydWxlcyA9IHtcbiAgICAgICAgXCJzdGFydFwiOiBbe1xuICAgICAgICAgICAgICAgIHRva2VuOiBcImVtcHR5X2xpbmVcIixcbiAgICAgICAgICAgICAgICByZWdleDogJ14kJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRUb2tlbjogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH1dXG4gICAgfTtcbn07XG4oZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkUnVsZXMgPSBmdW5jdGlvbiAocnVsZXMsIHByZWZpeCkge1xuICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMuJHJ1bGVzW2tleV0gPSBydWxlc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHN0YXRlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLm5leHQgfHwgcnVsZS5vbk1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5uZXh0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm5leHQuaW5kZXhPZihwcmVmaXgpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHByZWZpeCArIHJ1bGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0U3RhdGUgJiYgcnVsZS5uZXh0U3RhdGUuaW5kZXhPZihwcmVmaXgpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0U3RhdGUgPSBwcmVmaXggKyBydWxlLm5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRydWxlc1twcmVmaXggKyBrZXldID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0UnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRydWxlcztcbiAgICB9O1xuICAgIHRoaXMuZW1iZWRSdWxlcyA9IGZ1bmN0aW9uIChIaWdobGlnaHRSdWxlcywgcHJlZml4LCBlc2NhcGVSdWxlcywgc3RhdGVzLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGVtYmVkUnVsZXMgPSB0eXBlb2YgSGlnaGxpZ2h0UnVsZXMgPT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IG5ldyBIaWdobGlnaHRSdWxlcygpLmdldFJ1bGVzKClcbiAgICAgICAgICAgIDogSGlnaGxpZ2h0UnVsZXM7XG4gICAgICAgIGlmIChzdGF0ZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlc1tpXSA9IHByZWZpeCArIHN0YXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVtYmVkUnVsZXMpXG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1c2gocHJlZml4ICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFJ1bGVzKGVtYmVkUnVsZXMsIHByZWZpeCk7XG4gICAgICAgIGlmIChlc2NhcGVSdWxlcykge1xuICAgICAgICAgICAgdmFyIGFkZFJ1bGVzID0gQXJyYXkucHJvdG90eXBlW2FwcGVuZCA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYWRkUnVsZXMuYXBwbHkodGhpcy4kcnVsZXNbc3RhdGVzW2ldXSwgZGVlcENvcHkoZXNjYXBlUnVsZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuJGVtYmVkcylcbiAgICAgICAgICAgIHRoaXMuJGVtYmVkcyA9IFtdO1xuICAgICAgICB0aGlzLiRlbWJlZHMucHVzaChwcmVmaXgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRFbWJlZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbWJlZHM7XG4gICAgfTtcbiAgICB2YXIgcHVzaFN0YXRlID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPSBcInN0YXJ0XCIgfHwgc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgc3RhY2sudW5zaGlmdCh0aGlzLm5leHRTdGF0ZSwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFN0YXRlO1xuICAgIH07XG4gICAgdmFyIHBvcFN0YXRlID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnNoaWZ0KCkgfHwgXCJzdGFydFwiO1xuICAgIH07XG4gICAgdGhpcy5ub3JtYWxpemVSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gMDtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy4kcnVsZXM7XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTdGF0ZShrZXkpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICBzdGF0ZVtcInByb2Nlc3NlZFwiXSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBzdGF0ZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9JbnNlcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvSW5zZXJ0ID0gcnVsZTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUucmVnZXggJiYgcnVsZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLnJlZ2V4ID0gcnVsZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlLm5leHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRva2VuOiBydWxlLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBydWxlLnRva2VuICsgXCIuZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogcnVsZS5lbmQgfHwgcnVsZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwicG9wXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSBydWxlLnRva2VuICsgXCIuc3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5wdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBydWxlLm5leHQgfHwgcnVsZS5wdXNoO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IHJ1bGUuc3RhdGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lID0gcnVsZS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lWzBdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbc3RhdGVOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWUgKz0gaWQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBydWxlc1tzdGF0ZU5hbWVdID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gc3RhdGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzU3RhdGUoc3RhdGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PSBcInBvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHBvcFN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5wdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dFN0YXRlID0gcnVsZS5uZXh0IHx8IHJ1bGUucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gcHVzaFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZS5wdXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByIGluIHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tyXS5wdXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlc1tyXS5wdXNoLmFwcGx5KHJ1bGVzW3JdLCBydWxlLnJ1bGVzW3JdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzW3JdID0gcnVsZS5ydWxlc1tyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZU5hbWUgPSB0eXBlb2YgcnVsZSA9PSBcInN0cmluZ1wiID8gcnVsZSA6IHJ1bGUuaW5jbHVkZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVOYW1lID09PSBcIiRzZWxmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlTmFtZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5jbHVkZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9JbnNlcnQgPSBpbmNsdWRlTmFtZS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJ1bGVzW3hdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9JbnNlcnQgPSBydWxlc1tpbmNsdWRlTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b0luc2VydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtpLCAxXS5jb25jYXQodG9JbnNlcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5ub0VzY2FwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gIXgubmV4dDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNwbGljZS5hcHBseShzdGF0ZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUua2V5d29yZE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gdGhpcy5jcmVhdGVLZXl3b3JkTWFwcGVyKHJ1bGUua2V5d29yZE1hcCwgcnVsZS5kZWZhdWx0VG9rZW4gfHwgXCJ0ZXh0XCIsIHJ1bGUuY2FzZUluc2Vuc2l0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGUuZGVmYXVsdFRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhydWxlcykuZm9yRWFjaChwcm9jZXNzU3RhdGUsIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVLZXl3b3JkTWFwcGVyID0gZnVuY3Rpb24gKG1hcCwgZGVmYXVsdFRva2VuLCBpZ25vcmVDYXNlLCBzcGxpdENoYXIpIHtcbiAgICAgICAgdmFyIGtleXdvcmRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy4ka2V5d29yZExpc3QgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBhID0gbWFwW2NsYXNzTmFtZV07XG4gICAgICAgICAgICB2YXIgbGlzdCA9IGEuc3BsaXQoc3BsaXRDaGFyIHx8IFwifFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLiRrZXl3b3JkTGlzdC5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVDYXNlKVxuICAgICAgICAgICAgICAgICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGtleXdvcmRzW3dvcmRdID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgbWFwID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGlnbm9yZUNhc2VcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBrZXl3b3Jkc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCBkZWZhdWx0VG9rZW47IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBrZXl3b3Jkc1t2YWx1ZV0gfHwgZGVmYXVsdFRva2VuOyB9O1xuICAgIH07XG4gICAgdGhpcy5nZXRLZXl3b3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGtleXdvcmRzO1xuICAgIH07XG59KS5jYWxsKFRleHRIaWdobGlnaHRSdWxlcy5wcm90b3R5cGUpO1xuZXhwb3J0cy5UZXh0SGlnaGxpZ2h0UnVsZXMgPSBUZXh0SGlnaGxpZ2h0UnVsZXM7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vZGUvYmVoYXZpb3VyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIEJlaGF2aW91cjtcbkJlaGF2aW91ciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiZWhhdmlvdXJzID0ge307XG59O1xuKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHN3aXRjaCAodW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuJGJlaGF2aW91cnM6XG4gICAgICAgICAgICAgICAgdGhpcy4kYmVoYXZpb3VycyA9IHt9O1xuICAgICAgICAgICAgY2FzZSB0aGlzLiRiZWhhdmlvdXJzW25hbWVdOlxuICAgICAgICAgICAgICAgIHRoaXMuJGJlaGF2aW91cnNbbmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRiZWhhdmlvdXJzW25hbWVdW2FjdGlvbl0gPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHRoaXMuYWRkQmVoYXZpb3VycyA9IGZ1bmN0aW9uIChiZWhhdmlvdXJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBiZWhhdmlvdXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhY3Rpb24gaW4gYmVoYXZpb3Vyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoa2V5LCBhY3Rpb24sIGJlaGF2aW91cnNba2V5XVthY3Rpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy4kYmVoYXZpb3VycyAmJiB0aGlzLiRiZWhhdmlvdXJzW25hbWVdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbmhlcml0ID0gZnVuY3Rpb24gKG1vZGUsIGZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW91cnMgPSBuZXcgbW9kZSgpLmdldEJlaGF2aW91cnMoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiZWhhdmlvdXJzID0gbW9kZS5nZXRCZWhhdmlvdXJzKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRCZWhhdmlvdXJzKGJlaGF2aW91cnMpO1xuICAgIH07XG4gICAgdGhpcy5nZXRCZWhhdmlvdXJzID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGJlaGF2aW91cnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRiZWhhdmlvdXJzW2ZpbHRlcltpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ZpbHRlcltpXV0gPSB0aGlzLiRiZWhhdmlvdXJzW2ZpbHRlcltpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH07XG59KS5jYWxsKEJlaGF2aW91ci5wcm90b3R5cGUpO1xuZXhwb3J0cy5CZWhhdmlvdXIgPSBCZWhhdmlvdXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBUb2tlbkl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuSXRlcmF0b3Ioc2Vzc2lvbiwgaW5pdGlhbFJvdywgaW5pdGlhbENvbHVtbikge1xuICAgICAgICB0aGlzLiRzZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy4kcm93ID0gaW5pdGlhbFJvdztcbiAgICAgICAgdGhpcy4kcm93VG9rZW5zID0gc2Vzc2lvbi5nZXRUb2tlbnMoaW5pdGlhbFJvdyk7XG4gICAgICAgIHZhciB0b2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChpbml0aWFsUm93LCBpbml0aWFsQ29sdW1uKTtcbiAgICAgICAgdGhpcy4kdG9rZW5JbmRleCA9IHRva2VuID8gdG9rZW4uaW5kZXggOiAtMTtcbiAgICB9XG4gICAgVG9rZW5JdGVyYXRvci5wcm90b3R5cGUuc3RlcEJhY2t3YXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiR0b2tlbkluZGV4IC09IDE7XG4gICAgICAgIHdoaWxlICh0aGlzLiR0b2tlbkluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy4kcm93IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy4kcm93IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvdyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRyb3dUb2tlbnMgPSB0aGlzLiRzZXNzaW9uLmdldFRva2Vucyh0aGlzLiRyb3cpO1xuICAgICAgICAgICAgdGhpcy4kdG9rZW5JbmRleCA9IHRoaXMuJHJvd1Rva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XG4gICAgfTtcbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kdG9rZW5JbmRleCArPSAxO1xuICAgICAgICB2YXIgcm93Q291bnQ7XG4gICAgICAgIHdoaWxlICh0aGlzLiR0b2tlbkluZGV4ID49IHRoaXMuJHJvd1Rva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuJHJvdyArPSAxO1xuICAgICAgICAgICAgaWYgKCFyb3dDb3VudClcbiAgICAgICAgICAgICAgICByb3dDb3VudCA9IHRoaXMuJHNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kcm93ID49IHJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcm93ID0gcm93Q291bnQgLSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kcm93VG9rZW5zID0gdGhpcy4kc2Vzc2lvbi5nZXRUb2tlbnModGhpcy4kcm93KTtcbiAgICAgICAgICAgIHRoaXMuJHRva2VuSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XG4gICAgfTtcbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XG4gICAgfTtcbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VG9rZW5Sb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyb3c7XG4gICAgfTtcbiAgICBUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VG9rZW5Db2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dUb2tlbnMgPSB0aGlzLiRyb3dUb2tlbnM7XG4gICAgICAgIHZhciB0b2tlbkluZGV4ID0gdGhpcy4kdG9rZW5JbmRleDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHJvd1Rva2Vuc1t0b2tlbkluZGV4XS5zdGFydDtcbiAgICAgICAgaWYgKGNvbHVtbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKHRva2VuSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbkluZGV4IC09IDE7XG4gICAgICAgICAgICBjb2x1bW4gKz0gcm93VG9rZW5zW3Rva2VuSW5kZXhdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH07XG4gICAgVG9rZW5JdGVyYXRvci5wcm90b3R5cGUuZ2V0Q3VycmVudFRva2VuUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IHJvdzogdGhpcy4kcm93LCBjb2x1bW46IHRoaXMuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgfTtcbiAgICB9O1xuICAgIFRva2VuSXRlcmF0b3IucHJvdG90eXBlLmdldEN1cnJlbnRUb2tlblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuJHJvdywgY29sdW1uLCB0aGlzLiRyb3csIGNvbHVtbiArIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW5JdGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlRva2VuSXRlcmF0b3IgPSBUb2tlbkl0ZXJhdG9yO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL2JlaGF2aW91ci9jc3R5bGVcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbW9kZS9iZWhhdmlvdXJcIixcImFjZS90b2tlbl9pdGVyYXRvclwiLFwiYWNlL2xpYi9sYW5nXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvb29wXCIpO1xudmFyIEJlaGF2aW91ciA9IHJlcXVpcmUoXCIuLi9iZWhhdmlvdXJcIikuQmVoYXZpb3VyO1xudmFyIFRva2VuSXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vLi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uL2xpYi9sYW5nXCIpO1xudmFyIFNBRkVfSU5TRVJUX0lOX1RPS0VOUyA9IFtcInRleHRcIiwgXCJwYXJlbi5ycGFyZW5cIiwgXCJycGFyZW5cIiwgXCJwYXJlblwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCJdO1xudmFyIFNBRkVfSU5TRVJUX0JFRk9SRV9UT0tFTlMgPSBbXCJ0ZXh0XCIsIFwicGFyZW4ucnBhcmVuXCIsIFwicnBhcmVuXCIsIFwicGFyZW5cIiwgXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiLCBcImNvbW1lbnRcIl07XG52YXIgY29udGV4dDtcbnZhciBjb250ZXh0Q2FjaGUgPSB7fTtcbnZhciBkZWZhdWx0UXVvdGVzID0geyAnXCInOiAnXCInLCBcIidcIjogXCInXCIgfTtcbnZhciBpbml0Q29udGV4dCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICB2YXIgaWQgPSAtMTtcbiAgICBpZiAoZWRpdG9yLm11bHRpU2VsZWN0KSB7XG4gICAgICAgIGlkID0gZWRpdG9yLnNlbGVjdGlvbi5pbmRleDtcbiAgICAgICAgaWYgKGNvbnRleHRDYWNoZS5yYW5nZUNvdW50ICE9IGVkaXRvci5tdWx0aVNlbGVjdC5yYW5nZUNvdW50KVxuICAgICAgICAgICAgY29udGV4dENhY2hlID0geyByYW5nZUNvdW50OiBlZGl0b3IubXVsdGlTZWxlY3QucmFuZ2VDb3VudCB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dENhY2hlW2lkXSlcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPSBjb250ZXh0Q2FjaGVbaWRdO1xuICAgIGNvbnRleHQgPSBjb250ZXh0Q2FjaGVbaWRdID0ge1xuICAgICAgICBhdXRvSW5zZXJ0ZWRCcmFja2V0czogMCxcbiAgICAgICAgYXV0b0luc2VydGVkUm93OiAtMSxcbiAgICAgICAgYXV0b0luc2VydGVkTGluZUVuZDogXCJcIixcbiAgICAgICAgbWF5YmVJbnNlcnRlZEJyYWNrZXRzOiAwLFxuICAgICAgICBtYXliZUluc2VydGVkUm93OiAtMSxcbiAgICAgICAgbWF5YmVJbnNlcnRlZExpbmVTdGFydDogXCJcIixcbiAgICAgICAgbWF5YmVJbnNlcnRlZExpbmVFbmQ6IFwiXCJcbiAgICB9O1xufTtcbnZhciBnZXRXcmFwcGVkID0gZnVuY3Rpb24gKHNlbGVjdGlvbiwgc2VsZWN0ZWQsIG9wZW5pbmcsIGNsb3NpbmcpIHtcbiAgICB2YXIgcm93RGlmZiA9IHNlbGVjdGlvbi5lbmQucm93IC0gc2VsZWN0aW9uLnN0YXJ0LnJvdztcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBvcGVuaW5nICsgc2VsZWN0ZWQgKyBjbG9zaW5nLFxuICAgICAgICBzZWxlY3Rpb246IFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzZWxlY3Rpb24uc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIHJvd0RpZmYsXG4gICAgICAgICAgICBzZWxlY3Rpb24uZW5kLmNvbHVtbiArIChyb3dEaWZmID8gMCA6IDEpXG4gICAgICAgIF1cbiAgICB9O1xufTtcbnZhciBDc3R5bGVCZWhhdmlvdXI7XG5Dc3R5bGVCZWhhdmlvdXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuYWRkKFwiYnJhY2VzXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgIGlmICh0ZXh0ID09ICd7Jykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gc2Vzc2lvbi5nZXRUb2tlbkF0KGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICE9PSBcIlwiICYmIHNlbGVjdGVkICE9PSBcIntcIiAmJiBlZGl0b3IuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZChzZWxlY3Rpb24sIHNlbGVjdGVkLCAneycsICd9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiAmJiAvKD86c3RyaW5nKVxcLnF1YXNpfFxcLnhtbC8udGVzdCh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBleGNsdWRlVG9rZW5zID0gW1xuICAgICAgICAgICAgICAgICAgICAvdGFnXFwtKD86b3BlbnxuYW1lKS8sIC9hdHRyaWJ1dGVcXC1uYW1lL1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVUb2tlbnMuc29tZShmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnRlc3QodG9rZW4udHlwZSk7IH0pIHx8IC8oc3RyaW5nKVxcLnF1YXNpLy50ZXN0KHRva2VuLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICYmIHRva2VuLnZhbHVlW2N1cnNvci5jb2x1bW4gLSB0b2tlbi5zdGFydCAtIDFdICE9PSAnJCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwifVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAne30nLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoL1tcXF1cXH1cXCldLy50ZXN0KGxpbmVbY3Vyc29yLmNvbHVtbl0pIHx8IGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSB8fCBvcHRpb25zLmJyYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7fScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnJlY29yZE1heWJlSW5zZXJ0KGVkaXRvciwgc2Vzc2lvbiwgXCJ7XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3snLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSAnfScpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnfScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBzZXNzaW9uLiRmaW5kT3BlbmluZ0JyYWNrZXQoJ30nLCB7IGNvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvdyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmcgIT09IG51bGwgJiYgQ3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUsIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5wb3BBdXRvSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCJcXG5cIiB8fCB0ZXh0ID09IFwiXFxyXFxuXCIpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgY2xvc2luZyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoQ3N0eWxlQmVoYXZpb3VyLmlzTWF5YmVJbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lKSkge1xuICAgICAgICAgICAgICAgIGNsb3NpbmcgPSBsYW5nLnN0cmluZ1JlcGVhdChcIn1cIiwgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMpO1xuICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5jbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5CcmFjZVBvcyA9IHNlc3Npb24uZmluZE1hdGNoaW5nQnJhY2tldCh7IHJvdzogY3Vyc29yLnJvdywgY29sdW1uOiBjdXJzb3IuY29sdW1uICsgMSB9LCAnfScpO1xuICAgICAgICAgICAgICAgIGlmICghb3BlbkJyYWNlUG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF9pbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQoc2Vzc2lvbi5nZXRMaW5lKG9wZW5CcmFjZVBvcy5yb3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF9pbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBuZXh0X2luZGVudCArIHNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdcXG4nICsgaW5kZW50ICsgJ1xcbicgKyBuZXh0X2luZGVudCArIGNsb3NpbmcsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgaW5kZW50Lmxlbmd0aCwgMSwgaW5kZW50Lmxlbmd0aF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJicmFjZXNcIiwgXCJkZWxldGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCByYW5nZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJ3snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2UuZW5kLmNvbHVtbiwgcmFuZ2UuZW5kLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnfScpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkKFwicGFyZW5zXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gJygnKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWQoc2VsZWN0aW9uLCBzZWxlY3RlZCwgJygnLCAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQ3N0eWxlQmVoYXZpb3VyLmlzU2FuZUluc2VydGlvbihlZGl0b3IsIHNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnJlY29yZEF1dG9JbnNlcnQoZWRpdG9yLCBzZXNzaW9uLCBcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJygpJyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gJyknKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcbiAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCcpJywgeyBjb2x1bW46IGN1cnNvci5jb2x1bW4gKyAxLCByb3c6IGN1cnNvci5yb3cgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nICE9PSBudWxsICYmIENzdHlsZUJlaGF2aW91ci5pc0F1dG9JbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lLCB0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkKFwicGFyZW5zXCIsIFwiZGVsZXRpb25cIiwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIHNlbGVjdGVkID09ICcoJykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnKScpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJicmFja2V0c1wiLCBcImluc2VydGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09ICdbJykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShzZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICE9PSBcIlwiICYmIGVkaXRvci5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXcmFwcGVkKHNlbGVjdGlvbiwgc2VsZWN0ZWQsICdbJywgJ10nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKENzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24oZWRpdG9yLCBzZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRBdXRvSW5zZXJ0KGVkaXRvciwgc2Vzc2lvbiwgXCJdXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdbXScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09ICddJykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09ICddJykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IHNlc3Npb24uJGZpbmRPcGVuaW5nQnJhY2tldCgnXScsIHsgY29sdW1uOiBjdXJzb3IuY29sdW1uICsgMSwgcm93OiBjdXJzb3Iucm93IH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZyAhPT0gbnVsbCAmJiBDc3R5bGVCZWhhdmlvdXIuaXNBdXRvSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSwgdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnBvcEF1dG9JbnNlcnRlZENsb3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChcImJyYWNrZXRzXCIsIFwiZGVsZXRpb25cIiwgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIHNlbGVjdGVkID09ICdbJykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnXScpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJzdHJpbmdfZHF1b3Rlc1wiLCBcImluc2VydGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCB0ZXh0KSB7XG4gICAgICAgIHZhciBxdW90ZXMgPSBzZXNzaW9uLiRtb2RlLiRxdW90ZXMgfHwgZGVmYXVsdFF1b3RlcztcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgcXVvdGVzW3RleHRdKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lQ29tbWVudFN0YXJ0ICYmIHRoaXMubGluZUNvbW1lbnRTdGFydC5pbmRleE9mKHRleHQpICE9IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgcXVvdGUgPSB0ZXh0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgKHNlbGVjdGVkLmxlbmd0aCAhPSAxIHx8ICFxdW90ZXNbc2VsZWN0ZWRdKSAmJiBlZGl0b3IuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZChzZWxlY3Rpb24sIHNlbGVjdGVkLCBxdW90ZSwgcXVvdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uIC0gMSwgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzZXNzaW9uLmdldFRva2VuQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0VG9rZW4gPSBzZXNzaW9uLmdldFRva2VuQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0Q2hhciA9PSBcIlxcXFxcIiAmJiB0b2tlbiAmJiAvZXNjYXBlLy50ZXN0KHRva2VuLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nQmVmb3JlID0gdG9rZW4gJiYgL3N0cmluZ3xlc2NhcGUvLnRlc3QodG9rZW4udHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0FmdGVyID0gIXJpZ2h0VG9rZW4gfHwgL3N0cmluZ3xlc2NhcGUvLnRlc3QocmlnaHRUb2tlbi50eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFpcjtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRDaGFyID09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSBzdHJpbmdCZWZvcmUgIT09IHN0cmluZ0FmdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFpciAmJiAvc3RyaW5nXFwuZW5kLy50ZXN0KHJpZ2h0VG9rZW4udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nQmVmb3JlICYmICFzdHJpbmdBZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyB3cmFwIHN0cmluZyB3aXRoIGRpZmZlcmVudCBxdW90ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nQmVmb3JlICYmIHN0cmluZ0FmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvIG5vdCBwYWlyIHF1b3RlcyBpbnNpZGUgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICB2YXIgd29yZFJlID0gc2Vzc2lvbi4kbW9kZS50b2tlblJlO1xuICAgICAgICAgICAgICAgICAgICB3b3JkUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzV29yZEJlZm9yZSA9IHdvcmRSZS50ZXN0KGxlZnRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgd29yZFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1dvcmRBZnRlciA9IHdvcmRSZS50ZXN0KHJpZ2h0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyUXVvdGVzQWZ0ZXIgPSBzZXNzaW9uLiRtb2RlLiRwYWlyUXVvdGVzQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRQYWlyUXVvdGVzID0gcGFpclF1b3Rlc0FmdGVyICYmIHBhaXJRdW90ZXNBZnRlcltxdW90ZV0gJiYgcGFpclF1b3Rlc0FmdGVyW3F1b3RlXS50ZXN0KGxlZnRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghc2hvdWxkUGFpclF1b3RlcyAmJiBpc1dvcmRCZWZvcmUpIHx8IGlzV29yZEFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGJlZm9yZSBvciBhZnRlciBhbHBoYW51bWVyaWNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciAmJiAhL1tcXHM7LC59KVxcXVxcXFxdLy50ZXN0KHJpZ2h0Q2hhcikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhlcmUgaXMgcmlnaHRDaGFyIGFuZCBpdCBpc24ndCBjbG9zaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQmVmb3JlID0gbGluZVtjdXJzb3IuY29sdW1uIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Q2hhciA9PSBxdW90ZSAmJiAoY2hhckJlZm9yZSA9PSBxdW90ZSB8fCB3b3JkUmUudGVzdChjaGFyQmVmb3JlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcGFpciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhaXIgPyBxdW90ZSArIHF1b3RlIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGQoXCJzdHJpbmdfZHF1b3Rlc1wiLCBcImRlbGV0aW9uXCIsIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHJhbmdlKSB7XG4gICAgICAgIHZhciBxdW90ZXMgPSBzZXNzaW9uLiRtb2RlLiRxdW90ZXMgfHwgZGVmYXVsdFF1b3RlcztcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIHF1b3Rlcy5oYXNPd25Qcm9wZXJ0eShzZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4gKyAxLCByYW5nZS5zdGFydC5jb2x1bW4gKyAyKTtcbiAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuY2xvc2VEb2NDb21tZW50ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZChcImRvYyBjb21tZW50IGVuZFwiLCBcImluc2VydGlvblwiLCBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCB0ZXh0KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZG9jLXN0YXJ0XCIgJiYgKHRleHQgPT09IFwiXFxuXCIgfHwgdGV4dCA9PT0gXCJcXHJcXG5cIikgJiYgZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5jb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKGN1cnNvci5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gdG9rZW5zW2ldLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGN1cnNvci5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gY3Vyc29yLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghL1xcLmRvYy8udGVzdChjdXJyZW50VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcKlxcLy8udGVzdChjdXJyZW50VG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0b2tlbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRUb2tlbiB8fCAhL1xcLmRvYy8udGVzdChuZXh0VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JQb3NJblRva2VuID0gY3Vyc29yLmNvbHVtbiAtIChpbmRleCAtIGN1cnJlbnRUb2tlbi52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlRG9jUG9zID0gY3VycmVudFRva2VuLnZhbHVlLmluZGV4T2YoXCIqL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuRG9jUG9zID0gY3VycmVudFRva2VuLnZhbHVlLmluZGV4T2YoXCIvKipcIiwgY2xvc2VEb2NQb3MgPiAtMSA/IGNsb3NlRG9jUG9zICsgMiA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5Eb2NQb3MgIT09IC0xICYmIGN1cnNvclBvc0luVG9rZW4gPiBvcGVuRG9jUG9zICYmIGN1cnNvclBvc0luVG9rZW4gPCBvcGVuRG9jUG9zICsgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZURvY1BvcyAhPT0gLTEgJiYgb3BlbkRvY1BvcyAhPT0gLTEgJiYgY3Vyc29yUG9zSW5Ub2tlbiA+PSBjbG9zZURvY1Bvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGN1cnNvclBvc0luVG9rZW4gPD0gb3BlbkRvY1BvcyB8fCAhL1xcLmRvYy8udGVzdChjdXJyZW50VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy4kZ2V0SW5kZW50KGxpbmUpO1xuICAgICAgICAgICAgICAgIGlmICgvXFxzKlxcKi8udGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxzKlxcKi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0ICsgaW5kZW50ICsgXCIqIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDIgKyBpbmRlbnQubGVuZ3RoLCAxLCAyICsgaW5kZW50Lmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQgKyBpbmRlbnQgKyBcIiAqIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDMgKyBpbmRlbnQubGVuZ3RoLCAxLCAzICsgaW5kZW50Lmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9cXC9cXCpcXCovLnRlc3QobGluZS5zdWJzdHJpbmcoMCwgY3Vyc29yLmNvbHVtbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0ICsgaW5kZW50ICsgXCIgKiBcIiArIHRleHQgKyBcIiBcIiArIGluZGVudCArIFwiKi9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDQgKyBpbmRlbnQubGVuZ3RoLCAxLCA0ICsgaW5kZW50Lmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5Dc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uID0gZnVuY3Rpb24gKGVkaXRvciwgc2Vzc2lvbikge1xuICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICBpZiAoIXRoaXMuJG1hdGNoVG9rZW5UeXBlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpIHx8IFwidGV4dFwiLCBTQUZFX0lOU0VSVF9JTl9UT0tFTlMpKSB7XG4gICAgICAgIGlmICgvWyl9XFxdXS8udGVzdChlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpW2N1cnNvci5jb2x1bW5dKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgaXRlcmF0b3IyID0gbmV3IFRva2VuSXRlcmF0b3Ioc2Vzc2lvbiwgY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICBpZiAoIXRoaXMuJG1hdGNoVG9rZW5UeXBlKGl0ZXJhdG9yMi5nZXRDdXJyZW50VG9rZW4oKSB8fCBcInRleHRcIiwgU0FGRV9JTlNFUlRfSU5fVE9LRU5TKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICByZXR1cm4gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCkgIT09IGN1cnNvci5yb3cgfHxcbiAgICAgICAgdGhpcy4kbWF0Y2hUb2tlblR5cGUoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCkgfHwgXCJ0ZXh0XCIsIFNBRkVfSU5TRVJUX0JFRk9SRV9UT0tFTlMpO1xufTtcbkNzdHlsZUJlaGF2aW91cltcIiRtYXRjaFRva2VuVHlwZVwiXSA9IGZ1bmN0aW9uICh0b2tlbiwgdHlwZXMpIHtcbiAgICByZXR1cm4gdHlwZXMuaW5kZXhPZih0b2tlbi50eXBlIHx8IHRva2VuKSA+IC0xO1xufTtcbkNzdHlsZUJlaGF2aW91cltcInJlY29yZEF1dG9JbnNlcnRcIl0gPSBmdW5jdGlvbiAoZWRpdG9yLCBzZXNzaW9uLCBicmFja2V0KSB7XG4gICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICBpZiAoIXRoaXNbXCJpc0F1dG9JbnNlcnRlZENsb3NpbmdcIl0oY3Vyc29yLCBsaW5lLCBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmRbMF0pKVxuICAgICAgICBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzID0gMDtcbiAgICBjb250ZXh0LmF1dG9JbnNlcnRlZFJvdyA9IGN1cnNvci5yb3c7XG4gICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kID0gYnJhY2tldCArIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xuICAgIGNvbnRleHQuYXV0b0luc2VydGVkQnJhY2tldHMrKztcbn07XG5Dc3R5bGVCZWhhdmlvdXJbXCJyZWNvcmRNYXliZUluc2VydFwiXSA9IGZ1bmN0aW9uIChlZGl0b3IsIHNlc3Npb24sIGJyYWNrZXQpIHtcbiAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgIGlmICghdGhpc1tcImlzTWF5YmVJbnNlcnRlZENsb3NpbmdcIl0oY3Vyc29yLCBsaW5lKSlcbiAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMgPSAwO1xuICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZFJvdyA9IGN1cnNvci5yb3c7XG4gICAgY29udGV4dC5tYXliZUluc2VydGVkTGluZVN0YXJ0ID0gbGluZS5zdWJzdHIoMCwgY3Vyc29yLmNvbHVtbikgKyBicmFja2V0O1xuICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZExpbmVFbmQgPSBsaW5lLnN1YnN0cihjdXJzb3IuY29sdW1uKTtcbiAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cysrO1xufTtcbkNzdHlsZUJlaGF2aW91cltcImlzQXV0b0luc2VydGVkQ2xvc2luZ1wiXSA9IGZ1bmN0aW9uIChjdXJzb3IsIGxpbmUsIGJyYWNrZXQpIHtcbiAgICByZXR1cm4gY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cyA+IDAgJiZcbiAgICAgICAgY3Vyc29yLnJvdyA9PT0gY29udGV4dC5hdXRvSW5zZXJ0ZWRSb3cgJiZcbiAgICAgICAgYnJhY2tldCA9PT0gY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kWzBdICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQ7XG59O1xuQ3N0eWxlQmVoYXZpb3VyW1wiaXNNYXliZUluc2VydGVkQ2xvc2luZ1wiXSA9IGZ1bmN0aW9uIChjdXJzb3IsIGxpbmUpIHtcbiAgICByZXR1cm4gY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMgPiAwICYmXG4gICAgICAgIGN1cnNvci5yb3cgPT09IGNvbnRleHQubWF5YmVJbnNlcnRlZFJvdyAmJlxuICAgICAgICBsaW5lLnN1YnN0cihjdXJzb3IuY29sdW1uKSA9PT0gY29udGV4dC5tYXliZUluc2VydGVkTGluZUVuZCAmJlxuICAgICAgICBsaW5lLnN1YnN0cigwLCBjdXJzb3IuY29sdW1uKSA9PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lU3RhcnQ7XG59O1xuQ3N0eWxlQmVoYXZpb3VyW1wicG9wQXV0b0luc2VydGVkQ2xvc2luZ1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQgPSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQuc3Vic3RyKDEpO1xuICAgIGNvbnRleHQuYXV0b0luc2VydGVkQnJhY2tldHMtLTtcbn07XG5Dc3R5bGVCZWhhdmlvdXJbXCJjbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nXCJdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzID0gMDtcbiAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkUm93ID0gLTE7XG4gICAgfVxufTtcbm9vcC5pbmhlcml0cyhDc3R5bGVCZWhhdmlvdXIsIEJlaGF2aW91cik7XG5leHBvcnRzLkNzdHlsZUJlaGF2aW91ciA9IENzdHlsZUJlaGF2aW91cjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdW5pY29kZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciB3b3JkQ2hhcnMgPSBbNDgsIDksIDgsIDI1LCA1LCAwLCAyLCAyNSwgNDgsIDAsIDExLCAwLCA1LCAwLCA2LCAyMiwgMiwgMzAsIDIsIDQ1NywgNSwgMTEsIDE1LCA0LCA4LCAwLCAyLCAwLCAxOCwgMTE2LCAyLCAxLCAzLCAzLCA5LCAwLCAyLCAyLCAyLCAwLCAyLCAxOSwgMiwgODIsIDIsIDEzOCwgMiwgNCwgMywgMTU1LCAxMiwgMzcsIDMsIDAsIDgsIDM4LCAxMCwgNDQsIDIsIDAsIDIsIDEsIDIsIDEsIDIsIDAsIDksIDI2LCA2LCAyLCAzMCwgMTAsIDcsIDYxLCAyLCA5LCA1LCAxMDEsIDIsIDcsIDMsIDksIDIsIDE4LCAzLCAwLCAxNywgNTgsIDMsIDEwMCwgMTUsIDUzLCA1LCAwLCA2LCA0NSwgMjExLCA1NywgMywgMTgsIDIsIDUsIDMsIDExLCAzLCA5LCAyLCAxLCA3LCA2LCAyLCAyLCAyLCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMCwgNCwgMywgMywgOCwgMywgMSwgMywgMywgOSwgMCwgNSwgMSwgMiwgNCwgMywgMTEsIDE2LCAyLCAyLCA1LCA1LCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgMSwgMiwgMSwgMywgMCwgMiwgNCwgNSwgMSwgMywgMiwgNCwgMCwgOCwgMywgMiwgMCwgOCwgMTUsIDEyLCAyLCAyLCA4LCAyLCAyLCAyLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgMywgOSwgMiwgMiwgMiwgMiwgMywgMCwgMTYsIDMsIDMsIDksIDE4LCAyLCAyLCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgMywgOCwgMywgMSwgMywgMiwgOSwgMSwgNSwgMSwgMiwgNCwgMywgOSwgMiwgMCwgMTcsIDEsIDIsIDUsIDQsIDIsIDIsIDMsIDQsIDEsIDIsIDAsIDIsIDEsIDQsIDEsIDQsIDIsIDQsIDExLCA1LCA0LCA0LCAyLCAyLCAzLCAzLCAwLCA3LCAwLCAxNSwgOSwgMTgsIDIsIDIsIDcsIDIsIDIsIDIsIDIyLCAyLCA5LCAyLCA0LCA0LCA3LCAyLCAyLCAyLCAzLCA4LCAxLCAyLCAxLCA3LCAzLCAzLCA5LCAxOSwgMSwgMiwgNywgMiwgMiwgMiwgMjIsIDIsIDksIDIsIDQsIDMsIDgsIDIsIDIsIDIsIDMsIDgsIDEsIDgsIDAsIDIsIDMsIDMsIDksIDE5LCAxLCAyLCA3LCAyLCAyLCAyLCAyMiwgMiwgMTUsIDQsIDcsIDIsIDIsIDIsIDMsIDEwLCAwLCA5LCAzLCAzLCA5LCAxMSwgNSwgMywgMSwgMiwgMTcsIDQsIDIzLCAyLCA4LCAyLCAwLCAzLCA2LCA0LCAwLCA1LCA1LCAyLCAwLCAyLCA3LCAxOSwgMSwgMTQsIDU3LCA2LCAxNCwgMiwgOSwgNDAsIDEsIDIsIDAsIDMsIDEsIDIsIDAsIDMsIDAsIDcsIDMsIDIsIDYsIDIsIDIsIDIsIDAsIDIsIDAsIDMsIDEsIDIsIDEyLCAyLCAyLCAzLCA0LCAyLCAwLCAyLCA1LCAzLCA5LCAzLCAxLCAzNSwgMCwgMjQsIDEsIDcsIDksIDEyLCAwLCAyLCAwLCAyLCAwLCA1LCA5LCAyLCAzNSwgNSwgMTksIDIsIDUsIDUsIDcsIDIsIDM1LCAxMCwgMCwgNTgsIDczLCA3LCA3NywgMywgMzcsIDExLCA0MiwgMiwgMCwgNCwgMzI4LCAyLCAzLCAzLCA2LCAyLCAwLCAyLCAzLCAzLCA0MCwgMiwgMywgMywgMzIsIDIsIDMsIDMsIDYsIDIsIDAsIDIsIDMsIDMsIDE0LCAyLCA1NiwgMiwgMywgMywgNjYsIDUsIDAsIDMzLCAxNSwgMTcsIDg0LCAxMywgNjE5LCAzLCAxNiwgMiwgMjUsIDYsIDc0LCAyMiwgMTIsIDIsIDYsIDEyLCAyMCwgMTIsIDE5LCAxMywgMTIsIDIsIDIsIDIsIDEsIDEzLCA1MSwgMywgMjksIDQsIDAsIDUsIDEsIDMsIDksIDM0LCAyLCAzLCA5LCA3LCA4NywgOSwgNDIsIDYsIDY5LCAxMSwgMjgsIDQsIDExLCA1LCAxMSwgMTEsIDM5LCAzLCA0LCAxMiwgNDMsIDUsIDI1LCA3LCAxMCwgMzgsIDI3LCA1LCA2MiwgMiwgMjgsIDMsIDEwLCA3LCA5LCAxNCwgMCwgODksIDc1LCA1LCA5LCAxOCwgOCwgMTMsIDQyLCA0LCAxMSwgNzEsIDU1LCA5LCA5LCA0LCA0OCwgODMsIDIsIDIsIDMwLCAxNCwgMjMwLCAyMywgMjgwLCAzLCA1LCAzLCAzNywgMywgNSwgMywgNywgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMzAsIDMsIDUyLCAyLCA2LCAyLCAwLCA0LCAyLCAyLCA2LCA0LCAzLCAzLCA1LCA1LCAxMiwgNiwgMiwgMiwgNiwgNjcsIDEsIDIwLCAwLCAyOSwgMCwgMTQsIDAsIDE3LCA0LCA2MCwgMTIsIDUsIDAsIDQsIDExLCAxOCwgMCwgNSwgMCwgMywgOSwgMiwgMCwgNCwgNCwgNywgMCwgMiwgMCwgMiwgMCwgMiwgMywgMiwgMTAsIDMsIDMsIDYsIDQsIDUsIDAsIDUzLCAxLCAyNjg0LCA0NiwgMiwgNDYsIDIsIDEzMiwgNywgNiwgMTUsIDM3LCAxMSwgNTMsIDEwLCAwLCAxNywgMjIsIDEwLCA2LCAyLCA2LCAyLCA2LCAyLCA2LCAyLCA2LCAyLCA2LCAyLCA2LCAyLCA2LCAyLCAzMSwgNDgsIDAsIDQ3MCwgMSwgMzYsIDUsIDIsIDQsIDYsIDEsIDUsIDg1LCAzLCAxLCAzLCAyLCAyLCA4OSwgMiwgMywgNiwgNDAsIDQsIDkzLCAxOCwgMjMsIDU3LCAxNSwgNTEzLCA2NTgxLCA3NSwgMjA5MzksIDUzLCAxMTY0LCA2OCwgNDUsIDMsIDI2OCwgNCwgMjcsIDIxLCAzMSwgMywgMTMsIDEzLCAxLCAyLCAyNCwgOSwgNjksIDExLCAxLCAzOCwgOCwgMywgMTAyLCAzLCAxLCAxMTEsIDQ0LCAyNSwgNTEsIDEzLCA2OCwgMTIsIDksIDcsIDIzLCA0LCAwLCA1LCA0NSwgMywgMzUsIDEzLCAyOCwgNCwgNjQsIDE1LCAxMCwgMzksIDU0LCAxMCwgMTMsIDMsIDksIDcsIDIyLCA0LCAxLCA1LCA2NiwgMjUsIDIsIDIyNywgNDIsIDIsIDEsIDMsIDksIDcsIDExMTcxLCAxMywgMjIsIDUsIDQ4LCA4NDUzLCAzMDEsIDMsIDYxLCAzLCAxMDUsIDM5LCA2LCAxMywgNCwgNiwgMTEsIDIsIDEyLCAyLCA0LCAyLCAwLCAyLCAxLCAyLCAxLCAyLCAxMDcsIDM0LCAzNjIsIDE5LCA2MywgMywgNTMsIDQxLCAxMSwgNSwgMTUsIDE3LCA2LCAxMywgMSwgMjUsIDIsIDMzLCA0LCAyLCAxMzQsIDIwLCA5LCA4LCAyNSwgNSwgMCwgMiwgMjUsIDEyLCA4OCwgNCwgNSwgMywgNSwgMywgNSwgMywgMl07XG52YXIgY29kZSA9IDA7XG52YXIgc3RyID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHN0ci5wdXNoKGNvZGUgKz0gd29yZENoYXJzW2ldKTtcbiAgICBpZiAod29yZENoYXJzW2kgKyAxXSlcbiAgICAgICAgc3RyLnB1c2goNDUsIGNvZGUgKz0gd29yZENoYXJzW2kgKyAxXSk7XG59XG5leHBvcnRzLndvcmRDaGFycyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgc3RyKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS90ZXh0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvdG9rZW5pemVyXCIsXCJhY2UvbW9kZS90ZXh0X2hpZ2hsaWdodF9ydWxlc1wiLFwiYWNlL21vZGUvYmVoYXZpb3VyL2NzdHlsZVwiLFwiYWNlL3VuaWNvZGVcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBUb2tlbml6ZXIgPSByZXF1aXJlKFwiLi4vdG9rZW5pemVyXCIpLlRva2VuaXplcjtcbnZhciBUZXh0SGlnaGxpZ2h0UnVsZXMgPSByZXF1aXJlKFwiLi90ZXh0X2hpZ2hsaWdodF9ydWxlc1wiKS5UZXh0SGlnaGxpZ2h0UnVsZXM7XG52YXIgQ3N0eWxlQmVoYXZpb3VyID0gcmVxdWlyZShcIi4vYmVoYXZpb3VyL2NzdHlsZVwiKS5Dc3R5bGVCZWhhdmlvdXI7XG52YXIgdW5pY29kZSA9IHJlcXVpcmUoXCIuLi91bmljb2RlXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgVG9rZW5JdGVyYXRvciA9IHJlcXVpcmUoXCIuLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIE1vZGU7XG5Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuSGlnaGxpZ2h0UnVsZXMgPSBUZXh0SGlnaGxpZ2h0UnVsZXM7XG59O1xuKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRkZWZhdWx0QmVoYXZpb3VyID0gbmV3IENzdHlsZUJlaGF2aW91cigpO1xuICAgIHRoaXMudG9rZW5SZSA9IG5ldyBSZWdFeHAoXCJeW1wiICsgdW5pY29kZS53b3JkQ2hhcnMgKyBcIlxcXFwkX10rXCIsIFwiZ1wiKTtcbiAgICB0aGlzLm5vblRva2VuUmUgPSBuZXcgUmVnRXhwKFwiXig/OlteXCIgKyB1bmljb2RlLndvcmRDaGFycyArIFwiXFxcXCRfXXxcXFxcc10pK1wiLCBcImdcIik7XG4gICAgdGhpcy5nZXRUb2tlbml6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG9rZW5pemVyKSB7XG4gICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRSdWxlcyA9IHRoaXMuJGhpZ2hsaWdodFJ1bGVzIHx8IG5ldyB0aGlzLkhpZ2hsaWdodFJ1bGVzKHRoaXMuJGhpZ2hsaWdodFJ1bGVDb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kdG9rZW5pemVyID0gbmV3IFRva2VuaXplcih0aGlzLiRoaWdobGlnaHRSdWxlcy5nZXRSdWxlcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kdG9rZW5pemVyO1xuICAgIH07XG4gICAgdGhpcy5saW5lQ29tbWVudFN0YXJ0ID0gXCJcIjtcbiAgICB0aGlzLmJsb2NrQ29tbWVudCA9IFwiXCI7XG4gICAgdGhpcy50b2dnbGVDb21tZW50TGluZXMgPSBmdW5jdGlvbiAoc3RhdGUsIHNlc3Npb24sIHN0YXJ0Um93LCBlbmRSb3cpIHtcbiAgICAgICAgdmFyIGRvYyA9IHNlc3Npb24uZG9jO1xuICAgICAgICB2YXIgaWdub3JlQmxhbmtMaW5lcyA9IHRydWU7XG4gICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSB0cnVlO1xuICAgICAgICB2YXIgbWluSW5kZW50ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB0YWJTaXplID0gc2Vzc2lvbi5nZXRUYWJTaXplKCk7XG4gICAgICAgIHZhciBpbnNlcnRBdFRhYlN0b3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVDb21tZW50U3RhcnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ibG9ja0NvbW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50U3RhcnQgPSB0aGlzLmJsb2NrQ29tbWVudC5zdGFydDtcbiAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudEVuZCA9IHRoaXMuYmxvY2tDb21tZW50LmVuZDtcbiAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKikoPzpcIiArIGxhbmcuZXNjYXBlUmVnRXhwKGxpbmVDb21tZW50U3RhcnQpICsgXCIpXCIpO1xuICAgICAgICAgICAgdmFyIHJlZ2V4cEVuZCA9IG5ldyBSZWdFeHAoXCIoPzpcIiArIGxhbmcuZXNjYXBlUmVnRXhwKGxpbmVDb21tZW50RW5kKSArIFwiKVxcXFxzKiRcIik7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RSZW1vdmUobGluZSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUJsYW5rTGluZXMgfHwgL1xcUy8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0SW5MaW5lKHsgcm93OiBpLCBjb2x1bW46IGxpbmUubGVuZ3RoIH0sIGxpbmVDb21tZW50RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7IHJvdzogaSwgY29sdW1uOiBtaW5JbmRlbnQgfSwgbGluZUNvbW1lbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1bmNvbW1lbnQgPSBmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBtO1xuICAgICAgICAgICAgICAgIGlmIChtID0gbGluZS5tYXRjaChyZWdleHBFbmQpKVxuICAgICAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIGxpbmUubGVuZ3RoIC0gbVswXS5sZW5ndGgsIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobSA9IGxpbmUubWF0Y2gocmVnZXhwU3RhcnQpKVxuICAgICAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIG1bMV0ubGVuZ3RoLCBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRlc3RSZW1vdmUgPSBmdW5jdGlvbiAobGluZSwgcm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4cFN0YXJ0LnRlc3QobGluZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gXCJjb21tZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saW5lQ29tbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IHRoaXMubGluZUNvbW1lbnRTdGFydC5tYXAobGFuZy5lc2NhcGVSZWdFeHApLmpvaW4oXCJ8XCIpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudFN0YXJ0ID0gdGhpcy5saW5lQ29tbWVudFN0YXJ0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cFN0YXJ0ID0gbGFuZy5lc2NhcGVSZWdFeHAodGhpcy5saW5lQ29tbWVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZUNvbW1lbnRTdGFydCA9IHRoaXMubGluZUNvbW1lbnRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2V4cFN0YXJ0ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKSg/OlwiICsgcmVnZXhwU3RhcnQgKyBcIikgP1wiKTtcbiAgICAgICAgICAgIGluc2VydEF0VGFiU3RvcCA9IHNlc3Npb24uZ2V0VXNlU29mdFRhYnMoKTtcbiAgICAgICAgICAgIHZhciB1bmNvbW1lbnQgPSBmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBtID0gbGluZS5tYXRjaChyZWdleHBTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbVsxXS5sZW5ndGgsIGVuZCA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkSW5zZXJ0U3BhY2UobGluZSwgc3RhcnQsIGVuZCkgJiYgbVswXVtlbmQgLSAxXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICAgICAgZG9jLnJlbW92ZUluTGluZShpLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29tbWVudFdpdGhTcGFjZSA9IGxpbmVDb21tZW50U3RhcnQgKyBcIiBcIjtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUJsYW5rTGluZXMgfHwgL1xcUy8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSW5zZXJ0U3BhY2UobGluZSwgbWluSW5kZW50LCBtaW5JbmRlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7IHJvdzogaSwgY29sdW1uOiBtaW5JbmRlbnQgfSwgY29tbWVudFdpdGhTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRJbkxpbmUoeyByb3c6IGksIGNvbHVtbjogbWluSW5kZW50IH0sIGxpbmVDb21tZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGVzdFJlbW92ZSA9IGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cFN0YXJ0LnRlc3QobGluZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNob3VsZEluc2VydFNwYWNlID0gZnVuY3Rpb24gKGxpbmUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYmVmb3JlLS0gJiYgbGluZS5jaGFyQXQoYmVmb3JlKSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlcyAlIHRhYlNpemUgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lLmNoYXJBdChhZnRlcisrKSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgICAgICAgaWYgKHRhYlNpemUgPiAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VzICUgdGFiU2l6ZSAhPSB0YWJTaXplIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZXMgJSB0YWJTaXplID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXIoZnVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3c7IGkgPD0gZW5kUm93OyBpKyspXG4gICAgICAgICAgICAgICAgZnVuKGRvYy5nZXRMaW5lKGkpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluRW1wdHlMZW5ndGggPSBJbmZpbml0eTtcbiAgICAgICAgaXRlcihmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IGxpbmUuc2VhcmNoKC9cXFMvKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUgJiYgIXRlc3RSZW1vdmUobGluZSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWluRW1wdHlMZW5ndGggPiBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1pbkVtcHR5TGVuZ3RoID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWluSW5kZW50ID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBtaW5JbmRlbnQgPSBtaW5FbXB0eUxlbmd0aDtcbiAgICAgICAgICAgIGlnbm9yZUJsYW5rTGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHNob3VsZFJlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnRBdFRhYlN0b3AgJiYgbWluSW5kZW50ICUgdGFiU2l6ZSAhPSAwKVxuICAgICAgICAgICAgbWluSW5kZW50ID0gTWF0aC5mbG9vcihtaW5JbmRlbnQgLyB0YWJTaXplKSAqIHRhYlNpemU7XG4gICAgICAgIGl0ZXIoc2hvdWxkUmVtb3ZlID8gdW5jb21tZW50IDogY29tbWVudCk7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZUJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uIChzdGF0ZSwgc2Vzc2lvbiwgcmFuZ2UsIGN1cnNvcikge1xuICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuYmxvY2tDb21tZW50O1xuICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY29tbWVudC5zdGFydCAmJiBjb21tZW50WzBdKVxuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRbMF07XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdmFyIHNlbCA9IHNlc3Npb24uc2VsZWN0aW9uO1xuICAgICAgICB2YXIgaW5pdGlhbFJhbmdlID0gc2Vzc2lvbi5zZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgIHZhciBzdGFydFJvdywgY29sRGlmZjtcbiAgICAgICAgaWYgKHRva2VuICYmIC9jb21tZW50Ly50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRSYW5nZSwgZW5kUmFuZ2U7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gJiYgL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRva2VuLnZhbHVlLmluZGV4T2YoY29tbWVudC5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uLCByb3csIGNvbHVtbiArIGNvbW1lbnQuc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICYmIC9jb21tZW50Ly50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0b2tlbi52YWx1ZS5pbmRleE9mKGNvbW1lbnQuZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIGk7XG4gICAgICAgICAgICAgICAgICAgIGVuZFJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uLCByb3csIGNvbHVtbiArIGNvbW1lbnQuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kUmFuZ2UpXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmUoZW5kUmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZShzdGFydFJhbmdlKTtcbiAgICAgICAgICAgICAgICBzdGFydFJvdyA9IHN0YXJ0UmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIGNvbERpZmYgPSAtY29tbWVudC5zdGFydC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xEaWZmID0gY29tbWVudC5zdGFydC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLmVuZCwgY29tbWVudC5lbmQpO1xuICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQocmFuZ2Uuc3RhcnQsIGNvbW1lbnQuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsUmFuZ2Uuc3RhcnQucm93ID09IHN0YXJ0Um93KVxuICAgICAgICAgICAgaW5pdGlhbFJhbmdlLnN0YXJ0LmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICBpZiAoaW5pdGlhbFJhbmdlLmVuZC5yb3cgPT0gc3RhcnRSb3cpXG4gICAgICAgICAgICBpbml0aWFsUmFuZ2UuZW5kLmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICBzZXNzaW9uLnNlbGVjdGlvbi5mcm9tT3JpZW50ZWRSYW5nZShpbml0aWFsUmFuZ2UpO1xuICAgIH07XG4gICAgdGhpcy5nZXROZXh0TGluZUluZGVudCA9IGZ1bmN0aW9uIChzdGF0ZSwgbGluZSwgdGFiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRnZXRJbmRlbnQobGluZSk7XG4gICAgfTtcbiAgICB0aGlzLmNoZWNrT3V0ZGVudCA9IGZ1bmN0aW9uIChzdGF0ZSwgbGluZSwgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5hdXRvT3V0ZGVudCA9IGZ1bmN0aW9uIChzdGF0ZSwgZG9jLCByb3cpIHtcbiAgICB9O1xuICAgIHRoaXMuJGdldEluZGVudCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lLm1hdGNoKC9eXFxzKi8pWzBdO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuY3JlYXRlTW9kZURlbGVnYXRlcyA9IGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHRoaXMuJGVtYmVkcyA9IFtdO1xuICAgICAgICB0aGlzLiRtb2RlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmIChtYXBwaW5nW2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIE1vZGUgPSBtYXBwaW5nW2ldO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IE1vZGUucHJvdG90eXBlLiRpZDtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IGNvbmZpZy4kbW9kZXNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLiRtb2Rlc1tpZF0gPSBtb2RlID0gbmV3IE1vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy4kbW9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy4kbW9kZXNbaV0gPSBtb2RlO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtYmVkcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJG1vZGVzW2ldID0gbW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsZWdhdGlvbnMgPSBbXCJ0b2dnbGVCbG9ja0NvbW1lbnRcIiwgXCJ0b2dnbGVDb21tZW50TGluZXNcIiwgXCJnZXROZXh0TGluZUluZGVudFwiLFxuICAgICAgICAgICAgXCJjaGVja091dGRlbnRcIiwgXCJhdXRvT3V0ZGVudFwiLCBcInRyYW5zZm9ybUFjdGlvblwiLCBcImdldENvbXBsZXRpb25zXCJdO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGRlbGVnYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0SGFuZGxlciA9IHNjb3BlW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgc2NvcGVbZGVsZWdhdGlvbnNbaV1dID1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGRlbGVnYXRvcihmdW5jdGlvbk5hbWUsIGFyZ3VtZW50cywgZGVmYXVsdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSh0aGlzXzEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZWdhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJGRlbGVnYXRvciA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MsIGRlZmF1bHRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbMF0gfHwgXCJzdGFydFwiO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlWzJdKSkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5ndWFnZSA9IHN0YXRlWzJdW3N0YXRlWzJdLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gdGhpcy4kbW9kZXNbbGFuZ3VhZ2VdO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZVttZXRob2RdLmFwcGx5KG1vZGUsIFtzdGF0ZVsxXV0uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncywgMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVbMF0gfHwgXCJzdGFydFwiO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZW1iZWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJG1vZGVzW3RoaXMuJGVtYmVkc1tpXV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBzdGF0ZS5zcGxpdCh0aGlzLiRlbWJlZHNbaV0pO1xuICAgICAgICAgICAgaWYgKCFzcGxpdFswXSAmJiBzcGxpdFsxXSkge1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IHRoaXMuJG1vZGVzW3RoaXMuJGVtYmVkc1tpXV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVbbWV0aG9kXS5hcHBseShtb2RlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gZGVmYXVsdEhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SGFuZGxlciA/IHJldCA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHRoaXMudHJhbnNmb3JtQWN0aW9uID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMuJGJlaGF2aW91cikge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW91cnMgPSB0aGlzLiRiZWhhdmlvdXIuZ2V0QmVoYXZpb3VycygpO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJlaGF2aW91cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3Vyc1trZXldW2FjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGJlaGF2aW91cnNba2V5XVthY3Rpb25dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0S2V5d29yZHMgPSBmdW5jdGlvbiAoYXBwZW5kKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9uS2V5d29yZHMpIHtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuJHRva2VuaXplcltcInJ1bGVzXCJdO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRpb25LZXl3b3JkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcnVsZSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlSXRyID0gcnVsZXNbcnVsZV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsIGwgPSBydWxlSXRyLmxlbmd0aDsgciA8IGw7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVJdHJbcl0udG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgva2V5d29yZHxzdXBwb3J0fHN0b3JhZ2UvLnRlc3QocnVsZUl0cltyXS50b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbktleXdvcmRzLnB1c2gocnVsZUl0cltyXS5yZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGVJdHJbcl0udG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBhTGVuZ3RoID0gcnVsZUl0cltyXS50b2tlbi5sZW5ndGg7IGEgPCBhTGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL2tleXdvcmR8c3VwcG9ydHxzdG9yYWdlLy50ZXN0KHJ1bGVJdHJbcl0udG9rZW5bYV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlID0gcnVsZUl0cltyXS5yZWdleC5tYXRjaCgvXFwoLis/XFwpL2cpW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uS2V5d29yZHMucHVzaChydWxlLnN1YnN0cigxLCBydWxlLmxlbmd0aCAtIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25LZXl3b3JkcyA9IGNvbXBsZXRpb25LZXl3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkTGlzdDtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25LZXl3b3Jkcy5jb25jYXQodGhpcy4ka2V5d29yZExpc3QgfHwgW10pO1xuICAgIH07XG4gICAgdGhpcy4kY3JlYXRlS2V5d29yZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kaGlnaGxpZ2h0UnVsZXMpXG4gICAgICAgICAgICB0aGlzLmdldFRva2VuaXplcigpO1xuICAgICAgICByZXR1cm4gdGhpcy4ka2V5d29yZExpc3QgPSB0aGlzLiRoaWdobGlnaHRSdWxlcy4ka2V5d29yZExpc3QgfHwgW107XG4gICAgfTtcbiAgICB0aGlzLmdldENvbXBsZXRpb25zID0gZnVuY3Rpb24gKHN0YXRlLCBzZXNzaW9uLCBwb3MsIHByZWZpeCkge1xuICAgICAgICB2YXIga2V5d29yZHMgPSB0aGlzLiRrZXl3b3JkTGlzdCB8fCB0aGlzLiRjcmVhdGVLZXl3b3JkTGlzdCgpO1xuICAgICAgICByZXR1cm4ga2V5d29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICAgICAgbWV0YTogXCJrZXl3b3JkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy4kaWQgPSBcImFjZS9tb2RlL3RleHRcIjtcbn0pLmNhbGwoTW9kZS5wcm90b3R5cGUpO1xuZXhwb3J0cy5Nb2RlID0gTW9kZTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGluZV93aWRnZXRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIExpbmVXaWRnZXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVXaWRnZXRzKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLndpZGdldE1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoID0gdGhpcy5nZXRSb3dMZW5ndGg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi4kZ2V0V2lkZ2V0U2NyZWVuTGVuZ3RoID0gdGhpcy4kZ2V0V2lkZ2V0U2NyZWVuTGVuZ3RoO1xuICAgICAgICB0aGlzLnVwZGF0ZU9uQ2hhbmdlID0gdGhpcy51cGRhdGVPbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcldpZGdldHMgPSB0aGlzLnJlbmRlcldpZGdldHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlV2lkZ2V0cyA9IHRoaXMubWVhc3VyZVdpZGdldHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLl9jaGFuZ2VkV2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLiRvbkNoYW5nZUVkaXRvciA9IHRoaXMuJG9uQ2hhbmdlRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZU9uQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlRm9sZFwiLCB0aGlzLnVwZGF0ZU9uRm9sZCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZUVkaXRvclwiLCB0aGlzLiRvbkNoYW5nZUVkaXRvcik7XG4gICAgfVxuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5nZXRSb3dMZW5ndGggPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBoO1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIGggPSB0aGlzLmxpbmVXaWRnZXRzW3Jvd10gJiYgdGhpcy5saW5lV2lkZ2V0c1tyb3ddLnJvd0NvdW50IHx8IDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGggPSAwO1xuICAgICAgICBpZiAoIXRoaXNbXCIkdXNlV3JhcE1vZGVcIl0gfHwgIXRoaXNbXCIkd3JhcERhdGFcIl1bcm93XSkge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCIkd3JhcERhdGFcIl1bcm93XS5sZW5ndGggKyAxICsgaDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JlZW5Sb3dzID0gMDtcbiAgICAgICAgdGhpcy5saW5lV2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICBpZiAodyAmJiB3LnJvd0NvdW50ICYmICF3LmhpZGRlbilcbiAgICAgICAgICAgICAgICBzY3JlZW5Sb3dzICs9IHcucm93Q291bnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2NyZWVuUm93cztcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS4kb25DaGFuZ2VFZGl0b3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmF0dGFjaChlLmVkaXRvcik7XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBpZiAoZWRpdG9yICYmIGVkaXRvci53aWRnZXRNYW5hZ2VyICYmIGVkaXRvci53aWRnZXRNYW5hZ2VyICE9IHRoaXMpXG4gICAgICAgICAgICBlZGl0b3Iud2lkZ2V0TWFuYWdlci5kZXRhY2goKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yID09IGVkaXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci53aWRnZXRNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5vbihcImJlZm9yZVJlbmRlclwiLCB0aGlzLm1lYXN1cmVXaWRnZXRzKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIHRoaXMucmVuZGVyV2lkZ2V0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGlmICghZWRpdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgICAgIGVkaXRvci53aWRnZXRNYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9mZihcImJlZm9yZVJlbmRlclwiLCB0aGlzLm1lYXN1cmVXaWRnZXRzKTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9mZihcImFmdGVyUmVuZGVyXCIsIHRoaXMucmVuZGVyV2lkZ2V0cyk7XG4gICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cztcbiAgICAgICAgbGluZVdpZGdldHMgJiYgbGluZVdpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKHcgJiYgdy5lbCAmJiB3LmVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB3Ll9pbkRvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHcuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS51cGRhdGVPbkZvbGQgPSBmdW5jdGlvbiAoZSwgc2Vzc2lvbikge1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSBzZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBpZiAoIWxpbmVXaWRnZXRzIHx8ICFlLmFjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZvbGQgPSBlLmRhdGE7XG4gICAgICAgIHZhciBzdGFydCA9IGZvbGQuc3RhcnQucm93O1xuICAgICAgICB2YXIgZW5kID0gZm9sZC5lbmQucm93O1xuICAgICAgICB2YXIgaGlkZSA9IGUuYWN0aW9uID09IFwiYWRkXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWRnZXRzW2ldKVxuICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW2ldLmhpZGRlbiA9IGhpZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVXaWRnZXRzW2VuZF0pIHtcbiAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lV2lkZ2V0c1tzdGFydF0pXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW3N0YXJ0XSA9IGxpbmVXaWRnZXRzW2VuZF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkZ2V0c1tlbmRdLmhpZGRlbiA9IGhpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZVdpZGdldHNbc3RhcnRdID09IGxpbmVXaWRnZXRzW2VuZF0pXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWRnZXRzW3N0YXJ0XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsaW5lV2lkZ2V0c1tlbmRdLmhpZGRlbiA9IGhpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS51cGRhdGVPbkNoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIGlmICghbGluZVdpZGdldHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdGFydFJvdyA9IGRlbHRhLnN0YXJ0LnJvdztcbiAgICAgICAgdmFyIGxlbiA9IGRlbHRhLmVuZC5yb3cgLSBzdGFydFJvdztcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGxpbmVXaWRnZXRzLnNwbGljZShzdGFydFJvdyArIDEsIGxlbik7XG4gICAgICAgICAgICBpZiAoIWxpbmVXaWRnZXRzW3N0YXJ0Um93XSAmJiByZW1vdmVkW3JlbW92ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkZ2V0c1tzdGFydFJvd10gPSByZW1vdmVkLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgdyAmJiB0aGlzLnJlbW92ZUxpbmVXaWRnZXQodyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgICAgICBpZiAobGluZVdpZGdldHNbc3RhcnRSb3ddICYmIGxpbmVXaWRnZXRzW3N0YXJ0Um93XS5jb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YS5zdGFydC5jb2x1bW4gPiBsaW5lV2lkZ2V0c1tzdGFydFJvd10uY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICBzdGFydFJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHN0YXJ0Um93LCAwKTtcbiAgICAgICAgICAgIGxpbmVXaWRnZXRzLnNwbGljZS5hcHBseShsaW5lV2lkZ2V0cywgYXJncyk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS4kdXBkYXRlUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbm9XaWRnZXRzID0gdHJ1ZTtcbiAgICAgICAgbGluZVdpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAodywgaSkge1xuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICBub1dpZGdldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3LnJvdyA9IGk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHcuJG9sZFdpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICB3LiRvbGRXaWRnZXQucm93ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHcuJG9sZFdpZGdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9XaWRnZXRzKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzID0gbnVsbDtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS4kcmVnaXN0ZXJMaW5lV2lkZ2V0ID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24ubGluZVdpZGdldHMpXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubGluZVdpZGdldHMgPSBuZXcgQXJyYXkodGhpcy5zZXNzaW9uLmdldExlbmd0aCgpKTtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t3LnJvd107XG4gICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgIHcuJG9sZFdpZGdldCA9IG9sZDtcbiAgICAgICAgICAgIGlmIChvbGQuZWwgJiYgb2xkLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBvbGQuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvbGQuZWwpO1xuICAgICAgICAgICAgICAgIG9sZC5faW5Eb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t3LnJvd10gPSB3O1xuICAgICAgICByZXR1cm4gdztcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5hZGRMaW5lV2lkZ2V0ID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgdGhpcy4kcmVnaXN0ZXJMaW5lV2lkZ2V0KHcpO1xuICAgICAgICB3LnNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5lZGl0b3IucmVuZGVyZXI7XG4gICAgICAgIGlmICh3Lmh0bWwgJiYgIXcuZWwpIHtcbiAgICAgICAgICAgIHcuZWwgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHcuZWwuaW5uZXJIVE1MID0gdy5odG1sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3LnRleHQgJiYgIXcuZWwpIHtcbiAgICAgICAgICAgIHcuZWwgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHcuZWwudGV4dENvbnRlbnQgPSB3LnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcuZWwpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh3LmVsLCBcImFjZV9saW5lV2lkZ2V0Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgaWYgKHcuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHcuZWwsIHcuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcuZWwuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICB3LmVsLnN0eWxlLnpJbmRleCA9IFwiNVwiO1xuICAgICAgICAgICAgcmVuZGVyZXIuY29udGFpbmVyLmFwcGVuZENoaWxkKHcuZWwpO1xuICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXcuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnpJbmRleCA9IFwiM1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHcucGl4ZWxIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHcucGl4ZWxIZWlnaHQgPSB3LmVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAody5yb3dDb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3LnJvd0NvdW50ID0gdy5waXhlbEhlaWdodCAvIHJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHcucm93LCAwKTtcbiAgICAgICAgdy4kZm9sZCA9IGZvbGQ7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgICAgICBpZiAody5yb3cgPT0gZm9sZC5lbmQucm93ICYmICFsaW5lV2lkZ2V0c1tmb2xkLnN0YXJ0LnJvd10pXG4gICAgICAgICAgICAgICAgbGluZVdpZGdldHNbZm9sZC5zdGFydC5yb3ddID0gdztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7IGRhdGE6IHsgc3RhcnQ6IHsgcm93OiB3LnJvdyB9IH0gfSk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJXaWRnZXRzKG51bGwsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5vbldpZGdldENoYW5nZWQodyk7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH07XG4gICAgTGluZVdpZGdldHMucHJvdG90eXBlLnJlbW92ZUxpbmVXaWRnZXQgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB3Ll9pbkRvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgIHcuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIGlmICh3LmVsICYmIHcuZWwucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHcuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3LmVsKTtcbiAgICAgICAgaWYgKHcuZWRpdG9yICYmIHcuZWRpdG9yLmRlc3Ryb3kpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHcuZWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cykge1xuICAgICAgICAgICAgdmFyIHcxID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XTtcbiAgICAgICAgICAgIGlmICh3MSA9PSB3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XSA9IHcuJG9sZFdpZGdldDtcbiAgICAgICAgICAgICAgICBpZiAody4kb2xkV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uV2lkZ2V0Q2hhbmdlZCh3LiRvbGRXaWRnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHcxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3MS4kb2xkV2lkZ2V0ID09IHcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcxLiRvbGRXaWRnZXQgPSB3LiRvbGRXaWRnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3MSA9IHcxLiRvbGRXaWRnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5fZW1pdChcImNoYW5nZUZvbGRcIiwgeyBkYXRhOiB7IHN0YXJ0OiB7IHJvdzogdy5yb3cgfSB9IH0pO1xuICAgICAgICB0aGlzLiR1cGRhdGVSb3dzKCk7XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUuZ2V0V2lkZ2V0c0F0Um93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIHZhciB3ID0gbGluZVdpZGdldHMgJiYgbGluZVdpZGdldHNbcm93XTtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgd2hpbGUgKHcpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh3KTtcbiAgICAgICAgICAgIHcgPSB3LiRvbGRXaWRnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUub25XaWRnZXRDaGFuZ2VkID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLl9jaGFuZ2VkV2lkZ2V0cy5wdXNoKHcpO1xuICAgICAgICB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5yZW5kZXJlci51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICBMaW5lV2lkZ2V0cy5wcm90b3R5cGUubWVhc3VyZVdpZGdldHMgPSBmdW5jdGlvbiAoZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIGNoYW5nZWRXaWRnZXRzID0gdGhpcy5zZXNzaW9uLl9jaGFuZ2VkV2lkZ2V0cztcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlbmRlcmVyLmxheWVyQ29uZmlnO1xuICAgICAgICBpZiAoIWNoYW5nZWRXaWRnZXRzIHx8ICFjaGFuZ2VkV2lkZ2V0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkV2lkZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBjaGFuZ2VkV2lkZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmICghdyB8fCAhdy5lbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh3LnNlc3Npb24gIT0gdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCF3Ll9pbkRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t3LnJvd10gIT0gdylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY29udGFpbmVyLmFwcGVuZENoaWxkKHcuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdy5oID0gdy5lbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXcuZml4ZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHcudyA9IHcuZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdy5zY3JlZW5XaWR0aCA9IE1hdGguY2VpbCh3LncgLyBjb25maWcuY2hhcmFjdGVyV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdy5oIC8gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBpZiAody5jb3ZlckxpbmUpIHtcbiAgICAgICAgICAgICAgICByb3dDb3VudCAtPSB0aGlzLnNlc3Npb24uZ2V0Um93TGluZUNvdW50KHcucm93KTtcbiAgICAgICAgICAgICAgICBpZiAocm93Q291bnQgPCAwKVxuICAgICAgICAgICAgICAgICAgICByb3dDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAody5yb3dDb3VudCAhPSByb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHcucm93Q291bnQgPSByb3dDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAody5yb3cgPCBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHcucm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gIT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5fZW1pdChcImNoYW5nZUZvbGRcIiwgeyBkYXRhOiB7IHN0YXJ0OiB7IHJvdzogbWluIH0gfSB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0V2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMgPSBbXTtcbiAgICB9O1xuICAgIExpbmVXaWRnZXRzLnByb3RvdHlwZS5yZW5kZXJXaWRnZXRzID0gZnVuY3Rpb24gKGUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBjb25maWcgPSByZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1pbih0aGlzLmZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cpO1xuICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWF4KHRoaXMubGFzdFJvdywgY29uZmlnLmxhc3RSb3csIGxpbmVXaWRnZXRzLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChmaXJzdCA+IDAgJiYgIWxpbmVXaWRnZXRzW2ZpcnN0XSlcbiAgICAgICAgICAgIGZpcnN0LS07XG4gICAgICAgIHRoaXMuZmlyc3RSb3cgPSBjb25maWcuZmlyc3RSb3c7XG4gICAgICAgIHRoaXMubGFzdFJvdyA9IGNvbmZpZy5sYXN0Um93O1xuICAgICAgICByZW5kZXJlci4kY3Vyc29yTGF5ZXIuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGxpbmVXaWRnZXRzW2ldO1xuICAgICAgICAgICAgaWYgKCF3IHx8ICF3LmVsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHcuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdy5lbC5zdHlsZS50b3AgPSAtMTAwIC0gKHcucGl4ZWxIZWlnaHQgfHwgMCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXcuX2luRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB3Ll9pbkRvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9wID0gcmVuZGVyZXIuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oeyByb3c6IGksIGNvbHVtbjogMCB9LCB0cnVlKS50b3A7XG4gICAgICAgICAgICBpZiAoIXcuY292ZXJMaW5lKVxuICAgICAgICAgICAgICAgIHRvcCArPSBjb25maWcubGluZUhlaWdodCAqIHRoaXMuc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQody5yb3cpO1xuICAgICAgICAgICAgdy5lbC5zdHlsZS50b3AgPSB0b3AgLSBjb25maWcub2Zmc2V0ICsgXCJweFwiO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB3LmNvdmVyR3V0dGVyID8gMCA6IHJlbmRlcmVyLmd1dHRlcldpZHRoO1xuICAgICAgICAgICAgaWYgKCF3LmZpeGVkV2lkdGgpXG4gICAgICAgICAgICAgICAgbGVmdCAtPSByZW5kZXJlci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdy5lbC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIGlmICh3LmZ1bGxXaWR0aCAmJiB3LnNjcmVlbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgdy5lbC5zdHlsZS5taW5XaWR0aCA9IGNvbmZpZy53aWR0aCArIDIgKiBjb25maWcucGFkZGluZyArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3LmZpeGVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnJpZ2h0ID0gcmVuZGVyZXIuc2Nyb2xsQmFyLmdldFdpZHRoKCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExpbmVXaWRnZXRzO1xufSgpKTtcbmV4cG9ydHMuTGluZVdpZGdldHMgPSBMaW5lV2lkZ2V0cztcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXBwbHlfZGVsdGFcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsIGVycm9yVGV4dCkge1xuICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBEZWx0YTpcIiwgZGVsdGEpO1xuICAgIHRocm93IFwiSW52YWxpZCBEZWx0YTogXCIgKyBlcnJvclRleHQ7XG59XG5mdW5jdGlvbiBwb3NpdGlvbkluRG9jdW1lbnQoZG9jTGluZXMsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uLnJvdyA+PSAwICYmIHBvc2l0aW9uLnJvdyA8IGRvY0xpbmVzLmxlbmd0aCAmJlxuICAgICAgICBwb3NpdGlvbi5jb2x1bW4gPj0gMCAmJiBwb3NpdGlvbi5jb2x1bW4gPD0gZG9jTGluZXNbcG9zaXRpb24ucm93XS5sZW5ndGg7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZURlbHRhKGRvY0xpbmVzLCBkZWx0YSkge1xuICAgIGlmIChkZWx0YS5hY3Rpb24gIT0gXCJpbnNlcnRcIiAmJiBkZWx0YS5hY3Rpb24gIT0gXCJyZW1vdmVcIilcbiAgICAgICAgdGhyb3dEZWx0YUVycm9yKGRlbHRhLCBcImRlbHRhLmFjdGlvbiBtdXN0IGJlICdpbnNlcnQnIG9yICdyZW1vdmUnXCIpO1xuICAgIGlmICghKGRlbHRhLmxpbmVzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsIFwiZGVsdGEubGluZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICBpZiAoIWRlbHRhLnN0YXJ0IHx8ICFkZWx0YS5lbmQpXG4gICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgXCJkZWx0YS5zdGFydC9lbmQgbXVzdCBiZSBhbiBwcmVzZW50XCIpO1xuICAgIHZhciBzdGFydCA9IGRlbHRhLnN0YXJ0O1xuICAgIGlmICghcG9zaXRpb25JbkRvY3VtZW50KGRvY0xpbmVzLCBkZWx0YS5zdGFydCkpXG4gICAgICAgIHRocm93RGVsdGFFcnJvcihkZWx0YSwgXCJkZWx0YS5zdGFydCBtdXN0IGJlIGNvbnRhaW5lZCBpbiBkb2N1bWVudFwiKTtcbiAgICB2YXIgZW5kID0gZGVsdGEuZW5kO1xuICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVcIiAmJiAhcG9zaXRpb25JbkRvY3VtZW50KGRvY0xpbmVzLCBlbmQpKVxuICAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsIFwiZGVsdGEuZW5kIG11c3QgY29udGFpbmVkIGluIGRvY3VtZW50IGZvciAncmVtb3ZlJyBhY3Rpb25zXCIpO1xuICAgIHZhciBudW1SYW5nZVJvd3MgPSBlbmQucm93IC0gc3RhcnQucm93O1xuICAgIHZhciBudW1SYW5nZUxhc3RMaW5lQ2hhcnMgPSAoZW5kLmNvbHVtbiAtIChudW1SYW5nZVJvd3MgPT0gMCA/IHN0YXJ0LmNvbHVtbiA6IDApKTtcbiAgICBpZiAobnVtUmFuZ2VSb3dzICE9IGRlbHRhLmxpbmVzLmxlbmd0aCAtIDEgfHwgZGVsdGEubGluZXNbbnVtUmFuZ2VSb3dzXS5sZW5ndGggIT0gbnVtUmFuZ2VMYXN0TGluZUNoYXJzKVxuICAgICAgICB0aHJvd0RlbHRhRXJyb3IoZGVsdGEsIFwiZGVsdGEucmFuZ2UgbXVzdCBtYXRjaCBkZWx0YSBsaW5lc1wiKTtcbn1cbmV4cG9ydHMuYXBwbHlEZWx0YSA9IGZ1bmN0aW9uIChkb2NMaW5lcywgZGVsdGEsIGRvTm90VmFsaWRhdGUpIHtcbiAgICB2YXIgcm93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgIHZhciBzdGFydENvbHVtbiA9IGRlbHRhLnN0YXJ0LmNvbHVtbjtcbiAgICB2YXIgbGluZSA9IGRvY0xpbmVzW3Jvd10gfHwgXCJcIjtcbiAgICBzd2l0Y2ggKGRlbHRhLmFjdGlvbikge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBkZWx0YS5saW5lcztcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkb2NMaW5lc1tyb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgZGVsdGEubGluZXNbMF0gKyBsaW5lLnN1YnN0cmluZyhzdGFydENvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtyb3csIDFdLmNvbmNhdChkZWx0YS5saW5lcyk7XG4gICAgICAgICAgICAgICAgZG9jTGluZXMuc3BsaWNlLmFwcGx5KGRvY0xpbmVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBkb2NMaW5lc1tyb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgZG9jTGluZXNbcm93XTtcbiAgICAgICAgICAgICAgICBkb2NMaW5lc1tyb3cgKyBkZWx0YS5saW5lcy5sZW5ndGggLSAxXSArPSBsaW5lLnN1YnN0cmluZyhzdGFydENvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IGRlbHRhLmVuZC5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gZGVsdGEuZW5kLnJvdztcbiAgICAgICAgICAgIGlmIChyb3cgPT09IGVuZFJvdykge1xuICAgICAgICAgICAgICAgIGRvY0xpbmVzW3Jvd10gPSBsaW5lLnN1YnN0cmluZygwLCBzdGFydENvbHVtbikgKyBsaW5lLnN1YnN0cmluZyhlbmRDb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jTGluZXMuc3BsaWNlKHJvdywgZW5kUm93IC0gcm93ICsgMSwgbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgZG9jTGluZXNbZW5kUm93XS5zdWJzdHJpbmcoZW5kQ29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9hbmNob3JcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgQW5jaG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuY2hvcihkb2MsIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuJG9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF0dGFjaChkb2MpO1xuICAgICAgICBpZiAodHlwZW9mIHJvdyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihyb3cucm93LCByb3cuY29sdW1uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgfVxuICAgIEFuY2hvci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHRoaXMucm93LCB0aGlzLmNvbHVtbik7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudDtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgaWYgKGRlbHRhLnN0YXJ0LnJvdyA9PSBkZWx0YS5lbmQucm93ICYmIGRlbHRhLnN0YXJ0LnJvdyAhPSB0aGlzLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRlbHRhLnN0YXJ0LnJvdyA+IHRoaXMucm93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcG9pbnQgPSAkZ2V0VHJhbnNmb3JtZWRQb2ludChkZWx0YSwgeyByb3c6IHRoaXMucm93LCBjb2x1bW46IHRoaXMuY29sdW1uIH0sIHRoaXMuJGluc2VydFJpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb2ludC5yb3csIHBvaW50LmNvbHVtbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBBbmNob3IucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCBub0NsaXApIHtcbiAgICAgICAgdmFyIHBvcztcbiAgICAgICAgaWYgKG5vQ2xpcCkge1xuICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChyb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm93ID09IHBvcy5yb3cgJiYgdGhpcy5jb2x1bW4gPT0gcG9zLmNvbHVtbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9sZCA9IHtcbiAgICAgICAgICAgIHJvdzogdGhpcy5yb3csXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucm93ID0gcG9zLnJvdztcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBwb3MuY29sdW1uO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgICAgb2xkOiBvbGQsXG4gICAgICAgICAgICB2YWx1ZTogcG9zXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQW5jaG9yLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQub2ZmKFwiY2hhbmdlXCIsIHRoaXMuJG9uQ2hhbmdlKTtcbiAgICB9O1xuICAgIEFuY2hvci5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jIHx8IHRoaXMuZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuICAgIH07XG4gICAgQW5jaG9yLnByb3RvdHlwZS4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgcG9zID0ge307XG4gICAgICAgIGlmIChyb3cgPj0gdGhpcy5kb2N1bWVudC5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgcG9zLnJvdyA9IE1hdGgubWF4KDAsIHRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgICAgIHBvcy5jb2x1bW4gPSB0aGlzLmRvY3VtZW50LmdldExpbmUocG9zLnJvdykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgICAgIHBvcy5yb3cgPSAwO1xuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3Mucm93ID0gcm93O1xuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IE1hdGgubWluKHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgsIE1hdGgubWF4KDAsIGNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPCAwKVxuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDA7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICByZXR1cm4gQW5jaG9yO1xufSgpKTtcbkFuY2hvci5wcm90b3R5cGUuJGluc2VydFJpZ2h0ID0gZmFsc2U7XG5vb3AuaW1wbGVtZW50KEFuY2hvci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiAkcG9pbnRzSW5PcmRlcihwb2ludDEsIHBvaW50MiwgZXF1YWxQb2ludHNJbk9yZGVyKSB7XG4gICAgdmFyIGJDb2xJc0FmdGVyID0gZXF1YWxQb2ludHNJbk9yZGVyID8gcG9pbnQxLmNvbHVtbiA8PSBwb2ludDIuY29sdW1uIDogcG9pbnQxLmNvbHVtbiA8IHBvaW50Mi5jb2x1bW47XG4gICAgcmV0dXJuIChwb2ludDEucm93IDwgcG9pbnQyLnJvdykgfHwgKHBvaW50MS5yb3cgPT0gcG9pbnQyLnJvdyAmJiBiQ29sSXNBZnRlcik7XG59XG5mdW5jdGlvbiAkZ2V0VHJhbnNmb3JtZWRQb2ludChkZWx0YSwgcG9pbnQsIG1vdmVJZkVxdWFsKSB7XG4gICAgdmFyIGRlbHRhSXNJbnNlcnQgPSBkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIjtcbiAgICB2YXIgZGVsdGFSb3dTaGlmdCA9IChkZWx0YUlzSW5zZXJ0ID8gMSA6IC0xKSAqIChkZWx0YS5lbmQucm93IC0gZGVsdGEuc3RhcnQucm93KTtcbiAgICB2YXIgZGVsdGFDb2xTaGlmdCA9IChkZWx0YUlzSW5zZXJ0ID8gMSA6IC0xKSAqIChkZWx0YS5lbmQuY29sdW1uIC0gZGVsdGEuc3RhcnQuY29sdW1uKTtcbiAgICB2YXIgZGVsdGFTdGFydCA9IGRlbHRhLnN0YXJ0O1xuICAgIHZhciBkZWx0YUVuZCA9IGRlbHRhSXNJbnNlcnQgPyBkZWx0YVN0YXJ0IDogZGVsdGEuZW5kOyAvLyBDb2xsYXBzZSBpbnNlcnQgcmFuZ2UuXG4gICAgaWYgKCRwb2ludHNJbk9yZGVyKHBvaW50LCBkZWx0YVN0YXJ0LCBtb3ZlSWZFcXVhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogcG9pbnQucm93LFxuICAgICAgICAgICAgY29sdW1uOiBwb2ludC5jb2x1bW5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCRwb2ludHNJbk9yZGVyKGRlbHRhRW5kLCBwb2ludCwgIW1vdmVJZkVxdWFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiBwb2ludC5yb3cgKyBkZWx0YVJvd1NoaWZ0LFxuICAgICAgICAgICAgY29sdW1uOiBwb2ludC5jb2x1bW4gKyAocG9pbnQucm93ID09IGRlbHRhRW5kLnJvdyA/IGRlbHRhQ29sU2hpZnQgOiAwKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByb3c6IGRlbHRhU3RhcnQucm93LFxuICAgICAgICBjb2x1bW46IGRlbHRhU3RhcnQuY29sdW1uXG4gICAgfTtcbn1cbmV4cG9ydHMuQW5jaG9yID0gQW5jaG9yO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9kb2N1bWVudFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9hcHBseV9kZWx0YVwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9hbmNob3JcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBhcHBseURlbHRhID0gcmVxdWlyZShcIi4vYXBwbHlfZGVsdGFcIikuYXBwbHlEZWx0YTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBBbmNob3IgPSByZXF1aXJlKFwiLi9hbmNob3JcIikuQW5jaG9yO1xudmFyIERvY3VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50KHRleHRPckxpbmVzKSB7XG4gICAgICAgIHRoaXMuJGxpbmVzID0gW1wiXCJdO1xuICAgICAgICBpZiAodGV4dE9yTGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lcyA9IFtcIlwiXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRleHRPckxpbmVzKSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRNZXJnZWRMaW5lcyh7IHJvdzogMCwgY29sdW1uOiAwIH0sIHRleHRPckxpbmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHsgcm93OiAwLCBjb2x1bW46IDAgfSwgdGV4dE9yTGluZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERvY3VtZW50LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgdGhpcy5yZW1vdmUobmV3IFJhbmdlKDAsIDAsIGxlbiwgdGhpcy5nZXRMaW5lKGxlbikubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHsgcm93OiAwLCBjb2x1bW46IDAgfSwgdGV4dCB8fCBcIlwiKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsTGluZXMoKS5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVBbmNob3IgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcywgcm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLiRkZXRlY3ROZXdMaW5lID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXi4qPyhcXHJcXG58XFxyfFxcbikvbSk7XG4gICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiXFxuXCI7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZU5ld0xpbmVNb2RlXCIpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldE5ld0xpbmVDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy4kbmV3TGluZU1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3aW5kb3dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxyXFxuXCI7XG4gICAgICAgICAgICBjYXNlIFwidW5peFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kYXV0b05ld0xpbmUgfHwgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnNldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24gKG5ld0xpbmVNb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLiRuZXdMaW5lTW9kZSA9PT0gbmV3TGluZU1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJG5ld0xpbmVNb2RlID0gbmV3TGluZU1vZGU7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZU5ld0xpbmVNb2RlXCIpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbmV3TGluZU1vZGU7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaXNOZXdMaW5lID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuICh0ZXh0ID09IFwiXFxyXFxuXCIgfHwgdGV4dCA9PSBcIlxcclwiIHx8IHRleHQgPT0gXCJcXG5cIik7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0TGluZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxpbmVzW3Jvd10gfHwgXCJcIjtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbGluZXMuc2xpY2UoZmlyc3RSb3csIGxhc3RSb3cgKyAxKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRBbGxMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZXMoMCwgdGhpcy5nZXRMZW5ndGgoKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbGluZXMubGVuZ3RoO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldFRleHRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lc0ZvclJhbmdlKHJhbmdlKS5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRMaW5lc0ZvclJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBsaW5lcztcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PT0gcmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgbGluZXMgPSBbdGhpcy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdykuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiwgcmFuZ2UuZW5kLmNvbHVtbildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZXMgPSB0aGlzLmdldExpbmVzKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2UuZW5kLnJvdyk7XG4gICAgICAgICAgICBsaW5lc1swXSA9IChsaW5lc1swXSB8fCBcIlwiKS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBsID0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmQucm93IC0gcmFuZ2Uuc3RhcnQucm93ID09IGwpXG4gICAgICAgICAgICAgICAgbGluZXNbbF0gPSBsaW5lc1tsXS5zdWJzdHJpbmcoMCwgcmFuZ2UuZW5kLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmluc2VydExpbmVzID0gZnVuY3Rpb24gKHJvdywgbGluZXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVXNlIG9mIGRvY3VtZW50Lmluc2VydExpbmVzIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgaW5zZXJ0RnVsbExpbmVzIG1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RnVsbExpbmVzKHJvdywgbGluZXMpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZUxpbmVzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVzZSBvZiBkb2N1bWVudC5yZW1vdmVMaW5lcyBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIHJlbW92ZUZ1bGxMaW5lcyBtZXRob2QgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUZ1bGxMaW5lcyhmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaW5zZXJ0TmV3TGluZSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVc2Ugb2YgZG9jdW1lbnQuaW5zZXJ0TmV3TGluZSBpcyBkZXByZWNhdGVkLiBVc2UgaW5zZXJ0TWVyZ2VkTGluZXMocG9zaXRpb24sIFsnJywgJyddKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0TWVyZ2VkTGluZXMocG9zaXRpb24sIFtcIlwiLCBcIlwiXSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldExlbmd0aCgpIDw9IDEpXG4gICAgICAgICAgICB0aGlzLiRkZXRlY3ROZXdMaW5lKHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRNZXJnZWRMaW5lcyhwb3NpdGlvbiwgdGhpcy4kc3BsaXQodGV4dCkpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmluc2VydEluTGluZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgdGV4dCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmNsaXBwZWRQb3MocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5wb3MocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4gKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYXBwbHlEZWx0YSh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnNlcnRcIixcbiAgICAgICAgICAgIGxpbmVzOiBbdGV4dF1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lUG9zKGVuZCk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuY2xpcHBlZFBvcyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByb3cgPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgcm93ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3cgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByb3cgPSBsZW5ndGggLSAxO1xuICAgICAgICAgICAgY29sdW1uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIGlmIChjb2x1bW4gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29sdW1uID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGNvbHVtbiA9IE1hdGgubWluKE1hdGgubWF4KGNvbHVtbiwgMCksIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuY2xvbmVQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiB7IHJvdzogcG9zLnJvdywgY29sdW1uOiBwb3MuY29sdW1uIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7IHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiB9O1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLiRjbGlwUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5yb3cgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5yb3cgPSBNYXRoLm1heCgwLCBsZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmNvbHVtbiA9IHRoaXMuZ2V0TGluZShsZW5ndGggLSAxKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5yb3cgPSBNYXRoLm1heCgwLCBwb3NpdGlvbi5yb3cpO1xuICAgICAgICAgICAgcG9zaXRpb24uY29sdW1uID0gTWF0aC5taW4oTWF0aC5tYXgocG9zaXRpb24uY29sdW1uLCAwKSwgdGhpcy5nZXRMaW5lKHBvc2l0aW9uLnJvdykubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuaW5zZXJ0RnVsbExpbmVzID0gZnVuY3Rpb24gKHJvdywgbGluZXMpIHtcbiAgICAgICAgcm93ID0gTWF0aC5taW4oTWF0aC5tYXgocm93LCAwKSwgdGhpcy5nZXRMZW5ndGgoKSk7XG4gICAgICAgIHZhciBjb2x1bW4gPSAwO1xuICAgICAgICBpZiAocm93IDwgdGhpcy5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQoW1wiXCJdKTtcbiAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lcyA9IFtcIlwiXS5jb25jYXQobGluZXMpO1xuICAgICAgICAgICAgcm93LS07XG4gICAgICAgICAgICBjb2x1bW4gPSB0aGlzLiRsaW5lc1tyb3ddLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydE1lcmdlZExpbmVzKHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH0sIGxpbmVzKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pbnNlcnRNZXJnZWRMaW5lcyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbGluZXMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jbGlwcGVkUG9zKHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIHJvdzogc3RhcnQucm93ICsgbGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGNvbHVtbjogKGxpbmVzLmxlbmd0aCA9PSAxID8gc3RhcnQuY29sdW1uIDogMCkgKyBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseURlbHRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgYWN0aW9uOiBcImluc2VydFwiLFxuICAgICAgICAgICAgbGluZXM6IGxpbmVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZVBvcyhlbmQpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmNsaXBwZWRQb3MocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5jbGlwcGVkUG9zKHJhbmdlLmVuZC5yb3csIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBhY3Rpb246IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICBsaW5lczogdGhpcy5nZXRMaW5lc0ZvclJhbmdlKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVQb3Moc3RhcnQpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZUluTGluZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jbGlwcGVkUG9zKHJvdywgc3RhcnRDb2x1bW4pO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5jbGlwcGVkUG9zKHJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgdGhpcy5hcHBseURlbHRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgYWN0aW9uOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgbGluZXM6IHRoaXMuZ2V0TGluZXNGb3JSYW5nZSh7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSlcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lUG9zKHN0YXJ0KTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVGdWxsTGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgZmlyc3RSb3cgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBmaXJzdFJvdyksIHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgbGFzdFJvdyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGxhc3RSb3cpLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIHZhciBkZWxldGVGaXJzdE5ld0xpbmUgPSBsYXN0Um93ID09IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxICYmIGZpcnN0Um93ID4gMDtcbiAgICAgICAgdmFyIGRlbGV0ZUxhc3ROZXdMaW5lID0gbGFzdFJvdyA8IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSAoZGVsZXRlRmlyc3ROZXdMaW5lID8gZmlyc3RSb3cgLSAxIDogZmlyc3RSb3cpO1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSAoZGVsZXRlRmlyc3ROZXdMaW5lID8gdGhpcy5nZXRMaW5lKHN0YXJ0Um93KS5sZW5ndGggOiAwKTtcbiAgICAgICAgdmFyIGVuZFJvdyA9IChkZWxldGVMYXN0TmV3TGluZSA/IGxhc3RSb3cgKyAxIDogbGFzdFJvdyk7XG4gICAgICAgIHZhciBlbmRDb2wgPSAoZGVsZXRlTGFzdE5ld0xpbmUgPyAwIDogdGhpcy5nZXRMaW5lKGVuZFJvdykubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0Um93LCBzdGFydENvbCwgZW5kUm93LCBlbmRDb2wpO1xuICAgICAgICB2YXIgZGVsZXRlZExpbmVzID0gdGhpcy4kbGluZXMuc2xpY2UoZmlyc3RSb3csIGxhc3RSb3cgKyAxKTtcbiAgICAgICAgdGhpcy5hcHBseURlbHRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiByYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcmFuZ2UuZW5kLFxuICAgICAgICAgICAgYWN0aW9uOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgbGluZXM6IHRoaXMuZ2V0TGluZXNGb3JSYW5nZShyYW5nZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkTGluZXM7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmVtb3ZlTmV3TGluZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKHJvdyA8IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxICYmIHJvdyA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBvcyhyb3csIHRoaXMuZ2V0TGluZShyb3cpLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBvcyhyb3cgKyAxLCAwKSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgbGluZXM6IFtcIlwiLCBcIlwiXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKVxuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDAgJiYgcmFuZ2UuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLmdldFRleHRSYW5nZShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZW5kO1xuICAgICAgICB0aGlzLnJlbW92ZShyYW5nZSk7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmluc2VydChyYW5nZS5zdGFydCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmFwcGx5RGVsdGFzID0gZnVuY3Rpb24gKGRlbHRhcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hcHBseURlbHRhKGRlbHRhc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZXZlcnREZWx0YXMgPSBmdW5jdGlvbiAoZGVsdGFzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBkZWx0YXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0RGVsdGEoZGVsdGFzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmFwcGx5RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEsIGRvTm90VmFsaWRhdGUpIHtcbiAgICAgICAgdmFyIGlzSW5zZXJ0ID0gZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCI7XG4gICAgICAgIGlmIChpc0luc2VydCA/IGRlbHRhLmxpbmVzLmxlbmd0aCA8PSAxICYmICFkZWx0YS5saW5lc1swXVxuICAgICAgICAgICAgOiAhUmFuZ2UuY29tcGFyZVBvaW50cyhkZWx0YS5zdGFydCwgZGVsdGEuZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luc2VydCAmJiBkZWx0YS5saW5lcy5sZW5ndGggPiAyMDAwMCkge1xuICAgICAgICAgICAgdGhpcy4kc3BsaXRBbmRhcHBseUxhcmdlRGVsdGEoZGVsdGEsIDIwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5RGVsdGEodGhpcy4kbGluZXMsIGRlbHRhLCBkb05vdFZhbGlkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS4kc2FmZUFwcGx5RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIGRvY0xlbmd0aCA9IHRoaXMuJGxpbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVwiICYmIGRlbHRhLnN0YXJ0LnJvdyA8IGRvY0xlbmd0aCAmJiBkZWx0YS5lbmQucm93IDwgZG9jTGVuZ3RoXG4gICAgICAgICAgICB8fCBkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIiAmJiBkZWx0YS5zdGFydC5yb3cgPD0gZG9jTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuJHNwbGl0QW5kYXBwbHlMYXJnZURlbHRhID0gZnVuY3Rpb24gKGRlbHRhLCBNQVgpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZGVsdGEubGluZXM7XG4gICAgICAgIHZhciBsID0gbGluZXMubGVuZ3RoIC0gTUFYICsgMTtcbiAgICAgICAgdmFyIHJvdyA9IGRlbHRhLnN0YXJ0LnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IGRlbHRhLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgZm9yICh2YXIgZnJvbSA9IDAsIHRvID0gMDsgZnJvbSA8IGw7IGZyb20gPSB0bykge1xuICAgICAgICAgICAgdG8gKz0gTUFYIC0gMTtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IGxpbmVzLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGNodW5rLnB1c2goXCJcIik7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVsdGEoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBvcyhyb3cgKyBmcm9tLCBjb2x1bW4pLFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcy5wb3Mocm93ICsgdG8sIGNvbHVtbiA9IDApLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogZGVsdGEuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGxpbmVzOiBjaHVua1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGEubGluZXMgPSBsaW5lcy5zbGljZShmcm9tKTtcbiAgICAgICAgZGVsdGEuc3RhcnQucm93ID0gcm93ICsgZnJvbTtcbiAgICAgICAgZGVsdGEuc3RhcnQuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLmFwcGx5RGVsdGEoZGVsdGEsIHRydWUpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJldmVydERlbHRhID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuJHNhZmVBcHBseURlbHRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNsb25lUG9zKGRlbHRhLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5jbG9uZVBvcyhkZWx0YS5lbmQpLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCIgPyBcInJlbW92ZVwiIDogXCJpbnNlcnRcIiksXG4gICAgICAgICAgICBsaW5lczogZGVsdGEubGluZXMuc2xpY2UoKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5pbmRleFRvUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHN0YXJ0Um93KSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMuJGxpbmVzIHx8IHRoaXMuZ2V0QWxsTGluZXMoKTtcbiAgICAgICAgdmFyIG5ld2xpbmVMZW5ndGggPSB0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdyB8fCAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleCAtPSBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyByb3c6IGksIGNvbHVtbjogaW5kZXggKyBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcm93OiBsIC0gMSwgY29sdW1uOiBpbmRleCArIGxpbmVzW2wgLSAxXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25Ub0luZGV4ID0gZnVuY3Rpb24gKHBvcywgc3RhcnRSb3cpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kbGluZXMgfHwgdGhpcy5nZXRBbGxMaW5lcygpO1xuICAgICAgICB2YXIgbmV3bGluZUxlbmd0aCA9IHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJvdyA9IE1hdGgubWluKHBvcy5yb3csIGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdyB8fCAwOyBpIDwgcm93OyArK2kpXG4gICAgICAgICAgICBpbmRleCArPSBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoO1xuICAgICAgICByZXR1cm4gaW5kZXggKyBwb3MuY29sdW1uO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLiRzcGxpdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50O1xufSgpKTtcbkRvY3VtZW50LnByb3RvdHlwZS4kYXV0b05ld0xpbmUgPSBcIlwiO1xuRG9jdW1lbnQucHJvdG90eXBlLiRuZXdMaW5lTW9kZSA9IFwiYXV0b1wiO1xub29wLmltcGxlbWVudChEb2N1bWVudC5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2JhY2tncm91bmRfdG9rZW5pemVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIEJhY2tncm91bmRUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFja2dyb3VuZFRva2VuaXplcih0b2tlbml6ZXIsIHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuJHdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdvcmtlclN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGluZSA9IHNlbGYuY3VycmVudExpbmU7XG4gICAgICAgICAgICB2YXIgZW5kTGluZSA9IC0xO1xuICAgICAgICAgICAgdmFyIGRvYyA9IHNlbGYuZG9jO1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGYubGluZXNbY3VycmVudExpbmVdKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgICB2YXIgbGVuID0gZG9jLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NlZExpbmVzID0gMDtcbiAgICAgICAgICAgIHNlbGYucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRMaW5lIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi4kdG9rZW5pemVSb3coY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBjdXJyZW50TGluZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoc2VsZi5saW5lc1tjdXJyZW50TGluZV0pO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZExpbmVzKys7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzZWRMaW5lcyAlIDUgPT09IDApICYmIChuZXcgRGF0ZSgpIC0gd29ya2VyU3RhcnQpID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ydW5uaW5nID0gc2V0VGltZW91dChzZWxmLiR3b3JrZXIsIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdXJyZW50TGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgaWYgKGVuZExpbmUgPT0gLTEpXG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TGluZSA8PSBlbmRMaW5lKVxuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVVwZGF0ZUV2ZW50KHN0YXJ0TGluZSwgZW5kTGluZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLnNldFRva2VuaXplciA9IGZ1bmN0aW9uICh0b2tlbml6ZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCgwKTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLnNldERvY3VtZW50ID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLmZpcmVVcGRhdGVFdmVudCA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGZpcnN0OiBmaXJzdFJvdyxcbiAgICAgICAgICAgIGxhc3Q6IGxhc3RSb3dcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwidXBkYXRlXCIsIHsgZGF0YTogZGF0YSB9KTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0Um93KSB7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBNYXRoLm1pbihzdGFydFJvdyB8fCAwLCB0aGlzLmN1cnJlbnRMaW5lLCB0aGlzLmRvYy5nZXRMZW5ndGgoKSk7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMuY3VycmVudExpbmUsIHRoaXMubGluZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMuc3BsaWNlKHRoaXMuY3VycmVudExpbmUsIHRoaXMuc3RhdGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBzZXRUaW1lb3V0KHRoaXMuJHdvcmtlciwgNzAwKTtcbiAgICB9O1xuICAgIEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLnNjaGVkdWxlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gc2V0VGltZW91dCh0aGlzLiR3b3JrZXIsIDcwMCk7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS4kdXBkYXRlT25DaGFuZ2UgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gZGVsdGEuZW5kLnJvdyAtIHN0YXJ0Um93O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzW3N0YXJ0Um93XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHN0YXJ0Um93LCBsZW4gKyAxLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnNwbGljZShzdGFydFJvdywgbGVuICsgMSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5KGxlbiArIDEpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHN0YXJ0Um93LCAxKTtcbiAgICAgICAgICAgIHRoaXMubGluZXMuc3BsaWNlLmFwcGx5KHRoaXMubGluZXMsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMuc3BsaWNlLmFwcGx5KHRoaXMuc3RhdGVzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gTWF0aC5taW4oc3RhcnRSb3csIHRoaXMuY3VycmVudExpbmUsIHRoaXMuZG9jLmdldExlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucnVubmluZyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuZ2V0VG9rZW5zID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tyb3ddIHx8IHRoaXMuJHRva2VuaXplUm93KHJvdyk7XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExpbmUgPT0gcm93KVxuICAgICAgICAgICAgdGhpcy4kdG9rZW5pemVSb3cocm93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW3Jvd10gfHwgXCJzdGFydFwiO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuJHRva2VuaXplUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZXNbcm93IC0gMV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy50b2tlbml6ZXIuZ2V0TGluZVRva2VucyhsaW5lLCBzdGF0ZSwgcm93KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzW3Jvd10gKyBcIlwiICE9PSBkYXRhLnN0YXRlICsgXCJcIikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXNbcm93XSA9IGRhdGEuc3RhdGU7XG4gICAgICAgICAgICB0aGlzLmxpbmVzW3JvdyArIDFdID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMaW5lID4gcm93ICsgMSlcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gcm93ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRMaW5lID09IHJvdykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IHJvdyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXNbcm93XSA9IGRhdGEudG9rZW5zO1xuICAgIH07XG4gICAgQmFja2dyb3VuZFRva2VuaXplci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IDA7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFja2dyb3VuZFRva2VuaXplcjtcbn0oKSk7XG5vb3AuaW1wbGVtZW50KEJhY2tncm91bmRUb2tlbml6ZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5CYWNrZ3JvdW5kVG9rZW5pemVyID0gQmFja2dyb3VuZFRva2VuaXplcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uvc2VhcmNoX2hpZ2hsaWdodFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgU2VhcmNoSGlnaGxpZ2h0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaEhpZ2hsaWdodChyZWdFeHAsIGNsYXp6LCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IFwidGV4dFwiOyB9XG4gICAgICAgIHRoaXMuc2V0UmVnZXhwKHJlZ0V4cCk7XG4gICAgICAgIHRoaXMuY2xhenogPSBjbGF6ejtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kb2NMZW4gPSAwO1xuICAgIH1cbiAgICBTZWFyY2hIaWdobGlnaHQucHJvdG90eXBlLnNldFJlZ2V4cCA9IGZ1bmN0aW9uIChyZWdFeHApIHtcbiAgICAgICAgaWYgKHRoaXMucmVnRXhwICsgXCJcIiA9PSByZWdFeHAgKyBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlZ0V4cCA9IHJlZ0V4cDtcbiAgICAgICAgdGhpcy5jYWNoZSA9IFtdO1xuICAgIH07XG4gICAgU2VhcmNoSGlnaGxpZ2h0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaHRtbCwgbWFya2VyTGF5ZXIsIHNlc3Npb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoIXRoaXMucmVnRXhwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnQgPSBjb25maWcuZmlyc3RSb3c7XG4gICAgICAgIHZhciBlbmQgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIHJlbmRlcmVkTWFya2VyUmFuZ2VzID0ge307XG4gICAgICAgIHZhciBfc2VhcmNoID0gc2Vzc2lvbi4kZWRpdG9yLiRzZWFyY2g7XG4gICAgICAgIHZhciBtdFNlYXJjaCA9IF9zZWFyY2guJGlzTXVsdGlsaW5lU2VhcmNoKHNlc3Npb24uJGVkaXRvci5nZXRMYXN0U2VhcmNoT3B0aW9ucygpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMgPT0gbnVsbCB8fCBzZXNzaW9uLmdldFZhbHVlKCkubGVuZ3RoICE9IHRoaXMuZG9jTGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG10U2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBfc2VhcmNoLiRtdWx0aUxpbmVGb3J3YXJkKHNlc3Npb24sIHRoaXMucmVnRXhwLCBpLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRfcm93ID0gbWF0Y2guZW5kUm93IDw9IGVuZCA/IG1hdGNoLmVuZFJvdyAtIDEgOiBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kX3JvdyA+IGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVuZF9yb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UobWF0Y2guc3RhcnRSb3csIG1hdGNoLnN0YXJ0Q29sLCBtYXRjaC5lbmRSb3csIG1hdGNoLmVuZENvbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gdGhpcy5NQVhfUkFOR0VTKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gcmFuZ2VzLnNsaWNlKDAsIHRoaXMuTUFYX1JBTkdFUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSBsYW5nLmdldE1hdGNoT2Zmc2V0cyhzZXNzaW9uLmdldExpbmUoaSksIHRoaXMucmVnRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiB0aGlzLk1BWF9SQU5HRVMpXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoMCwgdGhpcy5NQVhfUkFOR0VTKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoaSwgbWF0Y2gub2Zmc2V0LCBpLCBtYXRjaC5vZmZzZXQgKyBtYXRjaC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVtpXSA9IHJhbmdlcy5sZW5ndGggPyByYW5nZXMgOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcmFuZ2VzLmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZVRvQWRkTWFya2VyVG8gPSByYW5nZXNbal0udG9TY3JlZW5SYW5nZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VBc1N0cmluZyA9IHJhbmdlVG9BZGRNYXJrZXJUby50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZE1hcmtlclJhbmdlc1tyYW5nZUFzU3RyaW5nXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRNYXJrZXJSYW5nZXNbcmFuZ2VBc1N0cmluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcmtlckxheWVyLmRyYXdTaW5nbGVMaW5lTWFya2VyKGh0bWwsIHJhbmdlVG9BZGRNYXJrZXJUbywgdGhpcy5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY0xlbiA9IHNlc3Npb24uZ2V0VmFsdWUoKS5sZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoSGlnaGxpZ2h0O1xufSgpKTtcblNlYXJjaEhpZ2hsaWdodC5wcm90b3R5cGUuTUFYX1JBTkdFUyA9IDUwMDtcbmV4cG9ydHMuU2VhcmNoSGlnaGxpZ2h0ID0gU2VhcmNoSGlnaGxpZ2h0O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS91bmRvbWFuYWdlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFVuZG9NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuZG9NYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLiRrZWVwUmVkb1N0YWNrO1xuICAgICAgICB0aGlzLiRtYXhSZXYgPSAwO1xuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiR1bmRvRGVwdGggPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuYWRkU2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuJHNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkZWx0YSwgYWxsb3dNZXJnZSwgc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy4kZnJvbVVuZG8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChkZWx0YSA9PSB0aGlzLiRsYXN0RGVsdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy4ka2VlcFJlZG9TdGFjaylcbiAgICAgICAgICAgIHRoaXMuJHJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoYWxsb3dNZXJnZSA9PT0gZmFsc2UgfHwgIXRoaXMubGFzdERlbHRhcykge1xuICAgICAgICAgICAgdGhpcy5sYXN0RGVsdGFzID0gW107XG4gICAgICAgICAgICB2YXIgdW5kb1N0YWNrTGVuZ3RoID0gdGhpcy4kdW5kb1N0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh1bmRvU3RhY2tMZW5ndGggPiB0aGlzLiR1bmRvRGVwdGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdW5kb1N0YWNrLnNwbGljZSgwLCB1bmRvU3RhY2tMZW5ndGggLSB0aGlzLiR1bmRvRGVwdGggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHVuZG9TdGFjay5wdXNoKHRoaXMubGFzdERlbHRhcyk7XG4gICAgICAgICAgICBkZWx0YS5pZCA9IHRoaXMuJHJldiA9ICsrdGhpcy4kbWF4UmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVcIiB8fCBkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIilcbiAgICAgICAgICAgIHRoaXMuJGxhc3REZWx0YSA9IGRlbHRhO1xuICAgICAgICB0aGlzLmxhc3REZWx0YXMucHVzaChkZWx0YSk7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuYWRkU2VsZWN0aW9uID0gZnVuY3Rpb24gKHNlbGVjdGlvbiwgcmV2KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3Rpb24sXG4gICAgICAgICAgICByZXY6IHJldiB8fCB0aGlzLiRyZXZcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuc3RhcnROZXdHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0RGVsdGFzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJldjtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5tYXJrSWdub3JlZCA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gdGhpcy4kcmV2ICsgMTtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy4kdW5kb1N0YWNrO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBzdGFja1tpXVswXTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5pZCA8PSBmcm9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGRlbHRhLmlkIDwgdG8pXG4gICAgICAgICAgICAgICAgZGVsdGEuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REZWx0YXMgPSBudWxsO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChyZXYsIGFmdGVyKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc2VsZWN0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5yZXYgPCByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHN0YWNrW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuZ2V0UmV2aXNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZXY7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuZ2V0RGVsdGFzID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSB0aGlzLiRyZXYgKyAxO1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLiR1bmRvU3RhY2s7XG4gICAgICAgIHZhciBlbmQgPSBudWxsLCBzdGFydCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHN0YWNrW2ldWzBdO1xuICAgICAgICAgICAgaWYgKGRlbHRhLmlkIDwgdG8gJiYgIWVuZClcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5pZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2suc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2hhbmdlZFJhbmdlcyA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gdGhpcy4kcmV2ICsgMTtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5nZXRDaGFuZ2VkTGluZXMgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHRoaXMuJHJldiArIDE7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBkb250U2VsZWN0KSB7XG4gICAgICAgIHRoaXMubGFzdERlbHRhcyA9IG51bGw7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuJHVuZG9TdGFjaztcbiAgICAgICAgaWYgKCFyZWFycmFuZ2VVbmRvU3RhY2soc3RhY2ssIHN0YWNrLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgIHNlc3Npb24gPSB0aGlzLiRzZXNzaW9uO1xuICAgICAgICBpZiAodGhpcy4kcmVkb1N0YWNrQmFzZVJldiAhPT0gdGhpcy4kcmV2ICYmIHRoaXMuJHJlZG9TdGFjay5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRyZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xuICAgICAgICB2YXIgZGVsdGFTZXQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHVuZG9TZWxlY3Rpb25SYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChkZWx0YVNldCkge1xuICAgICAgICAgICAgdW5kb1NlbGVjdGlvblJhbmdlID0gc2Vzc2lvbi51bmRvQ2hhbmdlcyhkZWx0YVNldCwgZG9udFNlbGVjdCk7XG4gICAgICAgICAgICB0aGlzLiRyZWRvU3RhY2sucHVzaChkZWx0YVNldCk7XG4gICAgICAgICAgICB0aGlzLiRzeW5jUmV2KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHVuZG9TZWxlY3Rpb25SYW5nZTtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHNlc3Npb24sIGRvbnRTZWxlY3QpIHtcbiAgICAgICAgdGhpcy5sYXN0RGVsdGFzID0gbnVsbDtcbiAgICAgICAgaWYgKCFzZXNzaW9uKVxuICAgICAgICAgICAgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb247XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuJHJlZG9TdGFja0Jhc2VSZXYgIT0gdGhpcy4kcmV2KSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuZ2V0RGVsdGFzKHRoaXMuJHJlZG9TdGFja0Jhc2VSZXYsIHRoaXMuJHJldiArIDEpO1xuICAgICAgICAgICAgcmViYXNlUmVkb1N0YWNrKHRoaXMuJHJlZG9TdGFjaywgZGlmZik7XG4gICAgICAgICAgICB0aGlzLiRyZWRvU3RhY2tCYXNlUmV2ID0gdGhpcy4kcmV2O1xuICAgICAgICAgICAgdGhpcy4kcmVkb1N0YWNrLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB4WzBdLmlkID0gKyt0aGlzLiRtYXhSZXY7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsdGFTZXQgPSB0aGlzLiRyZWRvU3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZWRvU2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAoZGVsdGFTZXQpIHtcbiAgICAgICAgICAgIHJlZG9TZWxlY3Rpb25SYW5nZSA9IHNlc3Npb24ucmVkb0NoYW5nZXMoZGVsdGFTZXQsIGRvbnRTZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy4kdW5kb1N0YWNrLnB1c2goZGVsdGFTZXQpO1xuICAgICAgICAgICAgdGhpcy4kc3luY1JldigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZWRvU2VsZWN0aW9uUmFuZ2U7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuJHN5bmNSZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuJHVuZG9TdGFjaztcbiAgICAgICAgdmFyIG5leHREZWx0YSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaWQgPSBuZXh0RGVsdGEgJiYgbmV4dERlbHRhWzBdLmlkIHx8IDA7XG4gICAgICAgIHRoaXMuJHJlZG9TdGFja0Jhc2VSZXYgPSBpZDtcbiAgICAgICAgdGhpcy4kcmV2ID0gaWQ7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdERlbHRhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJGxhc3REZWx0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHVuZG9TdGFjayA9IFtdO1xuICAgICAgICB0aGlzLiRyZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy4kcmV2ID0gMDtcbiAgICAgICAgdGhpcy5tYXJrID0gMDtcbiAgICAgICAgdGhpcy4kcmVkb1N0YWNrQmFzZVJldiA9IHRoaXMuJHJldjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuY2FuVW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVuZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgVW5kb01hbmFnZXIucHJvdG90eXBlLmNhblJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5ib29rbWFyayA9IGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgICAgaWYgKHJldiA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXYgPSB0aGlzLiRyZXY7XG4gICAgICAgIHRoaXMubWFyayA9IHJldjtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5pc0F0Qm9va21hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZXYgPT09IHRoaXMubWFyaztcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkcmVkb1N0YWNrOiB0aGlzLiRyZWRvU3RhY2ssXG4gICAgICAgICAgICAkdW5kb1N0YWNrOiB0aGlzLiR1bmRvU3RhY2tcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy4kdW5kb1N0YWNrID0ganNvbi4kdW5kb1N0YWNrO1xuICAgICAgICB0aGlzLiRyZWRvU3RhY2sgPSBqc29uLiRyZWRvU3RhY2s7XG4gICAgfTtcbiAgICBVbmRvTWFuYWdlci5wcm90b3R5cGUuJHByZXR0eVByaW50ID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlEZWx0YShkZWx0YSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlEZWx0YSh0aGlzLiR1bmRvU3RhY2spICsgXCJcXG4tLS1cXG5cIiArIHN0cmluZ2lmeURlbHRhKHRoaXMuJHJlZG9TdGFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5kb01hbmFnZXI7XG59KCkpO1xuVW5kb01hbmFnZXIucHJvdG90eXBlLmhhc1VuZG8gPSBVbmRvTWFuYWdlci5wcm90b3R5cGUuY2FuVW5kbztcblVuZG9NYW5hZ2VyLnByb3RvdHlwZS5oYXNSZWRvID0gVW5kb01hbmFnZXIucHJvdG90eXBlLmNhblJlZG87XG5VbmRvTWFuYWdlci5wcm90b3R5cGUuaXNDbGVhbiA9IFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5pc0F0Qm9va21hcms7XG5VbmRvTWFuYWdlci5wcm90b3R5cGUubWFya0NsZWFuID0gVW5kb01hbmFnZXIucHJvdG90eXBlLmJvb2ttYXJrO1xuZnVuY3Rpb24gcmVhcnJhbmdlVW5kb1N0YWNrKHN0YWNrLCBwb3MpIHtcbiAgICBmb3IgKHZhciBpID0gcG9zOyBpLS07KSB7XG4gICAgICAgIHZhciBkZWx0YVNldCA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZGVsdGFTZXQgJiYgIWRlbHRhU2V0WzBdLmlnbm9yZSkge1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBwb3MgLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN3YXBwZWQgPSBzd2FwR3JvdXBzKHN0YWNrW2ldLCBzdGFja1tpICsgMV0pO1xuICAgICAgICAgICAgICAgIHN0YWNrW2ldID0gc3dhcHBlZFswXTtcbiAgICAgICAgICAgICAgICBzdGFja1tpICsgMV0gPSBzd2FwcGVkWzFdO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgY21wID0gUmFuZ2UuY29tcGFyZVBvaW50cztcbnZhciBjb21wYXJlUG9pbnRzID0gUmFuZ2UuY29tcGFyZVBvaW50cztcbmZ1bmN0aW9uICR1cGRhdGVNYXJrZXJzKGRlbHRhKSB7XG4gICAgdmFyIGlzSW5zZXJ0ID0gZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0XCI7XG4gICAgdmFyIHN0YXJ0ID0gZGVsdGEuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IGRlbHRhLmVuZDtcbiAgICB2YXIgcm93U2hpZnQgPSAoZW5kLnJvdyAtIHN0YXJ0LnJvdykgKiAoaXNJbnNlcnQgPyAxIDogLTEpO1xuICAgIHZhciBjb2xTaGlmdCA9IChlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKSAqIChpc0luc2VydCA/IDEgOiAtMSk7XG4gICAgaWYgKGlzSW5zZXJ0KVxuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMubWFya3MpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5tYXJrc1tpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocG9pbnQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBkZWx0YSBzdGFydHMgYWZ0ZXIgdGhlIHJhbmdlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50LmJpYXMgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjbXAgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuYmlhcyA9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjbXAyID0gaXNJbnNlcnQgPyBjbXAgOiBjb21wYXJlUG9pbnRzKHBvaW50LCBlbmQpO1xuICAgICAgICBpZiAoY21wMiA+IDApIHtcbiAgICAgICAgICAgIHBvaW50LnJvdyArPSByb3dTaGlmdDtcbiAgICAgICAgICAgIHBvaW50LmNvbHVtbiArPSBwb2ludC5yb3cgPT0gZW5kLnJvdyA/IGNvbFNoaWZ0IDogMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNJbnNlcnQgJiYgY21wMiA8PSAwKSB7XG4gICAgICAgICAgICBwb2ludC5yb3cgPSBzdGFydC5yb3c7XG4gICAgICAgICAgICBwb2ludC5jb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICBpZiAoY21wMiA9PT0gMClcbiAgICAgICAgICAgICAgICBwb2ludC5iaWFzID0gMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lUG9zKHBvcykge1xuICAgIHJldHVybiB7IHJvdzogcG9zLnJvdywgY29sdW1uOiBwb3MuY29sdW1uIH07XG59XG5mdW5jdGlvbiBjbG9uZURlbHRhKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogY2xvbmVQb3MoZC5zdGFydCksXG4gICAgICAgIGVuZDogY2xvbmVQb3MoZC5lbmQpLFxuICAgICAgICBhY3Rpb246IGQuYWN0aW9uLFxuICAgICAgICBsaW5lczogZC5saW5lcy5zbGljZSgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeURlbHRhKGQpIHtcbiAgICBkID0gZCB8fCB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGQpKSB7XG4gICAgICAgIHJldHVybiBkLm1hcChzdHJpbmdpZnlEZWx0YSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBcIlwiO1xuICAgIGlmIChkLmFjdGlvbikge1xuICAgICAgICB0eXBlID0gZC5hY3Rpb24gPT0gXCJpbnNlcnRcIiA/IFwiK1wiIDogXCItXCI7XG4gICAgICAgIHR5cGUgKz0gXCJbXCIgKyBkLmxpbmVzICsgXCJdXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGQudmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBkLnZhbHVlLm1hcChzdHJpbmdpZnlSYW5nZSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSBzdHJpbmdpZnlSYW5nZShkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZC5zdGFydCkge1xuICAgICAgICB0eXBlICs9IHN0cmluZ2lmeVJhbmdlKGQpO1xuICAgIH1cbiAgICBpZiAoZC5pZCB8fCBkLnJldikge1xuICAgICAgICB0eXBlICs9IFwiXFx0KFwiICsgKGQuaWQgfHwgZC5yZXYpICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmFuZ2Uocikge1xuICAgIHJldHVybiByLnN0YXJ0LnJvdyArIFwiOlwiICsgci5zdGFydC5jb2x1bW5cbiAgICAgICAgKyBcIj0+XCIgKyByLmVuZC5yb3cgKyBcIjpcIiArIHIuZW5kLmNvbHVtbjtcbn1cbmZ1bmN0aW9uIHN3YXAoZDEsIGQyKSB7XG4gICAgdmFyIGkxID0gZDEuYWN0aW9uID09IFwiaW5zZXJ0XCI7XG4gICAgdmFyIGkyID0gZDIuYWN0aW9uID09IFwiaW5zZXJ0XCI7XG4gICAgaWYgKGkxICYmIGkyKSB7XG4gICAgICAgIGlmIChjbXAoZDIuc3RhcnQsIGQxLmVuZCkgPj0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDIsIGQxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wKGQyLnN0YXJ0LCBkMS5zdGFydCkgPD0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDEsIGQyLCArMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpMSAmJiAhaTIpIHtcbiAgICAgICAgaWYgKGNtcChkMi5zdGFydCwgZDEuZW5kKSA+PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMiwgZDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAoZDIuZW5kLCBkMS5zdGFydCkgPD0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDEsIGQyLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaTEgJiYgaTIpIHtcbiAgICAgICAgaWYgKGNtcChkMi5zdGFydCwgZDEuc3RhcnQpID49IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQyLCBkMSwgKzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcChkMi5zdGFydCwgZDEuc3RhcnQpIDw9IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBkMiwgKzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWkxICYmICFpMikge1xuICAgICAgICBpZiAoY21wKGQyLnN0YXJ0LCBkMS5zdGFydCkgPj0gMCkge1xuICAgICAgICAgICAgc2hpZnQoZDIsIGQxLCArMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wKGQyLmVuZCwgZDEuc3RhcnQpIDw9IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBkMiwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtkMiwgZDFdO1xufVxuZnVuY3Rpb24gc3dhcEdyb3VwcyhkczEsIGRzMikge1xuICAgIGZvciAodmFyIGkgPSBkczEubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoIXN3YXAoZHMxW2ldLCBkczJbal0pKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBkczEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAoZHMyW2pdLCBkczFbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogPSBkczIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbZHMxLCBkczJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRzMS5zZWxlY3Rpb25CZWZvcmUgPSBkczIuc2VsZWN0aW9uQmVmb3JlID1cbiAgICAgICAgZHMxLnNlbGVjdGlvbkFmdGVyID0gZHMyLnNlbGVjdGlvbkFmdGVyID0gbnVsbDtcbiAgICByZXR1cm4gW2RzMiwgZHMxXTtcbn1cbmZ1bmN0aW9uIHhmb3JtKGQxLCBjMSkge1xuICAgIHZhciBpMSA9IGQxLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIHZhciBpMiA9IGMxLmFjdGlvbiA9PSBcImluc2VydFwiO1xuICAgIGlmIChpMSAmJiBpMikge1xuICAgICAgICBpZiAoY21wKGQxLnN0YXJ0LCBjMS5zdGFydCkgPCAwKSB7XG4gICAgICAgICAgICBzaGlmdChjMSwgZDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hpZnQoZDEsIGMxLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpMSAmJiAhaTIpIHtcbiAgICAgICAgaWYgKGNtcChkMS5zdGFydCwgYzEuZW5kKSA+PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgYzEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAoZDEuc3RhcnQsIGMxLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChjMSwgZDEsICsxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBSYW5nZS5mcm9tUG9pbnRzKGMxLnN0YXJ0LCBkMS5zdGFydCksIC0xKTtcbiAgICAgICAgICAgIHNoaWZ0KGMxLCBkMSwgKzEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpMSAmJiBpMikge1xuICAgICAgICBpZiAoY21wKGMxLnN0YXJ0LCBkMS5lbmQpID49IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGMxLCBkMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcChjMS5zdGFydCwgZDEuc3RhcnQpIDw9IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGQxLCBjMSwgKzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hpZnQoYzEsIFJhbmdlLmZyb21Qb2ludHMoZDEuc3RhcnQsIGMxLnN0YXJ0KSwgLTEpO1xuICAgICAgICAgICAgc2hpZnQoZDEsIGMxLCArMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWkxICYmICFpMikge1xuICAgICAgICBpZiAoY21wKGMxLnN0YXJ0LCBkMS5lbmQpID49IDApIHtcbiAgICAgICAgICAgIHNoaWZ0KGMxLCBkMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcChjMS5lbmQsIGQxLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgICAgICBzaGlmdChkMSwgYzEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiZWZvcmUsIGFmdGVyO1xuICAgICAgICAgICAgaWYgKGNtcChkMS5zdGFydCwgYzEuc3RhcnQpIDwgMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGQxO1xuICAgICAgICAgICAgICAgIGQxID0gc3BsaXREZWx0YShkMSwgYzEuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtcChkMS5lbmQsIGMxLmVuZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBzcGxpdERlbHRhKGQxLCBjMS5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hpZnRQb3MoYzEuZW5kLCBkMS5zdGFydCwgZDEuZW5kLCAtMSk7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIWJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGQxLmxpbmVzID0gYWZ0ZXIubGluZXM7XG4gICAgICAgICAgICAgICAgZDEuc3RhcnQgPSBhZnRlci5zdGFydDtcbiAgICAgICAgICAgICAgICBkMS5lbmQgPSBhZnRlci5lbmQ7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbYzEsIGJlZm9yZSwgYWZ0ZXJdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2MxLCBkMV07XG59XG5mdW5jdGlvbiBzaGlmdChkMSwgZDIsIGRpcikge1xuICAgIHNoaWZ0UG9zKGQxLnN0YXJ0LCBkMi5zdGFydCwgZDIuZW5kLCBkaXIpO1xuICAgIHNoaWZ0UG9zKGQxLmVuZCwgZDIuc3RhcnQsIGQyLmVuZCwgZGlyKTtcbn1cbmZ1bmN0aW9uIHNoaWZ0UG9zKHBvcywgc3RhcnQsIGVuZCwgZGlyKSB7XG4gICAgaWYgKHBvcy5yb3cgPT0gKGRpciA9PSAxID8gc3RhcnQgOiBlbmQpLnJvdykge1xuICAgICAgICBwb3MuY29sdW1uICs9IGRpciAqIChlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKTtcbiAgICB9XG4gICAgcG9zLnJvdyArPSBkaXIgKiAoZW5kLnJvdyAtIHN0YXJ0LnJvdyk7XG59XG5mdW5jdGlvbiBzcGxpdERlbHRhKGMsIHBvcykge1xuICAgIHZhciBsaW5lcyA9IGMubGluZXM7XG4gICAgdmFyIGVuZCA9IGMuZW5kO1xuICAgIGMuZW5kID0gY2xvbmVQb3MocG9zKTtcbiAgICB2YXIgcm93c0JlZm9yZSA9IGMuZW5kLnJvdyAtIGMuc3RhcnQucm93O1xuICAgIHZhciBvdGhlckxpbmVzID0gbGluZXMuc3BsaWNlKHJvd3NCZWZvcmUsIGxpbmVzLmxlbmd0aCk7XG4gICAgdmFyIGNvbCA9IHJvd3NCZWZvcmUgPyBwb3MuY29sdW1uIDogcG9zLmNvbHVtbiAtIGMuc3RhcnQuY29sdW1uO1xuICAgIGxpbmVzLnB1c2gob3RoZXJMaW5lc1swXS5zdWJzdHJpbmcoMCwgY29sKSk7XG4gICAgb3RoZXJMaW5lc1swXSA9IG90aGVyTGluZXNbMF0uc3Vic3RyKGNvbCk7XG4gICAgdmFyIHJlc3QgPSB7XG4gICAgICAgIHN0YXJ0OiBjbG9uZVBvcyhwb3MpLFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgbGluZXM6IG90aGVyTGluZXMsXG4gICAgICAgIGFjdGlvbjogYy5hY3Rpb25cbiAgICB9O1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gbW92ZURlbHRhc0J5T25lKHJlZG9TdGFjaywgZCkge1xuICAgIGQgPSBjbG9uZURlbHRhKGQpO1xuICAgIGZvciAodmFyIGogPSByZWRvU3RhY2subGVuZ3RoOyBqLS07KSB7XG4gICAgICAgIHZhciBkZWx0YVNldCA9IHJlZG9TdGFja1tqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBkZWx0YVNldFtpXTtcbiAgICAgICAgICAgIHZhciB4Zm9ybWVkID0geGZvcm0oeCwgZCk7XG4gICAgICAgICAgICBkID0geGZvcm1lZFswXTtcbiAgICAgICAgICAgIGlmICh4Zm9ybWVkLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhmb3JtZWRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFTZXQuc3BsaWNlKGkgKyAxLCAxLCB4Zm9ybWVkWzFdLCB4Zm9ybWVkWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgheGZvcm1lZFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVNldC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWx0YVNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlZG9TdGFjay5zcGxpY2UoaiwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZG9TdGFjaztcbn1cbmZ1bmN0aW9uIHJlYmFzZVJlZG9TdGFjayhyZWRvU3RhY2ssIGRlbHRhU2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFTZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZWx0YXMgPSBkZWx0YVNldHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVsdGFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBtb3ZlRGVsdGFzQnlPbmUocmVkb1N0YWNrLCBkZWx0YXNbal0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VbmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9lZGl0X3Nlc3Npb24vZm9sZF9saW5lXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgRm9sZExpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9sZExpbmUoZm9sZERhdGEsIGZvbGRzKSB7XG4gICAgICAgIHRoaXMuZm9sZERhdGEgPSBmb2xkRGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZHMpKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGRzID0gZm9sZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHMgPSBbZm9sZHNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0ID0gZm9sZHNbZm9sZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UoZm9sZHNbMF0uc3RhcnQucm93LCBmb2xkc1swXS5zdGFydC5jb2x1bW4sIGxhc3QuZW5kLnJvdywgbGFzdC5lbmQuY29sdW1uKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5yYW5nZS5lbmQ7XG4gICAgICAgIHRoaXMuZm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgZm9sZC5zZXRGb2xkTGluZSh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIEZvbGRMaW5lLnByb3RvdHlwZS5zaGlmdFJvdyA9IGZ1bmN0aW9uIChzaGlmdCkge1xuICAgICAgICB0aGlzLnN0YXJ0LnJvdyArPSBzaGlmdDtcbiAgICAgICAgdGhpcy5lbmQucm93ICs9IHNoaWZ0O1xuICAgICAgICB0aGlzLmZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQuc3RhcnQucm93ICs9IHNoaWZ0O1xuICAgICAgICAgICAgZm9sZC5lbmQucm93ICs9IHNoaWZ0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS5hZGRGb2xkID0gZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgaWYgKGZvbGQuc2FtZVJvdykge1xuICAgICAgICAgICAgaWYgKGZvbGQuc3RhcnQucm93IDwgdGhpcy5zdGFydFJvdyB8fCBmb2xkLmVuZFJvdyA+IHRoaXMuZW5kUm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYWRkIGEgZm9sZCB0byB0aGlzIEZvbGRMaW5lIGFzIGl0IGhhcyBubyBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb2xkcy5wdXNoKGZvbGQpO1xuICAgICAgICAgICAgdGhpcy5mb2xkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1hLnJhbmdlLmNvbXBhcmVFbmQoYi5zdGFydC5yb3csIGIuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2UuY29tcGFyZUVuZChmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4pID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGQuZW5kLnJvdztcbiAgICAgICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSBmb2xkLmVuZC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJhbmdlLmNvbXBhcmVTdGFydChmb2xkLmVuZC5yb3csIGZvbGQuZW5kLmNvbHVtbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvbGQuc3RhcnQucm93ID09IHRoaXMuZW5kLnJvdykge1xuICAgICAgICAgICAgdGhpcy5mb2xkcy5wdXNoKGZvbGQpO1xuICAgICAgICAgICAgdGhpcy5lbmQucm93ID0gZm9sZC5lbmQucm93O1xuICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvbGQuZW5kLnJvdyA9PSB0aGlzLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgdGhpcy5mb2xkcy51bnNoaWZ0KGZvbGQpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gZm9sZC5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gYWRkIGZvbGQgdG8gRm9sZFJvdyB0aGF0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIHJvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmb2xkLmZvbGRMaW5lID0gdGhpcztcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS5jb250YWluc1JvdyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdyA+PSB0aGlzLnN0YXJ0LnJvdyAmJiByb3cgPD0gdGhpcy5lbmQucm93O1xuICAgIH07XG4gICAgRm9sZExpbmUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVuZFJvdywgZW5kQ29sdW1uKSB7XG4gICAgICAgIHZhciBsYXN0RW5kID0gMCwgZm9sZHMgPSB0aGlzLmZvbGRzLCBmb2xkLCBjbXAsIHN0b3AsIGlzTmV3Um93ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVuZFJvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSB0aGlzLmVuZC5yb3c7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9sZCA9IGZvbGRzW2ldO1xuICAgICAgICAgICAgY21wID0gZm9sZC5yYW5nZS5jb21wYXJlU3RhcnQoZW5kUm93LCBlbmRDb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGVuZFJvdywgZW5kQ29sdW1uLCBsYXN0RW5kLCBpc05ld1Jvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xuICAgICAgICAgICAgc3RvcCA9ICFzdG9wICYmIGNhbGxiYWNrKGZvbGQucGxhY2Vob2xkZXIsIGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbiwgbGFzdEVuZCk7XG4gICAgICAgICAgICBpZiAoc3RvcCB8fCBjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc05ld1JvdyA9ICFmb2xkLnNhbWVSb3c7XG4gICAgICAgICAgICBsYXN0RW5kID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGVuZFJvdywgZW5kQ29sdW1uLCBsYXN0RW5kLCBpc05ld1Jvdyk7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuZ2V0TmV4dEZvbGRUbyA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgZm9sZCwgY21wO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmZvbGRzW2ldO1xuICAgICAgICAgICAgY21wID0gZm9sZC5yYW5nZS5jb21wYXJlRW5kKHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb2xkOiBmb2xkLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBcImFmdGVyXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZDogZm9sZCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCJpbnNpZGVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuYWRkUmVtb3ZlQ2hhcnMgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIGxlbikge1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy5nZXROZXh0Rm9sZFRvKHJvdywgY29sdW1uKSwgZm9sZCwgZm9sZHM7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIGZvbGQgPSByZXQuZm9sZDtcbiAgICAgICAgICAgIGlmIChyZXQua2luZCA9PSBcImluc2lkZVwiXG4gICAgICAgICAgICAgICAgJiYgZm9sZC5zdGFydC5jb2x1bW4gIT0gY29sdW1uXG4gICAgICAgICAgICAgICAgJiYgZm9sZC5zdGFydC5yb3cgIT0gcm93KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKHJvdywgY29sdW1uLCBmb2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvbGQuc3RhcnQucm93ID09IHJvdykge1xuICAgICAgICAgICAgICAgIGZvbGRzID0gdGhpcy5mb2xkcztcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZvbGRzLmluZGV4T2YoZm9sZCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gKz0gbGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvbGQuc3RhcnQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb2xkLnNhbWVSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb2xkLmVuZC5jb2x1bW4gKz0gbGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGb2xkTGluZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TmV4dEZvbGRUbyhyb3csIGNvbHVtbik7XG4gICAgICAgIGlmICghcG9zIHx8IHBvcy5raW5kID09IFwiaW5zaWRlXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGZvbGQgPSBwb3MuZm9sZDtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5mb2xkcztcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy5mb2xkRGF0YTtcbiAgICAgICAgdmFyIGkgPSBmb2xkcy5pbmRleE9mKGZvbGQpO1xuICAgICAgICB2YXIgZm9sZEJlZm9yZSA9IGZvbGRzW2kgLSAxXTtcbiAgICAgICAgdGhpcy5lbmQucm93ID0gZm9sZEJlZm9yZS5lbmQucm93O1xuICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSBmb2xkQmVmb3JlLmVuZC5jb2x1bW47XG4gICAgICAgIGZvbGRzID0gZm9sZHMuc3BsaWNlKGksIGZvbGRzLmxlbmd0aCAtIGkpO1xuICAgICAgICB2YXIgbmV3Rm9sZExpbmUgPSBuZXcgRm9sZExpbmUoZm9sZERhdGEsIGZvbGRzKTtcbiAgICAgICAgZm9sZERhdGEuc3BsaWNlKGZvbGREYXRhLmluZGV4T2YodGhpcykgKyAxLCAwLCBuZXdGb2xkTGluZSk7XG4gICAgICAgIHJldHVybiBuZXdGb2xkTGluZTtcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChmb2xkTGluZU5leHQpIHtcbiAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmVOZXh0LmZvbGRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGQoZm9sZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuZm9sZERhdGE7XG4gICAgICAgIGZvbGREYXRhLnNwbGljZShmb2xkRGF0YS5pbmRleE9mKGZvbGRMaW5lTmV4dCksIDEpO1xuICAgIH07XG4gICAgRm9sZExpbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0gW3RoaXMucmFuZ2UudG9TdHJpbmcoKSArIFwiOiBbXCJdO1xuICAgICAgICB0aGlzLmZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiICBcIiArIGZvbGQudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXQucHVzaChcIl1cIik7XG4gICAgICAgIHJldHVybiByZXQuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIEZvbGRMaW5lLnByb3RvdHlwZS5pZHhUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgbGFzdEZvbGRFbmRDb2x1bW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkID0gdGhpcy5mb2xkc1tpXTtcbiAgICAgICAgICAgIGlkeCAtPSBmb2xkLnN0YXJ0LmNvbHVtbiAtIGxhc3RGb2xkRW5kQ29sdW1uO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb3c6IGZvbGQuc3RhcnQucm93LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGZvbGQuc3RhcnQuY29sdW1uICsgaWR4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCAtPSBmb2xkLnBsYWNlaG9sZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbGQuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Rm9sZEVuZENvbHVtbiA9IGZvbGQuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiB0aGlzLmVuZC5yb3csXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuZW5kLmNvbHVtbiArIGlkeFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEZvbGRMaW5lO1xufSgpKTtcbmV4cG9ydHMuRm9sZExpbmUgPSBGb2xkTGluZTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcmFuZ2VfbGlzdFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgY29tcGFyZVBvaW50cyA9IFJhbmdlLmNvbXBhcmVQb2ludHM7XG52YXIgUmFuZ2VMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmdlTGlzdCgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy4kYmlhcyA9IDE7XG4gICAgfVxuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUucG9pbnRJbmRleCA9IGZ1bmN0aW9uIChwb3MsIGV4Y2x1ZGVFZGdlcywgc3RhcnRJbmRleCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBjbXBFbmQgPSBjb21wYXJlUG9pbnRzKHBvcywgcmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChjbXBFbmQgPiAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGNtcFN0YXJ0ID0gY29tcGFyZVBvaW50cyhwb3MsIHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChjbXBFbmQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFZGdlcyAmJiBjbXBTdGFydCAhPT0gMCA/IC1pIC0gMiA6IGk7XG4gICAgICAgICAgICBpZiAoY21wU3RhcnQgPiAwIHx8IChjbXBTdGFydCA9PT0gMCAmJiAhZXhjbHVkZUVkZ2VzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIHJldHVybiAtaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1pIC0gMTtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBleGNsdWRlRWRnZXMgPSAhcmFuZ2UuaXNFbXB0eSgpO1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMucG9pbnRJbmRleChyYW5nZS5zdGFydCwgZXhjbHVkZUVkZ2VzKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCAwKVxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IC1zdGFydEluZGV4IC0gMTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHJhbmdlLmVuZCwgZXhjbHVkZUVkZ2VzLCBzdGFydEluZGV4KTtcbiAgICAgICAgaWYgKGVuZEluZGV4IDwgMClcbiAgICAgICAgICAgIGVuZEluZGV4ID0gLWVuZEluZGV4IC0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLnNwbGljZShzdGFydEluZGV4LCBlbmRJbmRleCAtIHN0YXJ0SW5kZXgsIHJhbmdlKTtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuYWRkTGlzdCA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoLmFwcGx5KHJlbW92ZWQsIHRoaXMuYWRkKGxpc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuc3Vic3RyYWN0UG9pbnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wb2ludEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgIH07XG4gICAgUmFuZ2VMaXN0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludHMoYS5zdGFydCwgYi5zdGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAwICYmICFyYW5nZS5pc0VtcHR5KCkgJiYgIW5leHQuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LmVuZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IG5leHQuZW5kLnJvdztcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2gobmV4dCk7XG4gICAgICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYW5nZXMgPSBsaXN0O1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRJbmRleCh7IHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiB9KSA+PSAwO1xuICAgIH07XG4gICAgUmFuZ2VMaXN0LnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEluZGV4KHBvcykgPj0gMDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUucmFuZ2VBdFBvaW50ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgaSA9IHRoaXMucG9pbnRJbmRleChwb3MpO1xuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2ldO1xuICAgIH07XG4gICAgUmFuZ2VMaXN0LnByb3RvdHlwZS5jbGlwUm93cyA9IGZ1bmN0aW9uIChzdGFydFJvdywgZW5kUm93KSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGlmIChsaXN0WzBdLnN0YXJ0LnJvdyA+IGVuZFJvdyB8fCBsaXN0W2xpc3QubGVuZ3RoIC0gMV0uc3RhcnQucm93IDwgc3RhcnRSb3cpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHsgcm93OiBzdGFydFJvdywgY29sdW1uOiAwIH0pO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA8IDApXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gLXN0YXJ0SW5kZXggLSAxO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSB0aGlzLnBvaW50SW5kZXgoeyByb3c6IGVuZFJvdywgY29sdW1uOiAwIH0sIHN0YXJ0SW5kZXgpO1xuICAgICAgICBpZiAoZW5kSW5kZXggPCAwKVxuICAgICAgICAgICAgZW5kSW5kZXggPSAtZW5kSW5kZXggLSAxO1xuICAgICAgICB2YXIgY2xpcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaChsaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpcHBlZDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKDAsIHRoaXMucmFuZ2VzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBSYW5nZUxpc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy4kb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFJhbmdlTGlzdC5wcm90b3R5cGUuJG9uQ2hhbmdlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGRlbHRhLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gZGVsdGEuZW5kO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSBzdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmRSb3cgPSBlbmQucm93O1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoci5lbmQucm93ID49IHN0YXJ0Um93KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgdmFyIGxpbmVEaWYgPSBlbmRSb3cgLSBzdGFydFJvdztcbiAgICAgICAgICAgIHZhciBjb2xEaWZmID0gLXN0YXJ0LmNvbHVtbiArIGVuZC5jb2x1bW47XG4gICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LnJvdyA+IHN0YXJ0Um93KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoci5zdGFydC5yb3cgPT0gc3RhcnRSb3cgJiYgci5zdGFydC5jb2x1bW4gPj0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LmNvbHVtbiA9PSBzdGFydC5jb2x1bW4gJiYgdGhpcy4kYmlhcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5lbmQucm93ID09IHN0YXJ0Um93ICYmIHIuZW5kLmNvbHVtbiA+PSBzdGFydC5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuZW5kLmNvbHVtbiA9PSBzdGFydC5jb2x1bW4gJiYgdGhpcy4kYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmVuZC5jb2x1bW4gPT0gc3RhcnQuY29sdW1uICYmIGNvbERpZmYgPiAwICYmIGkgPCBuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuZW5kLmNvbHVtbiA+IHIuc3RhcnQuY29sdW1uICYmIHIuZW5kLmNvbHVtbiA9PSByYW5nZXNbaSArIDFdLnN0YXJ0LmNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmVuZC5jb2x1bW4gLT0gY29sRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLmVuZC5jb2x1bW4gKz0gY29sRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgci5lbmQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpbmVEaWYgPSBzdGFydFJvdyAtIGVuZFJvdztcbiAgICAgICAgICAgIHZhciBjb2xEaWZmID0gc3RhcnQuY29sdW1uIC0gZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHIuc3RhcnQucm93ID4gZW5kUm93KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoci5lbmQucm93IDwgZW5kUm93XG4gICAgICAgICAgICAgICAgICAgICYmIChzdGFydFJvdyA8IHIuZW5kLnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgc3RhcnRSb3cgPT0gci5lbmQucm93ICYmIHN0YXJ0LmNvbHVtbiA8IHIuZW5kLmNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgci5lbmQucm93ID0gc3RhcnRSb3c7XG4gICAgICAgICAgICAgICAgICAgIHIuZW5kLmNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5lbmQucm93ID09IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5lbmQuY29sdW1uIDw9IGVuZC5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lRGlmIHx8IHIuZW5kLmNvbHVtbiA+IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZW5kLmNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmVuZC5yb3cgPSBzdGFydC5yb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLmVuZC5jb2x1bW4gKz0gY29sRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuZW5kLnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIuZW5kLnJvdyA+IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICByLmVuZC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuc3RhcnQucm93IDwgZW5kUm93XG4gICAgICAgICAgICAgICAgICAgICYmIChzdGFydFJvdyA8IHIuc3RhcnQucm93XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBzdGFydFJvdyA9PSByLnN0YXJ0LnJvdyAmJiBzdGFydC5jb2x1bW4gPCByLnN0YXJ0LmNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSBzdGFydFJvdztcbiAgICAgICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIuc3RhcnQucm93ID09IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5zdGFydC5jb2x1bW4gPD0gZW5kLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVEaWYgfHwgci5zdGFydC5jb2x1bW4gPiBzdGFydC5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyA9IHN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc3RhcnQuY29sdW1uICs9IGNvbERpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIuc3RhcnQucm93ID4gZW5kUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHIuc3RhcnQucm93ICs9IGxpbmVEaWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lRGlmICE9IDAgJiYgaSA8IG4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgci5zdGFydC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgICAgICByLmVuZC5yb3cgKz0gbGluZURpZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlTGlzdDtcbn0oKSk7XG5SYW5nZUxpc3QucHJvdG90eXBlLmNvbXBhcmVQb2ludHMgPSBjb21wYXJlUG9pbnRzO1xuZXhwb3J0cy5SYW5nZUxpc3QgPSBSYW5nZUxpc3Q7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VfbGlzdFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmFuZ2VMaXN0ID0gcmVxdWlyZShcIi4uL3JhbmdlX2xpc3RcIikuUmFuZ2VMaXN0O1xudmFyIEZvbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9sZChyYW5nZSwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZm9sZExpbmUgPSBudWxsO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICBfdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICBfdGhpcy5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICBfdGhpcy5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIF90aGlzLnNhbWVSb3cgPSByYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgX3RoaXMuc3ViRm9sZHMgPSBfdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGb2xkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB0aGlzLnBsYWNlaG9sZGVyICsgJ1wiICcgKyB0aGlzLnJhbmdlLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5zZXRGb2xkTGluZSA9IGZ1bmN0aW9uIChmb2xkTGluZSkge1xuICAgICAgICB0aGlzLmZvbGRMaW5lID0gZm9sZExpbmU7XG4gICAgICAgIHRoaXMuc3ViRm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgZm9sZC5zZXRGb2xkTGluZShmb2xkTGluZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRm9sZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2UuY2xvbmUoKTtcbiAgICAgICAgdmFyIGZvbGQgPSBuZXcgRm9sZChyYW5nZSwgdGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMuc3ViRm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRm9sZCkge1xuICAgICAgICAgICAgZm9sZC5zdWJGb2xkcy5wdXNoKHN1YkZvbGQuY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gPSB0aGlzLmNvbGxhcHNlQ2hpbGRyZW47XG4gICAgICAgIHJldHVybiBmb2xkO1xuICAgIH07XG4gICAgRm9sZC5wcm90b3R5cGUuYWRkU3ViRm9sZCA9IGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlLmlzRXF1YWwoZm9sZCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN1bWVSYW5nZShmb2xkLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgdmFyIHJvdyA9IGZvbGQuc3RhcnQucm93LCBjb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNtcCA9IC0xOyBpIDwgdGhpcy5zdWJGb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gdGhpcy5zdWJGb2xkc1tpXS5yYW5nZS5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJTdGFydCA9IHRoaXMuc3ViRm9sZHNbaV07XG4gICAgICAgIHZhciBmaXJzdENvbnN1bWVkID0gMDtcbiAgICAgICAgaWYgKGNtcCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJTdGFydC5yYW5nZS5jb250YWluc1JhbmdlKGZvbGQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlclN0YXJ0LmFkZFN1YkZvbGQoZm9sZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZmlyc3RDb25zdW1lZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IGZvbGQucmFuZ2UuZW5kLnJvdywgY29sdW1uID0gZm9sZC5yYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICBmb3IgKHZhciBqID0gaSwgY21wID0gLTE7IGogPCB0aGlzLnN1YkZvbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLnN1YkZvbGRzW2pdLnJhbmdlLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAgPT0gMClcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgdmFyIGNvbnN1bWVkRm9sZHMgPSB0aGlzLnN1YkZvbGRzLnNwbGljZShpLCBqIC0gaSwgZm9sZCk7XG4gICAgICAgIHZhciBsYXN0ID0gY21wID09IDAgPyBjb25zdW1lZEZvbGRzLmxlbmd0aCAtIDEgOiBjb25zdW1lZEZvbGRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgayA9IGZpcnN0Q29uc3VtZWQ7IGsgPCBsYXN0OyBrKyspIHtcbiAgICAgICAgICAgIGZvbGQuYWRkU3ViRm9sZChjb25zdW1lZEZvbGRzW2tdKTtcbiAgICAgICAgfVxuICAgICAgICBmb2xkLnNldEZvbGRMaW5lKHRoaXMuZm9sZExpbmUpO1xuICAgICAgICByZXR1cm4gZm9sZDtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLnJlc3RvcmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmVzdG9yZVJhbmdlKHJhbmdlLCB0aGlzLnN0YXJ0KTtcbiAgICB9O1xuICAgIHJldHVybiBGb2xkO1xufShSYW5nZUxpc3QpKTtcbmZ1bmN0aW9uIGNvbnN1bWVQb2ludChwb2ludCwgYW5jaG9yKSB7XG4gICAgcG9pbnQucm93IC09IGFuY2hvci5yb3c7XG4gICAgaWYgKHBvaW50LnJvdyA9PSAwKVxuICAgICAgICBwb2ludC5jb2x1bW4gLT0gYW5jaG9yLmNvbHVtbjtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVSYW5nZShyYW5nZSwgYW5jaG9yKSB7XG4gICAgY29uc3VtZVBvaW50KHJhbmdlLnN0YXJ0LCBhbmNob3IpO1xuICAgIGNvbnN1bWVQb2ludChyYW5nZS5lbmQsIGFuY2hvcik7XG59XG5mdW5jdGlvbiByZXN0b3JlUG9pbnQocG9pbnQsIGFuY2hvcikge1xuICAgIGlmIChwb2ludC5yb3cgPT0gMClcbiAgICAgICAgcG9pbnQuY29sdW1uICs9IGFuY2hvci5jb2x1bW47XG4gICAgcG9pbnQucm93ICs9IGFuY2hvci5yb3c7XG59XG5mdW5jdGlvbiByZXN0b3JlUmFuZ2UocmFuZ2UsIGFuY2hvcikge1xuICAgIHJlc3RvcmVQb2ludChyYW5nZS5zdGFydCwgYW5jaG9yKTtcbiAgICByZXN0b3JlUG9pbnQocmFuZ2UuZW5kLCBhbmNob3IpO1xufVxuZXhwb3J0cy5Gb2xkID0gRm9sZDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRpbmdcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiLFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkX2xpbmVcIixcImFjZS9lZGl0X3Nlc3Npb24vZm9sZFwiLFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsXCJhY2UvbW91c2UvbW91c2VfZXZlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7Ly8gQHRzLW5vY2hlY2tcblwidXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIEZvbGRMaW5lID0gcmVxdWlyZShcIi4vZm9sZF9saW5lXCIpLkZvbGRMaW5lO1xudmFyIEZvbGQgPSByZXF1aXJlKFwiLi9mb2xkXCIpLkZvbGQ7XG52YXIgVG9rZW5JdGVyYXRvciA9IHJlcXVpcmUoXCIuLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi4vbW91c2UvbW91c2VfZXZlbnRcIikuTW91c2VFdmVudDtcbmZ1bmN0aW9uIEZvbGRpbmcoKSB7XG4gICAgdGhpcy5nZXRGb2xkQXQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIHNpZGUpIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICBpZiAoIWZvbGRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lLmZvbGRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBmb2xkc1tpXS5yYW5nZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5jb250YWlucyhyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PSAxICYmIHJhbmdlLmlzRW5kKHJvdywgY29sdW1uKSAmJiAhcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlID09IC0xICYmIHJhbmdlLmlzU3RhcnQocm93LCBjb2x1bW4pICYmICFyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRGb2xkc0luUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgdmFyIGZvdW5kRm9sZHMgPSBbXTtcbiAgICAgICAgc3RhcnQuY29sdW1uICs9IDE7XG4gICAgICAgIGVuZC5jb2x1bW4gLT0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkTGluZXNbaV0ucmFuZ2UuY29tcGFyZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09IC0yKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZXNbaV0uZm9sZHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGQgPSBmb2xkc1tqXTtcbiAgICAgICAgICAgICAgICBjbXAgPSBmb2xkLnJhbmdlLmNvbXBhcmVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21wID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRGb2xkcy5wdXNoKGZvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0LmNvbHVtbiAtPSAxO1xuICAgICAgICBlbmQuY29sdW1uICs9IDE7XG4gICAgICAgIHJldHVybiBmb3VuZEZvbGRzO1xuICAgIH07XG4gICAgdGhpcy5nZXRGb2xkc0luUmFuZ2VMaXN0ID0gZnVuY3Rpb24gKHJhbmdlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZXMpKSB7XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSBbXTtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIGZvbGRzID0gZm9sZHMuY29uY2F0KHRoaXMuZ2V0Rm9sZHNJblJhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRzO1xuICAgIH07XG4gICAgdGhpcy5nZXRBbGxGb2xkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvbGRzID0gW107XG4gICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvbGRMaW5lc1tpXS5mb2xkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKGZvbGRMaW5lc1tpXS5mb2xkc1tqXSk7XG4gICAgICAgIHJldHVybiBmb2xkcztcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZFN0cmluZ0F0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uLCB0cmltLCBmb2xkTGluZSkge1xuICAgICAgICBmb2xkTGluZSA9IGZvbGRMaW5lIHx8IHRoaXMuZ2V0Rm9sZExpbmUocm93KTtcbiAgICAgICAgaWYgKCFmb2xkTGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbGFzdEZvbGQgPSB7XG4gICAgICAgICAgICBlbmQ6IHsgY29sdW1uOiAwIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0ciwgZm9sZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZS5mb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9sZCA9IGZvbGRMaW5lLmZvbGRzW2ldO1xuICAgICAgICAgICAgdmFyIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZUVuZChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0TGluZShmb2xkLnN0YXJ0LnJvdylcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZyhsYXN0Rm9sZC5lbmQuY29sdW1uLCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RGb2xkID0gZm9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cilcbiAgICAgICAgICAgIHN0ciA9IHRoaXMuZ2V0TGluZShmb2xkLnN0YXJ0LnJvdykuc3Vic3RyaW5nKGxhc3RGb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICBpZiAodHJpbSA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGNvbHVtbiAtIGxhc3RGb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICBlbHNlIGlmICh0cmltID09IDEpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhjb2x1bW4gLSBsYXN0Rm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZExpbmUgPSBmdW5jdGlvbiAoZG9jUm93LCBzdGFydEZvbGRMaW5lKSB7XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChzdGFydEZvbGRMaW5lKVxuICAgICAgICAgICAgaSA9IGZvbGREYXRhLmluZGV4T2Yoc3RhcnRGb2xkTGluZSk7XG4gICAgICAgIGlmIChpID09IC0xKVxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoaTsgaSA8IGZvbGREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChmb2xkTGluZS5zdGFydC5yb3cgPD0gZG9jUm93ICYmIGZvbGRMaW5lLmVuZC5yb3cgPj0gZG9jUm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbGRMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9sZExpbmUuZW5kLnJvdyA+IGRvY1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdGhpcy5nZXROZXh0Rm9sZExpbmUgPSBmdW5jdGlvbiAoZG9jUm93LCBzdGFydEZvbGRMaW5lKSB7XG4gICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChzdGFydEZvbGRMaW5lKVxuICAgICAgICAgICAgaSA9IGZvbGREYXRhLmluZGV4T2Yoc3RhcnRGb2xkTGluZSk7XG4gICAgICAgIGlmIChpID09IC0xKVxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoaTsgaSA8IGZvbGREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChmb2xkTGluZS5lbmQucm93ID49IGRvY1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZGVkUm93Q291bnQgPSBmdW5jdGlvbiAoZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGEsIHJvd0NvdW50ID0gbGFzdCAtIGZpcnN0ICsgMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV0sIGVuZCA9IGZvbGRMaW5lLmVuZC5yb3csIHN0YXJ0ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb3VudCAtPSBsYXN0IC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gMDsgLy8gaW4gb25lIGZvbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPj0gZmlyc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gZmlyc3QpIC8vIGZvbGQgaW5zaWRlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50IC09IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgLT0gZW5kIC0gZmlyc3QgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dDb3VudDtcbiAgICB9O1xuICAgIHRoaXMuJGFkZEZvbGRMaW5lID0gZnVuY3Rpb24gKGZvbGRMaW5lKSB7XG4gICAgICAgIHRoaXMuJGZvbGREYXRhLnB1c2goZm9sZExpbmUpO1xuICAgICAgICB0aGlzLiRmb2xkRGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydC5yb3cgLSBiLnN0YXJ0LnJvdztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb2xkTGluZTtcbiAgICB9O1xuICAgIHRoaXMuYWRkRm9sZCA9IGZ1bmN0aW9uIChwbGFjZWhvbGRlciwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIHZhciBhZGRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZm9sZDtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyIGluc3RhbmNlb2YgRm9sZClcbiAgICAgICAgICAgIGZvbGQgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2xkID0gbmV3IEZvbGQocmFuZ2UsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIGZvbGQuY29sbGFwc2VDaGlsZHJlbiA9IHJhbmdlLmNvbGxhcHNlQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY2xpcFJhbmdlVG9Eb2N1bWVudChmb2xkLnJhbmdlKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgIHZhciBzdGFydENvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgZW5kUm93ID0gZm9sZC5lbmQucm93O1xuICAgICAgICB2YXIgZW5kQ29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICB2YXIgc3RhcnRGb2xkID0gdGhpcy5nZXRGb2xkQXQoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCAxKTtcbiAgICAgICAgdmFyIGVuZEZvbGQgPSB0aGlzLmdldEZvbGRBdChlbmRSb3csIGVuZENvbHVtbiwgLTEpO1xuICAgICAgICBpZiAoc3RhcnRGb2xkICYmIGVuZEZvbGQgPT0gc3RhcnRGb2xkKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Rm9sZC5hZGRTdWJGb2xkKGZvbGQpO1xuICAgICAgICBpZiAoc3RhcnRGb2xkICYmICFzdGFydEZvbGQucmFuZ2UuaXNTdGFydChzdGFydFJvdywgc3RhcnRDb2x1bW4pKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKHN0YXJ0Rm9sZCk7XG4gICAgICAgIGlmIChlbmRGb2xkICYmICFlbmRGb2xkLnJhbmdlLmlzRW5kKGVuZFJvdywgZW5kQ29sdW1uKSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChlbmRGb2xkKTtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZm9sZC5yYW5nZSk7XG4gICAgICAgIGlmIChmb2xkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKGZvbGRzKTtcbiAgICAgICAgICAgIGlmICghZm9sZC5jb2xsYXBzZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRm9sZCkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkLmFkZFN1YkZvbGQoc3ViRm9sZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICBpZiAoZW5kUm93ID09IGZvbGRMaW5lLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRSb3cgPT0gZm9sZExpbmUuZW5kLnJvdykge1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghZm9sZC5zYW1lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZU5leHQgPSBmb2xkRGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZU5leHQgJiYgZm9sZExpbmVOZXh0LnN0YXJ0LnJvdyA9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLm1lcmdlKGZvbGRMaW5lTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZFJvdyA8PSBmb2xkTGluZS5zdGFydC5yb3cpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFkZGVkKVxuICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLiRhZGRGb2xkTGluZShuZXcgRm9sZExpbmUodGhpcy4kZm9sZERhdGEsIGZvbGQpKTtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoZm9sZExpbmUuc3RhcnQucm93LCBmb2xkTGluZS5zdGFydC5yb3cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dMZW5ndGhDYWNoZShmb2xkTGluZS5zdGFydC5yb3csIGZvbGRMaW5lLnN0YXJ0LnJvdyk7XG4gICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlRm9sZFwiLCB7IGRhdGE6IGZvbGQsIGFjdGlvbjogXCJhZGRcIiB9KTtcbiAgICAgICAgcmV0dXJuIGZvbGQ7XG4gICAgfTtcbiAgICB0aGlzLmFkZEZvbGRzID0gZnVuY3Rpb24gKGZvbGRzKSB7XG4gICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9sZChmb2xkKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUZvbGQgPSBmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkLmZvbGRMaW5lO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICB2YXIgZm9sZExpbmVzID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lLmZvbGRzO1xuICAgICAgICBpZiAoZm9sZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGZvbGRMaW5lcy5zcGxpY2UoZm9sZExpbmVzLmluZGV4T2YoZm9sZExpbmUpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICBpZiAoZm9sZExpbmUucmFuZ2UuaXNFbmQoZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pKSB7XG4gICAgICAgICAgICBmb2xkcy5wb3AoKTtcbiAgICAgICAgICAgIGZvbGRMaW5lLmVuZC5yb3cgPSBmb2xkc1tmb2xkcy5sZW5ndGggLSAxXS5lbmQucm93O1xuICAgICAgICAgICAgZm9sZExpbmUuZW5kLmNvbHVtbiA9IGZvbGRzW2ZvbGRzLmxlbmd0aCAtIDFdLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAgaWYgKGZvbGRMaW5lLnJhbmdlLmlzU3RhcnQoZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKSkge1xuICAgICAgICAgICAgZm9sZHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGZvbGRMaW5lLnN0YXJ0LnJvdyA9IGZvbGRzWzBdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGZvbGRMaW5lLnN0YXJ0LmNvbHVtbiA9IGZvbGRzWzBdLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICBpZiAoZm9sZC5zYW1lUm93KSB7XG4gICAgICAgICAgICBmb2xkcy5zcGxpY2UoZm9sZHMuaW5kZXhPZihmb2xkKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld0ZvbGRMaW5lID0gZm9sZExpbmUuc3BsaXQoZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIGZvbGRzID0gbmV3Rm9sZExpbmUuZm9sZHM7XG4gICAgICAgICAgICBmb2xkcy5zaGlmdCgpO1xuICAgICAgICAgICAgbmV3Rm9sZExpbmUuc3RhcnQucm93ID0gZm9sZHNbMF0uc3RhcnQucm93O1xuICAgICAgICAgICAgbmV3Rm9sZExpbmUuc3RhcnQuY29sdW1uID0gZm9sZHNbMF0uc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy4kdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YShzdGFydFJvdywgZW5kUm93KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dMZW5ndGhDYWNoZShzdGFydFJvdywgZW5kUm93KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUZvbGRcIiwgeyBkYXRhOiBmb2xkLCBhY3Rpb246IFwicmVtb3ZlXCIgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUZvbGRzID0gZnVuY3Rpb24gKGZvbGRzKSB7XG4gICAgICAgIHZhciBjbG9uZUZvbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lRm9sZHMucHVzaChmb2xkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmVGb2xkcy5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmV4cGFuZEZvbGQgPSBmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgIGZvbGQuc3ViRm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRm9sZCkge1xuICAgICAgICAgICAgZm9sZC5yZXN0b3JlUmFuZ2Uoc3ViRm9sZCk7XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGQoc3ViRm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAoZm9sZC5jb2xsYXBzZUNoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKGZvbGQuc3RhcnQucm93ICsgMSwgZm9sZC5lbmQucm93LCBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBmb2xkLnN1YkZvbGRzID0gW107XG4gICAgfTtcbiAgICB0aGlzLmV4cGFuZEZvbGRzID0gZnVuY3Rpb24gKGZvbGRzKSB7XG4gICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24gKGZvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnVuZm9sZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgZXhwYW5kSW5uZXIpIHtcbiAgICAgICAgdmFyIHJhbmdlLCBmb2xkcztcbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIHRoaXMuZ2V0TGVuZ3RoKCksIDApO1xuICAgICAgICAgICAgaWYgKGV4cGFuZElubmVyID09IG51bGwpXG4gICAgICAgICAgICAgICAgZXhwYW5kSW5uZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShsb2NhdGlvbiwgMCwgbG9jYXRpb24sIHRoaXMuZ2V0TGluZShsb2NhdGlvbikubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcInJvd1wiIGluIGxvY2F0aW9uKSB7XG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMobG9jYXRpb24sIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgZm9sZHMgPSBbXTtcbiAgICAgICAgICAgIGxvY2F0aW9uLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZm9sZHMgPSBmb2xkcy5jb25jYXQodGhpcy51bmZvbGQocmFuZ2UpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZvbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlTGlzdChyYW5nZSk7XG4gICAgICAgIHZhciBvdXRlcm1vc3RGb2xkcyA9IGZvbGRzO1xuICAgICAgICB3aGlsZSAoZm9sZHMubGVuZ3RoID09IDFcbiAgICAgICAgICAgICYmIFJhbmdlLmNvbXBhcmVQb2ludHMoZm9sZHNbMF0uc3RhcnQsIHJhbmdlLnN0YXJ0KSA8IDBcbiAgICAgICAgICAgICYmIFJhbmdlLmNvbXBhcmVQb2ludHMoZm9sZHNbMF0uZW5kLCByYW5nZS5lbmQpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkcyhmb2xkcyk7XG4gICAgICAgICAgICBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlTGlzdChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGFuZElubmVyICE9IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKGZvbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZHMoZm9sZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRlcm1vc3RGb2xkcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gb3V0ZXJtb3N0Rm9sZHM7XG4gICAgfTtcbiAgICB0aGlzLmlzUm93Rm9sZGVkID0gZnVuY3Rpb24gKGRvY1Jvdywgc3RhcnRGb2xkUm93KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0Rm9sZExpbmUoZG9jUm93LCBzdGFydEZvbGRSb3cpO1xuICAgIH07XG4gICAgdGhpcy5nZXRSb3dGb2xkRW5kID0gZnVuY3Rpb24gKGRvY1Jvdywgc3RhcnRGb2xkUm93KSB7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZG9jUm93LCBzdGFydEZvbGRSb3cpO1xuICAgICAgICByZXR1cm4gZm9sZExpbmUgPyBmb2xkTGluZS5lbmQucm93IDogZG9jUm93O1xuICAgIH07XG4gICAgdGhpcy5nZXRSb3dGb2xkU3RhcnQgPSBmdW5jdGlvbiAoZG9jUm93LCBzdGFydEZvbGRSb3cpIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShkb2NSb3csIHN0YXJ0Rm9sZFJvdyk7XG4gICAgICAgIHJldHVybiBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IGRvY1JvdztcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZERpc3BsYXlMaW5lID0gZnVuY3Rpb24gKGZvbGRMaW5lLCBlbmRSb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIGlmIChzdGFydFJvdyA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIGlmIChzdGFydENvbHVtbiA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoZW5kUm93ID09IG51bGwpXG4gICAgICAgICAgICBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICBpZiAoZW5kQ29sdW1uID09IG51bGwpXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgdmFyIHRleHRMaW5lID0gXCJcIjtcbiAgICAgICAgZm9sZExpbmUud2FsayhmdW5jdGlvbiAocGxhY2Vob2xkZXIsIHJvdywgY29sdW1uLCBsYXN0Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAocm93IDwgc3RhcnRSb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJvdyA9PSBzdGFydFJvdykge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPCBzdGFydENvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBNYXRoLm1heChzdGFydENvbHVtbiwgbGFzdENvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lICs9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dExpbmUgKz0gZG9jLmdldExpbmUocm93KS5zdWJzdHJpbmcobGFzdENvbHVtbiwgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZW5kUm93LCBlbmRDb2x1bW4pO1xuICAgICAgICByZXR1cm4gdGV4dExpbmU7XG4gICAgfTtcbiAgICB0aGlzLmdldERpc3BsYXlMaW5lID0gZnVuY3Rpb24gKHJvdywgZW5kQ29sdW1uLCBzdGFydFJvdywgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICBpZiAoIWZvbGRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgbGluZTtcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoc3RhcnRDb2x1bW4gfHwgMCwgZW5kQ29sdW1uIHx8IGxpbmUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvbGREaXNwbGF5TGluZShmb2xkTGluZSwgcm93LCBlbmRDb2x1bW4sIHN0YXJ0Um93LCBzdGFydENvbHVtbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJGNsb25lRm9sZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmZCA9IFtdO1xuICAgICAgICBmZCA9IHRoaXMuJGZvbGREYXRhLm1hcChmdW5jdGlvbiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lLmZvbGRzLm1hcChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkLmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZExpbmUoZmQsIGZvbGRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZDtcbiAgICB9O1xuICAgIHRoaXMudG9nZ2xlRm9sZCA9IGZ1bmN0aW9uICh0cnlUb1VuZm9sZCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICB2YXIgZm9sZDtcbiAgICAgICAgdmFyIGJyYWNrZXRQb3M7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJyYWNrZXRQb3MgPSB0aGlzLmZpbmRNYXRjaGluZ0JyYWNrZXQoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlUG9pbnQoYnJhY2tldFBvcykgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQgPSBicmFja2V0UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSBicmFja2V0UG9zO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJyYWNrZXRQb3MgPSB0aGlzLmZpbmRNYXRjaGluZ0JyYWNrZXQoeyByb3c6IGN1cnNvci5yb3csIGNvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEgfSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZVBvaW50KGJyYWNrZXRQb3MpID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA9IGJyYWNrZXRQb3M7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydCA9IGJyYWNrZXRQb3M7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuZ2V0Q29tbWVudEZvbGRSYW5nZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKSB8fCByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0cnlUb1VuZm9sZCAmJiBmb2xkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGRzKGZvbGRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb2xkcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGZvbGQgPSBmb2xkc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvbGQpXG4gICAgICAgICAgICBmb2xkID0gdGhpcy5nZXRGb2xkQXQocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICBpZiAoZm9sZCAmJiBmb2xkLnJhbmdlLnRvU3RyaW5nKCkgPT0gcmFuZ2UudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IFwiLi4uXCI7XG4gICAgICAgIGlmICghcmFuZ2UuaXNNdWx0aUxpbmUoKSkge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIubGVuZ3RoIDwgNClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyLnRyaW0oKS5zdWJzdHJpbmcoMCwgMikgKyBcIi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRGb2xkKHBsYWNlaG9sZGVyLCByYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLmdldENvbW1lbnRGb2xkUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIGRpcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCByb3csIGNvbHVtbik7XG4gICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB2YXIgdHlwZSA9IHRva2VuICYmIHRva2VuLnR5cGU7XG4gICAgICAgIGlmICh0b2tlbiAmJiAvXmNvbW1lbnR8c3RyaW5nLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5tYXRjaCgvY29tbWVudHxzdHJpbmcvKVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwiY29tbWVudFwiKVxuICAgICAgICAgICAgICAgIHR5cGUgKz0gXCJ8ZG9jLXN0YXJ0fFxcXFwuZG9jXCI7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHR5cGUpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgICAgICAgICBpZiAoZGlyICE9IDEpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgcmUudGVzdCh0b2tlbi50eXBlKSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIHRva2VuLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgdmFyIGluaXRTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoaXRlcmF0b3IuJHJvdyk7XG4gICAgICAgICAgICBpZiAoZGlyICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RSb3cgPSAtMTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSb3cgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoaXRlcmF0b3IuJHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdFN0YXRlLnRvU3RyaW5nKCkgIT09IHN0YXRlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJvdyA9IGl0ZXJhdG9yLiRyb3c7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlcmF0b3IuJHJvdyA+IGxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgcmUudGVzdCh0b2tlbi50eXBlKSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmZvbGRBbGwgPSBmdW5jdGlvbiAoc3RhcnRSb3csIGVuZFJvdywgZGVwdGgsIHRlc3QpIHtcbiAgICAgICAgaWYgKGRlcHRoID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRlcHRoID0gMTAwMDAwOyAvLyBKU09OLnN0cmluZ2lmeSBkb2Vzbid0IGhhbmxlIEluZmluaXR5XG4gICAgICAgIHZhciBmb2xkV2lkZ2V0cyA9IHRoaXMuZm9sZFdpZGdldHM7XG4gICAgICAgIGlmICghZm9sZFdpZGdldHMpXG4gICAgICAgICAgICByZXR1cm47IC8vIG1vZGUgZG9lc24ndCBzdXBwb3J0IGZvbGRpbmdcbiAgICAgICAgZW5kUm93ID0gZW5kUm93IHx8IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHN0YXJ0Um93ID0gc3RhcnRSb3cgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8IGVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIGlmIChmb2xkV2lkZ2V0c1tyb3ddID09IG51bGwpXG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldHNbcm93XSA9IHRoaXMuZ2V0Rm9sZFdpZGdldChyb3cpO1xuICAgICAgICAgICAgaWYgKGZvbGRXaWRnZXRzW3Jvd10gIT0gXCJzdGFydFwiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRlc3QgJiYgIXRlc3Qocm93KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlKHJvdyk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuaXNNdWx0aUxpbmUoKVxuICAgICAgICAgICAgICAgICYmIHJhbmdlLmVuZC5yb3cgPD0gZW5kUm93XG4gICAgICAgICAgICAgICAgJiYgcmFuZ2Uuc3RhcnQucm93ID49IHN0YXJ0Um93KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZUNoaWxkcmVuID0gZGVwdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGb2xkKFwiLi4uXCIsIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5mb2xkVG9MZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB0aGlzLmZvbGRBbGwoKTtcbiAgICAgICAgd2hpbGUgKGxldmVsLS0gPiAwKVxuICAgICAgICAgICAgdGhpcy51bmZvbGQobnVsbCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5mb2xkQWxsQ29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcztcbiAgICAgICAgdGhpcy5mb2xkQWxsKG51bGwsIG51bGwsIG51bGwsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT0gXCJ0ZXh0XCIgJiYgL15cXHMrJC8udGVzdCh0b2tlbi52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICgvY29tbWVudC8udGVzdCh0b2tlbi50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuJGZvbGRTdHlsZXMgPSB7XG4gICAgICAgIFwibWFudWFsXCI6IDEsXG4gICAgICAgIFwibWFya2JlZ2luXCI6IDEsXG4gICAgICAgIFwibWFya2JlZ2luZW5kXCI6IDFcbiAgICB9O1xuICAgIHRoaXMuJGZvbGRTdHlsZSA9IFwibWFya2JlZ2luXCI7XG4gICAgdGhpcy5zZXRGb2xkU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRmb2xkU3R5bGVzW3N0eWxlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9sZCBzdHlsZTogXCIgKyBzdHlsZSArIFwiW1wiICsgT2JqZWN0LmtleXModGhpcy4kZm9sZFN0eWxlcykuam9pbihcIiwgXCIpICsgXCJdXCIpO1xuICAgICAgICBpZiAodGhpcy4kZm9sZFN0eWxlID09IHN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRmb2xkU3R5bGUgPSBzdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlID09IFwibWFudWFsXCIpXG4gICAgICAgICAgICB0aGlzLnVuZm9sZCgpO1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuJGZvbGRNb2RlO1xuICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG51bGwpO1xuICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG1vZGUpO1xuICAgIH07XG4gICAgdGhpcy4kc2V0Rm9sZGluZyA9IGZ1bmN0aW9uIChmb2xkTW9kZSkge1xuICAgICAgICBpZiAodGhpcy4kZm9sZE1vZGUgPT0gZm9sZE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGZvbGRNb2RlID0gZm9sZE1vZGU7XG4gICAgICAgIHRoaXMub2ZmKCdjaGFuZ2UnLCB0aGlzLiR1cGRhdGVGb2xkV2lkZ2V0cyk7XG4gICAgICAgIHRoaXMub2ZmKCd0b2tlbml6ZXJVcGRhdGUnLCB0aGlzLiR0b2tlbml6ZXJVcGRhdGVGb2xkV2lkZ2V0cyk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUFubm90YXRpb25cIik7XG4gICAgICAgIGlmICghZm9sZE1vZGUgfHwgdGhpcy4kZm9sZFN0eWxlID09IFwibWFudWFsXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9sZFdpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRGb2xkV2lkZ2V0ID0gZm9sZE1vZGUuZ2V0Rm9sZFdpZGdldC5iaW5kKGZvbGRNb2RlLCB0aGlzLCB0aGlzLiRmb2xkU3R5bGUpO1xuICAgICAgICB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZSA9IGZvbGRNb2RlLmdldEZvbGRXaWRnZXRSYW5nZS5iaW5kKGZvbGRNb2RlLCB0aGlzLCB0aGlzLiRmb2xkU3R5bGUpO1xuICAgICAgICB0aGlzLiR1cGRhdGVGb2xkV2lkZ2V0cyA9IHRoaXMudXBkYXRlRm9sZFdpZGdldHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4kdG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMgPSB0aGlzLnRva2VuaXplclVwZGF0ZUZvbGRXaWRnZXRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMuJHVwZGF0ZUZvbGRXaWRnZXRzKTtcbiAgICAgICAgdGhpcy5vbigndG9rZW5pemVyVXBkYXRlJywgdGhpcy4kdG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMpO1xuICAgIH07XG4gICAgdGhpcy5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhID0gZnVuY3Rpb24gKHJvdywgaWdub3JlQ3VycmVudCkge1xuICAgICAgICB2YXIgZncgPSB0aGlzLmZvbGRXaWRnZXRzO1xuICAgICAgICBpZiAoIWZ3IHx8IChpZ25vcmVDdXJyZW50ICYmIGZ3W3Jvd10pKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgaSA9IHJvdyAtIDEsIGZpcnN0UmFuZ2U7XG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgIHZhciBjID0gZndbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGMgPSBmd1tpXSA9IHRoaXMuZ2V0Rm9sZFdpZGdldChpKTtcbiAgICAgICAgICAgIGlmIChjID09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5lbmQucm93ID49IHJvdylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiBpICE9PSAtMSAmJiByYW5nZSxcbiAgICAgICAgICAgIGZpcnN0UmFuZ2U6IGZpcnN0UmFuZ2VcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMub25Gb2xkV2lkZ2V0Q2xpY2sgPSBmdW5jdGlvbiAocm93LCBlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTW91c2VFdmVudClcbiAgICAgICAgICAgIGUgPSBlLmRvbUV2ZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgYWxsOiBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5LFxuICAgICAgICAgICAgc2libGluZ3M6IGUuYWx0S2V5XG4gICAgICAgIH07XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuJHRvZ2dsZUZvbGRXaWRnZXQocm93LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgdmFyIGVsID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZWwgJiYgL2FjZV9mb2xkLXdpZGdldC8udGVzdChlbC5jbGFzc05hbWUpKVxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBhY2VfaW52YWxpZFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiR0b2dnbGVGb2xkV2lkZ2V0ID0gZnVuY3Rpb24gKHJvdywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Rm9sZFdpZGdldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldEZvbGRXaWRnZXQocm93KTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIGRpciA9IHR5cGUgPT09IFwiZW5kXCIgPyAtMSA6IDE7XG4gICAgICAgIHZhciBmb2xkID0gdGhpcy5nZXRGb2xkQXQocm93LCBkaXIgPT09IC0xID8gMCA6IGxpbmUubGVuZ3RoLCBkaXIpO1xuICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gfHwgb3B0aW9ucy5hbGwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgICAgIHJldHVybiBmb2xkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlKHJvdywgdHJ1ZSk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAhcmFuZ2UuaXNNdWx0aUxpbmUoKSkge1xuICAgICAgICAgICAgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCAxKTtcbiAgICAgICAgICAgIGlmIChmb2xkICYmIHJhbmdlLmlzRXF1YWwoZm9sZC5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2libGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGRhdGEucmFuZ2Uuc3RhcnQucm93ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gZGF0YS5yYW5nZS5lbmQucm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHN0YXJ0Um93LCBlbmRSb3csIG9wdGlvbnMuYWxsID8gMTAwMDAgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSByYW5nZSA/IHJhbmdlLmVuZC5yb3cgOiB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHJvdyArIDEsIGVuZFJvdywgb3B0aW9ucy5hbGwgPyAxMDAwMCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGwpXG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2VDaGlsZHJlbiA9IDEwMDAwO1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkKFwiLi4uXCIsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZUZvbGRXaWRnZXQgPSBmdW5jdGlvbiAodG9nZ2xlUGFyZW50KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKS5yb3c7XG4gICAgICAgIHJvdyA9IHRoaXMuZ2V0Um93Rm9sZFN0YXJ0KHJvdyk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuJHRvZ2dsZUZvbGRXaWRnZXQocm93LCB7fSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldFBhcmVudEZvbGRSYW5nZURhdGEocm93LCB0cnVlKTtcbiAgICAgICAgcmFuZ2UgPSBkYXRhLnJhbmdlIHx8IGRhdGEuZmlyc3RSYW5nZTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICByb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJvdywgdGhpcy5nZXRMaW5lKHJvdykubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGb2xkKFwiLi4uXCIsIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSBkZWx0YS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBsZW4gPSBkZWx0YS5lbmQucm93IC0gZmlyc3RSb3c7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHNbZmlyc3RSb3ddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHMuc3BsaWNlKGZpcnN0Um93LCBsZW4gKyAxLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDEpO1xuICAgICAgICAgICAgdGhpcy5mb2xkV2lkZ2V0cy5zcGxpY2UuYXBwbHkodGhpcy5mb2xkV2lkZ2V0cywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcm93cyA9IGUuZGF0YTtcbiAgICAgICAgaWYgKHJvd3MuZmlyc3QgIT0gcm93cy5sYXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xkV2lkZ2V0cy5sZW5ndGggPiByb3dzLmZpcnN0KVxuICAgICAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHMuc3BsaWNlKHJvd3MuZmlyc3QsIHRoaXMuZm9sZFdpZGdldHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLkZvbGRpbmcgPSBGb2xkaW5nO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9lZGl0X3Nlc3Npb24vYnJhY2tldF9tYXRjaFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgVG9rZW5JdGVyYXRvciA9IHJlcXVpcmUoXCIuLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xuZnVuY3Rpb24gQnJhY2tldE1hdGNoKCkge1xuICAgIHRoaXMuZmluZE1hdGNoaW5nQnJhY2tldCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgY2hyKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbi5jb2x1bW4gPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgY2hhckJlZm9yZUN1cnNvciA9IGNociB8fCB0aGlzLmdldExpbmUocG9zaXRpb24ucm93KS5jaGFyQXQocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgICAgIGlmIChjaGFyQmVmb3JlQ3Vyc29yID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG1hdGNoID0gY2hhckJlZm9yZUN1cnNvci5tYXRjaCgvKFtcXChcXFtcXHtdKXwoW1xcKVxcXVxcfV0pLyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG1hdGNoWzFdKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZpbmRDbG9zaW5nQnJhY2tldChtYXRjaFsxXSwgcG9zaXRpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZmluZE9wZW5pbmdCcmFja2V0KG1hdGNoWzJdLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICB0aGlzLmdldEJyYWNrZXRSYW5nZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocG9zLnJvdyk7XG4gICAgICAgIHZhciBiZWZvcmUgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgdmFyIGNociA9IGxpbmUuY2hhckF0KHBvcy5jb2x1bW4gLSAxKTtcbiAgICAgICAgdmFyIG1hdGNoID0gY2hyICYmIGNoci5tYXRjaCgvKFtcXChcXFtcXHtdKXwoW1xcKVxcXVxcfV0pLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGNociA9IGxpbmUuY2hhckF0KHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgcG9zID0geyByb3c6IHBvcy5yb3csIGNvbHVtbjogcG9zLmNvbHVtbiArIDEgfTtcbiAgICAgICAgICAgIG1hdGNoID0gY2hyICYmIGNoci5tYXRjaCgvKFtcXChcXFtcXHtdKXwoW1xcKVxcXVxcfV0pLyk7XG4gICAgICAgICAgICBiZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgdmFyIGJyYWNrZXRQb3MgPSB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQobWF0Y2hbMV0sIHBvcyk7XG4gICAgICAgICAgICBpZiAoIWJyYWNrZXRQb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocG9zLCBicmFja2V0UG9zKTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbisrO1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuY3Vyc29yID0gcmFuZ2UuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJyYWNrZXRQb3MgPSB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQobWF0Y2hbMl0sIHBvcyk7XG4gICAgICAgICAgICBpZiAoIWJyYWNrZXRQb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoYnJhY2tldFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuY3Vyc29yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgdGhpcy5nZXRNYXRjaGluZ0JyYWNrZXRSYW5nZXMgPSBmdW5jdGlvbiAocG9zLCBpc0JhY2t3YXJkcykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShwb3Mucm93KTtcbiAgICAgICAgdmFyIGJyYWNrZXRzUmVnRXhwID0gLyhbXFwoXFxbXFx7XSl8KFtcXClcXF1cXH1dKS87XG4gICAgICAgIHZhciBjaHIgPSAhaXNCYWNrd2FyZHMgJiYgbGluZS5jaGFyQXQocG9zLmNvbHVtbiAtIDEpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBjaHIgJiYgY2hyLm1hdGNoKGJyYWNrZXRzUmVnRXhwKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgY2hyID0gKGlzQmFja3dhcmRzID09PSB1bmRlZmluZWQgfHwgaXNCYWNrd2FyZHMpICYmIGxpbmUuY2hhckF0KHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgIHJvdzogcG9zLnJvdyxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHBvcy5jb2x1bW4gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWF0Y2ggPSBjaHIgJiYgY2hyLm1hdGNoKGJyYWNrZXRzUmVnRXhwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBzdGFydFJhbmdlID0gbmV3IFJhbmdlKHBvcy5yb3csIHBvcy5jb2x1bW4gLSAxLCBwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgdmFyIGJyYWNrZXRQb3MgPSBtYXRjaFsxXSA/IHRoaXMuJGZpbmRDbG9zaW5nQnJhY2tldChtYXRjaFsxXSwgcG9zKVxuICAgICAgICAgICAgOiB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQobWF0Y2hbMl0sIHBvcyk7XG4gICAgICAgIGlmICghYnJhY2tldFBvcylcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRSYW5nZV07XG4gICAgICAgIHZhciBlbmRSYW5nZSA9IG5ldyBSYW5nZShicmFja2V0UG9zLnJvdywgYnJhY2tldFBvcy5jb2x1bW4sIGJyYWNrZXRQb3Mucm93LCBicmFja2V0UG9zLmNvbHVtbiArIDEpO1xuICAgICAgICByZXR1cm4gW3N0YXJ0UmFuZ2UsIGVuZFJhbmdlXTtcbiAgICB9O1xuICAgIHRoaXMuJGJyYWNrZXRzID0ge1xuICAgICAgICBcIilcIjogXCIoXCIsXG4gICAgICAgIFwiKFwiOiBcIilcIixcbiAgICAgICAgXCJdXCI6IFwiW1wiLFxuICAgICAgICBcIltcIjogXCJdXCIsXG4gICAgICAgIFwie1wiOiBcIn1cIixcbiAgICAgICAgXCJ9XCI6IFwie1wiLFxuICAgICAgICBcIjxcIjogXCI+XCIsXG4gICAgICAgIFwiPlwiOiBcIjxcIlxuICAgIH07XG4gICAgdGhpcy4kZmluZE9wZW5pbmdCcmFja2V0ID0gZnVuY3Rpb24gKGJyYWNrZXQsIHBvc2l0aW9uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIG9wZW5CcmFja2V0ID0gdGhpcy4kYnJhY2tldHNbYnJhY2tldF07XG4gICAgICAgIHZhciBkZXB0aCA9IDE7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHRoaXMsIHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdHlwZVJlKSB7XG4gICAgICAgICAgICB0eXBlUmUgPSBuZXcgUmVnRXhwKFwiKFxcXFwuP1wiICtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlLnJlcGxhY2UoXCIuXCIsIFwiXFxcXC5cIikucmVwbGFjZShcInJwYXJlblwiLCBcIi5wYXJlblwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxiKD86ZW5kKVxcYi8sIFwiKD86c3RhcnR8YmVnaW58ZW5kKVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLWNsb3NlXFxiLywgXCItKGNsb3NlfG9wZW4pXCIpXG4gICAgICAgICAgICAgICAgKyBcIikrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUluZGV4ID0gcG9zaXRpb24uY29sdW1uIC0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgLSAyO1xuICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gdmFsdWUuY2hhckF0KHZhbHVlSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPT0gb3BlbkJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJvdzogaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB2YWx1ZUluZGV4ICsgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gYnJhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICYmICF0eXBlUmUudGVzdCh0b2tlbi50eXBlKSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YWx1ZUluZGV4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuJGZpbmRDbG9zaW5nQnJhY2tldCA9IGZ1bmN0aW9uIChicmFja2V0LCBwb3NpdGlvbiwgdHlwZVJlKSB7XG4gICAgICAgIHZhciBjbG9zaW5nQnJhY2tldCA9IHRoaXMuJGJyYWNrZXRzW2JyYWNrZXRdO1xuICAgICAgICB2YXIgZGVwdGggPSAxO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCBwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXR5cGVSZSkge1xuICAgICAgICAgICAgdHlwZVJlID0gbmV3IFJlZ0V4cChcIihcXFxcLj9cIiArXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZS5yZXBsYWNlKFwiLlwiLCBcIlxcXFwuXCIpLnJlcGxhY2UoXCJscGFyZW5cIiwgXCIucGFyZW5cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYig/OnN0YXJ0fGJlZ2luKVxcYi8sIFwiKD86c3RhcnR8YmVnaW58ZW5kKVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLW9wZW5cXGIvLCBcIi0oY2xvc2V8b3BlbilcIilcbiAgICAgICAgICAgICAgICArIFwiKStcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlSW5kZXggPSBwb3NpdGlvbi5jb2x1bW4gLSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlSW5kZXggPCB2YWx1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHIgPSB2YWx1ZS5jaGFyQXQodmFsdWVJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNociA9PSBjbG9zaW5nQnJhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcm93OiBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHZhbHVlSW5kZXggKyBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PSBicmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiAhdHlwZVJlLnRlc3QodG9rZW4udHlwZSkpO1xuICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCBwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy4kZmluZFRhZ05hbWUoaXRlcmF0b3IpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcHJldlRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZpbmRDbG9zaW5nVGFnKGl0ZXJhdG9yLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZmluZE9wZW5pbmdUYWcoaXRlcmF0b3IsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4kZmluZFRhZ05hbWUgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgYmFja3dhcmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3dhcmQpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gXCIvPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrd2FyZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIWZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICB0aGlzLiRmaW5kQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdG9rZW4pIHtcbiAgICAgICAgdmFyIHByZXZUb2tlbjtcbiAgICAgICAgdmFyIGN1cnJlbnRUYWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgdmFyIHRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICB2YXIgb3BlblRhZ1N0YXJ0ID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7XG4gICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgdG9rZW4udmFsdWUubGVuZ3RoKTtcbiAgICAgICAgdmFyIGZvdW5kT3BlblRhZ0VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwcmV2VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udHlwZS5pbmRleE9mKCd0YWctY2xvc2UnKSAhPT0gLTEgJiYgIWZvdW5kT3BlblRhZ0VuZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcGVuVGFnRW5kID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7IC8vUmFuZ2UgZm9yIGA+YFxuICAgICAgICAgICAgICAgIGZvdW5kT3BlblRhZ0VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICc+JyAmJiAhZm91bmRPcGVuVGFnRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVuVGFnRW5kID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7IC8vUmFuZ2UgZm9yIGA+YFxuICAgICAgICAgICAgICAgICAgICBmb3VuZE9wZW5UYWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFnID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IGN1cnJlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IDApIHsgLy9mb3VuZCBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnU3RhcnQgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAyKTsgLy9SYW5nZSBmb3IgPC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VUYWdOYW1lID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgdG9rZW4udmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigndGFnLWNsb3NlJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnZhbHVlID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVRhZ0VuZCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDEpOyAvL1JhbmdlIGZvciA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFnID09PSBjdXJyZW50VGFnICYmIHRva2VuLnZhbHVlID09PSAnLz4nKSB7IC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgMCkgeyAvL2ZvdW5kIHNlbGYtY2xvc2luZyB0YWcgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VUYWdTdGFydCA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnTmFtZSA9IGNsb3NlVGFnU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VUYWdFbmQgPSBjbG9zZVRhZ05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ0VuZCA9IG5ldyBSYW5nZShvcGVuVGFnTmFtZS5lbmQucm93LCBvcGVuVGFnTmFtZS5lbmQuY29sdW1uLCBvcGVuVGFnTmFtZS5lbmQucm93LCBvcGVuVGFnTmFtZS5lbmQuY29sdW1uICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRva2VuICYmIGRlcHRoID49IDApO1xuICAgICAgICBpZiAob3BlblRhZ1N0YXJ0ICYmIG9wZW5UYWdFbmQgJiYgY2xvc2VUYWdTdGFydCAmJiBjbG9zZVRhZ0VuZCAmJiBvcGVuVGFnTmFtZSAmJiBjbG9zZVRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BlblRhZzogbmV3IFJhbmdlKG9wZW5UYWdTdGFydC5zdGFydC5yb3csIG9wZW5UYWdTdGFydC5zdGFydC5jb2x1bW4sIG9wZW5UYWdFbmQuZW5kLnJvdywgb3BlblRhZ0VuZC5lbmQuY29sdW1uKSxcbiAgICAgICAgICAgICAgICBjbG9zZVRhZzogbmV3IFJhbmdlKGNsb3NlVGFnU3RhcnQuc3RhcnQucm93LCBjbG9zZVRhZ1N0YXJ0LnN0YXJ0LmNvbHVtbiwgY2xvc2VUYWdFbmQuZW5kLnJvdywgY2xvc2VUYWdFbmQuZW5kLmNvbHVtbiksXG4gICAgICAgICAgICAgICAgb3BlblRhZ05hbWU6IG9wZW5UYWdOYW1lLFxuICAgICAgICAgICAgICAgIGNsb3NlVGFnTmFtZTogY2xvc2VUYWdOYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiRmaW5kT3BlbmluZ1RhZyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdG9rZW4pIHtcbiAgICAgICAgdmFyIHByZXZUb2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICB2YXIgdGFnID0gdG9rZW4udmFsdWU7XG4gICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgIHZhciBzdGFydFJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKTtcbiAgICAgICAgdmFyIGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uICsgMjtcbiAgICAgICAgdmFyIGNsb3NlVGFnU3RhcnQgPSBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgZW5kQ29sdW1uKTsgLy9SYW5nZSBmb3IgPC9cbiAgICAgICAgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgdmFyIGNsb3NlVGFnTmFtZSA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIHRva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1jbG9zZScpID09PSAtMSkge1xuICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udmFsdWUgIT09IFwiPlwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2xvc2VUYWdFbmQgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAxKTsgLy9SYW5nZSBmb3IgPlxuICAgICAgICBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRva2VuID0gcHJldlRva2VuO1xuICAgICAgICAgICAgc3RhcnRSb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIHRva2VuLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHByZXZUb2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMCkgeyAvL2ZvdW5kIG9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG5ldyBSYW5nZShzdGFydFJvdywgc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCBlbmRDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblRhZ1N0YXJ0ID0gbmV3IFJhbmdlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7IC8vUmFuZ2UgZm9yIDxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiB0b2tlbi52YWx1ZSAhPT0gJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdFbmQgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpLCBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAxKTsgLy9SYW5nZSBmb3IgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJzwvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICcvPicpIHsgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRva2VuID0gcHJldlRva2VuO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG1wVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBUb2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xICYmIHRtcFRva2VuLnZhbHVlID09PSB0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG1wVG9rZW4udmFsdWUgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHByZXZUb2tlbiAmJiBkZXB0aCA8PSAwKTtcbiAgICAgICAgaWYgKG9wZW5UYWdTdGFydCAmJiBvcGVuVGFnRW5kICYmIGNsb3NlVGFnU3RhcnQgJiYgY2xvc2VUYWdFbmQgJiYgb3BlblRhZ05hbWUgJiYgY2xvc2VUYWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW5UYWc6IG5ldyBSYW5nZShvcGVuVGFnU3RhcnQuc3RhcnQucm93LCBvcGVuVGFnU3RhcnQuc3RhcnQuY29sdW1uLCBvcGVuVGFnRW5kLmVuZC5yb3csIG9wZW5UYWdFbmQuZW5kLmNvbHVtbiksXG4gICAgICAgICAgICAgICAgY2xvc2VUYWc6IG5ldyBSYW5nZShjbG9zZVRhZ1N0YXJ0LnN0YXJ0LnJvdywgY2xvc2VUYWdTdGFydC5zdGFydC5jb2x1bW4sIGNsb3NlVGFnRW5kLmVuZC5yb3csIGNsb3NlVGFnRW5kLmVuZC5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIG9wZW5UYWdOYW1lOiBvcGVuVGFnTmFtZSxcbiAgICAgICAgICAgICAgICBjbG9zZVRhZ05hbWU6IGNsb3NlVGFnTmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLkJyYWNrZXRNYXRjaCA9IEJyYWNrZXRNYXRjaDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvYmlkaWhhbmRsZXJcIixcImFjZS9jb25maWdcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL3NlbGVjdGlvblwiLFwiYWNlL21vZGUvdGV4dFwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGluZV93aWRnZXRzXCIsXCJhY2UvZG9jdW1lbnRcIixcImFjZS9iYWNrZ3JvdW5kX3Rva2VuaXplclwiLFwiYWNlL3NlYXJjaF9oaWdobGlnaHRcIixcImFjZS91bmRvbWFuYWdlclwiLFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkaW5nXCIsXCJhY2UvZWRpdF9zZXNzaW9uL2JyYWNrZXRfbWF0Y2hcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgQmlkaUhhbmRsZXIgPSByZXF1aXJlKFwiLi9iaWRpaGFuZGxlclwiKS5CaWRpSGFuZGxlcjtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvblwiKS5TZWxlY3Rpb247XG52YXIgVGV4dE1vZGUgPSByZXF1aXJlKFwiLi9tb2RlL3RleHRcIikuTW9kZTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIExpbmVXaWRnZXRzID0gcmVxdWlyZShcIi4vbGluZV93aWRnZXRzXCIpLkxpbmVXaWRnZXRzO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZShcIi4vZG9jdW1lbnRcIikuRG9jdW1lbnQ7XG52YXIgQmFja2dyb3VuZFRva2VuaXplciA9IHJlcXVpcmUoXCIuL2JhY2tncm91bmRfdG9rZW5pemVyXCIpLkJhY2tncm91bmRUb2tlbml6ZXI7XG52YXIgU2VhcmNoSGlnaGxpZ2h0ID0gcmVxdWlyZShcIi4vc2VhcmNoX2hpZ2hsaWdodFwiKS5TZWFyY2hIaWdobGlnaHQ7XG52YXIgVW5kb01hbmFnZXIgPSByZXF1aXJlKFwiLi91bmRvbWFuYWdlclwiKS5VbmRvTWFuYWdlcjtcbnZhciBFZGl0U2Vzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGl0U2Vzc2lvbih0ZXh0LCBtb2RlKSB7IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLiRicmVha3BvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLiRkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLiRmcm9udE1hcmtlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4kYmFja01hcmtlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4kbWFya2VySWQgPSAxO1xuICAgICAgICB0aGlzLiR1bmRvU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZWRpdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2T3AgPSB7fTtcbiAgICAgICAgdGhpcy4kZm9sZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IFwic2Vzc2lvblwiICsgKCsrRWRpdFNlc3Npb24uJHVpZCk7XG4gICAgICAgIHRoaXMuJGZvbGREYXRhLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iZ1Rva2VuaXplciA9IG5ldyBCYWNrZ3JvdW5kVG9rZW5pemVyKChuZXcgVGV4dE1vZGUoKSkuZ2V0VG9rZW5pemVyKCksIHRoaXMpO1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLm9uKFwidXBkYXRlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfc2VsZi5fc2lnbmFsKFwidG9rZW5pemVyVXBkYXRlXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZUZvbGRcIiwgdGhpcy5vbkNoYW5nZUZvbGQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuJG9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT0gXCJvYmplY3RcIiB8fCAhdGV4dC5nZXRMaW5lKVxuICAgICAgICAgICAgdGV4dCA9IG5ldyBEb2N1bWVudCgvKipAdHlwZXtzdHJpbmd9Ki8gKHRleHQpKTtcbiAgICAgICAgdGhpcy5zZXREb2N1bWVudCh0ZXh0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5vbihcImNoYW5nZUN1cnNvclwiLCB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIHRoaXMuJGJpZGlIYW5kbGVyID0gbmV3IEJpZGlIYW5kbGVyKHRoaXMpO1xuICAgICAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLnNldE1vZGUobW9kZSk7XG4gICAgICAgIGNvbmZpZy5fc2lnbmFsKFwic2Vzc2lvblwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kaW5pdE9wZXJhdGlvbkxpc3RlbmVycygpO1xuICAgIH1cbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGluaXRPcGVyYXRpb25MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VyT3ApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ck9wLnNlbGVjdGlvbkJlZm9yZSA9IF90aGlzLiRsYXN0U2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VyT3AuZG9jQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlU2VsZWN0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VyT3ApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ck9wLnNlbGVjdGlvbkJlZm9yZSA9IF90aGlzLiRsYXN0U2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLiRvcGVyYXRpb25SZXNldFRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLmVuZE9wZXJhdGlvbi5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zdGFydE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChjb21tYW5kRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyT3ApIHtcbiAgICAgICAgICAgIGlmICghY29tbWFuZEV2ZW50IHx8IHRoaXMuY3VyT3AuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldk9wID0gdGhpcy5jdXJPcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbW1hbmRFdmVudCkge1xuICAgICAgICAgICAgY29tbWFuZEV2ZW50ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kb3BlcmF0aW9uUmVzZXRUaW1lci5zY2hlZHVsZSgpO1xuICAgICAgICB0aGlzLmN1ck9wID0ge1xuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZEV2ZW50LmNvbW1hbmQgfHwge30sXG4gICAgICAgICAgICBhcmdzOiBjb21tYW5kRXZlbnQuYXJnc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1ck9wLnNlbGVjdGlvbkJlZm9yZSA9IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJzdGFydE9wZXJhdGlvblwiLCBjb21tYW5kRXZlbnQpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ck9wKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnJldHVyblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImVuZE9wZXJhdGlvblwiLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSA9PSB0cnVlICYmIHRoaXMuY3VyT3AuY29tbWFuZCAmJiB0aGlzLmN1ck9wLmNvbW1hbmQubmFtZSA9PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpO1xuICAgICAgICAgICAgdGhpcy5jdXJPcC5zZWxlY3Rpb25BZnRlciA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLiRsYXN0U2VsID0gdGhpcy5zZWxlY3Rpb24udG9KU09OKCk7XG4gICAgICAgICAgICB0aGlzLmdldFVuZG9NYW5hZ2VyKCkuYWRkU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYmVmb3JlRW5kT3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2T3AgPSB0aGlzLmN1ck9wO1xuICAgICAgICAgICAgdGhpcy5jdXJPcCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJlbmRPcGVyYXRpb25cIiwgZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKVxuICAgICAgICAgICAgdGhpcy5kb2Mub2ZmKFwiY2hhbmdlXCIsIHRoaXMuJG9uQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIGRvYy5vbihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0RG9jdW1lbnQodGhpcy5nZXREb2N1bWVudCgpKTtcbiAgICAgICAgdGhpcy5yZXNldENhY2hlcygpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdFNlc3Npb24ucHJvdG90eXBlLCBcIndpZGdldE1hbmFnZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWRnZXRNYW5hZ2VyID0gbmV3IExpbmVXaWRnZXRzKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy53aWRnZXRNYW5hZ2VyID0gd2lkZ2V0TWFuYWdlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLiRlZGl0b3IpXG4gICAgICAgICAgICAgICAgd2lkZ2V0TWFuYWdlci5hdHRhY2godGhpcy4kZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybiB3aWRnZXRNYW5hZ2VyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkZ2V0TWFuYWdlclwiLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHJlc2V0Um93Q2FjaGUgPSBmdW5jdGlvbiAoZG9jUm93KSB7XG4gICAgICAgIGlmICghZG9jUm93KSB7XG4gICAgICAgICAgICB0aGlzLiRkb2NSb3dDYWNoZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCA9IHRoaXMuJGRvY1Jvd0NhY2hlLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRnZXRSb3dDYWNoZUluZGV4KHRoaXMuJGRvY1Jvd0NhY2hlLCBkb2NSb3cpICsgMTtcbiAgICAgICAgaWYgKGwgPiBpKSB7XG4gICAgICAgICAgICB0aGlzLiRkb2NSb3dDYWNoZS5zcGxpY2UoaSwgbCk7XG4gICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5zcGxpY2UoaSwgbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kZ2V0Um93Q2FjaGVJbmRleCA9IGZ1bmN0aW9uIChjYWNoZUFycmF5LCB2YWwpIHtcbiAgICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICAgIHZhciBoaSA9IGNhY2hlQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaSkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIHZhciBjID0gY2FjaGVBcnJheVttaWRdO1xuICAgICAgICAgICAgaWYgKHZhbCA+IGMpXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IGMpXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvdyAtIDE7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUucmVzZXRDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kd3JhcERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4kcm93TGVuZ3RoQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc3RhcnQoMCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUub25DaGFuZ2VGb2xkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGZvbGQgPSBlLmRhdGE7XG4gICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoZm9sZC5zdGFydC5yb3cpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kYmlkaUhhbmRsZXIub25DaGFuZ2UoZGVsdGEpO1xuICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKGRlbHRhLnN0YXJ0LnJvdyk7XG4gICAgICAgIHZhciByZW1vdmVkRm9sZHMgPSB0aGlzLiR1cGRhdGVJbnRlcm5hbERhdGFPbkNoYW5nZShkZWx0YSk7XG4gICAgICAgIGlmICghdGhpcy4kZnJvbVVuZG8gJiYgdGhpcy4kdW5kb01hbmFnZXIpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkRm9sZHMgJiYgcmVtb3ZlZEZvbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHVuZG9NYW5hZ2VyLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVGb2xkc1wiLFxuICAgICAgICAgICAgICAgICAgICBmb2xkczogcmVtb3ZlZEZvbGRzXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tZXJnZVVuZG9EZWx0YXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VVbmRvRGVsdGFzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHVuZG9NYW5hZ2VyLmFkZChkZWx0YSwgdGhpcy5tZXJnZVVuZG9EZWx0YXMpO1xuICAgICAgICAgICAgdGhpcy5tZXJnZVVuZG9EZWx0YXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kaW5mb3JtVW5kb01hbmFnZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLiR1cGRhdGVPbkNoYW5nZShkZWx0YSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCBkZWx0YSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMuZG9jLnNldFZhbHVlKHRleHQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XG4gICAgICAgIHRoaXMuc2V0VW5kb01hbmFnZXIodGhpcy4kdW5kb01hbmFnZXIpO1xuICAgICAgICB0aGlzLmdldFVuZG9NYW5hZ2VyKCkucmVzZXQoKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLmZyb21KU09OID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBzZXNzaW9uID0gSlNPTi5wYXJzZShzZXNzaW9uKTtcbiAgICAgICAgdmFyIHVuZG9NYW5hZ2VyID0gbmV3IFVuZG9NYW5hZ2VyKCk7XG4gICAgICAgIHVuZG9NYW5hZ2VyLiR1bmRvU3RhY2sgPSBzZXNzaW9uLmhpc3RvcnkudW5kbztcbiAgICAgICAgdW5kb01hbmFnZXIuJHJlZG9TdGFjayA9IHNlc3Npb24uaGlzdG9yeS5yZWRvO1xuICAgICAgICB1bmRvTWFuYWdlci5tYXJrID0gc2Vzc2lvbi5oaXN0b3J5Lm1hcms7XG4gICAgICAgIHVuZG9NYW5hZ2VyLiRyZXYgPSBzZXNzaW9uLmhpc3RvcnkucmV2O1xuICAgICAgICB2YXIgZWRpdFNlc3Npb24gPSBuZXcgRWRpdFNlc3Npb24oc2Vzc2lvbi52YWx1ZSk7XG4gICAgICAgIHNlc3Npb24uZm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgZWRpdFNlc3Npb24uYWRkRm9sZChcIi4uLlwiLCBSYW5nZS5mcm9tUG9pbnRzKGZvbGQuc3RhcnQsIGZvbGQuZW5kKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0U2Vzc2lvbi5zZXRBbm5vdGF0aW9ucyhzZXNzaW9uLmFubm90YXRpb25zKTtcbiAgICAgICAgZWRpdFNlc3Npb24uc2V0QnJlYWtwb2ludHMoc2Vzc2lvbi5icmVha3BvaW50cyk7XG4gICAgICAgIGVkaXRTZXNzaW9uLnNldE1vZGUoc2Vzc2lvbi5tb2RlKTtcbiAgICAgICAgZWRpdFNlc3Npb24uc2V0U2Nyb2xsTGVmdChzZXNzaW9uLnNjcm9sbExlZnQpO1xuICAgICAgICBlZGl0U2Vzc2lvbi5zZXRTY3JvbGxUb3Aoc2Vzc2lvbi5zY3JvbGxUb3ApO1xuICAgICAgICBlZGl0U2Vzc2lvbi5zZXRVbmRvTWFuYWdlcih1bmRvTWFuYWdlcik7XG4gICAgICAgIGVkaXRTZXNzaW9uLnNlbGVjdGlvbi5mcm9tSlNPTihzZXNzaW9uLnNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiBlZGl0U2Vzc2lvbjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uczogdGhpcy4kYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBicmVha3BvaW50czogdGhpcy4kYnJlYWtwb2ludHMsXG4gICAgICAgICAgICBmb2xkczogdGhpcy5nZXRBbGxGb2xkcygpLm1hcChmdW5jdGlvbiAoZm9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkLnJhbmdlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoaXN0b3J5OiB0aGlzLmdldFVuZG9NYW5hZ2VyKCksXG4gICAgICAgICAgICBtb2RlOiB0aGlzLiRtb2RlLiRpZCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IHRoaXMuJHNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMuJHNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5kb2MuZ2V0VmFsdWUoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuZ2V0VmFsdWUoKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmdUb2tlbml6ZXIuZ2V0U3RhdGUocm93KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRUb2tlbnMgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJnVG9rZW5pemVyLmdldFRva2Vucyhyb3cpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFRva2VuQXQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuYmdUb2tlbml6ZXIuZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgIHZhciB0b2tlbiwgYyA9IDA7XG4gICAgICAgIGlmIChjb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGMgPSB0aGlzLmdldExpbmUocm93KS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGMgKz0gdG9rZW5zW2ldLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSBjb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRva2VuLmluZGV4ID0gaTtcbiAgICAgICAgdG9rZW4uc3RhcnQgPSBjIC0gdG9rZW4udmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VW5kb01hbmFnZXIgPSBmdW5jdGlvbiAodW5kb01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy4kdW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlcjtcbiAgICAgICAgaWYgKHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyKVxuICAgICAgICAgICAgdGhpcy4kaW5mb3JtVW5kb01hbmFnZXIuY2FuY2VsKCk7XG4gICAgICAgIGlmICh1bmRvTWFuYWdlcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdW5kb01hbmFnZXIuYWRkU2Vzc2lvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLiRpbmZvcm1VbmRvTWFuYWdlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBzZWxmLm1lcmdlVW5kb0RlbHRhcyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLiRzeW5jSW5mb3JtVW5kb01hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUubWFya1VuZG9Hcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcilcbiAgICAgICAgICAgIHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcigpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdW5kb01hbmFnZXIgfHwgdGhpcy4kZGVmYXVsdFVuZG9NYW5hZ2VyO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFRhYlN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VXNlU29mdFRhYnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcuc3RyaW5nUmVwZWF0KFwiIFwiLCB0aGlzLmdldFRhYlNpemUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFVzZVNvZnRUYWJzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInVzZVNvZnRUYWJzXCIsIHZhbCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VXNlU29mdFRhYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1c2VTb2Z0VGFicyAmJiAhdGhpcy4kbW9kZS4kaW5kZW50V2l0aFRhYnM7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0VGFiU2l6ZSA9IGZ1bmN0aW9uICh0YWJTaXplKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidGFiU2l6ZVwiLCB0YWJTaXplKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRUYWJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFiU2l6ZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5pc1RhYlN0b3AgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVzZVNvZnRUYWJzICYmIChwb3NpdGlvbi5jb2x1bW4gJSB0aGlzLiR0YWJTaXplID09PSAwKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXROYXZpZ2F0ZVdpdGhpblNvZnRUYWJzID0gZnVuY3Rpb24gKG5hdmlnYXRlV2l0aGluU29mdFRhYnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJuYXZpZ2F0ZVdpdGhpblNvZnRUYWJzXCIsIG5hdmlnYXRlV2l0aGluU29mdFRhYnMpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldE5hdmlnYXRlV2l0aGluU29mdFRhYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuYXZpZ2F0ZVdpdGhpblNvZnRUYWJzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChvdmVyd3JpdGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJvdmVyd3JpdGVcIiwgb3ZlcndyaXRlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRPdmVyd3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvdmVyd3JpdGU7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUudG9nZ2xlT3ZlcndyaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE92ZXJ3cml0ZSghdGhpcy4kb3ZlcndyaXRlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5hZGRHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24gKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGVjb3JhdGlvbnNbcm93XSlcbiAgICAgICAgICAgIHRoaXMuJGRlY29yYXRpb25zW3Jvd10gPSBcIlwiO1xuICAgICAgICB0aGlzLiRkZWNvcmF0aW9uc1tyb3ddICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24gKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuJGRlY29yYXRpb25zW3Jvd10gPSAodGhpcy4kZGVjb3JhdGlvbnNbcm93XSB8fCBcIlwiKS5yZXBsYWNlKFwiIFwiICsgY2xhc3NOYW1lLCBcIlwiKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0QnJlYWtwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRicmVha3BvaW50cztcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRCcmVha3BvaW50cyA9IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy4kYnJlYWtwb2ludHNbcm93c1tpXV0gPSBcImFjZV9icmVha3BvaW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuY2xlYXJCcmVha3BvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kYnJlYWtwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0QnJlYWtwb2ludCA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBcImFjZV9icmVha3BvaW50XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpXG4gICAgICAgICAgICB0aGlzLiRicmVha3BvaW50c1tyb3ddID0gY2xhc3NOYW1lO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy4kYnJlYWtwb2ludHNbcm93XTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuY2xlYXJCcmVha3BvaW50ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBkZWxldGUgdGhpcy4kYnJlYWtwb2ludHNbcm93XTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKHJhbmdlLCBjbGF6eiwgdHlwZSwgaW5Gcm9udCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLiRtYXJrZXJJZCsrO1xuICAgICAgICB2YXIgbWFya2VyID0ge1xuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgdHlwZTogdHlwZSB8fCBcImxpbmVcIixcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0eXBlb2YgdHlwZSA9PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogbnVsbCxcbiAgICAgICAgICAgIGNsYXp6OiBjbGF6eixcbiAgICAgICAgICAgIGluRnJvbnQ6ICEhaW5Gcm9udCxcbiAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5Gcm9udCkge1xuICAgICAgICAgICAgdGhpcy4kZnJvbnRNYXJrZXJzW2lkXSA9IG1hcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUZyb250TWFya2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kYmFja01hcmtlcnNbaWRdID0gbWFya2VyO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuYWRkRHluYW1pY01hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIsIGluRnJvbnQpIHtcbiAgICAgICAgaWYgKCFtYXJrZXIudXBkYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLiRtYXJrZXJJZCsrO1xuICAgICAgICBtYXJrZXIuaWQgPSBpZDtcbiAgICAgICAgbWFya2VyLmluRnJvbnQgPSAhIWluRnJvbnQ7XG4gICAgICAgIGlmIChpbkZyb250KSB7XG4gICAgICAgICAgICB0aGlzLiRmcm9udE1hcmtlcnNbaWRdID0gbWFya2VyO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlRnJvbnRNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRiYWNrTWFya2Vyc1tpZF0gPSBtYXJrZXI7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCYWNrTWFya2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcklkKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLiRmcm9udE1hcmtlcnNbbWFya2VySWRdIHx8IHRoaXMuJGJhY2tNYXJrZXJzW21hcmtlcklkXTtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtYXJrZXJzID0gbWFya2VyLmluRnJvbnQgPyB0aGlzLiRmcm9udE1hcmtlcnMgOiB0aGlzLiRiYWNrTWFya2VycztcbiAgICAgICAgZGVsZXRlIChtYXJrZXJzW21hcmtlcklkXSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChtYXJrZXIuaW5Gcm9udCA/IFwiY2hhbmdlRnJvbnRNYXJrZXJcIiA6IFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRNYXJrZXJzID0gZnVuY3Rpb24gKGluRnJvbnQpIHtcbiAgICAgICAgcmV0dXJuIGluRnJvbnQgPyB0aGlzLiRmcm9udE1hcmtlcnMgOiB0aGlzLiRiYWNrTWFya2VycztcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRzZWFyY2hIaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBuZXcgU2VhcmNoSGlnaGxpZ2h0KG51bGwsIFwiYWNlX3NlbGVjdGVkLXdvcmRcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgdGhpcy4kc2VhcmNoSGlnaGxpZ2h0ID0gdGhpcy5hZGREeW5hbWljTWFya2VyKGhpZ2hsaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2VhcmNoSGlnaGxpZ2h0LnNldFJlZ2V4cChyZSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuaGlnaGxpZ2h0TGluZXMgPSBmdW5jdGlvbiAoc3RhcnRSb3csIGVuZFJvdywgY2xhenosIGluRnJvbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRSb3cgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY2xhenogPSBlbmRSb3c7XG4gICAgICAgICAgICBlbmRSb3cgPSBzdGFydFJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsYXp6KVxuICAgICAgICAgICAgY2xhenogPSBcImFjZV9zdGVwXCI7XG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydFJvdywgMCwgZW5kUm93LCBJbmZpbml0eSk7XG4gICAgICAgIHJhbmdlLmlkID0gdGhpcy5hZGRNYXJrZXIocmFuZ2UsIGNsYXp6LCBcImZ1bGxMaW5lXCIsIGluRnJvbnQpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQW5ub3RhdGlvblwiLCB7fSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhbm5vdGF0aW9ucyB8fCBbXTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5jbGVhckFubm90YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEFubm90YXRpb25zKFtdKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kZGV0ZWN0TmV3TGluZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14uKj8oXFxyP1xcbikvbSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdGhpcy4kYXV0b05ld0xpbmUgPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFdvcmRSYW5nZSA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgaW5Ub2tlbiA9IGZhbHNlO1xuICAgICAgICBpZiAoY29sdW1uID4gMClcbiAgICAgICAgICAgIGluVG9rZW4gPSAhIWxpbmUuY2hhckF0KGNvbHVtbiAtIDEpLm1hdGNoKHRoaXMudG9rZW5SZSk7XG4gICAgICAgIGlmICghaW5Ub2tlbilcbiAgICAgICAgICAgIGluVG9rZW4gPSAhIWxpbmUuY2hhckF0KGNvbHVtbikubWF0Y2godGhpcy50b2tlblJlKTtcbiAgICAgICAgaWYgKGluVG9rZW4pXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLnRva2VuUmU7XG4gICAgICAgIGVsc2UgaWYgKC9eXFxzKyQvLnRlc3QobGluZS5zbGljZShjb2x1bW4gLSAxLCBjb2x1bW4gKyAxKSkpXG4gICAgICAgICAgICB2YXIgcmUgPSAvXFxzLztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIHJlID0gdGhpcy5ub25Ub2tlblJlO1xuICAgICAgICB2YXIgc3RhcnQgPSBjb2x1bW47XG4gICAgICAgIGlmIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3RhcnQgPj0gMCAmJiBsaW5lLmNoYXJBdChzdGFydCkubWF0Y2gocmUpKTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IGNvbHVtbjtcbiAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGxpbmUuY2hhckF0KGVuZCkubWF0Y2gocmUpKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJvdywgc3RhcnQsIHJvdywgZW5kKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRBV29yZFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciB3b3JkUmFuZ2UgPSB0aGlzLmdldFdvcmRSYW5nZShyb3csIGNvbHVtbik7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHdvcmRSYW5nZS5lbmQucm93KTtcbiAgICAgICAgd2hpbGUgKGxpbmUuY2hhckF0KHdvcmRSYW5nZS5lbmQuY29sdW1uKS5tYXRjaCgvWyBcXHRdLykpIHtcbiAgICAgICAgICAgIHdvcmRSYW5nZS5lbmQuY29sdW1uICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRSYW5nZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uIChuZXdMaW5lTW9kZSkge1xuICAgICAgICB0aGlzLmRvYy5zZXROZXdMaW5lTW9kZShuZXdMaW5lTW9kZSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXROZXdMaW5lTW9kZSgpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFVzZVdvcmtlciA9IGZ1bmN0aW9uICh1c2VXb3JrZXIpIHsgdGhpcy5zZXRPcHRpb24oXCJ1c2VXb3JrZXJcIiwgdXNlV29ya2VyKTsgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VXNlV29ya2VyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kdXNlV29ya2VyOyB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5vblJlbG9hZFRva2VuaXplciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByb3dzID0gZS5kYXRhO1xuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnN0YXJ0KHJvd3MuZmlyc3QpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJ0b2tlbml6ZXJVcGRhdGVcIiwgZSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIChtb2RlLCBjYikge1xuICAgICAgICBpZiAobW9kZSAmJiB0eXBlb2YgbW9kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG1vZGUuZ2V0VG9rZW5pemVyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRvbkNoYW5nZU1vZGUobW9kZSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG1vZGU7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSAvKipAdHlwZXtzdHJpbmd9Ki8gKG1vZGUpIHx8IFwiYWNlL21vZGUvdGV4dFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy4kbW9kZXNbXCJhY2UvbW9kZS90ZXh0XCJdKVxuICAgICAgICAgICAgdGhpcy4kbW9kZXNbXCJhY2UvbW9kZS90ZXh0XCJdID0gbmV3IFRleHRNb2RlKCk7XG4gICAgICAgIGlmICh0aGlzLiRtb2Rlc1twYXRoXSAmJiAhb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKHRoaXMuJG1vZGVzW3BhdGhdKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kbW9kZUlkID0gcGF0aDtcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoW1wibW9kZVwiLCBwYXRoXSwgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRtb2RlSWQgIT09IHBhdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kbW9kZXNbcGF0aF0gJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRvbkNoYW5nZU1vZGUodGhpcy4kbW9kZXNbcGF0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSAmJiBtLk1vZGUpIHtcbiAgICAgICAgICAgICAgICBtID0gbmV3IG0uTW9kZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW9kZXNbcGF0aF0gPSBtO1xuICAgICAgICAgICAgICAgICAgICBtLiRpZCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICghdGhpcy4kbW9kZSlcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSh0aGlzLiRtb2Rlc1tcImFjZS9tb2RlL3RleHRcIl0sIHRydWUpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRvbkNoYW5nZU1vZGUgPSBmdW5jdGlvbiAobW9kZSwgJGlzUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgaWYgKCEkaXNQbGFjZWhvbGRlcilcbiAgICAgICAgICAgIHRoaXMuJG1vZGVJZCA9IG1vZGUuJGlkO1xuICAgICAgICBpZiAodGhpcy4kbW9kZSA9PT0gbW9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9sZE1vZGUgPSB0aGlzLiRtb2RlO1xuICAgICAgICB0aGlzLiRtb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy4kc3RvcFdvcmtlcigpO1xuICAgICAgICBpZiAodGhpcy4kdXNlV29ya2VyKVxuICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcbiAgICAgICAgdmFyIHRva2VuaXplciA9IG1vZGUuZ2V0VG9rZW5pemVyKCk7XG4gICAgICAgIGlmICh0b2tlbml6ZXIub24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG9uUmVsb2FkVG9rZW5pemVyID0gdGhpcy5vblJlbG9hZFRva2VuaXplci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdG9rZW5pemVyLm9uKFwidXBkYXRlXCIsIG9uUmVsb2FkVG9rZW5pemVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnNldFRva2VuaXplcih0b2tlbml6ZXIpO1xuICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnNldERvY3VtZW50KHRoaXMuZ2V0RG9jdW1lbnQoKSk7XG4gICAgICAgIHRoaXMudG9rZW5SZSA9IG1vZGUudG9rZW5SZTtcbiAgICAgICAgdGhpcy5ub25Ub2tlblJlID0gbW9kZS5ub25Ub2tlblJlO1xuICAgICAgICBpZiAoISRpc1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBpZiAobW9kZS5hdHRhY2hUb1Nlc3Npb24pXG4gICAgICAgICAgICAgICAgbW9kZS5hdHRhY2hUb1Nlc3Npb24odGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRvcHRpb25zLndyYXBNZXRob2Quc2V0LmNhbGwodGhpcywgdGhpcy4kd3JhcE1ldGhvZCk7XG4gICAgICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG1vZGUuZm9sZGluZ1J1bGVzKTtcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc3RhcnQoMCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlTW9kZVwiLCB7IG9sZE1vZGU6IG9sZE1vZGUsIG1vZGU6IG1vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kc3RvcFdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHdvcmtlcikge1xuICAgICAgICAgICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy4kd29ya2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzdGFydFdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJHdvcmtlciA9IHRoaXMuJG1vZGUuY3JlYXRlV29ya2VyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25maWcud2FybihcIkNvdWxkIG5vdCBsb2FkIHdvcmtlclwiLCBlKTtcbiAgICAgICAgICAgIHRoaXMuJHdvcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW9kZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxUb3AgPT09IHNjcm9sbFRvcCB8fCBpc05hTihzY3JvbGxUb3ApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRzY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNjcm9sbFRvcFwiLCBzY3JvbGxUb3ApO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbFRvcDtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbExlZnQgPT09IHNjcm9sbExlZnQgfHwgaXNOYU4oc2Nyb2xsTGVmdCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJHNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTY3JvbGxMZWZ0XCIsIHNjcm9sbExlZnQpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzY3JvbGxMZWZ0O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFNjcmVlbldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRjb21wdXRlV2lkdGgoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHMpXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXRMaW5lV2lkZ2V0TWF4V2lkdGgoKSwgdGhpcy5zY3JlZW5XaWR0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbldpZHRoO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldExpbmVXaWRnZXRNYXhXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHNXaWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZVdpZGdldHNXaWR0aDtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5saW5lV2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICBpZiAodyAmJiB3LnNjcmVlbldpZHRoID4gd2lkdGgpXG4gICAgICAgICAgICAgICAgd2lkdGggPSB3LnNjcmVlbldpZHRoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVdpZGdldFdpZHRoID0gd2lkdGg7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNvbXB1dGVXaWR0aCA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy4kbW9kaWZpZWQgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuV2lkdGggPSB0aGlzLiR3cmFwTGltaXQ7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmRvYy5nZXRBbGxMaW5lcygpO1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gdGhpcy4kcm93TGVuZ3RoQ2FjaGU7XG4gICAgICAgICAgICB2YXIgbG9uZ2VzdFNjcmVlbkxpbmUgPSAwO1xuICAgICAgICAgICAgdmFyIGZvbGRJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLiRmb2xkRGF0YVtmb2xkSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy4kZm9sZERhdGFbZm9sZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVbaV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbaV0gPSB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aChsaW5lc1tpXSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW2ldID4gbG9uZ2VzdFNjcmVlbkxpbmUpXG4gICAgICAgICAgICAgICAgICAgIGxvbmdlc3RTY3JlZW5MaW5lID0gY2FjaGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcmVlbldpZHRoID0gbG9uZ2VzdFNjcmVlbkxpbmU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRMaW5lID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRMaW5lcyhmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuZ2V0TGVuZ3RoKCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0VGV4dFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5pbnNlcnQocG9zaXRpb24sIHRleHQpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MucmVtb3ZlKHJhbmdlKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5yZW1vdmVGdWxsTGluZXMgPSBmdW5jdGlvbiAoZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnJlbW92ZUZ1bGxMaW5lcyhmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUudW5kb0NoYW5nZXMgPSBmdW5jdGlvbiAoZGVsdGFzLCBkb250U2VsZWN0KSB7XG4gICAgICAgIGlmICghZGVsdGFzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gZGVsdGFzLmxlbmd0aCAtIDE7IGkgIT0gLTE7IGktLSkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldO1xuICAgICAgICAgICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcImluc2VydFwiIHx8IGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmV2ZXJ0RGVsdGEoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuZm9sZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZvbGRzKGRlbHRhLmZvbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRTZWxlY3QgJiYgdGhpcy4kdW5kb1NlbGVjdCkge1xuICAgICAgICAgICAgaWYgKGRlbHRhcy5zZWxlY3Rpb25CZWZvcmUpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZnJvbUpTT04oZGVsdGFzLnNlbGVjdGlvbkJlZm9yZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UodGhpcy4kZ2V0VW5kb1NlbGVjdGlvbihkZWx0YXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnJlZG9DaGFuZ2VzID0gZnVuY3Rpb24gKGRlbHRhcywgZG9udFNlbGVjdCkge1xuICAgICAgICBpZiAoIWRlbHRhcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGZyb21VbmRvID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIiB8fCBkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jLiRzYWZlQXBwbHlEZWx0YShkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb250U2VsZWN0ICYmIHRoaXMuJHVuZG9TZWxlY3QpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YXMuc2VsZWN0aW9uQWZ0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZnJvbUpTT04oZGVsdGFzLnNlbGVjdGlvbkFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZSh0aGlzLiRnZXRVbmRvU2VsZWN0aW9uKGRlbHRhcywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFVuZG9TZWxlY3QgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gICAgICAgIHRoaXMuJHVuZG9TZWxlY3QgPSBlbmFibGU7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGdldFVuZG9TZWxlY3Rpb24gPSBmdW5jdGlvbiAoZGVsdGFzLCBpc1VuZG8pIHtcbiAgICAgICAgZnVuY3Rpb24gaXNJbnNlcnQoZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1VuZG8gPyBkZWx0YS5hY3Rpb24gIT09IFwiaW5zZXJ0XCIgOiBkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlLCBwb2ludDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgICAgICAgIGlmICghZGVsdGEuc3RhcnQpXG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgZm9sZHNcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnNlcnQoZGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5zdGFydCwgZGVsdGEuZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5zdGFydCwgZGVsdGEuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0luc2VydChkZWx0YSkpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKHBvaW50LnJvdywgcG9pbnQuY29sdW1uKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50ID0gZGVsdGEuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKHBvaW50LnJvdywgcG9pbnQuY29sdW1uKSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBkZWx0YS5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZShwb2ludC5yb3csIHBvaW50LmNvbHVtbikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnN0YXJ0LCBkZWx0YS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5yZXBsYWNlKHJhbmdlLCB0ZXh0KTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5tb3ZlVGV4dCA9IGZ1bmN0aW9uIChmcm9tUmFuZ2UsIHRvUG9zaXRpb24sIGNvcHkpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHRSYW5nZShmcm9tUmFuZ2UpO1xuICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShmcm9tUmFuZ2UpO1xuICAgICAgICB2YXIgdG9SYW5nZSA9IFJhbmdlLmZyb21Qb2ludHModG9Qb3NpdGlvbiwgdG9Qb3NpdGlvbik7XG4gICAgICAgIGlmICghY29weSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZnJvbVJhbmdlKTtcbiAgICAgICAgICAgIHZhciByb3dEaWZmID0gZnJvbVJhbmdlLnN0YXJ0LnJvdyAtIGZyb21SYW5nZS5lbmQucm93O1xuICAgICAgICAgICAgdmFyIGNvbGxEaWZmID0gcm93RGlmZiA/IC1mcm9tUmFuZ2UuZW5kLmNvbHVtbiA6IGZyb21SYW5nZS5zdGFydC5jb2x1bW4gLSBmcm9tUmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChjb2xsRGlmZikge1xuICAgICAgICAgICAgICAgIGlmICh0b1JhbmdlLnN0YXJ0LnJvdyA9PSBmcm9tUmFuZ2UuZW5kLnJvdyAmJiB0b1JhbmdlLnN0YXJ0LmNvbHVtbiA+IGZyb21SYW5nZS5lbmQuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLnN0YXJ0LmNvbHVtbiArPSBjb2xsRGlmZjtcbiAgICAgICAgICAgICAgICBpZiAodG9SYW5nZS5lbmQucm93ID09IGZyb21SYW5nZS5lbmQucm93ICYmIHRvUmFuZ2UuZW5kLmNvbHVtbiA+IGZyb21SYW5nZS5lbmQuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLmVuZC5jb2x1bW4gKz0gY29sbERpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93RGlmZiAmJiB0b1JhbmdlLnN0YXJ0LnJvdyA+PSBmcm9tUmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgICAgIHRvUmFuZ2Uuc3RhcnQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICAgICAgdG9SYW5nZS5lbmQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9SYW5nZS5lbmQgPSB0aGlzLmluc2VydCh0b1JhbmdlLnN0YXJ0LCB0ZXh0KTtcbiAgICAgICAgaWYgKGZvbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG9sZFN0YXJ0ID0gZnJvbVJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gdG9SYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHZhciByb3dEaWZmID0gbmV3U3RhcnQucm93IC0gb2xkU3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGNvbGxEaWZmID0gbmV3U3RhcnQuY29sdW1uIC0gb2xkU3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkcyhmb2xkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB4ID0geC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmICh4LnN0YXJ0LnJvdyA9PSBvbGRTdGFydC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIHguc3RhcnQuY29sdW1uICs9IGNvbGxEaWZmO1xuICAgICAgICAgICAgICAgIGlmICh4LmVuZC5yb3cgPT0gb2xkU3RhcnQucm93KVxuICAgICAgICAgICAgICAgICAgICB4LmVuZC5jb2x1bW4gKz0gY29sbERpZmY7XG4gICAgICAgICAgICAgICAgeC5zdGFydC5yb3cgKz0gcm93RGlmZjtcbiAgICAgICAgICAgICAgICB4LmVuZC5yb3cgKz0gcm93RGlmZjtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SYW5nZTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5pbmRlbnRSb3dzID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBlbmRSb3csIGluZGVudFN0cmluZykge1xuICAgICAgICBpbmRlbnRTdHJpbmcgPSBpbmRlbnRTdHJpbmcucmVwbGFjZSgvXFx0L2csIHRoaXMuZ2V0VGFiU3RyaW5nKCkpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDw9IGVuZFJvdzsgcm93KyspXG4gICAgICAgICAgICB0aGlzLmRvYy5pbnNlcnRJbkxpbmUoeyByb3c6IHJvdywgY29sdW1uOiAwIH0sIGluZGVudFN0cmluZyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUub3V0ZGVudFJvd3MgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHJvd1JhbmdlID0gcmFuZ2UuY29sbGFwc2VSb3dzKCk7XG4gICAgICAgIHZhciBkZWxldGVSYW5nZSA9IG5ldyBSYW5nZSgwLCAwLCAwLCAwKTtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRhYlNpemUoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJvd1JhbmdlLnN0YXJ0LnJvdzsgaSA8PSByb3dSYW5nZS5lbmQucm93OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQucm93ID0gaTtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5yb3cgPSBpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplOyArK2opXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KGopICE9ICcgJylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoaiA8IHNpemUgJiYgbGluZS5jaGFyQXQoaikgPT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5jb2x1bW4gPSBqO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5jb2x1bW4gPSBqICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnN0YXJ0LmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLmNvbHVtbiA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShkZWxldGVSYW5nZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kbW92ZUxpbmVzID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93LCBkaXIpIHtcbiAgICAgICAgZmlyc3RSb3cgPSB0aGlzLmdldFJvd0ZvbGRTdGFydChmaXJzdFJvdyk7XG4gICAgICAgIGxhc3RSb3cgPSB0aGlzLmdldFJvd0ZvbGRFbmQobGFzdFJvdyk7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3dGb2xkU3RhcnQoZmlyc3RSb3cgKyBkaXIpO1xuICAgICAgICAgICAgaWYgKHJvdyA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHJvdyAtIGZpcnN0Um93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvd0ZvbGRFbmQobGFzdFJvdyArIGRpcik7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSByb3cgLSBsYXN0Um93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RSb3cgPSB0aGlzLiRjbGlwUm93VG9Eb2N1bWVudChmaXJzdFJvdyk7XG4gICAgICAgICAgICBsYXN0Um93ID0gdGhpcy4kY2xpcFJvd1RvRG9jdW1lbnQobGFzdFJvdyk7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGxhc3RSb3cgLSBmaXJzdFJvdyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGZpcnN0Um93LCAwLCBsYXN0Um93LCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UocmFuZ2UpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICAgICAgICAgIHguc3RhcnQucm93ICs9IGRpZmY7XG4gICAgICAgICAgICB4LmVuZC5yb3cgKz0gZGlmZjtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpbmVzID0gZGlyID09IDBcbiAgICAgICAgICAgID8gdGhpcy5kb2MuZ2V0TGluZXMoZmlyc3RSb3csIGxhc3RSb3cpXG4gICAgICAgICAgICA6IHRoaXMuZG9jLnJlbW92ZUZ1bGxMaW5lcyhmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgICAgIHRoaXMuZG9jLmluc2VydEZ1bGxMaW5lcyhmaXJzdFJvdyArIGRpZmYsIGxpbmVzKTtcbiAgICAgICAgZm9sZHMubGVuZ3RoICYmIHRoaXMuYWRkRm9sZHMoZm9sZHMpO1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5tb3ZlTGluZXNVcCA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW92ZUxpbmVzKGZpcnN0Um93LCBsYXN0Um93LCAtMSk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUubW92ZUxpbmVzRG93biA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW92ZUxpbmVzKGZpcnN0Um93LCBsYXN0Um93LCAxKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5kdXBsaWNhdGVMaW5lcyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW92ZUxpbmVzKGZpcnN0Um93LCBsYXN0Um93LCAwKTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kY2xpcFJvd1RvRG9jdW1lbnQgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3csIHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMSkpO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRjbGlwQ29sdW1uVG9Sb3cgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA8IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZG9jLmdldExpbmUocm93KS5sZW5ndGgsIGNvbHVtbik7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgY29sdW1uID0gTWF0aC5tYXgoMCwgY29sdW1uKTtcbiAgICAgICAgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgICAgICBjb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZG9jLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKHJvdyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByb3cgPSBsZW4gLSAxO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuZG9jLmdldExpbmUobGVuIC0gMSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC5taW4odGhpcy5kb2MuZ2V0TGluZShyb3cpLmxlbmd0aCwgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRjbGlwUmFuZ2VUb0RvY3VtZW50ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPCAwKSB7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSAwO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZC5yb3cgPiBsZW4pIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBsZW47XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShsZW4pLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSB0aGlzLiRjbGlwQ29sdW1uVG9Sb3cocmFuZ2UuZW5kLnJvdywgcmFuZ2UuZW5kLmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFVzZVdyYXBNb2RlID0gZnVuY3Rpb24gKHVzZVdyYXBNb2RlKSB7XG4gICAgICAgIGlmICh1c2VXcmFwTW9kZSAhPSB0aGlzLiR1c2VXcmFwTW9kZSkge1xuICAgICAgICAgICAgdGhpcy4kdXNlV3JhcE1vZGUgPSB1c2VXcmFwTW9kZTtcbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XG4gICAgICAgICAgICBpZiAodXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiR3cmFwRGF0YSA9IEFycmF5KGxlbik7XG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoMCwgbGVuIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VXcmFwTW9kZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFVzZVdyYXBNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXNlV3JhcE1vZGU7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2V0V3JhcExpbWl0UmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1pbiAhPT0gbWluIHx8IHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1heCAhPT0gbWF4KSB7XG4gICAgICAgICAgICB0aGlzLiR3cmFwTGltaXRSYW5nZSA9IHsgbWluOiBtaW4sIG1heDogbWF4IH07XG4gICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRiaWRpSGFuZGxlci5tYXJrQXNEaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVdyYXBNb2RlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24gKGRlc2lyZWRMaW1pdCwgJHByaW50TWFyZ2luKSB7XG4gICAgICAgIHZhciBsaW1pdHMgPSB0aGlzLiR3cmFwTGltaXRSYW5nZTtcbiAgICAgICAgaWYgKGxpbWl0cy5tYXggPCAwKVxuICAgICAgICAgICAgbGltaXRzID0geyBtaW46ICRwcmludE1hcmdpbiwgbWF4OiAkcHJpbnRNYXJnaW4gfTtcbiAgICAgICAgdmFyIHdyYXBMaW1pdCA9IHRoaXMuJGNvbnN0cmFpbldyYXBMaW1pdChkZXNpcmVkTGltaXQsIGxpbWl0cy5taW4sIGxpbWl0cy5tYXgpO1xuICAgICAgICBpZiAod3JhcExpbWl0ICE9IHRoaXMuJHdyYXBMaW1pdCAmJiB3cmFwTGltaXQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLiR3cmFwTGltaXQgPSB3cmFwTGltaXQ7XG4gICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VXcmFwTGltaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNvbnN0cmFpbldyYXBMaW1pdCA9IGZ1bmN0aW9uICh3cmFwTGltaXQsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChtaW4pXG4gICAgICAgICAgICB3cmFwTGltaXQgPSBNYXRoLm1heChtaW4sIHdyYXBMaW1pdCk7XG4gICAgICAgIGlmIChtYXgpXG4gICAgICAgICAgICB3cmFwTGltaXQgPSBNYXRoLm1pbihtYXgsIHdyYXBMaW1pdCk7XG4gICAgICAgIHJldHVybiB3cmFwTGltaXQ7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0V3JhcExpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kd3JhcExpbWl0O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNldFdyYXBMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuICAgICAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlKGxpbWl0LCBsaW1pdCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0V3JhcExpbWl0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1pbixcbiAgICAgICAgICAgIG1heDogdGhpcy4kd3JhcExpbWl0UmFuZ2UubWF4XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHVwZGF0ZUludGVybmFsRGF0YU9uQ2hhbmdlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHZhciB1c2VXcmFwTW9kZSA9IHRoaXMuJHVzZVdyYXBNb2RlO1xuICAgICAgICB2YXIgYWN0aW9uID0gZGVsdGEuYWN0aW9uO1xuICAgICAgICB2YXIgc3RhcnQgPSBkZWx0YS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGRlbHRhLmVuZDtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gc3RhcnQucm93O1xuICAgICAgICB2YXIgbGFzdFJvdyA9IGVuZC5yb3c7XG4gICAgICAgIHZhciBsZW4gPSBsYXN0Um93IC0gZmlyc3RSb3c7XG4gICAgICAgIHZhciByZW1vdmVkRm9sZHMgPSBudWxsO1xuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XG4gICAgICAgIGlmIChsZW4gIT0gMCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgICAgIHRoaXNbdXNlV3JhcE1vZGUgPyBcIiR3cmFwRGF0YVwiIDogXCIkcm93TGVuZ3RoQ2FjaGVcIl0uc3BsaWNlKGZpcnN0Um93LCBsZW4pO1xuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgICAgICAgICByZW1vdmVkRm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkcyhyZW1vdmVkRm9sZHMpO1xuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZW5kLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGVuZC5yb3csIGVuZC5jb2x1bW4sIHN0YXJ0LmNvbHVtbiAtIGVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdygtbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lQmVmb3JlID0gdGhpcy5nZXRGb2xkTGluZShmaXJzdFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZUJlZm9yZSAmJiBmb2xkTGluZUJlZm9yZSAhPT0gZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lQmVmb3JlLm1lcmdlKGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gZm9sZExpbmVCZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gZm9sZExpbmVzLmluZGV4T2YoZm9sZExpbmUpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpZHg7IGlkeCA8IGZvbGRMaW5lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGRMaW5lc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93ID49IGVuZC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KC1sZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RSb3cgPSBmaXJzdFJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuKTtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDApO1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSB1c2VXcmFwTW9kZSA/IHRoaXMuJHdyYXBEYXRhIDogdGhpcy4kcm93TGVuZ3RoQ2FjaGU7XG4gICAgICAgICAgICAgICAgYXJyLnNwbGljZS5hcHBseShhcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNtcCA9IGZvbGRMaW5lLnJhbmdlLmNvbXBhcmVJbnNpZGUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21wID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gZm9sZExpbmUuc3BsaXQoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuc2hpZnRSb3cobGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhsYXN0Um93LCAwLCBlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhmaXJzdFJvdywgMCwgZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGZvbGRMaW5lcy5pbmRleE9mKGZvbGRMaW5lKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaWR4OyBpZHggPCBmb2xkTGluZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkTGluZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lLnN0YXJ0LnJvdyA+PSBmaXJzdFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuc2hpZnRSb3cobGVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IE1hdGguYWJzKGRlbHRhLnN0YXJ0LmNvbHVtbiAtIGRlbHRhLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRGb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKHJlbW92ZWRGb2xkcyk7XG4gICAgICAgICAgICAgICAgbGVuID0gLWxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xuICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkUmVtb3ZlQ2hhcnMoZmlyc3RSb3csIHN0YXJ0LmNvbHVtbiwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlV3JhcE1vZGUgJiYgdGhpcy4kd3JhcERhdGEubGVuZ3RoICE9IHRoaXMuZG9jLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZG9jLmdldExlbmd0aCgpIGFuZCAkd3JhcERhdGEubGVuZ3RoIGhhdmUgdG8gYmUgdGhlIHNhbWUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVdyYXBEYXRhKGZpcnN0Um93LCBsYXN0Um93KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlUm93TGVuZ3RoQ2FjaGUoZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZEZvbGRzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiR1cGRhdGVSb3dMZW5ndGhDYWNoZSA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB0aGlzLiRyb3dMZW5ndGhDYWNoZVtmaXJzdFJvd10gPSBudWxsO1xuICAgICAgICB0aGlzLiRyb3dMZW5ndGhDYWNoZVtsYXN0Um93XSA9IG51bGw7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHVwZGF0ZVdyYXBEYXRhID0gZnVuY3Rpb24gKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZG9jLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5nZXRUYWJTaXplKCk7XG4gICAgICAgIHZhciB3cmFwRGF0YSA9IHRoaXMuJHdyYXBEYXRhO1xuICAgICAgICB2YXIgd3JhcExpbWl0ID0gdGhpcy4kd3JhcExpbWl0O1xuICAgICAgICB2YXIgdG9rZW5zO1xuICAgICAgICB2YXIgZm9sZExpbmU7XG4gICAgICAgIHZhciByb3cgPSBmaXJzdFJvdztcbiAgICAgICAgbGFzdFJvdyA9IE1hdGgubWluKGxhc3RSb3csIGxpbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB3aGlsZSAocm93IDw9IGxhc3RSb3cpIHtcbiAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgIGlmICghZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKGxpbmVzW3Jvd10pO1xuICAgICAgICAgICAgICAgIHdyYXBEYXRhW3Jvd10gPSB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyh0b2tlbnMsIHdyYXBMaW1pdCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb2xkTGluZS53YWxrKGZ1bmN0aW9uIChwbGFjZWhvbGRlciwgcm93LCBjb2x1bW4sIGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrVG9rZW5zID0gdGhpcy4kZ2V0RGlzcGxheVRva2VucyhwbGFjZWhvbGRlciwgdG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrVG9rZW5zWzBdID0gUExBQ0VIT0xERVJfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHdhbGtUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrVG9rZW5zW2ldID0gUExBQ0VIT0xERVJfQk9EWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKGxpbmVzW3Jvd10uc3Vic3RyaW5nKGxhc3RDb2x1bW4sIGNvbHVtbiksIHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQod2Fsa1Rva2Vucyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBmb2xkTGluZS5lbmQucm93LCBsaW5lc1tmb2xkTGluZS5lbmQucm93XS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB3cmFwRGF0YVtmb2xkTGluZS5zdGFydC5yb3ddID0gdGhpcy4kY29tcHV0ZVdyYXBTcGxpdHModG9rZW5zLCB3cmFwTGltaXQsIHRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuJGNvbXB1dGVXcmFwU3BsaXRzID0gZnVuY3Rpb24gKHRva2Vucywgd3JhcExpbWl0LCB0YWJTaXplKSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BsaXRzID0gW107XG4gICAgICAgIHZhciBkaXNwbGF5TGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RTcGxpdCA9IDAsIGxhc3REb2NTcGxpdCA9IDA7XG4gICAgICAgIHZhciBpc0NvZGUgPSB0aGlzLiR3cmFwQXNDb2RlO1xuICAgICAgICB2YXIgaW5kZW50ZWRTb2Z0V3JhcCA9IHRoaXMuJGluZGVudGVkU29mdFdyYXA7XG4gICAgICAgIHZhciBtYXhJbmRlbnQgPSB3cmFwTGltaXQgPD0gTWF0aC5tYXgoMiAqIHRhYlNpemUsIDgpXG4gICAgICAgICAgICB8fCBpbmRlbnRlZFNvZnRXcmFwID09PSBmYWxzZSA/IDAgOiBNYXRoLmZsb29yKHdyYXBMaW1pdCAvIDIpO1xuICAgICAgICBmdW5jdGlvbiBnZXRXcmFwSW5kZW50KCkge1xuICAgICAgICAgICAgdmFyIGluZGVudGF0aW9uID0gMDtcbiAgICAgICAgICAgIGlmIChtYXhJbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaWYgKGluZGVudGVkU29mdFdyYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBTUEFDRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09IFRBQilcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHRhYlNpemU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09IFRBQl9TUEFDRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb2RlICYmIGluZGVudGVkU29mdFdyYXAgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHRhYlNpemU7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oaW5kZW50YXRpb24sIG1heEluZGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkU3BsaXQoc2NyZWVuUG9zKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gc2NyZWVuUG9zIC0gbGFzdFNwbGl0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxhc3RTcGxpdDsgaSA8IHNjcmVlblBvczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTIgfHwgY2ggPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gZ2V0V3JhcEluZGVudCgpO1xuICAgICAgICAgICAgICAgIHNwbGl0cy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RG9jU3BsaXQgKz0gbGVuO1xuICAgICAgICAgICAgc3BsaXRzLnB1c2gobGFzdERvY1NwbGl0KTtcbiAgICAgICAgICAgIGxhc3RTcGxpdCA9IHNjcmVlblBvcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZW50ID0gMDtcbiAgICAgICAgd2hpbGUgKGRpc3BsYXlMZW5ndGggLSBsYXN0U3BsaXQgPiB3cmFwTGltaXQgLSBpbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGxhc3RTcGxpdCArIHdyYXBMaW1pdCAtIGluZGVudDtcbiAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXQgLSAxXSA+PSBTUEFDRSAmJiB0b2tlbnNbc3BsaXRdID49IFNQQUNFKSB7XG4gICAgICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2Vuc1tzcGxpdF0gPT0gUExBQ0VIT0xERVJfU1RBUlQgfHwgdG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9CT0RZKSB7XG4gICAgICAgICAgICAgICAgZm9yIChzcGxpdDsgc3BsaXQgIT0gbGFzdFNwbGl0IC0gMTsgc3BsaXQtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0ID4gbGFzdFNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0O1xuICAgICAgICAgICAgICAgIGZvciAoc3BsaXQ7IHNwbGl0IDwgdG9rZW5zLmxlbmd0aDsgc3BsaXQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSAhPSBQTEFDRUhPTERFUl9CT0RZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQgPT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gQnJlYWtzIHRoZSB3aGlsZS1sb29wLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRTcGxpdChzcGxpdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluU3BsaXQgPSBNYXRoLm1heChzcGxpdCAtICh3cmFwTGltaXQgLSAod3JhcExpbWl0ID4+IDIpKSwgbGFzdFNwbGl0IC0gMSk7XG4gICAgICAgICAgICB3aGlsZSAoc3BsaXQgPiBtaW5TcGxpdCAmJiB0b2tlbnNbc3BsaXRdIDwgUExBQ0VIT0xERVJfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBzcGxpdC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ29kZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BsaXQgPiBtaW5TcGxpdCAmJiB0b2tlbnNbc3BsaXRdID09IFBVTkNUVUFUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0ID4gbWluU3BsaXQgJiYgdG9rZW5zW3NwbGl0XSA8IFNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0ID4gbWluU3BsaXQpIHtcbiAgICAgICAgICAgICAgICBhZGRTcGxpdCgrK3NwbGl0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0O1xuICAgICAgICAgICAgaWYgKHRva2Vuc1tzcGxpdF0gPT0gQ0hBUl9FWFQpXG4gICAgICAgICAgICAgICAgc3BsaXQtLTtcbiAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0IC0gaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRnZXREaXNwbGF5VG9rZW5zID0gZnVuY3Rpb24gKHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIHRhYlNpemU7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09IDkpIHtcbiAgICAgICAgICAgICAgICB0YWJTaXplID0gdGhpcy5nZXRTY3JlZW5UYWJTaXplKGFyci5sZW5ndGggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFRBQik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDE7IG4gPCB0YWJTaXplOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goVEFCX1NQQUNFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09IDMyKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goU1BBQ0UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGMgPiAzOSAmJiBjIDwgNDgpIHx8IChjID4gNTcgJiYgYyA8IDY0KSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFBVTkNUVUFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPj0gMHgxMTAwICYmIGlzRnVsbFdpZHRoKGMpKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goQ0hBUiwgQ0hBUl9FWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goQ0hBUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS4kZ2V0U3RyaW5nU2NyZWVuV2lkdGggPSBmdW5jdGlvbiAoc3RyLCBtYXhTY3JlZW5Db2x1bW4sIHNjcmVlbkNvbHVtbikge1xuICAgICAgICBpZiAobWF4U2NyZWVuQ29sdW1uID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICBpZiAobWF4U2NyZWVuQ29sdW1uID09IG51bGwpXG4gICAgICAgICAgICBtYXhTY3JlZW5Db2x1bW4gPSBJbmZpbml0eTtcbiAgICAgICAgc2NyZWVuQ29sdW1uID0gc2NyZWVuQ29sdW1uIHx8IDA7XG4gICAgICAgIHZhciBjLCBjb2x1bW47XG4gICAgICAgIGZvciAoY29sdW1uID0gMDsgY29sdW1uIDwgc3RyLmxlbmd0aDsgY29sdW1uKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGMgPT0gOSkge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSB0aGlzLmdldFNjcmVlblRhYlNpemUoc2NyZWVuQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPj0gMHgxMTAwICYmIGlzRnVsbFdpZHRoKGMpKSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY3JlZW5Db2x1bW4gPiBtYXhTY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3NjcmVlbkNvbHVtbiwgY29sdW1uXTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRSb3dMZW5ndGggPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBoID0gMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHMpXG4gICAgICAgICAgICBoICs9IHRoaXMubGluZVdpZGdldHNbcm93XSAmJiB0aGlzLmxpbmVXaWRnZXRzW3Jvd10ucm93Q291bnQgfHwgMDtcbiAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSB8fCAhdGhpcy4kd3JhcERhdGFbcm93XSlcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XS5sZW5ndGggKyBoO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFJvd0xpbmVDb3VudCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSB8fCAhdGhpcy4kd3JhcERhdGFbcm93XSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0Um93V3JhcEluZGVudCA9IGZ1bmN0aW9uIChzY3JlZW5Sb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLiR3cmFwRGF0YVtwb3Mucm93XTtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdHMubGVuZ3RoICYmIHNwbGl0c1swXSA8IHBvcy5jb2x1bW4gPyBzcGxpdHMuaW5kZW50IDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbiA9IGZ1bmN0aW9uIChzY3JlZW5Sb3cpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VG9TY3JlZW5Db2x1bW4ocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0RG9jdW1lbnRMYXN0Um93Q29sdW1uID0gZnVuY3Rpb24gKGRvY1JvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLmRvY3VtZW50VG9TY3JlZW5Sb3coZG9jUm93LCBkb2NDb2x1bW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JlZW5MYXN0Um93Q29sdW1uKHNjcmVlblJvdyk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0RG9jdW1lbnRMYXN0Um93Q29sdW1uUG9zaXRpb24gPSBmdW5jdGlvbiAoZG9jUm93LCBkb2NDb2x1bW4pIHtcbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IHRoaXMuZG9jdW1lbnRUb1NjcmVlblJvdyhkb2NSb3csIGRvY0NvbHVtbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIE51bWJlci5NQVhfVkFMVUUgLyAxMCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0Um93U3BsaXREYXRhID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHdyYXBEYXRhW3Jvd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRTY3JlZW5UYWJTaXplID0gZnVuY3Rpb24gKHNjcmVlbkNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFiU2l6ZSAtIChzY3JlZW5Db2x1bW4gJSB0aGlzLiR0YWJTaXplIHwgMCk7XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuc2NyZWVuVG9Eb2N1bWVudFJvdyA9IGZ1bmN0aW9uIChzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCBzY3JlZW5Db2x1bW4pLnJvdztcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5zY3JlZW5Ub0RvY3VtZW50Q29sdW1uID0gZnVuY3Rpb24gKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbikuY29sdW1uO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbiwgb2Zmc2V0WCkge1xuICAgICAgICBpZiAoc2NyZWVuUm93IDwgMClcbiAgICAgICAgICAgIHJldHVybiB7IHJvdzogMCwgY29sdW1uOiAwIH07XG4gICAgICAgIHZhciBsaW5lO1xuICAgICAgICB2YXIgZG9jUm93ID0gMDtcbiAgICAgICAgdmFyIGRvY0NvbHVtbiA9IDA7XG4gICAgICAgIHZhciBjb2x1bW47XG4gICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICB2YXIgcm93TGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHJvd0NhY2hlID0gdGhpcy4kc2NyZWVuUm93Q2FjaGU7XG4gICAgICAgIHZhciBpID0gdGhpcy4kZ2V0Um93Q2FjaGVJbmRleChyb3dDYWNoZSwgc2NyZWVuUm93KTtcbiAgICAgICAgdmFyIGwgPSByb3dDYWNoZS5sZW5ndGg7XG4gICAgICAgIGlmIChsICYmIGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHJvd0NhY2hlW2ldO1xuICAgICAgICAgICAgdmFyIGRvY1JvdyA9IHRoaXMuJGRvY1Jvd0NhY2hlW2ldO1xuICAgICAgICAgICAgdmFyIGRvQ2FjaGUgPSBzY3JlZW5Sb3cgPiByb3dDYWNoZVtsIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZG9DYWNoZSA9ICFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhSb3cgPSB0aGlzLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUoZG9jUm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgIHdoaWxlIChyb3cgPD0gc2NyZWVuUm93KSB7XG4gICAgICAgICAgICByb3dMZW5ndGggPSB0aGlzLmdldFJvd0xlbmd0aChkb2NSb3cpO1xuICAgICAgICAgICAgaWYgKHJvdyArIHJvd0xlbmd0aCA+IHNjcmVlblJvdyB8fCBkb2NSb3cgPj0gbWF4Um93KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cgKz0gcm93TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRvY1JvdysrO1xuICAgICAgICAgICAgICAgIGlmIChkb2NSb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jUm93ID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUoZG9jUm93LCBmb2xkTGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkb2NSb3dDYWNoZS5wdXNoKGRvY1Jvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUucHVzaChyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb2xkTGluZSAmJiBmb2xkTGluZS5zdGFydC5yb3cgPD0gZG9jUm93KSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUpO1xuICAgICAgICAgICAgZG9jUm93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdyArIHJvd0xlbmd0aCA8PSBzY3JlZW5Sb3cgfHwgZG9jUm93ID4gbWF4Um93KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvdzogbWF4Um93LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5nZXRMaW5lKG1heFJvdykubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuZ2V0TGluZShkb2NSb3cpO1xuICAgICAgICAgICAgZm9sZExpbmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSW5kZW50ID0gMCwgc3BsaXRJbmRleCA9IE1hdGguZmxvb3Ioc2NyZWVuUm93IC0gcm93KTtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy4kd3JhcERhdGFbZG9jUm93XTtcbiAgICAgICAgICAgIGlmIChzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzcGxpdHNbc3BsaXRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0SW5kZXggPiAwICYmIHNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcEluZGVudCA9IHNwbGl0cy5pbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NvbHVtbiA9IHNwbGl0c1tzcGxpdEluZGV4IC0gMV0gfHwgc3BsaXRzW3NwbGl0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKGRvY0NvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRYICE9PSB1bmRlZmluZWQgJiYgdGhpcy4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHJvdyArIHNwbGl0SW5kZXgsIGRvY1Jvdywgc3BsaXRJbmRleCkpXG4gICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRiaWRpSGFuZGxlci5vZmZzZXRUb0NvbChvZmZzZXRYKTtcbiAgICAgICAgZG9jQ29sdW1uICs9IHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoKGxpbmUsIHNjcmVlbkNvbHVtbiAtIHdyYXBJbmRlbnQpWzFdO1xuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUgJiYgZG9jQ29sdW1uID49IGNvbHVtbilcbiAgICAgICAgICAgIGRvY0NvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgIHJldHVybiBmb2xkTGluZS5pZHhUb1Bvc2l0aW9uKGRvY0NvbHVtbik7XG4gICAgICAgIHJldHVybiB7IHJvdzogZG9jUm93LCBjb2x1bW46IGRvY0NvbHVtbiB9O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbiA9IGZ1bmN0aW9uIChkb2NSb3csIGRvY0NvbHVtbikge1xuICAgICAgICBpZiAodHlwZW9mIGRvY0NvbHVtbiA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KC8qKkB0eXBle1BvaW50fSovIChkb2NSb3cpLnJvdywgLyoqQHR5cGV7UG9pbnR9Ki8gKGRvY1JvdykuY29sdW1uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcG9zID0gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCgvKipAdHlwZXtudW1iZXJ9Ki8gKGRvY1JvdyksIGRvY0NvbHVtbik7XG4gICAgICAgIGRvY1JvdyA9IHBvcy5yb3c7XG4gICAgICAgIGRvY0NvbHVtbiA9IHBvcy5jb2x1bW47XG4gICAgICAgIHZhciBzY3JlZW5Sb3cgPSAwO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0Um93ID0gbnVsbDtcbiAgICAgICAgdmFyIGZvbGQgPSBudWxsO1xuICAgICAgICBmb2xkID0gdGhpcy5nZXRGb2xkQXQoZG9jUm93LCBkb2NDb2x1bW4sIDEpO1xuICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgZG9jUm93ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgICAgICBkb2NDb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm93RW5kLCByb3cgPSAwO1xuICAgICAgICB2YXIgcm93Q2FjaGUgPSB0aGlzLiRkb2NSb3dDYWNoZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRnZXRSb3dDYWNoZUluZGV4KHJvd0NhY2hlLCBkb2NSb3cpO1xuICAgICAgICB2YXIgbCA9IHJvd0NhY2hlLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgJiYgaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gcm93Q2FjaGVbaV07XG4gICAgICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy4kc2NyZWVuUm93Q2FjaGVbaV07XG4gICAgICAgICAgICB2YXIgZG9DYWNoZSA9IGRvY1JvdyA+IHJvd0NhY2hlW2wgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkb0NhY2hlID0gIWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUocm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgIHdoaWxlIChyb3cgPCBkb2NSb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPj0gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93RW5kID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0VuZCA+IGRvY1JvdylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShyb3dFbmQsIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93RW5kID0gcm93ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmVlblJvdyArPSB0aGlzLmdldFJvd0xlbmd0aChyb3cpO1xuICAgICAgICAgICAgcm93ID0gcm93RW5kO1xuICAgICAgICAgICAgaWYgKGRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkb2NSb3dDYWNoZS5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUucHVzaChzY3JlZW5Sb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFwiXCI7XG4gICAgICAgIGlmIChmb2xkTGluZSAmJiByb3cgPj0gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICB0ZXh0TGluZSA9IHRoaXMuZ2V0Rm9sZERpc3BsYXlMaW5lKGZvbGRMaW5lLCBkb2NSb3csIGRvY0NvbHVtbik7XG4gICAgICAgICAgICBmb2xkU3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0TGluZSA9IHRoaXMuZ2V0TGluZShkb2NSb3cpLnN1YnN0cmluZygwLCBkb2NDb2x1bW4pO1xuICAgICAgICAgICAgZm9sZFN0YXJ0Um93ID0gZG9jUm93O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSW5kZW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB2YXIgd3JhcFJvdyA9IHRoaXMuJHdyYXBEYXRhW2ZvbGRTdGFydFJvd107XG4gICAgICAgICAgICBpZiAod3JhcFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5Sb3dPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ZXh0TGluZS5sZW5ndGggPj0gd3JhcFJvd1tzY3JlZW5Sb3dPZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblJvdysrO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Sb3dPZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHJpbmcod3JhcFJvd1tzY3JlZW5Sb3dPZmZzZXQgLSAxXSB8fCAwLCB0ZXh0TGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHdyYXBJbmRlbnQgPSBzY3JlZW5Sb3dPZmZzZXQgPiAwID8gd3JhcFJvdy5pbmRlbnQgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzICYmIHRoaXMubGluZVdpZGdldHNbcm93XSAmJiB0aGlzLmxpbmVXaWRnZXRzW3Jvd10ucm93c0Fib3ZlKVxuICAgICAgICAgICAgc2NyZWVuUm93ICs9IHRoaXMubGluZVdpZGdldHNbcm93XS5yb3dzQWJvdmU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3c6IHNjcmVlblJvdyxcbiAgICAgICAgICAgIGNvbHVtbjogd3JhcEluZGVudCArIHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoKHRleHRMaW5lKVswXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmRvY3VtZW50VG9TY3JlZW5Db2x1bW4gPSBmdW5jdGlvbiAocm93LCBkb2NDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHJvdywgZG9jQ29sdW1uKS5jb2x1bW47XG4gICAgfTtcbiAgICBFZGl0U2Vzc2lvbi5wcm90b3R5cGUuZG9jdW1lbnRUb1NjcmVlblJvdyA9IGZ1bmN0aW9uIChkb2NSb3csIGRvY0NvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oZG9jUm93LCBkb2NDb2x1bW4pLnJvdztcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5nZXRTY3JlZW5MZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JlZW5Sb3dzID0gMDtcbiAgICAgICAgdmFyIGZvbGQgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICBzY3JlZW5Sb3dzID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvbGQgPSBmb2xkRGF0YVtpXTtcbiAgICAgICAgICAgICAgICBzY3JlZW5Sb3dzIC09IGZvbGQuZW5kLnJvdyAtIGZvbGQuc3RhcnQucm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhc3RSb3cgPSB0aGlzLiR3cmFwRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcm93ID0gMCwgaSA9IDA7XG4gICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuJGZvbGREYXRhW2krK107XG4gICAgICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB3aGlsZSAocm93IDwgbGFzdFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLiR3cmFwRGF0YVtyb3ddO1xuICAgICAgICAgICAgICAgIHNjcmVlblJvd3MgKz0gc3BsaXRzID8gc3BsaXRzLmxlbmd0aCArIDEgOiAxO1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gZm9sZC5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZCA9IHRoaXMuJGZvbGREYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGQgPyBmb2xkLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHNjcmVlblJvd3MgKz0gdGhpcy4kZ2V0V2lkZ2V0U2NyZWVuTGVuZ3RoKCk7XG4gICAgICAgIHJldHVybiBzY3JlZW5Sb3dzO1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzZXRGb250TWV0cmljcyA9IGZ1bmN0aW9uIChmbSkge1xuICAgICAgICBpZiAoIXRoaXMuJGVuYWJsZVZhckNoYXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoID0gZnVuY3Rpb24gKHN0ciwgbWF4U2NyZWVuQ29sdW1uLCBzY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChtYXhTY3JlZW5Db2x1bW4gPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgICAgIGlmICghbWF4U2NyZWVuQ29sdW1uKVxuICAgICAgICAgICAgICAgIG1heFNjcmVlbkNvbHVtbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgc2NyZWVuQ29sdW1uID0gc2NyZWVuQ29sdW1uIHx8IDA7XG4gICAgICAgICAgICB2YXIgYywgY29sdW1uO1xuICAgICAgICAgICAgZm9yIChjb2x1bW4gPSAwOyBjb2x1bW4gPCBzdHIubGVuZ3RoOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIGMgPSBzdHIuY2hhckF0KGNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IHRoaXMuZ2V0U2NyZWVuVGFiU2l6ZShzY3JlZW5Db2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IGZtLmdldENoYXJhY3RlcldpZHRoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NyZWVuQ29sdW1uID4gbWF4U2NyZWVuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbc2NyZWVuQ29sdW1uLCBjb2x1bW5dO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFByZWNlZGluZ0NoYXJhY3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAocG9zLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcy5yb3cgPT09IDAgPyBcIlwiIDogdGhpcy5kb2MuZ2V0TmV3TGluZUNoYXJhY3RlcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuZ2V0TGluZShwb3Mucm93KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMaW5lW3Bvcy5jb2x1bW4gLSAxXTtcbiAgICB9O1xuICAgIEVkaXRTZXNzaW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnNldERvY3VtZW50KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRPcGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy4kc3RvcFdvcmtlcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5kb2MpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jLm9mZihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5vZmYoXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5kZXRhY2goKTtcbiAgICB9O1xuICAgIHJldHVybiBFZGl0U2Vzc2lvbjtcbn0oKSk7XG5FZGl0U2Vzc2lvbi4kdWlkID0gMDtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kbW9kZXMgPSBjb25maWcuJG1vZGVzO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLmdldFZhbHVlID0gRWRpdFNlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRkZWZhdWx0VW5kb01hbmFnZXIgPSB7XG4gICAgdW5kbzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBoYXNVbmRvOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgaGFzUmVkbzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgYWRkOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgYWRkU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgc3RhcnROZXdHcm91cDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGFkZFNlc3Npb246IGZ1bmN0aW9uICgpIHsgfVxufTtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kb3ZlcndyaXRlID0gZmFsc2U7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJG1vZGUgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRtb2RlSWQgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzY3JvbGxUb3AgPSAwO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLiRzY3JvbGxMZWZ0ID0gMDtcbkVkaXRTZXNzaW9uLnByb3RvdHlwZS4kd3JhcExpbWl0ID0gODA7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHVzZVdyYXBNb2RlID0gZmFsc2U7XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUuJHdyYXBMaW1pdFJhbmdlID0ge1xuICAgIG1pbjogbnVsbCxcbiAgICBtYXg6IG51bGxcbn07XG5FZGl0U2Vzc2lvbi5wcm90b3R5cGUubGluZVdpZGdldHMgPSBudWxsO1xuRWRpdFNlc3Npb24ucHJvdG90eXBlLmlzRnVsbFdpZHRoID0gaXNGdWxsV2lkdGg7XG5vb3AuaW1wbGVtZW50KEVkaXRTZXNzaW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBDSEFSID0gMSwgQ0hBUl9FWFQgPSAyLCBQTEFDRUhPTERFUl9TVEFSVCA9IDMsIFBMQUNFSE9MREVSX0JPRFkgPSA0LCBQVU5DVFVBVElPTiA9IDksIFNQQUNFID0gMTAsIFRBQiA9IDExLCBUQUJfU1BBQ0UgPSAxMjtcbmZ1bmN0aW9uIGlzRnVsbFdpZHRoKGMpIHtcbiAgICBpZiAoYyA8IDB4MTEwMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjID49IDB4MTEwMCAmJiBjIDw9IDB4MTE1RiB8fFxuICAgICAgICBjID49IDB4MTFBMyAmJiBjIDw9IDB4MTFBNyB8fFxuICAgICAgICBjID49IDB4MTFGQSAmJiBjIDw9IDB4MTFGRiB8fFxuICAgICAgICBjID49IDB4MjMyOSAmJiBjIDw9IDB4MjMyQSB8fFxuICAgICAgICBjID49IDB4MkU4MCAmJiBjIDw9IDB4MkU5OSB8fFxuICAgICAgICBjID49IDB4MkU5QiAmJiBjIDw9IDB4MkVGMyB8fFxuICAgICAgICBjID49IDB4MkYwMCAmJiBjIDw9IDB4MkZENSB8fFxuICAgICAgICBjID49IDB4MkZGMCAmJiBjIDw9IDB4MkZGQiB8fFxuICAgICAgICBjID49IDB4MzAwMCAmJiBjIDw9IDB4MzAzRSB8fFxuICAgICAgICBjID49IDB4MzA0MSAmJiBjIDw9IDB4MzA5NiB8fFxuICAgICAgICBjID49IDB4MzA5OSAmJiBjIDw9IDB4MzBGRiB8fFxuICAgICAgICBjID49IDB4MzEwNSAmJiBjIDw9IDB4MzEyRCB8fFxuICAgICAgICBjID49IDB4MzEzMSAmJiBjIDw9IDB4MzE4RSB8fFxuICAgICAgICBjID49IDB4MzE5MCAmJiBjIDw9IDB4MzFCQSB8fFxuICAgICAgICBjID49IDB4MzFDMCAmJiBjIDw9IDB4MzFFMyB8fFxuICAgICAgICBjID49IDB4MzFGMCAmJiBjIDw9IDB4MzIxRSB8fFxuICAgICAgICBjID49IDB4MzIyMCAmJiBjIDw9IDB4MzI0NyB8fFxuICAgICAgICBjID49IDB4MzI1MCAmJiBjIDw9IDB4MzJGRSB8fFxuICAgICAgICBjID49IDB4MzMwMCAmJiBjIDw9IDB4NERCRiB8fFxuICAgICAgICBjID49IDB4NEUwMCAmJiBjIDw9IDB4QTQ4QyB8fFxuICAgICAgICBjID49IDB4QTQ5MCAmJiBjIDw9IDB4QTRDNiB8fFxuICAgICAgICBjID49IDB4QTk2MCAmJiBjIDw9IDB4QTk3QyB8fFxuICAgICAgICBjID49IDB4QUMwMCAmJiBjIDw9IDB4RDdBMyB8fFxuICAgICAgICBjID49IDB4RDdCMCAmJiBjIDw9IDB4RDdDNiB8fFxuICAgICAgICBjID49IDB4RDdDQiAmJiBjIDw9IDB4RDdGQiB8fFxuICAgICAgICBjID49IDB4RjkwMCAmJiBjIDw9IDB4RkFGRiB8fFxuICAgICAgICBjID49IDB4RkUxMCAmJiBjIDw9IDB4RkUxOSB8fFxuICAgICAgICBjID49IDB4RkUzMCAmJiBjIDw9IDB4RkU1MiB8fFxuICAgICAgICBjID49IDB4RkU1NCAmJiBjIDw9IDB4RkU2NiB8fFxuICAgICAgICBjID49IDB4RkU2OCAmJiBjIDw9IDB4RkU2QiB8fFxuICAgICAgICBjID49IDB4RkYwMSAmJiBjIDw9IDB4RkY2MCB8fFxuICAgICAgICBjID49IDB4RkZFMCAmJiBjIDw9IDB4RkZFNjtcbn1cbnJlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvbi9mb2xkaW5nXCIpLkZvbGRpbmcuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xucmVxdWlyZShcIi4vZWRpdF9zZXNzaW9uL2JyYWNrZXRfbWF0Y2hcIikuQnJhY2tldE1hdGNoLmNhbGwoRWRpdFNlc3Npb24ucHJvdG90eXBlKTtcbmNvbmZpZy5kZWZpbmVPcHRpb25zKEVkaXRTZXNzaW9uLnByb3RvdHlwZSwgXCJzZXNzaW9uXCIsIHtcbiAgICB3cmFwOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09IFwib2ZmXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwiZnJlZVwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwicHJpbnRNYXJnaW5cIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHdyYXAgPT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy4kd3JhcCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V3JhcExpbWl0UmFuZ2UoY29sLCBjb2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VXNlV3JhcE1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR3cmFwID09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmludE1hcmdpblwiO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRXcmFwTGltaXRSYW5nZSgpLm1pbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnJlZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwib2ZmXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIHdyYXBNZXRob2Q6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwgPT0gXCJhdXRvXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMuJG1vZGUudHlwZSAhPSBcInRleHRcIlxuICAgICAgICAgICAgICAgIDogdmFsICE9IFwidGV4dFwiO1xuICAgICAgICAgICAgaWYgKHZhbCAhPSB0aGlzLiR3cmFwQXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kd3JhcEFzQ29kZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdXNlV3JhcE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRVc2VXcmFwTW9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJhdXRvXCJcbiAgICB9LFxuICAgIGluZGVudGVkU29mdFdyYXA6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1c2VXcmFwTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgZmlyc3RMaW5lTnVtYmVyOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkgeyB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IDFcbiAgICB9LFxuICAgIHVzZVdvcmtlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh1c2VXb3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJHVzZVdvcmtlciA9IHVzZVdvcmtlcjtcbiAgICAgICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmICh1c2VXb3JrZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB1c2VTb2Z0VGFiczogeyBpbml0aWFsVmFsdWU6IHRydWUgfSxcbiAgICB0YWJTaXplOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHRhYlNpemUpIHtcbiAgICAgICAgICAgIHRhYlNpemUgPSBwYXJzZUludCh0YWJTaXplKTtcbiAgICAgICAgICAgIGlmICh0YWJTaXplID4gMCAmJiB0aGlzLiR0YWJTaXplICE9PSB0YWJTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy4kdGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlVGFiU2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiA0LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICBuYXZpZ2F0ZVdpdGhpblNvZnRUYWJzOiB7IGluaXRpYWxWYWx1ZTogZmFsc2UgfSxcbiAgICBmb2xkU3R5bGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc2V0Rm9sZFN0eWxlKHZhbCk7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIG92ZXJ3cml0ZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fc2lnbmFsKFwiY2hhbmdlT3ZlcndyaXRlXCIpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBuZXdMaW5lTW9kZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5kb2Muc2V0TmV3TGluZU1vZGUodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRvYy5nZXROZXdMaW5lTW9kZSgpOyB9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLnNldE1vZGUodmFsKTsgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRtb2RlSWQ7IH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9XG59KTtcbmV4cG9ydHMuRWRpdFNlc3Npb24gPSBFZGl0U2Vzc2lvbjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uvc2VhcmNoXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvb29wXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBTZWFyY2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoKCkge1xuICAgICAgICB0aGlzLiRvcHRpb25zID0ge307XG4gICAgfVxuICAgIFNlYXJjaC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb29wLm1peGluKHRoaXMuJG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhbmcuY29weU9iamVjdCh0aGlzLiRvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLiRtYXRjaEl0ZXJhdG9yKHNlc3Npb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWl0ZXJhdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZmlyc3RSYW5nZSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yLmZvckVhY2goZnVuY3Rpb24gKHNyLCBzYywgZXIsIGVjKSB7XG4gICAgICAgICAgICBmaXJzdFJhbmdlID0gbmV3IFJhbmdlKHNyLCBzYywgZXIsIGVjKTtcbiAgICAgICAgICAgIGlmIChzYyA9PSBlYyAmJiBvcHRpb25zLnN0YXJ0ICYmIC8qKkB0eXBle1JhbmdlfSovIChvcHRpb25zLnN0YXJ0KS5zdGFydFxuICAgICAgICAgICAgICAgICYmIG9wdGlvbnMuc2tpcEN1cnJlbnQgIT0gZmFsc2UgJiYgZmlyc3RSYW5nZS5pc0VxdWFsKC8qKkB0eXBle1JhbmdlfSovIChvcHRpb25zLnN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaXJzdFJhbmdlO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMubmVlZGxlKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcbiAgICAgICAgdmFyIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdmFyIGxpbmVzID0gcmFuZ2VcbiAgICAgICAgICAgID8gc2Vzc2lvbi5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICA6IHNlc3Npb24uZG9jLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIHJlID0gb3B0aW9ucy5yZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlzTXVsdGlMaW5lKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1heFJvdyA9IGxpbmVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgICAgIHZhciBwcmV2UmFuZ2U7XG4gICAgICAgICAgICBvdXRlcjogZm9yICh2YXIgcm93ID0gcmUub2Zmc2V0IHx8IDA7IHJvdyA8PSBtYXhSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzW3JvdyArIGpdLnNlYXJjaChyZVtqXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gbGluZXNbcm93XTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW3JvdyArIGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRMaW5lLmxlbmd0aCAtIHN0YXJ0TGluZS5tYXRjaChyZVswXSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGxpbmUubWF0Y2gocmVbbGVuIC0gMV0pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJldlJhbmdlICYmIHByZXZSYW5nZS5lbmQucm93ID09PSByb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJldlJhbmdlLmVuZC5jb2x1bW4gPiBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChwcmV2UmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBzdGFydEluZGV4LCByb3cgKyBsZW4gLSAxLCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyKVxuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3cgKyBsZW4gLSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbWF0Y2hlcywgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRpc011bHRpbGluZVNlYXJjaChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG5nID0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRoaXMuJG11bHRpTGluZUZvcndhcmQoc2Vzc2lvbiwgcmUsIGksIGxuZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kX3JvdyA9IG1hdGNoZXMuZW5kUm93IDw9IGxuZyA/IG1hdGNoZXMuZW5kUm93IC0gMSA6IGxuZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRfcm93ID4gaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZW5kX3JvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShtYXRjaGVzLnN0YXJ0Um93LCBtYXRjaGVzLnN0YXJ0Q29sLCBtYXRjaGVzLmVuZFJvdywgbWF0Y2hlcy5lbmRDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGxhbmcuZ2V0TWF0Y2hPZmZzZXRzKGxpbmVzW2ldLCByZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShpLCBtYXRjaC5vZmZzZXQsIGksIG1hdGNoLm9mZnNldCArIG1hdGNoLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGogPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaiAmJiByYW5nZXNbaV0uc3RhcnQuY29sdW1uIDwgc3RhcnRDb2x1bW4gJiYgcmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PSAwKVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIHZhciBlbmRSb3cgPSByYW5nZS5lbmQucm93IC0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBqICYmIHJhbmdlc1tqXS5lbmQuY29sdW1uID4gZW5kQ29sdW1uICYmIHJhbmdlc1tqXS5lbmQucm93ID09IGVuZFJvdylcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoaSwgaiArIDEpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uc3RhcnQucm93ICs9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uZW5kLnJvdyArPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUucGFyc2VSZXBsYWNlU3RyaW5nID0gZnVuY3Rpb24gKHJlcGxhY2VTdHJpbmcpIHtcbiAgICAgICAgdmFyIENoYXJDb2RlID0ge1xuICAgICAgICAgICAgRG9sbGFyU2lnbjogMzYsXG4gICAgICAgICAgICBBbXBlcnNhbmQ6IDM4LFxuICAgICAgICAgICAgRGlnaXQwOiA0OCxcbiAgICAgICAgICAgIERpZ2l0MTogNDksXG4gICAgICAgICAgICBEaWdpdDk6IDU3LFxuICAgICAgICAgICAgQmFja3NsYXNoOiA5MixcbiAgICAgICAgICAgIG46IDExMCxcbiAgICAgICAgICAgIHQ6IDExNlxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlcGxhY2VTdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaENvZGUgPSByZXBsYWNlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hDb2RlID09PSBDaGFyQ29kZS5CYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ICs9IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaENvZGUgPSByZXBsYWNlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0Q2hDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ2hhckNvZGUuQmFja3NsYXNoOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKz0gXCJcXFxcXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDaGFyQ29kZS5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENoYXJDb2RlLnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoQ29kZSA9PT0gQ2hhckNvZGUuRG9sbGFyU2lnbikge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKz0gXCIkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoQ29kZV8xID0gcmVwbGFjZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hDb2RlXzEgPT09IENoYXJDb2RlLkRvbGxhclNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKz0gXCIkJFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaENvZGVfMSA9PT0gQ2hhckNvZGUuRGlnaXQwIHx8IG5leHRDaENvZGVfMSA9PT0gQ2hhckNvZGUuQW1wZXJzYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ICs9IFwiJCZcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChDaGFyQ29kZS5EaWdpdDEgPD0gbmV4dENoQ29kZV8xICYmIG5leHRDaENvZGVfMSA8PSBDaGFyQ29kZS5EaWdpdDkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKz0gXCIkXCIgKyByZXBsYWNlU3RyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlbWVudCArPSByZXBsYWNlU3RyaW5nW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudCB8fCByZXBsYWNlU3RyaW5nO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKGlucHV0LCByZXBsYWNlbWVudCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgICAgIHZhciByZSA9IHRoaXMuJGFzc2VtYmxlUmVnRXhwKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIGlmICghcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtdFNlYXJjaCA9IHRoaXMuJGlzTXVsdGlsaW5lU2VhcmNoKG9wdGlvbnMpO1xuICAgICAgICBpZiAobXRTZWFyY2gpXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csIFwiXFxuXCIpO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGlucHV0KTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCAoIW10U2VhcmNoICYmIG1hdGNoWzBdLmxlbmd0aCAhPSBpbnB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gb3B0aW9ucy5yZWdFeHBcbiAgICAgICAgICAgID8gdGhpcy5wYXJzZVJlcGxhY2VTdHJpbmcocmVwbGFjZW1lbnQpXG4gICAgICAgICAgICA6IHJlcGxhY2VtZW50LnJlcGxhY2UoL1xcJC9nLCBcIiQkJCRcIik7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaW5wdXQucmVwbGFjZShyZSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICBpZiAob3B0aW9ucy5wcmVzZXJ2ZUNhc2UpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCBpbnB1dC5sZW5ndGgpOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gaW5wdXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoLnRvTG93ZXJDYXNlKCkgIT0gY2gpXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gcmVwbGFjZW1lbnRbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gcmVwbGFjZW1lbnRbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcbiAgICBTZWFyY2gucHJvdG90eXBlLiRhc3NlbWJsZVJlZ0V4cCA9IGZ1bmN0aW9uIChvcHRpb25zLCAkZGlzYWJsZUZha2VNdWx0aWxpbmUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubmVlZGxlIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgPSBvcHRpb25zLm5lZWRsZTtcbiAgICAgICAgdmFyIG5lZWRsZSA9IG9wdGlvbnMubmVlZGxlO1xuICAgICAgICBpZiAoIW9wdGlvbnMubmVlZGxlKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlZ0V4cClcbiAgICAgICAgICAgIG5lZWRsZSA9IGxhbmcuZXNjYXBlUmVnRXhwKG5lZWRsZSk7XG4gICAgICAgIHZhciBtb2RpZmllciA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IFwiZ21cIiA6IFwiZ21pXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKG5lZWRsZSwgXCJ1XCIpO1xuICAgICAgICAgICAgb3B0aW9ucy4kc3VwcG9ydHNVbmljb2RlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBtb2RpZmllciArPSBcInVcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3B0aW9ucy4kc3VwcG9ydHNVbmljb2RlRmxhZyA9IGZhbHNlOyAvL2xlZnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBmb3IgY2FzZXMgbGlrZSAvYWJcXHsyfS9ndVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndob2xlV29yZClcbiAgICAgICAgICAgIG5lZWRsZSA9IGFkZFdvcmRCb3VuZGFyeShuZWVkbGUsIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLiRpc011bHRpTGluZSA9ICEkZGlzYWJsZUZha2VNdWx0aWxpbmUgJiYgL1tcXG5cXHJdLy50ZXN0KG5lZWRsZSk7XG4gICAgICAgIGlmIChvcHRpb25zLiRpc011bHRpTGluZSlcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gdGhpcy4kYXNzZW1ibGVNdWx0aWxpbmVSZWdFeHAobmVlZGxlLCBtb2RpZmllcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKG5lZWRsZSwgbW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gcmU7XG4gICAgfTtcbiAgICBTZWFyY2gucHJvdG90eXBlLiRhc3NlbWJsZU11bHRpbGluZVJlZ0V4cCA9IGZ1bmN0aW9uIChuZWVkbGUsIG1vZGlmaWVyKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5lZWRsZS5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCBcIiRcXG5eXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgcmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmUucHVzaChuZXcgUmVnRXhwKHBhcnRzW2ldLCBtb2RpZmllcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZTtcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuJGlzTXVsdGlsaW5lU2VhcmNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgJiYgL1xcXFxyXFxcXG58XFxcXHJ8XFxcXG4vLnRlc3Qob3B0aW9ucy5yZS5zb3VyY2UpICYmIG9wdGlvbnMucmVnRXhwICYmICFvcHRpb25zLiRpc011bHRpTGluZTtcbiAgICB9O1xuICAgIFNlYXJjaC5wcm90b3R5cGUuJG11bHRpTGluZUZvcndhcmQgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgcmUsIHN0YXJ0LCBsYXN0KSB7XG4gICAgICAgIHZhciBsaW5lLCBjaHVuayA9IGNodW5rRW5kKHNlc3Npb24sIHN0YXJ0KTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnQ7IHJvdyA8PSBsYXN0Oykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuazsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc2Vzc2lvbi5nZXRMaW5lKHJvdysrKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZSA9PSBudWxsID8gbmV4dCA6IGxpbmUgKyBcIlxcblwiICsgbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMobGluZSk7XG4gICAgICAgICAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZU1hdGNoID0gbGluZS5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWRUZXh0ID0gbWF0Y2hbMF0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gc3RhcnQgKyBiZWZvcmVNYXRjaC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbCA9IGJlZm9yZU1hdGNoW2JlZm9yZU1hdGNoLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gc3RhcnRSb3cgKyBtYXRjaGVkVGV4dC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmRDb2wgPSBtYXRjaGVkVGV4dC5sZW5ndGggPT0gMVxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJ0Q29sICsgbWF0Y2hlZFRleHRbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIDogbWF0Y2hlZFRleHRbbWF0Y2hlZFRleHQubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Um93OiBzdGFydFJvdyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2w6IHN0YXJ0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmRSb3c6IGVuZFJvdyxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sOiBlbmRDb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU2VhcmNoLnByb3RvdHlwZS4kbXVsdGlMaW5lQmFja3dhcmQgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgcmUsIGVuZEluZGV4LCBzdGFydCwgZmlyc3QpIHtcbiAgICAgICAgdmFyIGxpbmUsIGNodW5rID0gY2h1bmtFbmQoc2Vzc2lvbiwgc3RhcnQpLCBlbmRNYXJnaW4gPSBzZXNzaW9uLmdldExpbmUoc3RhcnQpLmxlbmd0aCAtIGVuZEluZGV4O1xuICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydDsgcm93ID49IGZpcnN0Oykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuayAmJiByb3cgPj0gZmlyc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc2Vzc2lvbi5nZXRMaW5lKHJvdy0tKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZSA9PSBudWxsID8gbmV4dCA6IG5leHQgKyBcIlxcblwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG11bHRpTGluZUJhY2t3YXJkTWF0Y2gobGluZSwgcmUsIGVuZE1hcmdpbik7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlTWF0Y2ggPSBsaW5lLnNsaWNlKDAsIG1hdGNoLmluZGV4KS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZFRleHQgPSBtYXRjaFswXS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByb3cgKyBiZWZvcmVNYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29sID0gYmVmb3JlTWF0Y2hbYmVmb3JlTWF0Y2gubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlbmRSb3cgPSBzdGFydFJvdyArIG1hdGNoZWRUZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvbCA9IG1hdGNoZWRUZXh0Lmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAgICAgICAgID8gc3RhcnRDb2wgKyBtYXRjaGVkVGV4dFswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiBtYXRjaGVkVGV4dFttYXRjaGVkVGV4dC5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93LFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbDogc3RhcnRDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZFJvdzogZW5kUm93LFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2w6IGVuZENvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTZWFyY2gucHJvdG90eXBlLiRtYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlID0gdGhpcy4kYXNzZW1ibGVSZWdFeHAob3B0aW9ucyk7XG4gICAgICAgIGlmICghcmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBtdFNlYXJjaCA9IHRoaXMuJGlzTXVsdGlsaW5lU2VhcmNoKG9wdGlvbnMpO1xuICAgICAgICB2YXIgbXRGb3J3YXJkID0gdGhpcy4kbXVsdGlMaW5lRm9yd2FyZDtcbiAgICAgICAgdmFyIG10QmFja3dhcmQgPSB0aGlzLiRtdWx0aUxpbmVCYWNrd2FyZDtcbiAgICAgICAgdmFyIGJhY2t3YXJkcyA9IG9wdGlvbnMuYmFja3dhcmRzID09IHRydWU7XG4gICAgICAgIHZhciBza2lwQ3VycmVudCA9IG9wdGlvbnMuc2tpcEN1cnJlbnQgIT0gZmFsc2U7XG4gICAgICAgIHZhciBzdXBwb3J0c1VuaWNvZGVGbGFnID0gcmUudW5pY29kZTtcbiAgICAgICAgdmFyIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UgPyByYW5nZVtiYWNrd2FyZHMgPyBcImVuZFwiIDogXCJzdGFydFwiXSA6IHNlc3Npb24uc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgIGlmIChzdGFydC5zdGFydClcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRbc2tpcEN1cnJlbnQgIT0gYmFja3dhcmRzID8gXCJlbmRcIiA6IFwic3RhcnRcIl07XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlID8gcmFuZ2Uuc3RhcnQucm93IDogMDtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSByYW5nZSA/IHJhbmdlLmVuZC5yb3cgOiBzZXNzaW9uLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIGlmIChmb3JFYWNoSW5MaW5lKHJvdywgc3RhcnQuY29sdW1uLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHJvdy0tOyByb3cgPj0gZmlyc3RSb3c7IHJvdy0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yRWFjaEluTGluZShyb3csIE51bWJlci5NQVhfVkFMVUUsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53cmFwID09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yIChyb3cgPSBsYXN0Um93LCBmaXJzdFJvdyA9IHN0YXJ0LnJvdzsgcm93ID49IGZpcnN0Um93OyByb3ctLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvckVhY2hJbkxpbmUocm93LCBOdW1iZXIuTUFYX1ZBTFVFLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIGlmIChmb3JFYWNoSW5MaW5lKHJvdywgc3RhcnQuY29sdW1uLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IHJvdyArIDE7IHJvdyA8PSBsYXN0Um93OyByb3crKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvckVhY2hJbkxpbmUocm93LCAwLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud3JhcCA9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZvciAocm93ID0gZmlyc3RSb3csIGxhc3RSb3cgPSBzdGFydC5yb3c7IHJvdyA8PSBsYXN0Um93OyByb3crKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvckVhY2hJbkxpbmUocm93LCAwLCBjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLiRpc011bHRpTGluZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHJlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmb3JFYWNoSW5MaW5lID0gZnVuY3Rpb24gKHJvdywgb2Zmc2V0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGJhY2t3YXJkcyA/IHJvdyAtIGxlbiArIDEgOiByb3c7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0Um93IDwgMCB8fCBzdGFydFJvdyArIGxlbiA+IHNlc3Npb24uZ2V0TGVuZ3RoKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBsaW5lLnNlYXJjaChyZVswXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFiYWNrd2FyZHMgJiYgc3RhcnRJbmRleCA8IG9mZnNldCB8fCBzdGFydEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHNlc3Npb24uZ2V0TGluZShzdGFydFJvdyArIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zZWFyY2gocmVbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBsaW5lLm1hdGNoKHJlW2xlbiAtIDFdKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t3YXJkcyAmJiBlbmRJbmRleCA+IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhzdGFydFJvdywgc3RhcnRJbmRleCwgc3RhcnRSb3cgKyBsZW4gLSAxLCBlbmRJbmRleCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBmb3JFYWNoSW5MaW5lID0gZnVuY3Rpb24gKHJvdywgZW5kSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG10U2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBtdEJhY2t3YXJkKHNlc3Npb24sIHJlLCBlbmRJbmRleCwgcm93LCBmaXJzdFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socG9zLnN0YXJ0Um93LCBwb3Muc3RhcnRDb2wsIHBvcy5lbmRSb3csIHBvcy5lbmRDb2wpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSwgbGFzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHJlLmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPj0gbGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGxhc3QgKz0gbGFuZy5za2lwRW1wdHlNYXRjaChsaW5lLCBsYXN0LCBzdXBwb3J0c1VuaWNvZGVGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLmluZGV4ICsgbGVuZ3RoID4gZW5kSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobS5pbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG1hdGNoZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socm93LCBjb2x1bW4sIHJvdywgY29sdW1uICsgbGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9yRWFjaEluTGluZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobXRTZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG10Rm9yd2FyZChzZXNzaW9uLCByZSwgcm93LCBsYXN0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZF9yb3cgPSBwb3MuZW5kUm93IDw9IGxhc3RSb3cgPyBwb3MuZW5kUm93IC0gMSA6IGxhc3RSb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kX3JvdyA+IHJvdylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBlbmRfcm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2socG9zLnN0YXJ0Um93LCBwb3Muc3RhcnRDb2wsIHBvcy5lbmRSb3csIHBvcy5lbmRDb2wpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHJlLmV4ZWMobGluZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhyb3csIGxhc3QsIHJvdywgbGFzdCArIGxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGxhc3QgKz0gbGFuZy5za2lwRW1wdHlNYXRjaChsaW5lLCBsYXN0LCBzdXBwb3J0c1VuaWNvZGVGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA+PSBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JFYWNoOiBmb3JFYWNoIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoO1xufSgpKTtcbmZ1bmN0aW9uIGFkZFdvcmRCb3VuZGFyeShuZWVkbGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3VwcG9ydHNMb29rYmVoaW5kID0gbGFuZy5zdXBwb3J0c0xvb2tiZWhpbmQoKTtcbiAgICBmdW5jdGlvbiB3b3JkQm91bmRhcnkoYywgZmlyc3RDaGFyKSB7XG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IHZvaWQgMCkgeyBmaXJzdENoYXIgPSB0cnVlOyB9XG4gICAgICAgIHZhciB3b3JkUmVnRXhwID0gc3VwcG9ydHNMb29rYmVoaW5kICYmIG9wdGlvbnMuJHN1cHBvcnRzVW5pY29kZUZsYWcgPyBuZXcgUmVnRXhwKFwiW1xcXFxwe0x9XFxcXHB7Tn1fXVwiLCBcInVcIikgOiBuZXcgUmVnRXhwKFwiXFxcXHdcIik7XG4gICAgICAgIGlmICh3b3JkUmVnRXhwLnRlc3QoYykgfHwgb3B0aW9ucy5yZWdFeHApIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0xvb2tiZWhpbmQgJiYgb3B0aW9ucy4kc3VwcG9ydHNVbmljb2RlRmxhZykge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoYXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIig/PD1efFteXFxcXHB7TH1cXFxccHtOfV9dKVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIig/PVteXFxcXHB7TH1cXFxccHtOfV9dfCQpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgbmVlZGxlQXJyYXkgPSBBcnJheS5mcm9tKG5lZWRsZSk7XG4gICAgdmFyIGZpcnN0Q2hhciA9IG5lZWRsZUFycmF5WzBdO1xuICAgIHZhciBsYXN0Q2hhciA9IG5lZWRsZUFycmF5W25lZWRsZUFycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB3b3JkQm91bmRhcnkoZmlyc3RDaGFyKSArIG5lZWRsZSArIHdvcmRCb3VuZGFyeShsYXN0Q2hhciwgZmFsc2UpO1xufVxuZnVuY3Rpb24gbXVsdGlMaW5lQmFja3dhcmRNYXRjaChsaW5lLCByZSwgZW5kTWFyZ2luKSB7XG4gICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICB2YXIgZnJvbSA9IDA7XG4gICAgd2hpbGUgKGZyb20gPD0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gZnJvbTtcbiAgICAgICAgdmFyIG5ld01hdGNoID0gcmUuZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKCFuZXdNYXRjaClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2YXIgZW5kID0gbmV3TWF0Y2guaW5kZXggKyBuZXdNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPiBsaW5lLmxlbmd0aCAtIGVuZE1hcmdpbilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IGVuZCA+IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgICAgICAgICAgbWF0Y2ggPSBuZXdNYXRjaDtcbiAgICAgICAgZnJvbSA9IG5ld01hdGNoLmluZGV4ICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufVxuZnVuY3Rpb24gY2h1bmtFbmQoc2Vzc2lvbiwgc3RhcnQpIHtcbiAgICB2YXIgYmFzZSA9IDUwMDAsIHN0YXJ0UG9zaXRpb24gPSB7IHJvdzogc3RhcnQsIGNvbHVtbjogMCB9LCBzdGFydEluZGV4ID0gc2Vzc2lvbi5kb2MucG9zaXRpb25Ub0luZGV4KHN0YXJ0UG9zaXRpb24pLCB0YXJnZXRJbmRleCA9IHN0YXJ0SW5kZXggKyBiYXNlLCB0YXJnZXRQb3NpdGlvbiA9IHNlc3Npb24uZG9jLmluZGV4VG9Qb3NpdGlvbih0YXJnZXRJbmRleCksIHRhcmdldExpbmUgPSB0YXJnZXRQb3NpdGlvbi5yb3c7XG4gICAgcmV0dXJuIHRhcmdldExpbmUgKyAxO1xufVxuZXhwb3J0cy5TZWFyY2ggPSBTZWFyY2g7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9rZXlzXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7IHZhciBrZXlVdGlsID0gcmVxdWlyZShcIi4uL2xpYi9rZXlzXCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEtFWV9NT0RTID0ga2V5VXRpbC5LRVlfTU9EUztcbnZhciBNdWx0aUhhc2hIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpSGFzaEhhbmRsZXIoY29uZmlnLCBwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLiRpbml0KGNvbmZpZywgcGxhdGZvcm0sIGZhbHNlKTtcbiAgICB9XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuJGluaXQgPSBmdW5jdGlvbiAoY29uZmlnLCBwbGF0Zm9ybSwgJHNpbmdsZUNvbW1hbmQpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtIHx8ICh1c2VyYWdlbnQuaXNNYWMgPyBcIm1hY1wiIDogXCJ3aW5cIik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSB7fTtcbiAgICAgICAgdGhpcy5jb21tYW5kS2V5QmluZGluZyA9IHt9O1xuICAgICAgICB0aGlzLmFkZENvbW1hbmRzKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJHNpbmdsZUNvbW1hbmQgPSAkc2luZ2xlQ29tbWFuZDtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLmFkZENvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kc1tjb21tYW5kLm5hbWVdKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB0aGlzLmNvbW1hbmRzW2NvbW1hbmQubmFtZV0gPSBjb21tYW5kO1xuICAgICAgICBpZiAoY29tbWFuZC5iaW5kS2V5KVxuICAgICAgICAgICAgdGhpcy5fYnVpbGRLZXlIYXNoKGNvbW1hbmQpO1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlQ29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kLCBrZWVwQ29tbWFuZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNvbW1hbmQgJiYgKHR5cGVvZiBjb21tYW5kID09PSAnc3RyaW5nJyA/IGNvbW1hbmQgOiBjb21tYW5kLm5hbWUpO1xuICAgICAgICBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tuYW1lXTtcbiAgICAgICAgaWYgKCFrZWVwQ29tbWFuZClcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbW1hbmRzW25hbWVdO1xuICAgICAgICB2YXIgY2tiID0gdGhpcy5jb21tYW5kS2V5QmluZGluZztcbiAgICAgICAgZm9yICh2YXIga2V5SWQgaW4gY2tiKSB7XG4gICAgICAgICAgICB2YXIgY21kR3JvdXAgPSBja2Jba2V5SWRdO1xuICAgICAgICAgICAgaWYgKGNtZEdyb3VwID09IGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2tiW2tleUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY21kR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBjbWRHcm91cC5pbmRleE9mKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtZEdyb3VwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZEdyb3VwLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2tiW2tleUlkXSA9IGNtZEdyb3VwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuYmluZEtleSA9IGZ1bmN0aW9uIChrZXksIGNvbW1hbmQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09IFwib2JqZWN0XCIgJiYga2V5KSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ga2V5LnBvc2l0aW9uO1xuICAgICAgICAgICAga2V5ID0ga2V5W3RoaXMucGxhdGZvcm1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29tbWFuZCh7IGV4ZWM6IGNvbW1hbmQsIGJpbmRLZXk6IGtleSwgbmFtZTogY29tbWFuZC5uYW1lIHx8IC8qKkB0eXBle3N0cmluZ30qLyAoa2V5KSB9KTsgKGtleSkuc3BsaXQoXCJ8XCIpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhcnQpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbiA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa2V5UGFydC5pbmRleE9mKFwiIFwiKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGtleVBhcnQuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgICAgICBrZXlQYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5UGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMucGFyc2VLZXlzKGtleVBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBLRVlfTU9EU1tiaW5kaW5nLmhhc2hJZF0gKyBiaW5kaW5nLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4gKz0gKGNoYWluID8gXCIgXCIgOiBcIlwiKSArIGlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb21tYW5kVG9CaW5kaW5nKGNoYWluLCBcImNoYWluS2V5c1wiKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBjaGFpbiArPSBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUtleXMoa2V5UGFydCk7XG4gICAgICAgICAgICB2YXIgaWQgPSBLRVlfTU9EU1tiaW5kaW5nLmhhc2hJZF0gKyBiaW5kaW5nLmtleTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENvbW1hbmRUb0JpbmRpbmcoY2hhaW4gKyBpZCwgY29tbWFuZCwgcG9zaXRpb24pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLl9hZGRDb21tYW5kVG9CaW5kaW5nID0gZnVuY3Rpb24gKGtleUlkLCBjb21tYW5kLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2tiID0gdGhpcy5jb21tYW5kS2V5QmluZGluZywgaTtcbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgICBkZWxldGUgY2tiW2tleUlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2tiW2tleUlkXSB8fCB0aGlzLiRzaW5nbGVDb21tYW5kKSB7XG4gICAgICAgICAgICBja2Jba2V5SWRdID0gY29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShja2Jba2V5SWRdKSkge1xuICAgICAgICAgICAgICAgIGNrYltrZXlJZF0gPSBbY2tiW2tleUlkXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoaSA9IGNrYltrZXlJZF0uaW5kZXhPZihjb21tYW5kKSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBja2Jba2V5SWRdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24oY29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBja2Jba2V5SWRdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyUG9zID0gZ2V0UG9zaXRpb24ob3RoZXIpO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlclBvcyA+IHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1hbmRzLnNwbGljZShpLCAwLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuYWRkQ29tbWFuZHMgPSBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgICAgICAgY29tbWFuZHMgJiYgT2JqZWN0LmtleXMoY29tbWFuZHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRLZXkoY29tbWFuZCwgbmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb21tYW5kID0geyBleGVjOiBjb21tYW5kIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFjb21tYW5kLm5hbWUpXG4gICAgICAgICAgICAgICAgY29tbWFuZC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVDb21tYW5kcyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21tYW5kKGNvbW1hbmRzW25hbWVdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5iaW5kS2V5cyA9IGZ1bmN0aW9uIChrZXlMaXN0KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGtleUxpc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kS2V5KGtleSwga2V5TGlzdFtrZXldKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5fYnVpbGRLZXlIYXNoID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgdGhpcy5iaW5kS2V5KGNvbW1hbmQuYmluZEtleSwgY29tbWFuZCk7XG4gICAgfTtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS5wYXJzZUtleXMgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICB2YXIgcGFydHMgPSBrZXlzLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1tcXC1cXCtdKFtcXC1cXCtdKT8vKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICB2YXIga2V5ID0gcGFydHMucG9wKCk7XG4gICAgICAgIHZhciBrZXlDb2RlID0ga2V5VXRpbFtrZXldO1xuICAgICAgICBpZiAoa2V5VXRpbC5GVU5DVElPTl9LRVlTW2tleUNvZGVdKVxuICAgICAgICAgICAga2V5ID0ga2V5VXRpbC5GVU5DVElPTl9LRVlTW2tleUNvZGVdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGVsc2UgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgaGFzaElkOiAtMSB9O1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXSA9PSBcInNoaWZ0XCIpXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS50b1VwcGVyQ2FzZSgpLCBoYXNoSWQ6IC0xIH07XG4gICAgICAgIHZhciBoYXNoSWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBrZXlVdGlsLktFWV9NT0RTW3BhcnRzW2ldXTtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyIFwiICsgcGFydHNbaV0gKyBcIiBpbiBcIiArIGtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc2hJZCB8PSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgaGFzaElkOiBoYXNoSWQgfTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLmZpbmRLZXlDb21tYW5kID0gZnVuY3Rpb24gKGhhc2hJZCwga2V5U3RyaW5nKSB7XG4gICAgICAgIHZhciBrZXkgPSBLRVlfTU9EU1toYXNoSWRdICsga2V5U3RyaW5nO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kS2V5QmluZGluZ1trZXldO1xuICAgIH07XG4gICAgTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlS2V5Ym9hcmQgPSBmdW5jdGlvbiAoZGF0YSwgaGFzaElkLCBrZXlTdHJpbmcsIGtleUNvZGUpIHtcbiAgICAgICAgaWYgKGtleUNvZGUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2V5ID0gS0VZX01PRFNbaGFzaElkXSArIGtleVN0cmluZztcbiAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nW2tleV07XG4gICAgICAgIGlmIChkYXRhLiRrZXlDaGFpbikge1xuICAgICAgICAgICAgZGF0YS4ka2V5Q2hhaW4gKz0gXCIgXCIgKyBrZXk7XG4gICAgICAgICAgICBjb21tYW5kID0gdGhpcy5jb21tYW5kS2V5QmluZGluZ1tkYXRhLiRrZXlDaGFpbl0gfHwgY29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXCJjaGFpbktleXNcIiB8fCBjb21tYW5kW2NvbW1hbmQubGVuZ3RoIC0gMV0gPT0gXCJjaGFpbktleXNcIikge1xuICAgICAgICAgICAgICAgIGRhdGEuJGtleUNoYWluID0gZGF0YS4ka2V5Q2hhaW4gfHwga2V5O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvbW1hbmQ6IFwibnVsbFwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuJGtleUNoYWluKSB7XG4gICAgICAgICAgICBpZiAoKCFoYXNoSWQgfHwgaGFzaElkID09IDQpICYmIGtleVN0cmluZy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICBkYXRhLiRrZXlDaGFpbiA9IGRhdGEuJGtleUNoYWluLnNsaWNlKDAsIC1rZXkubGVuZ3RoIC0gMSk7IC8vIHdhaXQgZm9yIGlucHV0XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNoSWQgPT0gLTEgfHwga2V5Q29kZSA+IDApXG4gICAgICAgICAgICAgICAgZGF0YS4ka2V5Q2hhaW4gPSBcIlwiOyAvLyByZXNldCBrZXlDaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbW1hbmQ6IGNvbW1hbmQgfTtcbiAgICB9O1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLmdldFN0YXR1c1RleHQgPSBmdW5jdGlvbiAoZWRpdG9yLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLiRrZXlDaGFpbiB8fCBcIlwiO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpSGFzaEhhbmRsZXI7XG59KCkpO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oY29tbWFuZCkge1xuICAgIHJldHVybiB0eXBlb2YgY29tbWFuZCA9PSBcIm9iamVjdFwiICYmIGNvbW1hbmQuYmluZEtleVxuICAgICAgICAmJiBjb21tYW5kLmJpbmRLZXkucG9zaXRpb25cbiAgICAgICAgfHwgKGNvbW1hbmQuaXNEZWZhdWx0ID8gLTEwMCA6IDApO1xufVxudmFyIEhhc2hIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXNoSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYXNoSGFuZGxlcihjb25maWcsIHBsYXRmb3JtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZywgcGxhdGZvcm0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLiRzaW5nbGVDb21tYW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGFzaEhhbmRsZXI7XG59KE11bHRpSGFzaEhhbmRsZXIpKTtcbkhhc2hIYW5kbGVyLmNhbGwgPSBmdW5jdGlvbiAodGhpc0FyZywgY29uZmlnLCBwbGF0Zm9ybSkge1xuICAgIE11bHRpSGFzaEhhbmRsZXIucHJvdG90eXBlLiRpbml0LmNhbGwodGhpc0FyZywgY29uZmlnLCBwbGF0Zm9ybSwgdHJ1ZSk7XG59O1xuTXVsdGlIYXNoSGFuZGxlci5jYWxsID0gZnVuY3Rpb24gKHRoaXNBcmcsIGNvbmZpZywgcGxhdGZvcm0pIHtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZS4kaW5pdC5jYWxsKHRoaXNBcmcsIGNvbmZpZywgcGxhdGZvcm0sIGZhbHNlKTtcbn07XG5leHBvcnRzLkhhc2hIYW5kbGVyID0gSGFzaEhhbmRsZXI7XG5leHBvcnRzLk11bHRpSGFzaEhhbmRsZXIgPSBNdWx0aUhhc2hIYW5kbGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIE11bHRpSGFzaEhhbmRsZXIgPSByZXF1aXJlKFwiLi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIpLk11bHRpSGFzaEhhbmRsZXI7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBDb21tYW5kTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWFuZE1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tbWFuZE1hbmFnZXIocGxhdGZvcm0sIGNvbW1hbmRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbW1hbmRzLCBwbGF0Zm9ybSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnlOYW1lID0gX3RoaXMuY29tbWFuZHM7XG4gICAgICAgIF90aGlzLnNldERlZmF1bHRIYW5kbGVyKFwiZXhlY1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5jb21tYW5kLmV4ZWMoZS5lZGl0b3IsIHt9LCBlLmV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlLmNvbW1hbmQuZXhlYyhlLmVkaXRvciwgZS5hcmdzLCBlLmV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKGNvbW1hbmQsIGVkaXRvciwgYXJncykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21tYW5kKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvbW1hbmQubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhlYyhjb21tYW5kW2ldLCBlZGl0b3IsIGFyZ3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tjb21tYW5kXTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkV4ZWN1dGUoY29tbWFuZCwgZWRpdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0geyBlZGl0b3I6IGVkaXRvciwgY29tbWFuZDogY29tbWFuZCwgYXJnczogYXJncyB9O1xuICAgICAgICBlLnJldHVyblZhbHVlID0gdGhpcy5fZW1pdChcImV4ZWNcIiwgZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImFmdGVyRXhlY1wiLCBlKTtcbiAgICAgICAgcmV0dXJuIGUucmV0dXJuVmFsdWUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmNhbkV4ZWN1dGUgPSBmdW5jdGlvbiAoY29tbWFuZCwgZWRpdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW2NvbW1hbmRdO1xuICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChlZGl0b3IgJiYgZWRpdG9yLiRyZWFkT25seSAmJiAhY29tbWFuZC5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuJGNoZWNrQ29tbWFuZFN0YXRlICE9IGZhbHNlICYmIGNvbW1hbmQuaXNBdmFpbGFibGUgJiYgIWNvbW1hbmQuaXNBdmFpbGFibGUoZWRpdG9yKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUudG9nZ2xlUmVjb3JkaW5nID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBpZiAodGhpcy4kaW5SZXBsYXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVkaXRvciAmJiBlZGl0b3IuX2VtaXQoXCJjaGFuZ2VTdGF0dXNcIik7XG4gICAgICAgIGlmICh0aGlzLnJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5tYWNyby5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwiZXhlY1wiLCB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFjcm8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubWFjcm8gPSB0aGlzLm9sZE1hY3JvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRhZGRDb21tYW5kVG9NYWNybykge1xuICAgICAgICAgICAgdGhpcy4kYWRkQ29tbWFuZFRvTWFjcm8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFjcm8ucHVzaChbZS5jb21tYW5kLCBlLmFyZ3NdKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9sZE1hY3JvID0gdGhpcy5tYWNybztcbiAgICAgICAgdGhpcy5tYWNybyA9IFtdO1xuICAgICAgICB0aGlzLm9uKFwiZXhlY1wiLCB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29yZGluZyA9IHRydWU7XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUucmVwbGF5ID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBpZiAodGhpcy4kaW5SZXBsYXkgfHwgIXRoaXMubWFjcm8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJlY29yZGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZVJlY29yZGluZyhlZGl0b3IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWNyby5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlYyh4LCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjKHhbMF0sIGVkaXRvciwgeFsxXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuJGluUmVwbGF5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS50cmltTWFjcm8gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeFswXSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHhbMF0gPSB4WzBdLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXhbMV0pXG4gICAgICAgICAgICAgICAgeCA9IHhbMF07XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWFuZE1hbmFnZXI7XG59KE11bHRpSGFzaEhhbmRsZXIpKTtcbm9vcC5pbXBsZW1lbnQoQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5Db21tYW5kTWFuYWdlciA9IENvbW1hbmRNYW5hZ2VyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9jb25maWdcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi4vcmFuZ2VcIikuUmFuZ2U7XG5mdW5jdGlvbiBiaW5kS2V5KHdpbiwgbWFjKSB7XG4gICAgcmV0dXJuIHsgd2luOiB3aW4sIG1hYzogbWFjIH07XG59XG5leHBvcnRzLmNvbW1hbmRzID0gW3tcbiAgICAgICAgbmFtZTogXCJzaG93U2V0dGluZ3NNZW51XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNob3cgc2V0dGluZ3MgbWVudVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC0sXCIsIFwiQ29tbWFuZC0sXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25maWcubG9hZE1vZHVsZShcImFjZS9leHQvc2V0dGluZ3NfbWVudVwiLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmluaXQoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2hvd1NldHRpbmdzTWVudSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvVG9OZXh0RXJyb3JcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gbmV4dCBlcnJvclwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LUVcIiwgXCJGNFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L2Vycm9yX21hcmtlclwiLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLnNob3dFcnJvck1hcmtlcihlZGl0b3IsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ29Ub1ByZXZpb3VzRXJyb3JcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gcHJldmlvdXMgZXJyb3JcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1FXCIsIFwiU2hpZnQtRjRcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcIiwgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5zaG93RXJyb3JNYXJrZXIoZWRpdG9yLCAtMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RhbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IGFsbFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1BXCIsIFwiQ29tbWFuZC1BXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RBbGwoKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiY2VudGVyc2VsZWN0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNlbnRlciBzZWxlY3Rpb25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBcIkN0cmwtTFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY2VudGVyU2VsZWN0aW9uKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9saW5lXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIGxpbmUuLi5cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtTFwiLCBcIkNvbW1hbmQtTFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgbGluZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSBcIm51bWJlclwiICYmICFpc05hTihsaW5lKSlcbiAgICAgICAgICAgICAgICBlZGl0b3IuZ290b0xpbmUobGluZSk7XG4gICAgICAgICAgICBlZGl0b3IucHJvbXB0KHsgJHR5cGU6IFwiZ290b0xpbmVcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZm9sZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LUx8Q3RybC1GMVwiLCBcIkNvbW1hbmQtQWx0LUx8Q29tbWFuZC1GMVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2Vzc2lvbi50b2dnbGVGb2xkKGZhbHNlKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidW5mb2xkXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtTHxDdHJsLVNoaWZ0LUYxXCIsIFwiQ29tbWFuZC1BbHQtU2hpZnQtTHxDb21tYW5kLVNoaWZ0LUYxXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGQodHJ1ZSk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInRvZ2dsZUZvbGRXaWRnZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVG9nZ2xlIGZvbGQgd2lkZ2V0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJGMlwiLCBcIkYyXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGRXaWRnZXQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9nZ2xlUGFyZW50Rm9sZFdpZGdldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUb2dnbGUgcGFyZW50IGZvbGQgd2lkZ2V0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtRjJcIiwgXCJBbHQtRjJcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZFdpZGdldCh0cnVlKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZm9sZGFsbFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGb2xkIGFsbFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiQ3RybC1Db21tYW5kLU9wdGlvbi0wXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLmZvbGRBbGwoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZvbGRBbGxDb21tZW50c1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGb2xkIGFsbCBjb21tZW50c1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiQ3RybC1Db21tYW5kLU9wdGlvbi0wXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLmZvbGRBbGxDb21tZW50cygpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZm9sZE90aGVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZvbGQgb3RoZXJcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC0wXCIsIFwiQ29tbWFuZC1PcHRpb24tMFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24uZm9sZEFsbCgpO1xuICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24udW5mb2xkKGVkaXRvci5zZWxlY3Rpb24uZ2V0QWxsUmFuZ2VzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidW5mb2xkYWxsXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVuZm9sZCBhbGxcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC0wXCIsIFwiQ29tbWFuZC1PcHRpb24tU2hpZnQtMFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2Vzc2lvbi51bmZvbGQoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZpbmRuZXh0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbmQgbmV4dFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1LXCIsIFwiQ29tbWFuZC1HXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5maW5kTmV4dCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJmaW5kcHJldmlvdXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmluZCBwcmV2aW91c1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1LXCIsIFwiQ29tbWFuZC1TaGlmdC1HXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5maW5kUHJldmlvdXMoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0T3JGaW5kTmV4dFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3Qgb3IgZmluZCBuZXh0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtS1wiLCBcIkN0cmwtR1wiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0V29yZCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVkaXRvci5maW5kTmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RPckZpbmRQcmV2aW91c1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3Qgb3IgZmluZCBwcmV2aW91c1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LUtcIiwgXCJDdHJsLVNoaWZ0LUdcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlZGl0b3IuZmluZFByZXZpb3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZpbmRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmluZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1GXCIsIFwiQ29tbWFuZC1GXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25maWcubG9hZE1vZHVsZShcImFjZS9leHQvc2VhcmNoYm94XCIsIGZ1bmN0aW9uIChlKSB7IGUuU2VhcmNoKGVkaXRvcik7IH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJvdmVyd3JpdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiT3ZlcndyaXRlXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiSW5zZXJ0XCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R0b3N0YXJ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCB0byBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1Ib21lXCIsIFwiQ29tbWFuZC1TaGlmdC1Ib21lfENvbW1hbmQtU2hpZnQtVXBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdEZpbGVTdGFydCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgICAgIGFjZUNvbW1hbmRHcm91cDogXCJmaWxlSnVtcFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9zdGFydFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1Ib21lXCIsIFwiQ29tbWFuZC1Ib21lfENvbW1hbmQtVXBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlRmlsZVN0YXJ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgYWNlQ29tbWFuZEdyb3VwOiBcImZpbGVKdW1wXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0dXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHVwXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1VcFwiLCBcIlNoaWZ0LVVwfEN0cmwtU2hpZnQtUFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0VXAoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ29saW5ldXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gbGluZSB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiVXBcIiwgXCJVcHxDdHJsLVBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IsIGFyZ3MpIHsgZWRpdG9yLm5hdmlnYXRlVXAoYXJncy50aW1lcyk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHRvZW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCB0byBlbmRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRW5kXCIsIFwiQ29tbWFuZC1TaGlmdC1FbmR8Q29tbWFuZC1TaGlmdC1Eb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RGaWxlRW5kKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgYWNlQ29tbWFuZEdyb3VwOiBcImZpbGVKdW1wXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b2VuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBlbmRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRW5kXCIsIFwiQ29tbWFuZC1FbmR8Q29tbWFuZC1Eb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUZpbGVFbmQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICBhY2VDb21tYW5kR3JvdXA6IFwiZmlsZUp1bXBcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3Rkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1Eb3duXCIsIFwiU2hpZnQtRG93bnxDdHJsLVNoaWZ0LU5cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdERvd24oKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ29saW5lZG93blwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyBsaW5lIGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkRvd25cIiwgXCJEb3dufEN0cmwtTlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVEb3duKGFyZ3MudGltZXMpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R3b3JkbGVmdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3Qgd29yZCBsZWZ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUxlZnRcIiwgXCJPcHRpb24tU2hpZnQtTGVmdFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0V29yZExlZnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b3dvcmRsZWZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIHdvcmQgbGVmdFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1MZWZ0XCIsIFwiT3B0aW9uLUxlZnRcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlV29yZExlZnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0dG9saW5lc3RhcnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHRvIGxpbmUgc3RhcnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1MZWZ0XCIsIFwiQ29tbWFuZC1TaGlmdC1MZWZ0fEN0cmwtU2hpZnQtQVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZVN0YXJ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9saW5lc3RhcnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gbGluZSBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LUxlZnR8SG9tZVwiLCBcIkNvbW1hbmQtTGVmdHxIb21lfEN0cmwtQVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVMaW5lU3RhcnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0bGVmdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbGVmdFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtTGVmdFwiLCBcIlNoaWZ0LUxlZnR8Q3RybC1TaGlmdC1CXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMZWZ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImdvdG9sZWZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIGxlZnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkxlZnRcIiwgXCJMZWZ0fEN0cmwtQlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVMZWZ0KGFyZ3MudGltZXMpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3R3b3JkcmlnaHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHdvcmQgcmlnaHRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtUmlnaHRcIiwgXCJPcHRpb24tU2hpZnQtUmlnaHRcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFdvcmRSaWdodCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3Rvd29yZHJpZ2h0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIHdvcmQgcmlnaHRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtUmlnaHRcIiwgXCJPcHRpb24tUmlnaHRcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlV29yZFJpZ2h0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHRvbGluZWVuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgdG8gbGluZSBlbmRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1SaWdodFwiLCBcIkNvbW1hbmQtU2hpZnQtUmlnaHR8U2hpZnQtRW5kfEN0cmwtU2hpZnQtRVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZUVuZCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3RvbGluZWVuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHbyB0byBsaW5lIGVuZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVJpZ2h0fEVuZFwiLCBcIkNvbW1hbmQtUmlnaHR8RW5kfEN0cmwtRVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVMaW5lRW5kKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHJpZ2h0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCByaWdodFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtUmlnaHRcIiwgXCJTaGlmdC1SaWdodFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmlnaHQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZ290b3JpZ2h0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIHJpZ2h0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJSaWdodFwiLCBcIlJpZ2h0fEN0cmwtRlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVSaWdodChhcmdzLnRpbWVzKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0cGFnZWRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IHBhZ2UgZG93blwiLFxuICAgICAgICBiaW5kS2V5OiBcIlNoaWZ0LVBhZ2VEb3duXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdFBhZ2VEb3duKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInBhZ2Vkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBhZ2UgZG93blwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiT3B0aW9uLVBhZ2VEb3duXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zY3JvbGxQYWdlRG93bigpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3RvcGFnZWRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR28gdG8gcGFnZSBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJQYWdlRG93blwiLCBcIlBhZ2VEb3dufEN0cmwtVlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ290b1BhZ2VEb3duKCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdHBhZ2V1cFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgcGFnZSB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBcIlNoaWZ0LVBhZ2VVcFwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RQYWdlVXAoKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicGFnZXVwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBhZ2UgdXBcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBcIk9wdGlvbi1QYWdlVXBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNjcm9sbFBhZ2VVcCgpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJnb3RvcGFnZXVwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkdvIHRvIHBhZ2UgdXBcIixcbiAgICAgICAgYmluZEtleTogXCJQYWdlVXBcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ290b1BhZ2VVcCgpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzY3JvbGx1cFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTY3JvbGwgdXBcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtVXBcIiwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlKSB7IGUucmVuZGVyZXIuc2Nyb2xsQnkoMCwgLTIgKiBlLnJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJzY3JvbGxkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNjcm9sbCBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLURvd25cIiwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlKSB7IGUucmVuZGVyZXIuc2Nyb2xsQnkoMCwgMiAqIGUucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodCk7IH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdGxpbmVzdGFydFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbGluZSBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBcIlNoaWZ0LUhvbWVcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZVN0YXJ0KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdGxpbmVlbmRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IGxpbmUgZW5kXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiU2hpZnQtRW5kXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExpbmVFbmQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9nZ2xlcmVjb3JkaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZ2dsZSByZWNvcmRpbmdcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtQWx0LUVcIiwgXCJDb21tYW5kLU9wdGlvbi1FXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jb21tYW5kcy50b2dnbGVSZWNvcmRpbmcoZWRpdG9yKTsgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVwbGF5bWFjcm9cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVwbGF5IG1hY3JvXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUVcIiwgXCJDb21tYW5kLVNoaWZ0LUVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmNvbW1hbmRzLnJlcGxheShlZGl0b3IpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJqdW1wdG9tYXRjaGluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKdW1wIHRvIG1hdGNoaW5nXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVxcXFx8Q3RybC1QXCIsIFwiQ29tbWFuZC1cXFxcXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5qdW1wVG9NYXRjaGluZygpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0dG9tYXRjaGluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgdG8gbWF0Y2hpbmdcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtXFxcXHxDdHJsLVNoaWZ0LVBcIiwgXCJDb21tYW5kLVNoaWZ0LVxcXFxcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmp1bXBUb01hdGNoaW5nKHRydWUpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZXhwYW5kVG9NYXRjaGluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJFeHBhbmQgdG8gbWF0Y2hpbmdcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtTVwiLCBcIkN0cmwtU2hpZnQtTVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuanVtcFRvTWF0Y2hpbmcodHJ1ZSwgdHJ1ZSk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJwYXNzS2V5c1RvQnJvd3NlclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJQYXNzIGtleXMgdG8gYnJvd3NlclwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIG51bGwpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIHBhc3NFdmVudDogdHJ1ZSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiY29weVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDb3B5XCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJjdXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ3V0XCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBjdXRMaW5lID0gZWRpdG9yLiRjb3B5V2l0aEVtcHR5U2VsZWN0aW9uICYmIGVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gY3V0TGluZSA/IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKCkgOiBlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICBlZGl0b3IuX2VtaXQoXCJjdXRcIiwgcmFuZ2UpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgIGVkaXRvci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInBhc3RlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBhc3RlXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgICAgIGVkaXRvci4kaGFuZGxlUGFzdGUoYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZWxpbmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVtb3ZlIGxpbmVcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRFwiLCBcIkNvbW1hbmQtRFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlTGluZXMoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hMaW5lXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZHVwbGljYXRlU2VsZWN0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkR1cGxpY2F0ZSBzZWxlY3Rpb25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRFwiLCBcIkNvbW1hbmQtU2hpZnQtRFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZHVwbGljYXRlU2VsZWN0aW9uKCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic29ydGxpbmVzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNvcnQgbGluZXNcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtQWx0LVNcIiwgXCJDb21tYW5kLUFsdC1TXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zb3J0TGluZXMoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hMaW5lXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidG9nZ2xlY29tbWVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUb2dnbGUgY29tbWVudFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC0vXCIsIFwiQ29tbWFuZC0vXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci50b2dnbGVDb21tZW50TGluZXMoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uUGFydFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInRvZ2dsZUJsb2NrQ29tbWVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUb2dnbGUgYmxvY2sgY29tbWVudFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC0vXCIsIFwiQ29tbWFuZC1TaGlmdC0vXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci50b2dnbGVCbG9ja0NvbW1lbnQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwibW9kaWZ5TnVtYmVyVXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW9kaWZ5IG51bWJlciB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1VcFwiLCBcIkFsdC1TaGlmdC1VcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubW9kaWZ5TnVtYmVyKDEpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm1vZGlmeU51bWJlckRvd25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTW9kaWZ5IG51bWJlciBkb3duXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LURvd25cIiwgXCJBbHQtU2hpZnQtRG93blwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubW9kaWZ5TnVtYmVyKC0xKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlcGxhY2VcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtSFwiLCBcIkNvbW1hbmQtT3B0aW9uLUZcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFwiYWNlL2V4dC9zZWFyY2hib3hcIiwgZnVuY3Rpb24gKGUpIHsgZS5TZWFyY2goZWRpdG9yLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidW5kb1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJVbmRvXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVpcIiwgXCJDb21tYW5kLVpcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnVuZG8oKTsgfVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZWRvXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlZG9cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtWnxDdHJsLVlcIiwgXCJDb21tYW5kLVNoaWZ0LVp8Q29tbWFuZC1ZXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZWRvKCk7IH1cbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiY29weWxpbmVzdXBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ29weSBsaW5lcyB1cFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LVVwXCIsIFwiQ29tbWFuZC1PcHRpb24tVXBcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmNvcHlMaW5lc1VwKCk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm1vdmVsaW5lc3VwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk1vdmUgbGluZXMgdXBcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1VcFwiLCBcIk9wdGlvbi1VcFwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubW92ZUxpbmVzVXAoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiY29weWxpbmVzZG93blwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDb3B5IGxpbmVzIGRvd25cIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1Eb3duXCIsIFwiQ29tbWFuZC1PcHRpb24tRG93blwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29weUxpbmVzRG93bigpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJtb3ZlbGluZXNkb3duXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk1vdmUgbGluZXMgZG93blwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LURvd25cIiwgXCJPcHRpb24tRG93blwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IubW92ZUxpbmVzRG93bigpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJkZWxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRGVsZXRlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJEZWxldGVcIiwgXCJEZWxldGV8Q3RybC1EfFNoaWZ0LURlbGV0ZVwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlKFwicmlnaHRcIik7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYmFja3NwYWNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkJhY2tzcGFjZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtQmFja3NwYWNlfEJhY2tzcGFjZVwiLCBcIkN0cmwtQmFja3NwYWNlfFNoaWZ0LUJhY2tzcGFjZXxCYWNrc3BhY2V8Q3RybC1IXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmUoXCJsZWZ0XCIpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImN1dF9vcl9kZWxldGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ3V0IG9yIGRlbGV0ZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtRGVsZXRlXCIsIG51bGwpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlKFwibGVmdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZW1vdmV0b2xpbmVzdGFydFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgdG8gbGluZSBzdGFydFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LUJhY2tzcGFjZVwiLCBcIkNvbW1hbmQtQmFja3NwYWNlXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVUb0xpbmVTdGFydCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZXRvbGluZWVuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgdG8gbGluZSBlbmRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIkFsdC1EZWxldGVcIiwgXCJDdHJsLUt8Q29tbWFuZC1EZWxldGVcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVRvTGluZUVuZCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZXRvbGluZXN0YXJ0aGFyZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgdG8gbGluZSBzdGFydCBoYXJkXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUJhY2tzcGFjZVwiLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gMDtcbiAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZShyYW5nZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicmVtb3ZldG9saW5lZW5kaGFyZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgdG8gbGluZSBlbmQgaGFyZFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1EZWxldGVcIiwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJyZW1vdmV3b3JkbGVmdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgd29yZCBsZWZ0XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUJhY2tzcGFjZVwiLCBcIkFsdC1CYWNrc3BhY2V8Q3RybC1BbHQtQmFja3NwYWNlXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVXb3JkTGVmdCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInJlbW92ZXdvcmRyaWdodFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZW1vdmUgd29yZCByaWdodFwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1EZWxldGVcIiwgXCJBbHQtRGVsZXRlXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVXb3JkUmlnaHQoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJvdXRkZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk91dGRlbnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlNoaWZ0LVRhYlwiLCBcIlNoaWZ0LVRhYlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuYmxvY2tPdXRkZW50KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uUGFydFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImluZGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbmRlbnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShcIlRhYlwiLCBcIlRhYlwiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuaW5kZW50KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uUGFydFwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImJsb2Nrb3V0ZGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJCbG9jayBvdXRkZW50XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVtcIiwgXCJDdHJsLVtcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmJsb2NrT3V0ZGVudCgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoTGluZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYmxvY2tpbmRlbnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQmxvY2sgaW5kZW50XCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLV1cIiwgXCJDdHJsLV1cIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmJsb2NrSW5kZW50KCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hMaW5lXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcInNlbGVjdGlvblBhcnRcIlxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJpbnNlcnRzdHJpbmdcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW5zZXJ0IHN0cmluZ1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yLCBzdHIpIHsgZWRpdG9yLmluc2VydChzdHIpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImluc2VydHRleHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW5zZXJ0IHRleHRcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgYXJncykge1xuICAgICAgICAgICAgZWRpdG9yLmluc2VydChsYW5nLnN0cmluZ1JlcGVhdChhcmdzLnRleHQgfHwgXCJcIiwgYXJncy50aW1lcyB8fCAxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic3BsaXRsaW5lXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNwbGl0IGxpbmVcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBcIkN0cmwtT1wiKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc3BsaXRMaW5lKCk7IH0sXG4gICAgICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwidHJhbnNwb3NlbGV0dGVyc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUcmFuc3Bvc2UgbGV0dGVyc1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LVhcIiwgXCJDdHJsLVRcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRyYW5zcG9zZUxldHRlcnMoKTsgfSxcbiAgICAgICAgbXVsdGlTZWxlY3RBY3Rpb246IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnRyYW5zcG9zZVNlbGVjdGlvbnMoMSk7IH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInRvdXBwZXJjYXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvIHVwcGVyY2FzZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1VXCIsIFwiQ3RybC1VXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci50b1VwcGVyQ2FzZSgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInRvbG93ZXJjYXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvIGxvd2VyY2FzZVwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1VXCIsIFwiQ3RybC1TaGlmdC1VXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImF1dG9pbmRlbnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQXV0byBJbmRlbnRcIixcbiAgICAgICAgYmluZEtleTogYmluZEtleShudWxsLCBudWxsKSxcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuYXV0b0luZGVudCgpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCJcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZXhwYW5kdG9saW5lXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkV4cGFuZCB0byBsaW5lXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUxcIiwgXCJDb21tYW5kLVNoaWZ0LUxcIiksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdysrO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJvcGVubGlua1wiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybCtGM1wiLCBcIkYzXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5vcGVuTGluaygpOyB9XG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImpvaW5saW5lc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKb2luIGxpbmVzXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBpc0JhY2t3YXJkcyA9IGVkaXRvci5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGlzQmFja3dhcmRzID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25MZWFkKCkgOiBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkFuY2hvcigpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGlzQmFja3dhcmRzID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25BbmNob3IoKSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uTGVhZCgpO1xuICAgICAgICAgICAgdmFyIGZpcnN0TGluZUVuZENvbCA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKHNlbGVjdGlvblN0YXJ0LnJvdykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRUZXh0LnJlcGxhY2UoL1xcblxccyovLCBcIiBcIikubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluc2VydExpbmUgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGluZShzZWxlY3Rpb25TdGFydC5yb3cpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGVjdGlvblN0YXJ0LnJvdyArIDE7IGkgPD0gc2VsZWN0aW9uRW5kLnJvdyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJMaW5lID0gbGFuZy5zdHJpbmdUcmltTGVmdChsYW5nLnN0cmluZ1RyaW1SaWdodChlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGluZShpKSkpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJMaW5lLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID0gXCIgXCIgKyBjdXJMaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnRMaW5lICs9IGN1ckxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRW5kLnJvdyArIDEgPCAoZWRpdG9yLnNlc3Npb24uZG9jLmdldExlbmd0aCgpIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRMaW5lICs9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLmRvYy5yZXBsYWNlKG5ldyBSYW5nZShzZWxlY3Rpb25TdGFydC5yb3csIDAsIHNlbGVjdGlvbkVuZC5yb3cgKyAyLCAwKSwgaW5zZXJ0TGluZSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVDdXJzb3JUbyhzZWxlY3Rpb25TdGFydC5yb3csIHNlbGVjdGlvblN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RUbyhzZWxlY3Rpb25TdGFydC5yb3csIHNlbGVjdGlvblN0YXJ0LmNvbHVtbiArIHNlbGVjdGVkQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RMaW5lRW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoc2VsZWN0aW9uU3RhcnQucm93KS5sZW5ndGggPiBmaXJzdExpbmVFbmRDb2wgPyAoZmlyc3RMaW5lRW5kQ29sICsgMSkgOiBmaXJzdExpbmVFbmRDb2w7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8oc2VsZWN0aW9uU3RhcnQucm93LCBmaXJzdExpbmVFbmRDb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImludmVydFNlbGVjdGlvblwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnZlcnQgc2VsZWN0aW9uXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBlbmRSb3cgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICAgICAgdmFyIGVuZENvbCA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKGVuZFJvdykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGVkaXRvci5zZWxlY3Rpb24ucmFuZ2VMaXN0LnJhbmdlcztcbiAgICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJhbmdlcyA9IFtlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAocmFuZ2VzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJhbmdlc1tpXS5lbmQucm93ID09PSBlbmRSb3cgJiYgcmFuZ2VzW2ldLmVuZC5jb2x1bW4gPT09IGVuZENvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ldyBSYW5nZShyYW5nZXNbaV0uZW5kLnJvdywgcmFuZ2VzW2ldLmVuZC5jb2x1bW4sIGVuZFJvdywgZW5kQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PT0gMCAmJiByYW5nZXNbaV0uc3RhcnQuY29sdW1uID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKDAsIDAsIHJhbmdlc1tpXS5zdGFydC5yb3csIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKHJhbmdlc1tpIC0gMV0uZW5kLnJvdywgcmFuZ2VzW2kgLSAxXS5lbmQuY29sdW1uLCByYW5nZXNbaV0uc3RhcnQucm93LCByYW5nZXNbaV0uc3RhcnQuY29sdW1uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTtcbiAgICAgICAgICAgIGVkaXRvci5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1Jhbmdlc1tpXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwibm9uZVwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImFkZExpbmVBZnRlclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBZGQgbmV3IGxpbmUgYWZ0ZXIgdGhlIGN1cnJlbnQgbGluZVwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBlZGl0b3IubmF2aWdhdGVMaW5lRW5kKCk7XG4gICAgICAgICAgICBlZGl0b3IuaW5zZXJ0KFwiXFxuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImFkZExpbmVCZWZvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkIG5ldyBsaW5lIGJlZm9yZSB0aGUgY3VycmVudCBsaW5lXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvKGN1cnNvci5yb3cgLSAxLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnQoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnJvdyA9PT0gMClcbiAgICAgICAgICAgICAgICBlZGl0b3IubmF2aWdhdGVVcCgpO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcIm9wZW5Db21tYW5kUGFsbGV0ZVwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIGFuIG9ic29sZXRlIGNvbW1hbmQuIFBsZWFzZSB1c2UgYG9wZW5Db21tYW5kUGFsZXR0ZWAgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlZGl0b3IucHJvbXB0KHsgJHR5cGU6IFwiY29tbWFuZHNcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwib3BlbkNvbW1hbmRQYWxldHRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk9wZW4gY29tbWFuZCBwYWxldHRlXCIsXG4gICAgICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJGMVwiLCBcIkYxXCIpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3IucHJvbXB0KHsgJHR5cGU6IFwiY29tbWFuZHNcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwibW9kZVNlbGVjdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDaGFuZ2UgbGFuZ3VhZ2UgbW9kZS4uLlwiLFxuICAgICAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIG51bGwpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3IucHJvbXB0KHsgJHR5cGU6IFwibW9kZXNcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9XTtcbmZvciAodmFyIGkgPSAxOyBpIDwgOTsgaSsrKSB7XG4gICAgZXhwb3J0cy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgbmFtZTogXCJmb2xkVG9MZXZlbFwiICsgaSxcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRm9sZCBUbyBMZXZlbCBcIiArIGksXG4gICAgICAgIGxldmVsOiBpLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLmZvbGRUb0xldmVsKHRoaXMubGV2ZWwpOyB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9KTtcbn1cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uva2V5Ym9hcmQvZ3V0dGVyX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIva2V5c1wiLFwiYWNlL21vdXNlL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4uL2xpYi9rZXlzJyk7XG52YXIgR3V0dGVyVG9vbHRpcCA9IHJlcXVpcmUoXCIuLi9tb3VzZS9kZWZhdWx0X2d1dHRlcl9oYW5kbGVyXCIpLkd1dHRlclRvb2x0aXA7XG52YXIgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd1dHRlcktleWJvYXJkSGFuZGxlcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZ3V0dGVyTGF5ZXIgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlcjtcbiAgICAgICAgdGhpcy5saW5lcyA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuJGxpbmVzO1xuICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVMYW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uVG9vbHRpcCA9IG5ldyBHdXR0ZXJUb29sdGlwKHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuJG9uR3V0dGVyS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiRibHVyR3V0dGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcIm1vdXNld2hlZWxcIiwgdGhpcy4kYmx1ckd1dHRlci5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiRvbkd1dHRlcktleURvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4kYmx1ckd1dHRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwibW91c2V3aGVlbFwiLCB0aGlzLiRibHVyR3V0dGVyLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kb25HdXR0ZXJLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvblRvb2x0aXAuaXNPcGVuKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wiZXNjYXBlXCJdKVxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvblRvb2x0aXAuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPSBrZXlzW1wiZW50ZXJcIl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKS5yb3c7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmlzUm93VmlzaWJsZShyb3cpKVxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNjcm9sbFRvTGluZShyb3csIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRyb3dUb1Jvd0luZGV4KHRoaXMuZ3V0dGVyTGF5ZXIuJGN1cnNvckNlbGwucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgbmVhcmVzdEZvbGRJbmRleCA9IHRoaXMuJGZpbmROZWFyZXN0Rm9sZFdpZGdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIG5lYXJlc3RBbm5vdGF0aW9uSW5kZXggPSB0aGlzLiRmaW5kTmVhcmVzdEFubm90YXRpb24oaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0Rm9sZEluZGV4ID09PSBudWxsICYmIG5lYXJlc3RBbm5vdGF0aW9uSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdEZvbGRJbmRleCA9PT0gbnVsbCAmJiBuZWFyZXN0QW5ub3RhdGlvbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBuZWFyZXN0QW5ub3RhdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBcImFubm90YXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0Rm9sZEluZGV4ICE9PSBudWxsICYmIG5lYXJlc3RBbm5vdGF0aW9uSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IG5lYXJlc3RGb2xkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGFuZSA9IFwiZm9sZFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0ZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5lYXJlc3RBbm5vdGF0aW9uSW5kZXggLSBpbmRleCkgPCBNYXRoLmFicyhuZWFyZXN0Rm9sZEluZGV4IC0gaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBuZWFyZXN0QW5ub3RhdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxhbmUgPSBcImFubm90YXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gbmVhcmVzdEZvbGRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVMYW5lID0gXCJmb2xkXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGhhbmRsZUd1dHRlcktleWJvYXJkSW50ZXJhY3Rpb24oZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuX3NpZ25hbChcImd1dHRlcmtleWRvd25cIiwgbmV3IEd1dHRlcktleWJvYXJkRXZlbnQoZSwgdGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDEwKTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGhhbmRsZUd1dHRlcktleWJvYXJkSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1widGFiXCJdKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5c1tcImVzY2FwZVwiXSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4kYmx1ckd1dHRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmxhbmUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleXNbXCJ1cFwiXSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZUxhbmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtb3ZlRm9sZFdpZGdldFVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1vdmVBbm5vdGF0aW9uVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5c1tcImRvd25cIl0pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmVMYW5lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW92ZUZvbGRXaWRnZXREb3duKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1vdmVBbm5vdGF0aW9uRG93bigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wibGVmdFwiXSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4kc3dpdGNoTGFuZShcImFubm90YXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5c1tcInJpZ2h0XCJdKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRzd2l0Y2hMYW5lKFwiZm9sZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzW1wiZW50ZXJcIl0gfHwgZS5rZXlDb2RlID09PSBrZXlzW1wic3BhY2VcIl0pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmVMYW5lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3V0dGVyTGF5ZXIuc2Vzc2lvbi5mb2xkV2lkZ2V0c1t0aGlzLiRyb3dJbmRleFRvUm93KHRoaXMuYWN0aXZlUm93SW5kZXgpXSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0ZvbGRpbmdXaWRnZXQgPSB0aGlzLiRyb3dJbmRleFRvUm93KHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2Vzc2lvbi5vbkZvbGRXaWRnZXRDbGljayh0aGlzLiRyb3dJbmRleFRvUm93KHRoaXMuYWN0aXZlUm93SW5kZXgpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJHJvd0luZGV4VG9Sb3codGhpcy5hY3RpdmVSb3dJbmRleCkgIT09IHJvd0ZvbGRpbmdXaWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kYmx1ckZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSB0aGlzLiRyb3dUb1Jvd0luZGV4KHJvd0ZvbGRpbmdXaWRnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0ZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmd1dHRlckxheWVyLnNlc3Npb24uZm9sZFdpZGdldHNbdGhpcy4kcm93SW5kZXhUb1Jvdyh0aGlzLmFjdGl2ZVJvd0luZGV4KV0gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1dHRlckVsZW1lbnQgPSB0aGlzLmxpbmVzLmNlbGxzW3RoaXMuYWN0aXZlUm93SW5kZXhdLmVsZW1lbnQuY2hpbGROb2Rlc1syXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBndXR0ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmFubm90YXRpb25Ub29sdGlwLmdldEVsZW1lbnQoKS5zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IHJlY3QucmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IHJlY3QuYm90dG9tICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRpb25Ub29sdGlwLnNob3dUb29sdGlwKHRoaXMuJHJvd0luZGV4VG9Sb3codGhpcy5hY3RpdmVSb3dJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kYmx1ckd1dHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUm93SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmVMYW5lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYmx1ckZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGJsdXJBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uVG9vbHRpcC5pc09wZW4pXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25Ub29sdGlwLmhpZGVUb29sdGlwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGlzRm9sZFdpZGdldFZpc2libGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGlzUm93RnVsbHlWaXNpYmxlID0gdGhpcy5lZGl0b3IuaXNSb3dGdWxseVZpc2libGUodGhpcy4kcm93SW5kZXhUb1JvdyhpbmRleCkpO1xuICAgICAgICB2YXIgaXNJY29uVmlzaWJsZSA9IHRoaXMuJGdldEZvbGRXaWRnZXQoaW5kZXgpLnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gaXNSb3dGdWxseVZpc2libGUgJiYgaXNJY29uVmlzaWJsZTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGlzQW5ub3RhdGlvblZpc2libGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGlzUm93RnVsbHlWaXNpYmxlID0gdGhpcy5lZGl0b3IuaXNSb3dGdWxseVZpc2libGUodGhpcy4kcm93SW5kZXhUb1JvdyhpbmRleCkpO1xuICAgICAgICB2YXIgaXNJY29uVmlzaWJsZSA9IHRoaXMuJGdldEFubm90YXRpb24oaW5kZXgpLnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gaXNSb3dGdWxseVZpc2libGUgJiYgaXNJY29uVmlzaWJsZTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGdldEZvbGRXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmxpbmVzLmdldChpbmRleCk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY2VsbC5lbGVtZW50O1xuICAgICAgICByZXR1cm4gZWxlbWVudC5jaGlsZE5vZGVzWzFdO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kZ2V0QW5ub3RhdGlvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMubGluZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjZWxsLmVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkTm9kZXNbMl07XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRmaW5kTmVhcmVzdEZvbGRXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRm9sZFdpZGdldFZpc2libGUoaW5kZXgpKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCAtIGkgPiAwIHx8IGluZGV4ICsgaSA8IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaW5kZXggLSBpID49IDAgJiYgdGhpcy4kaXNGb2xkV2lkZ2V0VmlzaWJsZShpbmRleCAtIGkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAtIGk7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyBpIDw9IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxICYmIHRoaXMuJGlzRm9sZFdpZGdldFZpc2libGUoaW5kZXggKyBpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kZmluZE5lYXJlc3RBbm5vdGF0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLiRpc0Fubm90YXRpb25WaXNpYmxlKGluZGV4KSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggLSBpID4gMCB8fCBpbmRleCArIGkgPCB0aGlzLmxpbmVzLmdldExlbmd0aCgpIC0gMSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGluZGV4IC0gaSA+PSAwICYmIHRoaXMuJGlzQW5ub3RhdGlvblZpc2libGUoaW5kZXggLSBpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggLSBpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICsgaSA8PSB0aGlzLmxpbmVzLmdldExlbmd0aCgpIC0gMSAmJiB0aGlzLiRpc0Fubm90YXRpb25WaXNpYmxlKGluZGV4ICsgaSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGZvY3VzRm9sZFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZvbGRXaWRnZXQgPSB0aGlzLiRnZXRGb2xkV2lkZ2V0KGluZGV4KTtcbiAgICAgICAgZm9sZFdpZGdldC5jbGFzc0xpc3QuYWRkKHRoaXMuZWRpdG9yLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICBmb2xkV2lkZ2V0LmZvY3VzKCk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRmb2N1c0Fubm90YXRpb24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy4kZ2V0QW5ub3RhdGlvbihpbmRleCk7XG4gICAgICAgIGFubm90YXRpb24uY2xhc3NMaXN0LmFkZCh0aGlzLmVkaXRvci5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lKTtcbiAgICAgICAgYW5ub3RhdGlvbi5mb2N1cygpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kYmx1ckZvbGRXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGZvbGRXaWRnZXQgPSB0aGlzLiRnZXRGb2xkV2lkZ2V0KGluZGV4KTtcbiAgICAgICAgZm9sZFdpZGdldC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZWRpdG9yLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICBmb2xkV2lkZ2V0LmJsdXIoKTtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJGJsdXJBbm5vdGF0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy4kZ2V0QW5ub3RhdGlvbihpbmRleCk7XG4gICAgICAgIGFubm90YXRpb24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmVkaXRvci5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lKTtcbiAgICAgICAgYW5ub3RhdGlvbi5ibHVyKCk7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRtb3ZlRm9sZFdpZGdldFVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFjdGl2ZVJvd0luZGV4O1xuICAgICAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGlzRm9sZFdpZGdldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmx1ckZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzRm9sZFdpZGdldCh0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kbW92ZUZvbGRXaWRnZXREb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFjdGl2ZVJvd0luZGV4O1xuICAgICAgICB3aGlsZSAoaW5kZXggPCB0aGlzLmxpbmVzLmdldExlbmd0aCgpIC0gMSkge1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLiRpc0ZvbGRXaWRnZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGJsdXJGb2xkV2lkZ2V0KHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0ZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIEd1dHRlcktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUuJG1vdmVBbm5vdGF0aW9uVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWN0aXZlUm93SW5kZXg7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICBpZiAodGhpcy4kaXNBbm5vdGF0aW9uVmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRibHVyQW5ub3RhdGlvbih0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9jdXNBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEhhbmRsZXIucHJvdG90eXBlLiRtb3ZlQW5ub3RhdGlvbkRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWN0aXZlUm93SW5kZXg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHRoaXMubGluZXMuZ2V0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGlzQW5ub3RhdGlvblZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmx1ckFubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvY3VzQW5ub3RhdGlvbih0aGlzLmFjdGl2ZVJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kc3dpdGNoTGFuZSA9IGZ1bmN0aW9uIChkZXNpbmF0aW9uTGFuZSkge1xuICAgICAgICBzd2l0Y2ggKGRlc2luYXRpb25MYW5lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUxhbmUgPT09IFwiYW5ub3RhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluZGV4ID0gdGhpcy4kZmluZE5lYXJlc3RBbm5vdGF0aW9uKHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVMYW5lID0gXCJhbm5vdGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmx1ckZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGFubm90YXRpb25JbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0Fubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9sZFwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUxhbmUgPT09IFwiZm9sZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZm9sZFdpZGdldEluZGV4ID0gdGhpcy4kZmluZE5lYXJlc3RGb2xkV2lkZ2V0KHRoaXMuYWN0aXZlUm93SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChmb2xkV2lkZ2V0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVMYW5lID0gXCJmb2xkXCI7XG4gICAgICAgICAgICAgICAgdGhpcy4kYmx1ckFubm90YXRpb24odGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3dJbmRleCA9IGZvbGRXaWRnZXRJbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRmb2N1c0ZvbGRXaWRnZXQodGhpcy5hY3RpdmVSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kcm93SW5kZXhUb1JvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMubGluZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgaWYgKGNlbGwpXG4gICAgICAgICAgICByZXR1cm4gY2VsbC5yb3c7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZS4kcm93VG9Sb3dJbmRleCA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmdldExlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5saW5lcy5nZXQoaSk7XG4gICAgICAgICAgICBpZiAoY2VsbC5yb3cgPT0gcm93KVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEd1dHRlcktleWJvYXJkSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkd1dHRlcktleWJvYXJkSGFuZGxlciA9IEd1dHRlcktleWJvYXJkSGFuZGxlcjtcbnZhciBHdXR0ZXJLZXlib2FyZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd1dHRlcktleWJvYXJkRXZlbnQoZG9tRXZlbnQsIGd1dHRlcktleWJvYXJkSGFuZGxlcikge1xuICAgICAgICB0aGlzLmd1dHRlcktleWJvYXJkSGFuZGxlciA9IGd1dHRlcktleWJvYXJkSGFuZGxlcjtcbiAgICAgICAgdGhpcy5kb21FdmVudCA9IGRvbUV2ZW50O1xuICAgIH1cbiAgICBHdXR0ZXJLZXlib2FyZEV2ZW50LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXlzLmtleUNvZGVUb1N0cmluZyh0aGlzLmRvbUV2ZW50LmtleUNvZGUpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ndXR0ZXJLZXlib2FyZEhhbmRsZXIuJHJvd0luZGV4VG9Sb3codGhpcy5ndXR0ZXJLZXlib2FyZEhhbmRsZXIuYWN0aXZlUm93SW5kZXgpO1xuICAgIH07XG4gICAgR3V0dGVyS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUuaXNJbkFubm90YXRpb25MYW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ndXR0ZXJLZXlib2FyZEhhbmRsZXIuYWN0aXZlTGFuZSA9PT0gXCJhbm5vdGF0aW9uXCI7XG4gICAgfTtcbiAgICBHdXR0ZXJLZXlib2FyZEV2ZW50LnByb3RvdHlwZS5pc0luRm9sZExhbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd1dHRlcktleWJvYXJkSGFuZGxlci5hY3RpdmVMYW5lID09PSBcImZvbGRcIjtcbiAgICB9O1xuICAgIHJldHVybiBHdXR0ZXJLZXlib2FyZEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuR3V0dGVyS2V5Ym9hcmRFdmVudCA9IEd1dHRlcktleWJvYXJkRXZlbnQ7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2VkaXRvclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2Uva2V5Ym9hcmQvdGV4dGlucHV0XCIsXCJhY2UvbW91c2UvbW91c2VfaGFuZGxlclwiLFwiYWNlL21vdXNlL2ZvbGRfaGFuZGxlclwiLFwiYWNlL2tleWJvYXJkL2tleWJpbmRpbmdcIixcImFjZS9lZGl0X3Nlc3Npb25cIixcImFjZS9zZWFyY2hcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvY29tbWFuZHMvY29tbWFuZF9tYW5hZ2VyXCIsXCJhY2UvY29tbWFuZHMvZGVmYXVsdF9jb21tYW5kc1wiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsXCJhY2Uva2V5Ym9hcmQvZ3V0dGVyX2hhbmRsZXJcIixcImFjZS9jb25maWdcIixcImFjZS9jbGlwYm9hcmRcIixcImFjZS9saWIva2V5c1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuL2xpYi91c2VyYWdlbnRcIik7XG52YXIgVGV4dElucHV0ID0gcmVxdWlyZShcIi4va2V5Ym9hcmQvdGV4dGlucHV0XCIpLlRleHRJbnB1dDtcbnZhciBNb3VzZUhhbmRsZXIgPSByZXF1aXJlKFwiLi9tb3VzZS9tb3VzZV9oYW5kbGVyXCIpLk1vdXNlSGFuZGxlcjtcbnZhciBGb2xkSGFuZGxlciA9IHJlcXVpcmUoXCIuL21vdXNlL2ZvbGRfaGFuZGxlclwiKS5Gb2xkSGFuZGxlcjtcbnZhciBLZXlCaW5kaW5nID0gcmVxdWlyZShcIi4va2V5Ym9hcmQva2V5YmluZGluZ1wiKS5LZXlCaW5kaW5nO1xudmFyIEVkaXRTZXNzaW9uID0gcmVxdWlyZShcIi4vZWRpdF9zZXNzaW9uXCIpLkVkaXRTZXNzaW9uO1xudmFyIFNlYXJjaCA9IHJlcXVpcmUoXCIuL3NlYXJjaFwiKS5TZWFyY2g7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgQ29tbWFuZE1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcIikuQ29tbWFuZE1hbmFnZXI7XG52YXIgZGVmYXVsdENvbW1hbmRzID0gcmVxdWlyZShcIi4vY29tbWFuZHMvZGVmYXVsdF9jb21tYW5kc1wiKS5jb21tYW5kcztcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgVG9rZW5JdGVyYXRvciA9IHJlcXVpcmUoXCIuL3Rva2VuX2l0ZXJhdG9yXCIpLlRva2VuSXRlcmF0b3I7XG52YXIgR3V0dGVyS2V5Ym9hcmRIYW5kbGVyID0gcmVxdWlyZShcIi4va2V5Ym9hcmQvZ3V0dGVyX2hhbmRsZXJcIikuR3V0dGVyS2V5Ym9hcmRIYW5kbGVyO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKS5ubHM7XG52YXIgY2xpcGJvYXJkID0gcmVxdWlyZShcIi4vY2xpcGJvYXJkXCIpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzJyk7XG52YXIgRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkaXRvcihyZW5kZXJlciwgc2Vzc2lvbiwgb3B0aW9ucykgeyB0aGlzLnNlc3Npb247XG4gICAgICAgIHRoaXMuJHRvRGVzdHJveSA9IFtdO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcmVuZGVyZXIuZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmlkID0gXCJlZGl0b3JcIiArICgrK0VkaXRvci4kdWlkKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IG5ldyBDb21tYW5kTWFuYWdlcih1c2VyYWdlbnQuaXNNYWMgPyBcIm1hY1wiIDogXCJ3aW5cIiwgZGVmYXVsdENvbW1hbmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dCA9IG5ldyBUZXh0SW5wdXQocmVuZGVyZXIuZ2V0VGV4dEFyZWFDb250YWluZXIoKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHRhcmVhID0gdGhpcy50ZXh0SW5wdXQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy4kbW91c2VIYW5kbGVyID0gbmV3IE1vdXNlSGFuZGxlcih0aGlzKTtcbiAgICAgICAgICAgIG5ldyBGb2xkSGFuZGxlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleUJpbmRpbmcgPSBuZXcgS2V5QmluZGluZyh0aGlzKTtcbiAgICAgICAgdGhpcy4kc2VhcmNoID0gbmV3IFNlYXJjaCgpLnNldCh7XG4gICAgICAgICAgICB3cmFwOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRoaXN0b3J5VHJhY2tlciA9IHRoaXMuJGhpc3RvcnlUcmFja2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29tbWFuZHMub24oXCJleGVjXCIsIHRoaXMuJGhpc3RvcnlUcmFja2VyKTtcbiAgICAgICAgdGhpcy4kaW5pdE9wZXJhdGlvbkxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl8kZW1pdElucHV0RXZlbnQgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImlucHV0XCIsIHt9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgIXRoaXMuc2Vzc2lvbi5kZXN0cm95ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmJnVG9rZW5pemVyLnNjaGVkdWxlU3RhcnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoXywgX3NlbGYpIHtcbiAgICAgICAgICAgIF9zZWxmLl8kZW1pdElucHV0RXZlbnQuc2NoZWR1bGUoMzEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTZXNzaW9uKHNlc3Npb24gfHwgb3B0aW9ucyAmJiBvcHRpb25zLnNlc3Npb24gfHwgbmV3IEVkaXRTZXNzaW9uKFwiXCIpKTtcbiAgICAgICAgY29uZmlnLnJlc2V0T3B0aW9ucyh0aGlzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbmZpZy5fc2lnbmFsKFwiZWRpdG9yXCIsIHRoaXMpO1xuICAgIH1cbiAgICBFZGl0b3IucHJvdG90eXBlLiRpbml0T3BlcmF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLm9uKFwiZXhlY1wiLCB0aGlzLnN0YXJ0T3BlcmF0aW9uLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICB0aGlzLmNvbW1hbmRzLm9uKFwiYWZ0ZXJFeGVjXCIsIHRoaXMuZW5kT3BlcmF0aW9uLmJpbmQodGhpcyksIHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zdGFydE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChjb21tYW5kRXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXJ0T3BlcmF0aW9uKGNvbW1hbmRFdmVudCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5lbmRPcGVyYXRpb24oZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uU3RhcnRPcGVyYXRpb24gPSBmdW5jdGlvbiAoY29tbWFuZEV2ZW50KSB7XG4gICAgICAgIHRoaXMuY3VyT3AgPSB0aGlzLnNlc3Npb24uY3VyT3A7XG4gICAgICAgIHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0gdGhpcy5yZW5kZXJlci5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMucHJldk9wID0gdGhpcy5zZXNzaW9uLnByZXZPcDtcbiAgICAgICAgaWYgKCFjb21tYW5kRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ck9wICYmIHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1ck9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJiZWZvcmVFbmRPcGVyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VyT3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmN1ck9wLmNvbW1hbmQ7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsSW50b1ZpZXcgPSBjb21tYW5kICYmIGNvbW1hbmQuc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjZW50ZXItYW5pbWF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSBcImFuaW1hdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbmltYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjdXJzb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0aW9uUGFydFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLnJlbmRlcmVyLmxheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA+PSBjb25maWcubGFzdFJvdyB8fCByYW5nZS5lbmQucm93IDw9IGNvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcodGhpcy5zZWxlY3Rpb24uYW5jaG9yLCB0aGlzLnNlbGVjdGlvbi5sZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxJbnRvVmlldyA9PSBcImFuaW1hdGVcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hbmltYXRlU2Nyb2xsaW5nKHRoaXMuY3VyT3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGxhc3RTZWwgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLnRvSlNPTigpO1xuICAgICAgICAgICAgdGhpcy5wcmV2T3AgPSB0aGlzLmN1ck9wO1xuICAgICAgICAgICAgdGhpcy5jdXJPcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGhpc3RvcnlUcmFja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRtZXJnZVVuZG9EZWx0YXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2T3A7XG4gICAgICAgIHZhciBtZXJnZWFibGVDb21tYW5kcyA9IHRoaXMuJG1lcmdlYWJsZUNvbW1hbmRzO1xuICAgICAgICB2YXIgc2hvdWxkTWVyZ2UgPSBwcmV2LmNvbW1hbmQgJiYgKGUuY29tbWFuZC5uYW1lID09IHByZXYuY29tbWFuZC5uYW1lKTtcbiAgICAgICAgaWYgKGUuY29tbWFuZC5uYW1lID09IFwiaW5zZXJ0c3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZS5hcmdzO1xuICAgICAgICAgICAgaWYgKHRoaXMubWVyZ2VOZXh0Q29tbWFuZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VOZXh0Q29tbWFuZCA9IHRydWU7XG4gICAgICAgICAgICBzaG91bGRNZXJnZSA9IHNob3VsZE1lcmdlXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5tZXJnZU5leHRDb21tYW5kIC8vIHByZXZpb3VzIGNvbW1hbmQgYWxsb3dzIHRvIGNvYWxlc2NlIHdpdGhcbiAgICAgICAgICAgICAgICAmJiAoIS9cXHMvLnRlc3QodGV4dCkgfHwgL1xccy8udGVzdChwcmV2LmFyZ3MpKTsgLy8gcHJldmlvdXMgaW5zZXJ0aW9uIHdhcyBvZiBzYW1lIHR5cGVcbiAgICAgICAgICAgIHRoaXMubWVyZ2VOZXh0Q29tbWFuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaG91bGRNZXJnZSA9IHNob3VsZE1lcmdlXG4gICAgICAgICAgICAgICAgJiYgbWVyZ2VhYmxlQ29tbWFuZHMuaW5kZXhPZihlLmNvbW1hbmQubmFtZSkgIT09IC0xOyAvLyB0aGUgY29tbWFuZCBpcyBtZXJnZWFibGVcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kbWVyZ2VVbmRvRGVsdGFzICE9IFwiYWx3YXlzXCJcbiAgICAgICAgICAgICYmIERhdGUubm93KCkgLSB0aGlzLnNlcXVlbmNlU3RhcnRUaW1lID4gMjAwMCkge1xuICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBmYWxzZTsgLy8gdGhlIHNlcXVlbmNlIGlzIHRvbyBsb25nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lcmdlKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm1lcmdlVW5kb0RlbHRhcyA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKG1lcmdlYWJsZUNvbW1hbmRzLmluZGV4T2YoZS5jb21tYW5kLm5hbWUpICE9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbiAoa2V5Ym9hcmRIYW5kbGVyLCBjYikge1xuICAgICAgICBpZiAoa2V5Ym9hcmRIYW5kbGVyICYmIHR5cGVvZiBrZXlib2FyZEhhbmRsZXIgPT09IFwic3RyaW5nXCIgJiYga2V5Ym9hcmRIYW5kbGVyICE9IFwiYWNlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuJGtleWJpbmRpbmdJZCA9IGtleWJvYXJkSGFuZGxlcjtcbiAgICAgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25maWcubG9hZE1vZHVsZShbXCJrZXliaW5kaW5nXCIsIGtleWJvYXJkSGFuZGxlcl0sIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3NlbGYuJGtleWJpbmRpbmdJZCA9PSBrZXlib2FyZEhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgIF9zZWxmLmtleUJpbmRpbmcuc2V0S2V5Ym9hcmRIYW5kbGVyKG1vZHVsZSAmJiBtb2R1bGUuaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4ka2V5YmluZGluZ0lkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5QmluZGluZy5zZXRLZXlib2FyZEhhbmRsZXIoa2V5Ym9hcmRIYW5kbGVyKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlCaW5kaW5nLmdldEtleWJvYXJkSGFuZGxlcigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PSBzZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jdXJPcClcbiAgICAgICAgICAgIHRoaXMuZW5kT3BlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMuY3VyT3AgPSB7fTtcbiAgICAgICAgdmFyIG9sZFNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChvbGRTZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlXCIsIHRoaXMuJG9uRG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZU1vZGVcIiwgdGhpcy4kb25DaGFuZ2VNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJ0b2tlbml6ZXJVcGRhdGVcIiwgdGhpcy4kb25Ub2tlbml6ZXJVcGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZVRhYlNpemVcIiwgdGhpcy4kb25DaGFuZ2VUYWJTaXplKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VXcmFwTGltaXRcIiwgdGhpcy4kb25DaGFuZ2VXcmFwTGltaXQpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZVdyYXBNb2RlXCIsIHRoaXMuJG9uQ2hhbmdlV3JhcE1vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZUZvbGRcIiwgdGhpcy4kb25DaGFuZ2VGb2xkKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VGcm9udE1hcmtlclwiLCB0aGlzLiRvbkNoYW5nZUZyb250TWFya2VyKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VCYWNrTWFya2VyXCIsIHRoaXMuJG9uQ2hhbmdlQmFja01hcmtlcik7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB0aGlzLiRvbkNoYW5nZUJyZWFrcG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZUFubm90YXRpb25cIiwgdGhpcy4kb25DaGFuZ2VBbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vZmYoXCJjaGFuZ2VPdmVyd3JpdGVcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZVNjcm9sbFRvcFwiLCB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub2ZmKFwiY2hhbmdlU2Nyb2xsTGVmdFwiLCB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcInN0YXJ0T3BlcmF0aW9uXCIsIHRoaXMuJG9uU3RhcnRPcGVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImVuZE9wZXJhdGlvblwiLCB0aGlzLiRvbkVuZE9wZXJhdGlvbik7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZXNzaW9uLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLm9mZihcImNoYW5nZUN1cnNvclwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy4kb25Eb2N1bWVudENoYW5nZSA9IHRoaXMub25Eb2N1bWVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbihcImNoYW5nZVwiLCB0aGlzLiRvbkRvY3VtZW50Q2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSA9IHRoaXMub25DaGFuZ2VNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlTW9kZVwiLCB0aGlzLiRvbkNoYW5nZU1vZGUpO1xuICAgICAgICAgICAgdGhpcy4kb25Ub2tlbml6ZXJVcGRhdGUgPSB0aGlzLm9uVG9rZW5pemVyVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwidG9rZW5pemVyVXBkYXRlXCIsIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlVGFiU2l6ZSA9IHRoaXMucmVuZGVyZXIub25DaGFuZ2VUYWJTaXplLmJpbmQodGhpcy5yZW5kZXJlcik7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlVGFiU2l6ZVwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VXcmFwTGltaXQgPSB0aGlzLm9uQ2hhbmdlV3JhcExpbWl0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlV3JhcExpbWl0XCIsIHRoaXMuJG9uQ2hhbmdlV3JhcExpbWl0KTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlV3JhcE1vZGUgPSB0aGlzLm9uQ2hhbmdlV3JhcE1vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oXCJjaGFuZ2VXcmFwTW9kZVwiLCB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlRm9sZCA9IHRoaXMub25DaGFuZ2VGb2xkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKFwiY2hhbmdlRm9sZFwiLCB0aGlzLiRvbkNoYW5nZUZvbGQpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlciA9IHRoaXMub25DaGFuZ2VGcm9udE1hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlRnJvbnRNYXJrZXJcIiwgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlcik7XG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIgPSB0aGlzLm9uQ2hhbmdlQmFja01hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlQmFja01hcmtlclwiLCB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50ID0gdGhpcy5vbkNoYW5nZUJyZWFrcG9pbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZUJyZWFrcG9pbnRcIiwgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50KTtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbiA9IHRoaXMub25DaGFuZ2VBbm5vdGF0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJjaGFuZ2VBbm5vdGF0aW9uXCIsIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbik7XG4gICAgICAgICAgICB0aGlzLiRvbkN1cnNvckNoYW5nZSA9IHRoaXMub25DdXJzb3JDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZU92ZXJ3cml0ZVwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSA9IHRoaXMub25TY3JvbGxUb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZVNjcm9sbFRvcFwiLCB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UgPSB0aGlzLm9uU2Nyb2xsTGVmdENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlU2Nyb2xsTGVmdFwiLCB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZXNzaW9uLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ub24oXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRvblN0YXJ0T3BlcmF0aW9uID0gdGhpcy5vblN0YXJ0T3BlcmF0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJzdGFydE9wZXJhdGlvblwiLCB0aGlzLiRvblN0YXJ0T3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuJG9uRW5kT3BlcmF0aW9uID0gdGhpcy5vbkVuZE9wZXJhdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiZW5kT3BlcmF0aW9uXCIsIHRoaXMuJG9uRW5kT3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VNb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ3Vyc29yQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLm9uU2Nyb2xsVG9wQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLm9uU2Nyb2xsTGVmdENoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUZyb250TWFya2VyKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQmFja01hcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUJyZWFrcG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSAmJiB0aGlzLnJlbmRlcmVyLmFkanVzdFdyYXBMaW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVGdWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlU2Vzc2lvblwiLCB7XG4gICAgICAgICAgICBzZXNzaW9uOiBzZXNzaW9uLFxuICAgICAgICAgICAgb2xkU2Vzc2lvbjogb2xkU2Vzc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJPcCA9IG51bGw7XG4gICAgICAgIG9sZFNlc3Npb24gJiYgb2xkU2Vzc2lvbi5fc2lnbmFsKFwiY2hhbmdlRWRpdG9yXCIsIHsgb2xkRWRpdG9yOiB0aGlzIH0pO1xuICAgICAgICBpZiAob2xkU2Vzc2lvbilcbiAgICAgICAgICAgIG9sZFNlc3Npb24uJGVkaXRvciA9IG51bGw7XG4gICAgICAgIHNlc3Npb24gJiYgc2Vzc2lvbi5fc2lnbmFsKFwiY2hhbmdlRWRpdG9yXCIsIHsgZWRpdG9yOiB0aGlzIH0pO1xuICAgICAgICBpZiAoc2Vzc2lvbilcbiAgICAgICAgICAgIHNlc3Npb24uJGVkaXRvciA9IHRoaXM7XG4gICAgICAgIGlmIChzZXNzaW9uICYmICFzZXNzaW9uLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHNlc3Npb24uYmdUb2tlbml6ZXIuc2NoZWR1bGVTdGFydCgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIGN1cnNvclBvcykge1xuICAgICAgICB0aGlzLnNlc3Npb24uZG9jLnNldFZhbHVlKHZhbCk7XG4gICAgICAgIGlmICghY3Vyc29yUG9zKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yUG9zID09IDEpXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlRmlsZUVuZCgpO1xuICAgICAgICBlbHNlIGlmIChjdXJzb3JQb3MgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlRmlsZVN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFZhbHVlKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblJlc2l6ZShmb3JjZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lLCBjYikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFRoZW1lKHRoZW1lLCBjYik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRUaGVtZSgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUudW5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVuc2V0U3R5bGUoc3R5bGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRGb250U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZm9udFNpemVcIikgfHxcbiAgICAgICAgICAgIGRvbS5jb21wdXRlZFN0eWxlKHRoaXMuY29udGFpbmVyKS5mb250U2l6ZTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0Rm9udFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImZvbnRTaXplXCIsIHNpemUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS4kaGlnaGxpZ2h0QnJhY2tldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRQZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRoaWdobGlnaHRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLiRoaWdobGlnaHRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHNlbGYuc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCBzZXNzaW9uLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uJGJyYWNrZXRIaWdobGlnaHQubWFya2VySWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWxmLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGYuZ2V0S2V5Ym9hcmRIYW5kbGVyKCk7XG4gICAgICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSBoYW5kbGVyICYmIGhhbmRsZXIuJGdldERpcmVjdGlvbkZvckhpZ2hsaWdodCAmJiBoYW5kbGVyLiRnZXREaXJlY3Rpb25Gb3JIaWdobGlnaHQoc2VsZik7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2Vzc2lvbi5nZXRNYXRjaGluZ0JyYWNrZXRSYW5nZXMocG9zLCBpc0JhY2t3YXJkcyk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAmJiAvXFxiKD86dGFnLW9wZW58dGFnLW5hbWUpLy50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lc1JhbmdlcyA9IHNlc3Npb24uZ2V0TWF0Y2hpbmdUYWdzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lc1Jhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWVzUmFuZ2VzLm9wZW5UYWdOYW1lLmlzRW1wdHkoKSA/IHRhZ05hbWVzUmFuZ2VzLm9wZW5UYWcgOiB0YWdOYW1lc1Jhbmdlcy5vcGVuVGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lc1Jhbmdlcy5jbG9zZVRhZ05hbWUuaXNFbXB0eSgpID8gdGFnTmFtZXNSYW5nZXMuY2xvc2VUYWcgOiB0YWdOYW1lc1Jhbmdlcy5jbG9zZVRhZ05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJhbmdlcyAmJiBzZXNzaW9uLiRtb2RlLmdldE1hdGNoaW5nKVxuICAgICAgICAgICAgICAgIHJhbmdlcyA9IHNlc3Npb24uJG1vZGUuZ2V0TWF0Y2hpbmcoc2VsZi5zZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyZXIuJHRleHRMYXllci4kaGlnaGxpZ2h0SW5kZW50R3VpZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFya2VyVHlwZSA9IFwiYWNlX2JyYWNrZXRcIjtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzID0gW3Jhbmdlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJUeXBlID0gXCJhY2VfZXJyb3JfYnJhY2tldFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChSYW5nZS5jb21wYXJlUG9pbnRzKHJhbmdlc1swXS5lbmQsIHJhbmdlc1sxXS5zdGFydCkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1JhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCByYW5nZXNbMV0uZW5kKV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUmFuZ2UuY29tcGFyZVBvaW50cyhyYW5nZXNbMF0uc3RhcnQsIHJhbmdlc1sxXS5lbmQpID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IFtSYW5nZS5mcm9tUG9pbnRzKHJhbmdlc1sxXS5zdGFydCwgcmFuZ2VzWzBdLmVuZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCA9IHtcbiAgICAgICAgICAgICAgICByYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgICAgICBtYXJrZXJJZHM6IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgbWFya2VyVHlwZSwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNlbGYuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCkpXG4gICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJlci4kdGV4dExheWVyLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRleHRJbnB1dC5mb2N1cygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pc0ZvY3VzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRJbnB1dC5pc0ZvY3VzZWQoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZXh0SW5wdXQuYmx1cigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRm9jdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaG93Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudmlzdWFsaXplRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImZvY3VzXCIsIGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGlzRm9jdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnZpc3VhbGl6ZUJsdXIoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImJsdXJcIiwgZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRjdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEJyYWNrZXRzKCk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25Eb2N1bWVudENoYW5nZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgd3JhcCA9IHRoaXMuc2Vzc2lvbi4kdXNlV3JhcE1vZGU7XG4gICAgICAgIHZhciBsYXN0Um93ID0gKGRlbHRhLnN0YXJ0LnJvdyA9PSBkZWx0YS5lbmQucm93ID8gZGVsdGEuZW5kLnJvdyA6IEluZmluaXR5KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVMaW5lcyhkZWx0YS5zdGFydC5yb3csIGxhc3RSb3csIHdyYXApO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgZGVsdGEpO1xuICAgICAgICB0aGlzLiRjdXJzb3JDaGFuZ2UoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25Ub2tlbml6ZXJVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcm93cyA9IGUuZGF0YTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVMaW5lcyhyb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vblNjcm9sbFRvcENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1kodGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25TY3JvbGxMZWZ0Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvWCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0O1xuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0QWN0aXZlTGluZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNlbGVjdGlvblN0eWxlICE9IFwibGluZVwiIHx8ICF0aGlzLnNlbGVjdGlvbi5pc011bHRpTGluZSgpKVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnRoZW1lICYmIHRoaXMucmVuZGVyZXIudGhlbWUuJHNlbGVjdGlvbkNvbG9yQ29uZmxpY3QgJiYgIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLiRtYXhMaW5lcyAmJiB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkgPT09IDEgJiYgISh0aGlzLnJlbmRlcmVyLiRtaW5MaW5lcyA+IDEpKVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyICYmICFoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuaWQpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIgJiYgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoaGlnaGxpZ2h0LnJvdywgaGlnaGxpZ2h0LmNvbHVtbiwgaGlnaGxpZ2h0LnJvdywgSW5maW5pdHkpO1xuICAgICAgICAgICAgcmFuZ2UuaWQgPSBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXCJhY2VfYWN0aXZlLWxpbmVcIiwgXCJzY3JlZW5MaW5lXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5zdGFydC5yb3cgPSBoaWdobGlnaHQucm93O1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5lbmQucm93ID0gaGlnaGxpZ2h0LnJvdztcbiAgICAgICAgICAgIHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuc3RhcnQuY29sdW1uID0gaGlnaGxpZ2h0LmNvbHVtbjtcbiAgICAgICAgICAgIHNlc3Npb24uX3NpZ25hbChcImNoYW5nZUJhY2tNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25TZWxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGUoKTtcbiAgICAgICAgICAgIHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlciA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9zZWxlY3Rpb25cIiwgc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZSA9IHRoaXMuJGhpZ2hsaWdodFNlbGVjdGVkV29yZCAmJiB0aGlzLiRnZXRTZWxlY3Rpb25IaWdoTGlnaHRSZWdleHAoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmhpZ2hsaWdodChyZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGdldFNlbGVjdGlvbkhpZ2hMaWdodFJlZ2V4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uaXNFbXB0eSgpIHx8IHNlbGVjdGlvbi5pc011bHRpTGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBzZWxlY3Rpb24uc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2VsZWN0aW9uLmVuZC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHNlbGVjdGlvbi5zdGFydC5yb3cpO1xuICAgICAgICB2YXIgbmVlZGxlID0gbGluZS5zdWJzdHJpbmcoc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChuZWVkbGUubGVuZ3RoID4gNTAwMCB8fCAhL1tcXHdcXGRdLy50ZXN0KG5lZWRsZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByZSA9IHRoaXMuJHNlYXJjaC4kYXNzZW1ibGVSZWdFeHAoe1xuICAgICAgICAgICAgd2hvbGVXb3JkOiB0cnVlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRsZTogbmVlZGxlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgd29yZFdpdGhCb3VuZGFyeSA9IGxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uIC0gMSwgZW5kQ29sdW1uICsgMSk7XG4gICAgICAgIGlmICghcmUudGVzdCh3b3JkV2l0aEJvdW5kYXJ5KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHJlO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUZyb250TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUZyb250TWFya2VycygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUJhY2tNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DaGFuZ2VCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJyZWFrcG9pbnRzKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ2hhbmdlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbm5vdGF0aW9ucyh0aGlzLnNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlTW9kZVwiLCBlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25DaGFuZ2VXcmFwTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZVdyYXBNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uUmVzaXplKHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNoYW5nZUZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0Q29weVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgdmFyIG5sID0gdGhpcy5zZXNzaW9uLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XG4gICAgICAgIHZhciBjb3B5TGluZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRleHQgJiYgdGhpcy4kY29weVdpdGhFbXB0eVNlbGVjdGlvbikge1xuICAgICAgICAgICAgY29weUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgcmFuZ2VzW2kgLSAxXS5zdGFydC5yb3cgPT0gcmFuZ2Uuc3RhcnQucm93KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdykgKyBubDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZSA9IHsgdGV4dDogdGV4dCB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjb3B5XCIsIGUpO1xuICAgICAgICBjbGlwYm9hcmQubGluZU1vZGUgPSBjb3B5TGluZSA/IGUudGV4dCA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gZS50ZXh0O1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImNvcHlcIiwgdGhpcyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uQ3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJjdXRcIiwgdGhpcyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uUGFzdGUgPSBmdW5jdGlvbiAodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGUgPSB7IHRleHQ6IHRleHQsIGV2ZW50OiBldmVudCB9O1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJwYXN0ZVwiLCB0aGlzLCBlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuJGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBlID0geyB0ZXh0OiBlIH07XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInBhc3RlXCIsIGUpO1xuICAgICAgICB2YXIgdGV4dCA9IGUudGV4dDtcbiAgICAgICAgdmFyIGxpbmVNb2RlID0gdGV4dCA9PT0gY2xpcGJvYXJkLmxpbmVNb2RlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCF0aGlzLmluTXVsdGlTZWxlY3RNb2RlIHx8IHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgaWYgKGxpbmVNb2RlKVxuICAgICAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHsgcm93OiB0aGlzLnNlbGVjdGlvbi5sZWFkLnJvdywgY29sdW1uOiAwIH0sIHRleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQoeyByb3c6IHJhbmdlLnN0YXJ0LnJvdywgY29sdW1uOiAwIH0sIHRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgICAgICB2YXIgaXNGdWxsTGluZSA9IGxpbmVzLmxlbmd0aCA9PSAyICYmICghbGluZXNbMF0gfHwgIWxpbmVzWzFdKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggIT0gcmFuZ2VzLmxlbmd0aCB8fCBpc0Z1bGxMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRzdHJpbmdcIiwgdGhpcywgdGV4dCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLnN0YXJ0LCBsaW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5leGVjKGNvbW1hbmQsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodGV4dCwgcGFzdGVkKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgbW9kZSA9IHNlc3Npb24uZ2V0TW9kZSgpO1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5nZXRCZWhhdmlvdXJzRW5hYmxlZCgpICYmICFwYXN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtb2RlLnRyYW5zZm9ybUFjdGlvbihzZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpLCAnaW5zZXJ0aW9uJywgdGhpcywgc2Vzc2lvbiwgdGV4dCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IHRyYW5zZm9ybS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ubWVyZ2VVbmRvRGVsdGFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlTmV4dENvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdHJhbnNmb3JtLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQgPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCkgJiYgdGV4dC5pbmRleE9mKFwiXFxuXCIpID09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGN1cnNvciwgY3Vyc29yKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCA9PSBcIlxcblwiIHx8IHRleHQgPT0gXCJcXHJcXG5cIikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLmNvbHVtbiA+IGxpbmUuc2VhcmNoKC9cXFN8JC8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBsaW5lLnN1YnN0cihjdXJzb3IuY29sdW1uKS5zZWFyY2goL1xcU3wkLyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5kb2MucmVtb3ZlSW5MaW5lKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBzdGFydCA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lU3RhdGUgPSBzZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgdmFyIHNob3VsZE91dGRlbnQgPSBtb2RlLmNoZWNrT3V0ZGVudChsaW5lU3RhdGUsIGxpbmUsIHRleHQpO1xuICAgICAgICBzZXNzaW9uLmluc2VydChjdXJzb3IsIHRleHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0uc2VsZWN0aW9uLmxlbmd0aCA9PSAyKSB7IC8vIFRyYW5zZm9ybSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjb2x1bW5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShuZXcgUmFuZ2UoY3Vyc29yLnJvdywgc3RhcnQgKyB0cmFuc2Zvcm0uc2VsZWN0aW9uWzBdLCBjdXJzb3Iucm93LCBzdGFydCArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBUcmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm93LlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKG5ldyBSYW5nZShjdXJzb3Iucm93ICsgdHJhbnNmb3JtLnNlbGVjdGlvblswXSwgdHJhbnNmb3JtLnNlbGVjdGlvblsxXSwgY3Vyc29yLnJvdyArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMl0sIHRyYW5zZm9ybS5zZWxlY3Rpb25bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kZW5hYmxlQXV0b0luZGVudCkge1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uZ2V0RG9jdW1lbnQoKS5pc05ld0xpbmUodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZUluZGVudCA9IG1vZGUuZ2V0TmV4dExpbmVJbmRlbnQobGluZVN0YXRlLCBsaW5lLnNsaWNlKDAsIGN1cnNvci5jb2x1bW4pLCBzZXNzaW9uLmdldFRhYlN0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydCh7IHJvdzogY3Vyc29yLnJvdyArIDEsIGNvbHVtbjogMCB9LCBsaW5lSW5kZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRPdXRkZW50KVxuICAgICAgICAgICAgICAgIG1vZGUuYXV0b091dGRlbnQobGluZVN0YXRlLCBzZXNzaW9uLCBjdXJzb3Iucm93KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5hdXRvSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIG1vZGUgPSBzZXNzaW9uLmdldE1vZGUoKTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKVxuICAgICAgICAgICAgPyBbbmV3IFJhbmdlKDAsIDAsIHNlc3Npb24uZG9jLmdldExlbmd0aCgpIC0gMSwgMCldXG4gICAgICAgICAgICA6IHRoaXMuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICB2YXIgcHJldkxpbmVTdGF0ZSA9IFwiXCI7XG4gICAgICAgIHZhciBwcmV2TGluZSA9IFwiXCI7XG4gICAgICAgIHZhciBsaW5lSW5kZW50ID0gXCJcIjtcbiAgICAgICAgdmFyIHRhYiA9IHNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZXNbaV0uc3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJhbmdlc1tpXS5lbmQucm93O1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8PSBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkxpbmVTdGF0ZSA9IHNlc3Npb24uZ2V0U3RhdGUocm93IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZMaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lSW5kZW50ID0gbW9kZS5nZXROZXh0TGluZUluZGVudChwcmV2TGluZVN0YXRlLCBwcmV2TGluZSwgdGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckluZGVudCA9IG1vZGUuJGdldEluZGVudChsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUluZGVudCAhPT0gY3VyckluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckluZGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCAwLCByb3csIGN1cnJJbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUluZGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydCh7IHJvdzogcm93LCBjb2x1bW46IDAgfSwgbGluZUluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZS5hdXRvT3V0ZGVudChwcmV2TGluZVN0YXRlLCBzZXNzaW9uLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9uVGV4dElucHV0ID0gZnVuY3Rpb24gKHRleHQsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghY29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlCaW5kaW5nLm9uVGV4dElucHV0KHRleHQpO1xuICAgICAgICB0aGlzLnN0YXJ0T3BlcmF0aW9uKHsgY29tbWFuZDogeyBuYW1lOiBcImluc2VydHN0cmluZ1wiIH0gfSk7XG4gICAgICAgIHZhciBhcHBseUNvbXBvc2l0aW9uID0gdGhpcy5hcHBseUNvbXBvc2l0aW9uLmJpbmQodGhpcywgdGV4dCwgY29tcG9zaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24ucmFuZ2VDb3VudClcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFNlbGVjdGlvbihhcHBseUNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXBwbHlDb21wb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmVuZE9wZXJhdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5hcHBseUNvbXBvc2l0aW9uID0gZnVuY3Rpb24gKHRleHQsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGlvbi5leHRlbmRMZWZ0IHx8IGNvbXBvc2l0aW9uLmV4dGVuZFJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiAtPSBjb21wb3NpdGlvbi5leHRlbmRMZWZ0O1xuICAgICAgICAgICAgci5lbmQuY29sdW1uICs9IGNvbXBvc2l0aW9uLmV4dGVuZFJpZ2h0O1xuICAgICAgICAgICAgaWYgKHIuc3RhcnQuY29sdW1uIDwgMCkge1xuICAgICAgICAgICAgICAgIHIuc3RhcnQucm93LS07XG4gICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gKz0gdGhpcy5zZXNzaW9uLmdldExpbmUoci5zdGFydC5yb3cpLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyKTtcbiAgICAgICAgICAgIGlmICghdGV4dCAmJiAhci5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCB8fCAhdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5pbnNlcnQodGV4dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb21wb3NpdGlvbi5yZXN0b3JlU3RhcnQgfHwgY29tcG9zaXRpb24ucmVzdG9yZUVuZCkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gLT0gY29tcG9zaXRpb24ucmVzdG9yZVN0YXJ0O1xuICAgICAgICAgICAgci5lbmQuY29sdW1uIC09IGNvbXBvc2l0aW9uLnJlc3RvcmVFbmQ7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvbW1hbmRLZXkgPSBmdW5jdGlvbiAoZSwgaGFzaElkLCBrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUJpbmRpbmcub25Db21tYW5kS2V5KGUsIGhhc2hJZCwga2V5Q29kZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChvdmVyd3JpdGUpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldE92ZXJ3cml0ZShvdmVyd3JpdGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRPdmVyd3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvZ2dsZU92ZXJ3cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnRvZ2dsZU92ZXJ3cml0ZSgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInNjcm9sbFNwZWVkXCIsIHNwZWVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0U2Nyb2xsU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNjcm9sbFNwZWVkXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXREcmFnRGVsYXkgPSBmdW5jdGlvbiAoZHJhZ0RlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIsIGRyYWdEZWxheSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldERyYWdEZWxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25TdHlsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzZWxlY3Rpb25TdHlsZVwiLCB2YWwpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25TdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwic2VsZWN0aW9uU3R5bGVcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiaGlnaGxpZ2h0QWN0aXZlTGluZVwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRIaWdobGlnaHRBY3RpdmVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRBY3RpdmVMaW5lXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24gKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodEd1dHRlckxpbmVcIiwgc2hvdWxkSGlnaGxpZ2h0KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiaGlnaGxpZ2h0R3V0dGVyTGluZVwiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0U2VsZWN0ZWRXb3JkID0gZnVuY3Rpb24gKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodFNlbGVjdGVkV29yZFwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZWxlY3RlZFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoaWdobGlnaHRTZWxlY3RlZFdvcmQ7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEFuaW1hdGVkU2Nyb2xsID0gZnVuY3Rpb24gKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbmltYXRlZFNjcm9sbChzaG91bGRBbmltYXRlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0QW5pbWF0ZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldEFuaW1hdGVkU2Nyb2xsKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24gKHNob3dJbnZpc2libGVzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2hvd0ludmlzaWJsZXMoc2hvd0ludmlzaWJsZXMpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTaG93SW52aXNpYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2hvd0ludmlzaWJsZXMoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RGlzcGxheUluZGVudEd1aWRlcyhkaXNwbGF5KTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0RGlzcGxheUluZGVudEd1aWRlcygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRIaWdobGlnaHRJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKGhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEhpZ2hsaWdodEluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uIChzaG93UHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaG93UHJpbnRNYXJnaW4oc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTaG93UHJpbnRNYXJnaW4oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbiAoc2hvd1ByaW50TWFyZ2luKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJpbnRNYXJnaW5Db2x1bW4oc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFByaW50TWFyZ2luQ29sdW1uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKHJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgcmVhZE9ubHkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRSZWFkT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwicmVhZE9ubHlcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJiZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImJlaGF2aW91cnNFbmFibGVkXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcIndyYXBCZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJ3cmFwQmVoYXZpb3Vyc0VuYWJsZWRcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwic2hvd0ZvbGRXaWRnZXRzXCIsIHNob3cpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dGb2xkV2lkZ2V0c1wiKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0RmFkZUZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKGZhZGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJmYWRlRm9sZFdpZGdldHNcIiwgZmFkZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZmFkZUZvbGRXaWRnZXRzXCIpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gXCJsZWZ0XCIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGVmdCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNlc3Npb24uZ2V0U3RhdGUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciBuZXdfcmFuZ2UgPSBzZXNzaW9uLmdldE1vZGUoKS50cmFuc2Zvcm1BY3Rpb24oc3RhdGUsICdkZWxldGlvbicsIHRoaXMsIHNlc3Npb24sIHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmQuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJhbmdlLmVuZC5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld19yYW5nZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ld19yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVXb3JkUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkUmlnaHQoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbW92ZVdvcmRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0V29yZExlZnQoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbW92ZVRvTGluZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGluZVN0YXJ0KCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RMZWZ0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVUb0xpbmVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RMaW5lRW5kKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LmNvbHVtbiA9PSByYW5nZS5lbmQuY29sdW1uICYmIHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gMDtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3crKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zcGxpdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoXCJcXG5cIik7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0R2hvc3RUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0R2hvc3RUZXh0KHRleHQsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUucmVtb3ZlR2hvc3RUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUdob3N0VGV4dCgpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS50cmFuc3Bvc2VMZXR0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjdXJzb3IuY29sdW1uO1xuICAgICAgICBpZiAoY29sdW1uID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgc3dhcCwgcmFuZ2U7XG4gICAgICAgIGlmIChjb2x1bW4gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dhcCA9IGxpbmUuY2hhckF0KGNvbHVtbikgKyBsaW5lLmNoYXJBdChjb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5yb3csIGNvbHVtbiAtIDEsIGN1cnNvci5yb3csIGNvbHVtbiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dhcCA9IGxpbmUuY2hhckF0KGNvbHVtbiAtIDEpICsgbGluZS5jaGFyQXQoY29sdW1uIC0gMik7XG4gICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3Iucm93LCBjb2x1bW4gLSAyLCBjdXJzb3Iucm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCBzd2FwKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihyYW5nZS5lbmQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS50b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsUmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCB0ZXh0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShvcmlnaW5hbFJhbmdlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUudG9VcHBlckNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgdGV4dC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2Uob3JpZ2luYWxSYW5nZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA8IHJhbmdlLmVuZC5yb3cpIHtcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICBzZXNzaW9uLmluZGVudFJvd3Mocm93cy5maXJzdCwgcm93cy5sYXN0LCBcIlxcdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYW5nZS5zdGFydC5jb2x1bW4gPCByYW5nZS5lbmQuY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmICghL15cXHMrJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5pbmRlbnRSb3dzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCwgXCJcXHRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB2YXIgc2l6ZSA9IHNlc3Npb24uZ2V0VGFiU2l6ZSgpO1xuICAgICAgICB2YXIgY29sdW1uID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuQ29sdW1uKHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5nZXRVc2VTb2Z0VGFicygpKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAoc2l6ZSAtIGNvbHVtbiAlIHNpemUpO1xuICAgICAgICAgICAgdmFyIGluZGVudFN0cmluZyA9IGxhbmcuc3RyaW5nUmVwZWF0KFwiIFwiLCBjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBjb2x1bW4gJSBzaXplO1xuICAgICAgICAgICAgd2hpbGUgKGxpbmVbcmFuZ2Uuc3RhcnQuY29sdW1uIC0gMV0gPT0gXCIgXCIgJiYgY291bnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgaW5kZW50U3RyaW5nID0gXCJcXHRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQoaW5kZW50U3RyaW5nKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuYmxvY2tJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5pbmRlbnRSb3dzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCwgXCJcXHRcIik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmJsb2NrT3V0ZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2Vzc2lvbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm91dGRlbnRSb3dzKHNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc29ydExpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSByb3dzLmZpcnN0OyBpIDw9IHJvd3MubGFzdDsgaSsrKVxuICAgICAgICAgICAgbGluZXMucHVzaChzZXNzaW9uLmdldExpbmUoaSkpO1xuICAgICAgICBsaW5lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChhLnRvTG93ZXJDYXNlKCkgPiBiLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxldGVSYW5nZSA9IG5ldyBSYW5nZSgwLCAwLCAwLCAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJvd3MuZmlyc3Q7IGkgPD0gcm93cy5sYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQucm93ID0gaTtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5yb3cgPSBpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLmNvbHVtbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlKGRlbGV0ZVJhbmdlLCBsaW5lc1tpIC0gcm93cy5maXJzdF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnRvZ2dsZUNvbW1lbnRMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zZXNzaW9uLmdldFN0YXRlKHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKS5yb3cpO1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0TW9kZSgpLnRvZ2dsZUNvbW1lbnRMaW5lcyhzdGF0ZSwgdGhpcy5zZXNzaW9uLCByb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS50b2dnbGVCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRTdGF0ZShjdXJzb3Iucm93KTtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0TW9kZSgpLnRvZ2dsZUJsb2NrQ29tbWVudChzdGF0ZSwgdGhpcy5zZXNzaW9uLCByYW5nZSwgY3Vyc29yKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0TnVtYmVyQXQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIF9udW1iZXJSeCA9IC9bXFwtXT9bMC05XSsoPzpcXC5bMC05XSspPy9nO1xuICAgICAgICBfbnVtYmVyUngubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3cpO1xuICAgICAgICB3aGlsZSAoX251bWJlclJ4Lmxhc3RJbmRleCA8IGNvbHVtbikge1xuICAgICAgICAgICAgdmFyIG0gPSBfbnVtYmVyUnguZXhlYyhzKTtcbiAgICAgICAgICAgIGlmIChtLmluZGV4IDw9IGNvbHVtbiAmJiBtLmluZGV4ICsgbVswXS5sZW5ndGggPj0gY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBtLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG0uaW5kZXggKyBtWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubW9kaWZ5TnVtYmVyID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkuY29sdW1uO1xuICAgICAgICB2YXIgY2hhclJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uIC0gMSwgcm93LCBjb2x1bW4pO1xuICAgICAgICB2YXIgYyA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoY2hhclJhbmdlKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KGMpKSAmJiBpc0Zpbml0ZShjKSkge1xuICAgICAgICAgICAgdmFyIG5yID0gdGhpcy5nZXROdW1iZXJBdChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICBpZiAobnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnAgPSBuci52YWx1ZS5pbmRleE9mKFwiLlwiKSA+PSAwID8gbnIuc3RhcnQgKyBuci52YWx1ZS5pbmRleE9mKFwiLlwiKSArIDEgOiBuci5lbmQ7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gbnIuc3RhcnQgKyBuci52YWx1ZS5sZW5ndGggLSBmcDtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHBhcnNlRmxvYXQobnIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHQgKj0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICBpZiAoZnAgIT09IG5yLmVuZCAmJiBjb2x1bW4gPCBmcCkge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQgKj0gTWF0aC5wb3coMTAsIG5yLmVuZCAtIGNvbHVtbiAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ICo9IE1hdGgucG93KDEwLCBuci5lbmQgLSBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ICs9IGFtb3VudDtcbiAgICAgICAgICAgICAgICB0IC89IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgdmFyIG5uciA9IHQudG9GaXhlZChkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VSYW5nZSA9IG5ldyBSYW5nZShyb3csIG5yLnN0YXJ0LCByb3csIG5yLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlcGxhY2UocmVwbGFjZVJhbmdlLCBubnIpO1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgTWF0aC5tYXgobnIuc3RhcnQgKyAxLCBjb2x1bW4gKyBubnIubGVuZ3RoIC0gbnIudmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVdvcmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS50b2dnbGVXb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkuY29sdW1uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgICAgICB2YXIgY3VycldvcmRTdGFydCA9IHRoaXMuc2VsZWN0aW9uLmdldFdvcmRSYW5nZSgpLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgdmFyIHdvcmRQYXJ0cyA9IGN1cnJlbnRTdGF0ZS5yZXBsYWNlKC8oW2Etel0rfFtBLVpdKykoPz1bQS1aX118JCkvZywgJyQxICcpLnNwbGl0KC9cXHMvKTtcbiAgICAgICAgdmFyIGRlbHRhID0gY29sdW1uIC0gY3VycldvcmRTdGFydCAtIDE7XG4gICAgICAgIGlmIChkZWx0YSA8IDApXG4gICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgIHZhciBjdXJMZW5ndGggPSAwLCBpdExlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5tYXRjaCgvW0EtWmEtejAtOV9dKy8pKSB7XG4gICAgICAgICAgICB3b3JkUGFydHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgIGl0TGVuZ3RoID0gY3VyTGVuZ3RoICsgaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhID49IGN1ckxlbmd0aCAmJiBkZWx0YSA8PSBpdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vdmVDdXJzb3JUbyhyb3csIGN1ckxlbmd0aCArIGN1cnJXb3JkU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZWxlY3RUbyhyb3csIGl0TGVuZ3RoICsgY3VycldvcmRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckxlbmd0aCA9IGl0TGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmRQYWlycyA9IHRoaXMuJHRvZ2dsZVdvcmRQYWlycztcbiAgICAgICAgdmFyIHJlZztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkUGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gd29yZFBhaXJzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZSA9ICshajtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RDb25kaXRpb24gPSBjdXJyZW50U3RhdGUubWF0Y2gobmV3IFJlZ0V4cCgnXlxcXFxzP18/KCcgKyBsYW5nLmVzY2FwZVJlZ0V4cChpdGVtW2pdKSArICcpXFxcXHM/JCcsICdpJykpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ29uZGl0aW9uID0gY3VycmVudFN0YXRlLm1hdGNoKG5ldyBSZWdFeHAoJyhbX118XnxcXFxccykoJyArIGxhbmcuZXNjYXBlUmVnRXhwKGZpcnN0Q29uZGl0aW9uWzFdKSArICcpKCR8XFxcXHMpJywgJ2cnKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZyA9IGN1cnJlbnRTdGF0ZS5yZXBsYWNlKG5ldyBSZWdFeHAobGFuZy5lc2NhcGVSZWdFeHAoaXRlbVtqXSksICdpJyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gaXRlbVtuZWdhdGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudG9VcHBlckNhc2UoKSA9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSA9PSByZXN1bHQuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdWJzdHIoMCwgMCkgKyBpdGVtW25lZ2F0ZV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXMuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydChyZWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5maW5kTGlua0F0ID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciB3b3JkUGFydHMgPSBsaW5lLnNwbGl0KC8oKD86aHR0cHM/fGZ0cCk6XFwvXFwvW1xcU10rKS8pO1xuICAgICAgICB2YXIgY29sdW1uUG9zaXRpb24gPSBjb2x1bW47XG4gICAgICAgIGlmIChjb2x1bW5Qb3NpdGlvbiA8IDApXG4gICAgICAgICAgICBjb2x1bW5Qb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uID0gMCwgY3VycmVudFBvc2l0aW9uID0gMCwgbWF0Y2g7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkUGFydHNfMSA9IF9fdmFsdWVzKHdvcmRQYXJ0cyksIHdvcmRQYXJ0c18xXzEgPSB3b3JkUGFydHNfMS5uZXh0KCk7ICF3b3JkUGFydHNfMV8xLmRvbmU7IHdvcmRQYXJ0c18xXzEgPSB3b3JkUGFydHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHdvcmRQYXJ0c18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gcHJldmlvdXNQb3NpdGlvbiArIGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5Qb3NpdGlvbiA+PSBwcmV2aW91c1Bvc2l0aW9uICYmIGNvbHVtblBvc2l0aW9uIDw9IGN1cnJlbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5tYXRjaCgvKCg/Omh0dHBzP3xmdHApOlxcL1xcL1tcXFNdKykvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBpdGVtLnJlcGxhY2UoL1tcXHM6LiwnXCI7fVxcXV0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRQYXJ0c18xXzEgJiYgIXdvcmRQYXJ0c18xXzEuZG9uZSAmJiAoX2EgPSB3b3JkUGFydHNfMS5yZXR1cm4pKSBfYS5jYWxsKHdvcmRQYXJ0c18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm9wZW5MaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmZpbmRMaW5rQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIGlmICh1cmwpXG4gICAgICAgICAgICB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKTtcbiAgICAgICAgcmV0dXJuIHVybCAhPSBudWxsO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUZ1bGxMaW5lcyhyb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmR1cGxpY2F0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIHJldmVyc2UgPSBzZWwuaXNCYWNrd2FyZHMoKTtcbiAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGRvYy5kdXBsaWNhdGVMaW5lcyhyb3csIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XG4gICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBkb2MuaW5zZXJ0KHBvaW50LCBkb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgICByYW5nZS5zdGFydCA9IHBvaW50O1xuICAgICAgICAgICAgcmFuZ2UuZW5kID0gZW5kUG9pbnQ7XG4gICAgICAgICAgICBzZWwuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UsIHJldmVyc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm1vdmVMaW5lc0Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygxLCBmYWxzZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm1vdmVMaW5lc1VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlTGluZXMoLTEsIGZhbHNlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubW92ZVRleHQgPSBmdW5jdGlvbiAocmFuZ2UsIHRvUG9zaXRpb24sIGNvcHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5tb3ZlVGV4dChyYW5nZSwgdG9Qb3NpdGlvbiwgY29weSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmNvcHlMaW5lc1VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlTGluZXMoLTEsIHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5jb3B5TGluZXNEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlTGluZXMoMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRtb3ZlTGluZXMgPSBmdW5jdGlvbiAoZGlyLCBjb3B5KSB7XG4gICAgICAgIHZhciByb3dzLCBtb3ZlZDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSB8fCB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcbiAgICAgICAgICAgIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MocmFuZ2UpO1xuICAgICAgICAgICAgbW92ZWQgPSB0aGlzLnNlc3Npb24uJG1vdmVMaW5lcyhyb3dzLmZpcnN0LCByb3dzLmxhc3QsIGNvcHkgPyAwIDogZGlyKTtcbiAgICAgICAgICAgIGlmIChjb3B5ICYmIGRpciA9PSAtMSlcbiAgICAgICAgICAgICAgICBtb3ZlZCA9IDA7XG4gICAgICAgICAgICByYW5nZS5tb3ZlQnkobW92ZWQsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBzZWxlY3Rpb24ucmFuZ2VMaXN0LnJhbmdlcztcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yYW5nZUxpc3QuZGV0YWNoKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgICAgICAgdmFyIHRvdGFsRGlmZiA9IDA7XG4gICAgICAgICAgICB2YXIgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0ubW92ZUJ5KGRpZmYsIDApO1xuICAgICAgICAgICAgICAgIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSByb3dzLmZpcnN0O1xuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gcm93cy5sYXN0O1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbERpZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXNbaV0ubW92ZUJ5KHRvdGFsRGlmZiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJSb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5ICYmIHN1YlJvd3MuZmlyc3QgIT0gbGFzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY29weSAmJiBzdWJSb3dzLmZpcnN0ID4gbGFzdCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHN1YlJvd3MubGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnNlc3Npb24uJG1vdmVMaW5lcyhmaXJzdCwgbGFzdCwgY29weSA/IDAgOiBkaXIpO1xuICAgICAgICAgICAgICAgIGlmIChjb3B5ICYmIGRpciA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZUluZGV4IDw9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzW3JhbmdlSW5kZXhdLm1vdmVCeShkaWZmLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSAwO1xuICAgICAgICAgICAgICAgIHRvdGFsRGlmZiArPSBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHNlbGVjdGlvbi5yYW5nZXNbMF0pO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnJhbmdlTGlzdC5hdHRhY2godGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRnZXRTZWxlY3RlZFJvd3MgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSAocmFuZ2UgfHwgdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKS5jb2xsYXBzZVJvd3MoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLnNlc3Npb24uZ2V0Um93Rm9sZFN0YXJ0KHJhbmdlLnN0YXJ0LnJvdyksXG4gICAgICAgICAgICBsYXN0OiB0aGlzLnNlc3Npb24uZ2V0Um93Rm9sZEVuZChyYW5nZS5lbmQucm93KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvbXBvc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiAoY29tcG9zaXRpb25TdGF0ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNob3dDb21wb3NpdGlvbihjb21wb3NpdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUub25Db21wb3NpdGlvblVwZGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q29tcG9zaXRpb25UZXh0KHRleHQpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5vbkNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmhpZGVDb21wb3NpdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRGaXJzdFZpc2libGVSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldEZpcnN0VmlzaWJsZVJvdygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRMYXN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0TGFzdFZpc2libGVSb3coKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuaXNSb3dWaXNpYmxlID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gKHJvdyA+PSB0aGlzLmdldEZpcnN0VmlzaWJsZVJvdygpICYmIHJvdyA8PSB0aGlzLmdldExhc3RWaXNpYmxlUm93KCkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5pc1Jvd0Z1bGx5VmlzaWJsZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIChyb3cgPj0gdGhpcy5yZW5kZXJlci5nZXRGaXJzdEZ1bGx5VmlzaWJsZVJvdygpICYmIHJvdyA8PSB0aGlzLnJlbmRlcmVyLmdldExhc3RGdWxseVZpc2libGVSb3coKSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRnZXRWaXNpYmxlUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbEJvdHRvbVJvdygpIC0gdGhpcy5yZW5kZXJlci5nZXRTY3JvbGxUb3BSb3coKSArIDE7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLiRtb3ZlQnlQYWdlID0gZnVuY3Rpb24gKGRpciwgc2VsZWN0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLnJlbmRlcmVyLmxheWVyQ29uZmlnO1xuICAgICAgICB2YXIgcm93cyA9IGRpciAqIE1hdGguZmxvb3IoY29uZmlnLmhlaWdodCAvIGNvbmZpZy5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uJG1vdmVTZWxlY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KHJvd3MsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckJ5KHJvd3MsIDApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcmVuZGVyZXIuc2Nyb2xsVG9wO1xuICAgICAgICByZW5kZXJlci5zY3JvbGxCeSgwLCByb3dzICogY29uZmlnLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAoc2VsZWN0ICE9IG51bGwpXG4gICAgICAgICAgICByZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUpO1xuICAgICAgICByZW5kZXJlci5hbmltYXRlU2Nyb2xsaW5nKHNjcm9sbFRvcCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNlbGVjdFBhZ2VEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKDEsIHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zZWxlY3RQYWdlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEsIHRydWUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nb3RvUGFnZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoMSwgZmFsc2UpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nb3RvUGFnZVVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKC0xLCBmYWxzZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNjcm9sbFBhZ2VEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKDEpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zY3JvbGxQYWdlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zY3JvbGxUb1JvdyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1Jvdyhyb3cpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5zY3JvbGxUb0xpbmUgPSBmdW5jdGlvbiAobGluZSwgY2VudGVyLCBhbmltYXRlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvTGluZShsaW5lLCBjZW50ZXIsIGFuaW1hdGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuY2VudGVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICByb3c6IE1hdGguZmxvb3IocmFuZ2Uuc3RhcnQucm93ICsgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cpIC8gMiksXG4gICAgICAgICAgICBjb2x1bW46IE1hdGguZmxvb3IocmFuZ2Uuc3RhcnQuY29sdW1uICsgKHJhbmdlLmVuZC5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW4pIC8gMilcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hbGlnbkN1cnNvcihwb3MsIDAuNSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEN1cnNvclBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdldEN1cnNvclBvc2l0aW9uU2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbih0aGlzLmdldEN1cnNvclBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0QWxsKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG8gPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubW92ZUN1cnNvclRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHBvcyk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmp1bXBUb01hdGNoaW5nID0gZnVuY3Rpb24gKHNlbGVjdCwgZXhwYW5kKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHRoaXMuc2Vzc2lvbiwgY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHZhciBwcmV2VG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdmFyIHRva2VuQ291bnQgPSAwO1xuICAgICAgICBpZiAocHJldlRva2VuICYmIHByZXZUb2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xKSB7XG4gICAgICAgICAgICBwcmV2VG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSBwcmV2VG9rZW4gfHwgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1hdGNoVHlwZTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBkZXB0aCA9IHt9O1xuICAgICAgICB2YXIgaSA9IGN1cnNvci5jb2x1bW4gLSB0b2tlbi5zdGFydDtcbiAgICAgICAgdmFyIGJyYWNrZXRUeXBlO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSB7XG4gICAgICAgICAgICBcIilcIjogXCIoXCIsXG4gICAgICAgICAgICBcIihcIjogXCIoXCIsXG4gICAgICAgICAgICBcIl1cIjogXCJbXCIsXG4gICAgICAgICAgICBcIltcIjogXCJbXCIsXG4gICAgICAgICAgICBcIntcIjogXCJ7XCIsXG4gICAgICAgICAgICBcIn1cIjogXCJ7XCJcbiAgICAgICAgfTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlLm1hdGNoKC9be30oKVxcW1xcXV0vZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHRva2VuLnZhbHVlLmxlbmd0aCAmJiAhZm91bmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXRzW3Rva2VuLnZhbHVlW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldFR5cGUgPSBicmFja2V0c1t0b2tlbi52YWx1ZVtpXV0gKyAnLicgKyB0b2tlbi50eXBlLnJlcGxhY2UoXCJycGFyZW5cIiwgXCJscGFyZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkZXB0aFticmFja2V0VHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aFticmFja2V0VHlwZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aFticmFja2V0VHlwZV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aFticmFja2V0VHlwZV0tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhbYnJhY2tldFR5cGVdID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFR5cGUgPSAnYnJhY2tldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRlcHRoW3Rva2VuLnZhbHVlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhbdG9rZW4udmFsdWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJzwnICYmIHRva2VuQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoW3Rva2VuLnZhbHVlXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhbdG9rZW4udmFsdWVdLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXB0aFt0b2tlbi52YWx1ZV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoVHlwZSA9ICd0YWcnO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHByZXZUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHRva2VuQ291bnQrKztcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRva2VuICYmICFmb3VuZCk7XG4gICAgICAgIGlmICghbWF0Y2hUeXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmFuZ2UsIHBvcztcbiAgICAgICAgaWYgKG1hdGNoVHlwZSA9PT0gJ2JyYWNrZXQnKSB7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRCcmFja2V0UmFuZ2UoY3Vyc29yKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpIC0gMSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgaSAtIDEpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmQgfHwgcG9zLnJvdyA9PT0gY3Vyc29yLnJvdyAmJiBNYXRoLmFicyhwb3MuY29sdW1uIC0gY3Vyc29yLmNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgPCAyKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRCcmFja2V0UmFuZ2UocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgICBpZiAoIXRva2VuIHx8IHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpIC0gMiwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpIC0gMik7XG4gICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWdzUmFuZ2VzID0gdGhpcy5zZXNzaW9uLmdldE1hdGNoaW5nVGFncyhjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGlmICh0YWdzUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdzUmFuZ2VzLm9wZW5UYWcuY29udGFpbnMoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGFnc1Jhbmdlcy5jbG9zZVRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0YWdzUmFuZ2VzLm9wZW5UYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnc1Jhbmdlcy5jbG9zZVRhZy5zdGFydC5yb3cgPT09IGN1cnNvci5yb3cgJiYgdGFnc1Jhbmdlcy5jbG9zZVRhZy5zdGFydC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9PT0gY3Vyc29yLmNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBwb3MgfHwgcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcmFuZ2UgJiYgcmFuZ2UuY3Vyc29yIHx8IHBvcztcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiBleHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZSAmJiByYW5nZS5pc0VxdWFsKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0VG8ocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZVRvKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmdvdG9MaW5lID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGNvbHVtbiwgYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNlc3Npb24udW5mb2xkKHsgcm93OiBsaW5lTnVtYmVyIC0gMSwgY29sdW1uOiBjb2x1bW4gfHwgMCB9KTtcbiAgICAgICAgdGhpcy5leGl0TXVsdGlTZWxlY3RNb2RlICYmIHRoaXMuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhsaW5lTnVtYmVyIC0gMSwgY29sdW1uIHx8IDApO1xuICAgICAgICBpZiAoIXRoaXMuaXNSb3dGdWxseVZpc2libGUobGluZU51bWJlciAtIDEpKVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0xpbmUobGluZU51bWJlciAtIDEsIHRydWUsIGFuaW1hdGUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZVRvID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlVXAgPSBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzTXVsdGlMaW5lKCkgJiYgIXRoaXMuc2VsZWN0aW9uLmlzQmFja3dhcmRzKCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uLmFuY2hvci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JCeSgtdGltZXMgfHwgLTEsIDApO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZURvd24gPSBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzTXVsdGlMaW5lKCkgJiYgdGhpcy5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uLmFuY2hvci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yQnkodGltZXMgfHwgMSwgMCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlTGVmdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lcyA9IHRpbWVzIHx8IDE7XG4gICAgICAgICAgICB3aGlsZSAodGltZXMtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JMZWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZVJpZ2h0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpLmVuZDtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVzID0gdGltZXMgfHwgMTtcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcy0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvclJpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZUxpbmVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckxpbmVTdGFydCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlTGluZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckxpbmVFbmQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZUZpbGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JGaWxlRW5kKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUubmF2aWdhdGVGaWxlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JGaWxlU3RhcnQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZVdvcmRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvcldvcmRSaWdodCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLm5hdmlnYXRlV29yZExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JXb3JkTGVmdCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAocmVwbGFjZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLiRzZWFyY2guc2V0KG9wdGlvbnMpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiRzZWFyY2guZmluZCh0aGlzLnNlc3Npb24pO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSAwO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xuICAgICAgICBpZiAodGhpcy4kdHJ5UmVwbGFjZShyYW5nZSwgcmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZWQ7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocmVwbGFjZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuJHNlYXJjaC5maW5kQWxsKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IDA7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlZDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZVRvKDAsIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdHJ5UmVwbGFjZShyYW5nZXNbaV0sIHJlcGxhY2VtZW50KSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS4kdHJ5UmVwbGFjZSA9IGZ1bmN0aW9uIChyYW5nZSwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gdGhpcy4kc2VhcmNoLnJlcGxhY2UoaW5wdXQsIHJlcGxhY2VtZW50KTtcbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuZ2V0TGFzdFNlYXJjaE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZWFyY2guZ2V0T3B0aW9ucygpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKG5lZWRsZSwgb3B0aW9ucywgYW5pbWF0ZSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmVlZGxlID09IFwic3RyaW5nXCIgfHwgbmVlZGxlIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSBuZWVkbGU7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZWVkbGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIG9vcC5taXhpbihvcHRpb25zLCBuZWVkbGUpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5uZWVkbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVlZGxlID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSlcbiAgICAgICAgICAgICAgICB8fCB0aGlzLiRzZWFyY2guJG9wdGlvbnMubmVlZGxlO1xuICAgICAgICAgICAgaWYgKCFuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRXb3JkUmFuZ2UocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIG5lZWRsZSA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldCh7IG5lZWRsZTogbmVlZGxlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNlYXJjaC5zZXQob3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdGFydClcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQoeyBzdGFydDogcmFuZ2UgfSk7XG4gICAgICAgIHZhciBuZXdSYW5nZSA9IHRoaXMuJHNlYXJjaC5maW5kKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIGlmIChvcHRpb25zLnByZXZlbnRTY3JvbGwpXG4gICAgICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XG4gICAgICAgIGlmIChuZXdSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5yZXZlYWxSYW5nZShuZXdSYW5nZSwgYW5pbWF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYmFja3dhcmRzKVxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5lbmQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlLmVuZCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZpbmROZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5maW5kKHsgc2tpcEN1cnJlbnQ6IHRydWUsIGJhY2t3YXJkczogZmFsc2UgfSwgb3B0aW9ucywgYW5pbWF0ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLmZpbmRQcmV2aW91cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuZmluZChvcHRpb25zLCB7IHNraXBDdXJyZW50OiB0cnVlLCBiYWNrd2FyZHM6IHRydWUgfSwgYW5pbWF0ZSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJldmVhbFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi51bmZvbGQocmFuZ2UpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSk7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCAwLjUpO1xuICAgICAgICBpZiAoYW5pbWF0ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFuaW1hdGVTY3JvbGxpbmcoc2Nyb2xsVG9wKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkudW5kbyh0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgfTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRVbmRvTWFuYWdlcigpLnJlZG8odGhpcy5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kdG9EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLiR0b0Rlc3Ryb3kuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuJHRvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJG1vdXNlSGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMuJG1vdXNlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuXyRlbWl0SW5wdXRFdmVudClcbiAgICAgICAgICAgIHRoaXMuXyRlbWl0SW5wdXRFdmVudC5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEVkaXRvci5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgICAgICBpZiAoIWVuYWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNob3VsZFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuJHNjcm9sbEFuY2hvcilcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBzY3JvbGxBbmNob3IgPSB0aGlzLiRzY3JvbGxBbmNob3I7XG4gICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc2Nyb2xsQW5jaG9yLCB0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgdmFyIG9uQ2hhbmdlU2VsZWN0aW9uID0gdGhpcy5vbihcImNoYW5nZVNlbGVjdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaG91bGRTY3JvbGwgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9uQmVmb3JlUmVuZGVyID0gdGhpcy5yZW5kZXJlci5vbihcImJlZm9yZVJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKVxuICAgICAgICAgICAgICAgIHJlY3QgPSBzZWxmLnJlbmRlcmVyLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvbkFmdGVyUmVuZGVyID0gdGhpcy5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgcmVjdCAmJiAoc2VsZi5pc0ZvY3VzZWQoKVxuICAgICAgICAgICAgICAgIHx8IHNlbGYuc2VhcmNoQm94ICYmIHNlbGYuc2VhcmNoQm94LmlzRm9jdXNlZCgpKSkge1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHNlbGYucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHJlbmRlcmVyLiRjdXJzb3JMYXllci4kcGl4ZWxQb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHJlbmRlcmVyLmxheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIHZhciB0b3AgPSBwb3MudG9wIC0gY29uZmlnLm9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnRvcCA+PSAwICYmIHRvcCArIHJlY3QudG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb3MudG9wIDwgY29uZmlnLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICBwb3MudG9wICsgcmVjdC50b3AgKyBjb25maWcubGluZUhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUuaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zY3JvbGxJbnRvVmlldyhzaG91bGRTY3JvbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgICAgICAgICAgaWYgKGVuYWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zZXRBdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXc7XG4gICAgICAgICAgICB0aGlzLm9mZihcImNoYW5nZVNlbGVjdGlvblwiLCBvbkNoYW5nZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLm9mZihcImFmdGVyUmVuZGVyXCIsIG9uQWZ0ZXJSZW5kZXIpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5vZmYoXCJiZWZvcmVSZW5kZXJcIiwgb25CZWZvcmVSZW5kZXIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS4kcmVzZXRDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy4kY3Vyc29yU3R5bGUgfHwgXCJhY2VcIjtcbiAgICAgICAgdmFyIGN1cnNvckxheWVyID0gdGhpcy5yZW5kZXJlci4kY3Vyc29yTGF5ZXI7XG4gICAgICAgIGlmICghY3Vyc29yTGF5ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN1cnNvckxheWVyLnNldFNtb290aEJsaW5raW5nKC9zbW9vdGgvLnRlc3Qoc3R5bGUpKTtcbiAgICAgICAgY3Vyc29yTGF5ZXIuaXNCbGlua2luZyA9ICF0aGlzLiRyZWFkT25seSAmJiBzdHlsZSAhPSBcIndpZGVcIjtcbiAgICAgICAgZG9tLnNldENzc0NsYXNzKGN1cnNvckxheWVyLmVsZW1lbnQsIFwiYWNlX3NsaW0tY3Vyc29yc1wiLCAvc2xpbS8udGVzdChzdHlsZSkpO1xuICAgIH07XG4gICAgRWRpdG9yLnByb3RvdHlwZS5wcm9tcHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXM7XG4gICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFwiYWNlL2V4dC9wcm9tcHRcIiwgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgbW9kdWxlLnByb21wdChlZGl0b3IsIG1lc3NhZ2UsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRWRpdG9yO1xufSgpKTtcbkVkaXRvci4kdWlkID0gMDtcbkVkaXRvci5wcm90b3R5cGUuY3VyT3AgPSBudWxsO1xuRWRpdG9yLnByb3RvdHlwZS5wcmV2T3AgPSB7fTtcbkVkaXRvci5wcm90b3R5cGUuJG1lcmdlYWJsZUNvbW1hbmRzID0gW1wiYmFja3NwYWNlXCIsIFwiZGVsXCIsIFwiaW5zZXJ0c3RyaW5nXCJdO1xuRWRpdG9yLnByb3RvdHlwZS4kdG9nZ2xlV29yZFBhaXJzID0gW1xuICAgIFtcImZpcnN0XCIsIFwibGFzdFwiXSxcbiAgICBbXCJ0cnVlXCIsIFwiZmFsc2VcIl0sXG4gICAgW1wieWVzXCIsIFwibm9cIl0sXG4gICAgW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gICAgW1widG9wXCIsIFwiYm90dG9tXCJdLFxuICAgIFtcInJpZ2h0XCIsIFwibGVmdFwiXSxcbiAgICBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICBbXCJ4XCIsIFwieVwiXSxcbiAgICBbXCJnZXRcIiwgXCJzZXRcIl0sXG4gICAgW1wibWF4XCIsIFwibWluXCJdLFxuICAgIFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSxcbiAgICBbXCJzaG93XCIsIFwiaGlkZVwiXSxcbiAgICBbXCJhZGRcIiwgXCJyZW1vdmVcIl0sXG4gICAgW1widXBcIiwgXCJkb3duXCJdLFxuICAgIFtcImJlZm9yZVwiLCBcImFmdGVyXCJdLFxuICAgIFtcImV2ZW5cIiwgXCJvZGRcIl0sXG4gICAgW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgW1wiaW5zaWRlXCIsIFwib3V0c2lkZVwiXSxcbiAgICBbXCJuZXh0XCIsIFwicHJldmlvdXNcIl0sXG4gICAgW1wiaW5jcmVhc2VcIiwgXCJkZWNyZWFzZVwiXSxcbiAgICBbXCJhdHRhY2hcIiwgXCJkZXRhY2hcIl0sXG4gICAgW1wiJiZcIiwgXCJ8fFwiXSxcbiAgICBbXCI9PVwiLCBcIiE9XCJdXG5dO1xub29wLmltcGxlbWVudChFZGl0b3IucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuY29uZmlnLmRlZmluZU9wdGlvbnMoRWRpdG9yLnByb3RvdHlwZSwgXCJlZGl0b3JcIiwge1xuICAgIHNlbGVjdGlvblN0eWxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTZWxlY3Rpb25TdHlsZVwiLCB7IGRhdGE6IHN0eWxlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IFwibGluZVwiXG4gICAgfSxcbiAgICBoaWdobGlnaHRBY3RpdmVMaW5lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkgeyB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7IH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgaGlnaGxpZ2h0U2VsZWN0ZWRXb3JkOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3VsZEhpZ2hsaWdodCkgeyB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSgpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHJlYWRPbmx5OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dC5zZXRSZWFkT25seShyZWFkT25seSk7XG4gICAgICAgICAgICB0aGlzLiRyZXNldEN1cnNvclN0eWxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGNvcHlXaXRoRW1wdHlTZWxlY3Rpb246IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dElucHV0LnNldENvcHlXaXRoRW1wdHlTZWxlY3Rpb24odmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBjdXJzb3JTdHlsZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy4kcmVzZXRDdXJzb3JTdHlsZSgpOyB9LFxuICAgICAgICB2YWx1ZXM6IFtcImFjZVwiLCBcInNsaW1cIiwgXCJzbW9vdGhcIiwgXCJ3aWRlXCJdLFxuICAgICAgICBpbml0aWFsVmFsdWU6IFwiYWNlXCJcbiAgICB9LFxuICAgIG1lcmdlVW5kb0RlbHRhczoge1xuICAgICAgICB2YWx1ZXM6IFtmYWxzZSwgdHJ1ZSwgXCJhbHdheXNcIl0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgYmVoYXZpb3Vyc0VuYWJsZWQ6IHsgaW5pdGlhbFZhbHVlOiB0cnVlIH0sXG4gICAgd3JhcEJlaGF2aW91cnNFbmFibGVkOiB7IGluaXRpYWxWYWx1ZTogdHJ1ZSB9LFxuICAgIGVuYWJsZUF1dG9JbmRlbnQ6IHsgaW5pdGlhbFZhbHVlOiB0cnVlIH0sXG4gICAgYXV0b1Njcm9sbEVkaXRvckludG9WaWV3OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldyh2YWwpOyB9XG4gICAgfSxcbiAgICBrZXlib2FyZEhhbmRsZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc2V0S2V5Ym9hcmRIYW5kbGVyKHZhbCk7IH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4ka2V5YmluZGluZ0lkOyB9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5zZXNzaW9uLnNldFZhbHVlKHZhbCk7IH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpOyB9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlLFxuICAgICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHNlc3Npb246IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc2V0U2Vzc2lvbih2YWwpOyB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2Vzc2lvbjsgfSxcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICBzaG93TGluZU51bWJlcnM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuc2V0U2hvd0xpbmVOdW1iZXJzKHNob3cpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kbG9vcC5zY2hlZHVsZSh0aGlzLnJlbmRlcmVyLkNIQU5HRV9HVVRURVIpO1xuICAgICAgICAgICAgaWYgKHNob3cgJiYgdGhpcy4kcmVsYXRpdmVMaW5lTnVtYmVycylcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU51bWJlclJlbmRlcmVyLmF0dGFjaCh0aGlzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU51bWJlclJlbmRlcmVyLmRldGFjaCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICByZWxhdGl2ZUxpbmVOdW1iZXJzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2hvd0xpbmVOdW1iZXJzICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTnVtYmVyUmVuZGVyZXIuYXR0YWNoKHRoaXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTnVtYmVyUmVuZGVyZXIuZGV0YWNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHVwZGF0ZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IHRoaXMuc2Vzc2lvbiAmJiAodGhpcy5yZW5kZXJlci4kY29tcG9zaXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSA+IDEgfHwgdGhpcy5zZXNzaW9uLmdldExpbmUoMCkubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZSAmJiB0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5vZmYoXCJhZnRlclJlbmRlclwiLCB0aGlzLiR1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFwiYWNlX2hhc1BsYWNlaG9sZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wbGFjZWhvbGRlck5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWhhc1ZhbHVlICYmICF0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIHRoaXMuJHVwZGF0ZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJhY2VfaGFzUGxhY2Vob2xkZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiYWNlX3BsYWNlaG9sZGVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHRoaXMuJHBsYWNlaG9sZGVyIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnBsYWNlaG9sZGVyTm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaGFzVmFsdWUgJiYgdGhpcy5yZW5kZXJlci5wbGFjZWhvbGRlck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucGxhY2Vob2xkZXJOb2RlLnRleHRDb250ZW50ID0gdGhpcy4kcGxhY2Vob2xkZXIgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKFwiaW5wdXRcIiwgdGhpcy4kdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlS2V5Ym9hcmRBY2Nlc3NpYmlsaXR5OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYmx1ckNvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJibHVyVGV4dElucHV0XCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU2V0IGZvY3VzIHRvIHRoZSBlZGl0b3IgY29udGVudCBkaXYgdG8gYWxsb3cgdGFiYmluZyB0aHJvdWdoIHRoZSBwYWdlXCIsXG4gICAgICAgICAgICAgICAgYmluZEtleTogXCJFc2NcIixcbiAgICAgICAgICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxlci5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZm9jdXNPbkVudGVyS2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PSB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyICYmIGUua2V5Q29kZSA9PT0ga2V5c1snZW50ZXInXSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCkucm93O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSb3dWaXNpYmxlKHJvdykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvTGluZShyb3csIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBndXR0ZXJLZXlib2FyZEhhbmRsZXI7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmVuYWJsZUtleWJvYXJkQWNjZXNzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5rZXlib2FyZEZvY3VzQ2xhc3NOYW1lID0gXCJhY2Vfa2V5Ym9hcmQtZm9jdXNcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dC5nZXRFbGVtZW50KCkuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dElucHV0LnNldE51bWJlck9mRXh0cmFMaW5lcyh1c2VyYWdlbnQuaXNXaW4gPyAzIDogMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIG5scyhcImVkaXRvci5zY3JvbGxlci5hcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcImVkaXRvclwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5jbGFzc0xpc3QuYWRkKHRoaXMucmVuZGVyZXIua2V5Ym9hcmRGb2N1c0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG5scyhcImVkaXRvci5zY3JvbGxlci5hcmlhLWxhYmVsXCIsIFwiRWRpdG9yIGNvbnRlbnQsIHByZXNzIEVudGVyIHRvIHN0YXJ0IGVkaXRpbmcsIHByZXNzIEVzY2FwZSB0byBleGl0XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmb2N1c09uRW50ZXJLZXl1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmFkZENvbW1hbmQoYmx1ckNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JvdXBcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIG5scyhcImVkaXRvci5ndXR0ZXIuYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgXCJlZGl0b3IgZ3V0dGVyXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBubHMoXCJlZGl0b3IuZ3V0dGVyLmFyaWEtbGFiZWxcIiwgXCJFZGl0b3IgZ3V0dGVyLCBwcmVzcyBFbnRlciB0byBpbnRlcmFjdCB3aXRoIGNvbnRyb2xzIHVzaW5nIGFycm93IGtleXMsIHByZXNzIEVzY2FwZSB0byBleGl0XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuY2xhc3NMaXN0LmFkZCh0aGlzLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuY29udGVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWd1dHRlcktleWJvYXJkSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVyS2V5Ym9hcmRIYW5kbGVyID0gbmV3IEd1dHRlcktleWJvYXJkSGFuZGxlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBndXR0ZXJLZXlib2FyZEhhbmRsZXIuYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dC5zZXRBcmlhT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIHNldExhYmVsOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmVuYWJsZUtleWJvYXJkQWNjZXNzaWJpbGl0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dElucHV0LmdldEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dC5zZXROdW1iZXJPZkV4dHJhTGluZXMoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMucmVuZGVyZXIua2V5Ym9hcmRGb2N1c0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxlci5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZvY3VzT25FbnRlcktleXVwLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlQ29tbWFuZChibHVyQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5jb250ZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci4kZ3V0dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuJGd1dHRlci5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLiRndXR0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnJlbmRlcmVyLmtleWJvYXJkRm9jdXNDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChndXR0ZXJLZXlib2FyZEhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcktleWJvYXJkSGFuZGxlci5yZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB0ZXh0SW5wdXRBcmlhTGFiZWw6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuJHRleHRJbnB1dEFyaWFMYWJlbCA9IHZhbDsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBcIlwiXG4gICAgfSxcbiAgICBlbmFibGVNb2JpbGVNZW51OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLiRlbmFibGVNb2JpbGVNZW51ID0gdmFsOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGN1c3RvbVNjcm9sbGJhcjogXCJyZW5kZXJlclwiLFxuICAgIGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiBcInJlbmRlcmVyXCIsXG4gICAgdlNjcm9sbEJhckFsd2F5c1Zpc2libGU6IFwicmVuZGVyZXJcIixcbiAgICBoaWdobGlnaHRHdXR0ZXJMaW5lOiBcInJlbmRlcmVyXCIsXG4gICAgYW5pbWF0ZWRTY3JvbGw6IFwicmVuZGVyZXJcIixcbiAgICBzaG93SW52aXNpYmxlczogXCJyZW5kZXJlclwiLFxuICAgIHNob3dQcmludE1hcmdpbjogXCJyZW5kZXJlclwiLFxuICAgIHByaW50TWFyZ2luQ29sdW1uOiBcInJlbmRlcmVyXCIsXG4gICAgcHJpbnRNYXJnaW46IFwicmVuZGVyZXJcIixcbiAgICBmYWRlRm9sZFdpZGdldHM6IFwicmVuZGVyZXJcIixcbiAgICBzaG93Rm9sZFdpZGdldHM6IFwicmVuZGVyZXJcIixcbiAgICBkaXNwbGF5SW5kZW50R3VpZGVzOiBcInJlbmRlcmVyXCIsXG4gICAgaGlnaGxpZ2h0SW5kZW50R3VpZGVzOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0d1dHRlcjogXCJyZW5kZXJlclwiLFxuICAgIGZvbnRTaXplOiBcInJlbmRlcmVyXCIsXG4gICAgZm9udEZhbWlseTogXCJyZW5kZXJlclwiLFxuICAgIG1heExpbmVzOiBcInJlbmRlcmVyXCIsXG4gICAgbWluTGluZXM6IFwicmVuZGVyZXJcIixcbiAgICBzY3JvbGxQYXN0RW5kOiBcInJlbmRlcmVyXCIsXG4gICAgZml4ZWRXaWR0aEd1dHRlcjogXCJyZW5kZXJlclwiLFxuICAgIHRoZW1lOiBcInJlbmRlcmVyXCIsXG4gICAgaGFzQ3NzVHJhbnNmb3JtczogXCJyZW5kZXJlclwiLFxuICAgIG1heFBpeGVsSGVpZ2h0OiBcInJlbmRlcmVyXCIsXG4gICAgdXNlVGV4dGFyZWFGb3JJTUU6IFwicmVuZGVyZXJcIixcbiAgICB1c2VSZXNpemVPYnNlcnZlcjogXCJyZW5kZXJlclwiLFxuICAgIHVzZVN2Z0d1dHRlckljb25zOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0ZvbGRlZEFubm90YXRpb25zOiBcInJlbmRlcmVyXCIsXG4gICAgc2Nyb2xsU3BlZWQ6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGRyYWdEZWxheTogXCIkbW91c2VIYW5kbGVyXCIsXG4gICAgZHJhZ0VuYWJsZWQ6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGZvY3VzVGltZW91dDogXCIkbW91c2VIYW5kbGVyXCIsXG4gICAgdG9vbHRpcEZvbGxvd3NNb3VzZTogXCIkbW91c2VIYW5kbGVyXCIsXG4gICAgZmlyc3RMaW5lTnVtYmVyOiBcInNlc3Npb25cIixcbiAgICBvdmVyd3JpdGU6IFwic2Vzc2lvblwiLFxuICAgIG5ld0xpbmVNb2RlOiBcInNlc3Npb25cIixcbiAgICB1c2VXb3JrZXI6IFwic2Vzc2lvblwiLFxuICAgIHVzZVNvZnRUYWJzOiBcInNlc3Npb25cIixcbiAgICBuYXZpZ2F0ZVdpdGhpblNvZnRUYWJzOiBcInNlc3Npb25cIixcbiAgICB0YWJTaXplOiBcInNlc3Npb25cIixcbiAgICB3cmFwOiBcInNlc3Npb25cIixcbiAgICBpbmRlbnRlZFNvZnRXcmFwOiBcInNlc3Npb25cIixcbiAgICBmb2xkU3R5bGU6IFwic2Vzc2lvblwiLFxuICAgIG1vZGU6IFwic2Vzc2lvblwiXG59KTtcbnZhciByZWxhdGl2ZU51bWJlclJlbmRlcmVyID0ge1xuICAgIGdldFRleHQ6IGZ1bmN0aW9uICgvKipAdHlwZXtFZGl0U2Vzc2lvbn0qLyBzZXNzaW9uLCAvKipAdHlwZXtudW1iZXJ9Ki8gcm93KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoc2Vzc2lvbi5zZWxlY3Rpb24ubGVhZC5yb3cgLSByb3cpIHx8IChyb3cgKyAxICsgKHJvdyA8IDkgPyBcIlxceGI3XCIgOiBcIlwiKSkpICsgXCJcIjtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoc2Vzc2lvbiwgLyoqQHR5cGV7bnVtYmVyfSovIGxhc3RMaW5lTnVtYmVyLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxhc3RMaW5lTnVtYmVyLnRvU3RyaW5nKCkubGVuZ3RoLCAoY29uZmlnLmxhc3RSb3cgKyAxKS50b1N0cmluZygpLmxlbmd0aCwgMikgKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChlLCAvKipAdHlwZXtFZGl0b3J9Ki8gZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci4kbG9vcC5zY2hlZHVsZShlZGl0b3IucmVuZGVyZXIuQ0hBTkdFX0dVVFRFUik7XG4gICAgfSxcbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgvKipAdHlwZXtFZGl0b3J9Ki8gZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuJHJlbmRlcmVyID0gdGhpcztcbiAgICAgICAgZWRpdG9yLm9uKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMudXBkYXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGUobnVsbCwgZWRpdG9yKTtcbiAgICB9LFxuICAgIGRldGFjaDogZnVuY3Rpb24gKC8qKkB0eXBle0VkaXRvcn0qLyBlZGl0b3IpIHtcbiAgICAgICAgaWYgKGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuJHJlbmRlcmVyID09IHRoaXMpXG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRyZW5kZXJlciA9IG51bGw7XG4gICAgICAgIGVkaXRvci5vZmYoXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy51cGRhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZShudWxsLCBlZGl0b3IpO1xuICAgIH1cbn07XG5leHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvbGluZXNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIExpbmVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVzKGVsZW1lbnQsIGNhbnZhc0hlaWdodCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodCB8fCA1MDAwMDA7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAodGhpcy5jYW52YXNIZWlnaHQgKiAyKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdO1xuICAgICAgICB0aGlzLmNlbGxDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLiRvZmZzZXRDb2VmZmljaWVudCA9IDA7XG4gICAgfVxuICAgIExpbmVzLnByb3RvdHlwZS5tb3ZlQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBkb20udHJhbnNsYXRlKHRoaXMuZWxlbWVudCwgMCwgLSgoY29uZmlnLmZpcnN0Um93U2NyZWVuICogY29uZmlnLmxpbmVIZWlnaHQpICUgdGhpcy5jYW52YXNIZWlnaHQpIC0gY29uZmlnLm9mZnNldCAqIHRoaXMuJG9mZnNldENvZWZmaWNpZW50KTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5wYWdlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRDb25maWcsIG5ld0NvbmZpZykge1xuICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoKG9sZENvbmZpZy5maXJzdFJvd1NjcmVlbiAqIG9sZENvbmZpZy5saW5lSGVpZ2h0KSAvIHRoaXMuY2FudmFzSGVpZ2h0KSAhPT1cbiAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld0NvbmZpZy5maXJzdFJvd1NjcmVlbiAqIG5ld0NvbmZpZy5saW5lSGVpZ2h0KSAvIHRoaXMuY2FudmFzSGVpZ2h0KSk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUuY29tcHV0ZUxpbmVUb3AgPSBmdW5jdGlvbiAocm93LCBjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHNjcmVlblRvcCA9IGNvbmZpZy5maXJzdFJvd1NjcmVlbiAqIGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgc2NyZWVuUGFnZSA9IE1hdGguZmxvb3Ioc2NyZWVuVG9wIC8gdGhpcy5jYW52YXNIZWlnaHQpO1xuICAgICAgICB2YXIgbGluZVRvcCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhyb3csIDApICogY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHJldHVybiBsaW5lVG9wIC0gKHNjcmVlblBhZ2UgKiB0aGlzLmNhbnZhc0hlaWdodCk7XG4gICAgfTtcbiAgICBMaW5lcy5wcm90b3R5cGUuY29tcHV0ZUxpbmVIZWlnaHQgPSBmdW5jdGlvbiAocm93LCBjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5saW5lSGVpZ2h0ICogc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQocm93KTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzLmxlbmd0aDtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNbaW5kZXhdO1xuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRjYWNoZUNlbGwodGhpcy5jZWxscy5zaGlmdCgpKTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGNhY2hlQ2VsbCh0aGlzLmNlbGxzLnBvcCgpKTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaC5hcHBseSh0aGlzLmNlbGxzLCBjZWxsKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvbS5jcmVhdGVGcmFnbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2VsbFtpXS5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoY2VsbC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjZWxsKSkge1xuICAgICAgICAgICAgdGhpcy5jZWxscy51bnNoaWZ0LmFwcGx5KHRoaXMuY2VsbHMsIGNlbGwpO1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9tLmNyZWF0ZUZyYWdtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjZWxsW2ldLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jZWxscy51bnNoaWZ0KGNlbGwpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgY2VsbC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxzW3RoaXMuY2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGluZXMucHJvdG90eXBlLiRjYWNoZUNlbGwgPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNlbGwuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUucHVzaChjZWxsKTtcbiAgICB9O1xuICAgIExpbmVzLnByb3RvdHlwZS5jcmVhdGVDZWxsID0gZnVuY3Rpb24gKHJvdywgY29uZmlnLCBzZXNzaW9uLCBpbml0RWxlbWVudCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbENhY2hlLnBvcCgpO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBpZiAoaW5pdEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgaW5pdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBjZWxsID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjZWxsLnJvdyA9IHJvdztcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZXM7XG59KCkpO1xuZXhwb3J0cy5MaW5lcyA9IExpbmVzO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci9ndXR0ZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9sYXllci9saW5lc1wiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgTGluZXMgPSByZXF1aXJlKFwiLi9saW5lc1wiKS5MaW5lcztcbnZhciBubHMgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpLm5scztcbnZhciBHdXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3V0dGVyKHBhcmVudEVsKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2VfbGF5ZXIgYWNlX2d1dHRlci1sYXllclwiO1xuICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNldFNob3dGb2xkV2lkZ2V0cyh0aGlzLiRzaG93Rm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLmd1dHRlcldpZHRoID0gMDtcbiAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMgPSB0aGlzLiR1cGRhdGVBbm5vdGF0aW9ucy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiRsaW5lcyA9IG5ldyBMaW5lcyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLiRsaW5lcy4kb2Zmc2V0Q29lZmZpY2llbnQgPSAxO1xuICAgIH1cbiAgICBHdXR0ZXIucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm9mZihcImNoYW5nZVwiLCB0aGlzLiR1cGRhdGVBbm5vdGF0aW9ucyk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgc2Vzc2lvbi5vbihcImNoYW5nZVwiLCB0aGlzLiR1cGRhdGVBbm5vdGF0aW9ucyk7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLmFkZEd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbiAocm93LCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKVxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2FybihcImRlcHJlY2F0ZWQgdXNlIHNlc3Npb24uYWRkR3V0dGVyRGVjb3JhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmFkZEd1dHRlckRlY29yYXRpb24ocm93LCBjbGFzc05hbWUpO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24gKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSlcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oXCJkZXByZWNhdGVkIHVzZSBzZXNzaW9uLnJlbW92ZUd1dHRlckRlY29yYXRpb25cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciByb3cgPSBhbm5vdGF0aW9uLnJvdztcbiAgICAgICAgICAgIHZhciByb3dJbmZvID0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XTtcbiAgICAgICAgICAgIGlmICghcm93SW5mbylcbiAgICAgICAgICAgICAgICByb3dJbmZvID0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XSA9IHsgdGV4dDogW10sIHR5cGU6IFtdLCBkaXNwbGF5VGV4dDogW10gfTtcbiAgICAgICAgICAgIHZhciBhbm5vVGV4dCA9IGFubm90YXRpb24udGV4dDtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5QW5ub1RleHQgPSBhbm5vdGF0aW9uLnRleHQ7XG4gICAgICAgICAgICB2YXIgYW5ub1R5cGUgPSBhbm5vdGF0aW9uLnR5cGU7XG4gICAgICAgICAgICBhbm5vVGV4dCA9IGFubm9UZXh0ID8gbGFuZy5lc2NhcGVIVE1MKGFubm9UZXh0KSA6IGFubm90YXRpb24uaHRtbCB8fCBcIlwiO1xuICAgICAgICAgICAgZGlzcGxheUFubm9UZXh0ID0gZGlzcGxheUFubm9UZXh0ID8gZGlzcGxheUFubm9UZXh0IDogYW5ub3RhdGlvbi5odG1sIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocm93SW5mby50ZXh0LmluZGV4T2YoYW5ub1RleHQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJvd0luZm8udGV4dC5wdXNoKGFubm9UZXh0KTtcbiAgICAgICAgICAgICAgICByb3dJbmZvLnR5cGUucHVzaChhbm5vVHlwZSk7XG4gICAgICAgICAgICAgICAgcm93SW5mby5kaXNwbGF5VGV4dC5wdXNoKGRpc3BsYXlBbm5vVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gYW5ub3RhdGlvbi5jbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbm5vVHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2VfZXJyb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFubm9UeXBlID09PSBcInNlY3VyaXR5XCIgJiYgIS9cXGJhY2VfZXJyb3JcXGIvLnRlc3Qocm93SW5mby5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2Vfc2VjdXJpdHlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFubm9UeXBlID09PSBcIndhcm5pbmdcIiAmJiAhL1xcYmFjZV8oZXJyb3J8c2VjdXJpdHkpXFxiLy50ZXN0KHJvd0luZm8uY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJvd0luZm8uY2xhc3NOYW1lID0gXCIgYWNlX3dhcm5pbmdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFubm9UeXBlID09PSBcImluZm9cIiAmJiAhcm93SW5mby5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByb3dJbmZvLmNsYXNzTmFtZSA9IFwiIGFjZV9pbmZvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbm5vVHlwZSA9PT0gXCJoaW50XCIgJiYgIXJvd0luZm8uY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2VfaGludFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLiR1cGRhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMuJGFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gZGVsdGEuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gZGVsdGEuZW5kLnJvdyAtIGZpcnN0Um93O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucy5zcGxpY2UoZmlyc3RSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDEpO1xuICAgICAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMuc3BsaWNlLmFwcGx5KHRoaXMuJGFubm90YXRpb25zLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93O1xuICAgICAgICB2YXIgbGFzdFJvdyA9IE1hdGgubWluKGNvbmZpZy5sYXN0Um93ICsgY29uZmlnLmd1dHRlck9mZnNldCwgLy8gbmVlZGVkIHRvIGNvbXBlbnNhdGUgZm9yIGhvciBzY29sbGJhclxuICAgICAgICBzZXNzaW9uLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIHRoaXMub2xkTGFzdFJvdyA9IGxhc3RSb3c7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLiRsaW5lcy5tb3ZlQ29udGFpbmVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvclJvdygpO1xuICAgICAgICB2YXIgZm9sZCA9IHNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGQgPyBmb2xkLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICB2YXIgY2VsbCA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZC5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICBmb2xkID0gc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkID8gZm9sZC5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuJGxpbmVzLmdldExlbmd0aCgpID4gaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLiRsaW5lcy5nZXQoKytpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIGNlbGwucm93ID0gcm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IHRoaXMuJGxpbmVzLmNyZWF0ZUNlbGwocm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbiwgb25DcmVhdGVDZWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2VsbChjZWxsLCBjb25maWcsIGZvbGQsIHJvdyk7XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZnRlclJlbmRlclwiKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlR3V0dGVyV2lkdGgoY29uZmlnKTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuJHVwZGF0ZUd1dHRlcldpZHRoID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGd1dHRlclJlbmRlcmVyID0gc2Vzc2lvbi5ndXR0ZXJSZW5kZXJlciB8fCB0aGlzLiRyZW5kZXJlcjtcbiAgICAgICAgdmFyIGZpcnN0TGluZU51bWJlciA9IHNlc3Npb24uJGZpcnN0TGluZU51bWJlcjtcbiAgICAgICAgdmFyIGxhc3RMaW5lVGV4dCA9IHRoaXMuJGxpbmVzLmxhc3QoKSA/IHRoaXMuJGxpbmVzLmxhc3QoKS50ZXh0IDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuJGZpeGVkV2lkdGggfHwgc2Vzc2lvbi4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICBsYXN0TGluZVRleHQgPSBzZXNzaW9uLmdldExlbmd0aCgpICsgZmlyc3RMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgdmFyIGd1dHRlcldpZHRoID0gZ3V0dGVyUmVuZGVyZXJcbiAgICAgICAgICAgID8gZ3V0dGVyUmVuZGVyZXIuZ2V0V2lkdGgoc2Vzc2lvbiwgbGFzdExpbmVUZXh0LCBjb25maWcpXG4gICAgICAgICAgICA6IGxhc3RMaW5lVGV4dC50b1N0cmluZygpLmxlbmd0aCAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLiRwYWRkaW5nIHx8IHRoaXMuJGNvbXB1dGVQYWRkaW5nKCk7XG4gICAgICAgIGd1dHRlcldpZHRoICs9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgIGlmIChndXR0ZXJXaWR0aCAhPT0gdGhpcy5ndXR0ZXJXaWR0aCAmJiAhaXNOYU4oZ3V0dGVyV2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmd1dHRlcldpZHRoID0gZ3V0dGVyV2lkdGg7ICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IE1hdGguY2VpbCh0aGlzLmd1dHRlcldpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUd1dHRlcldpZHRoXCIsIGd1dHRlcldpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS4kdXBkYXRlQ3Vyc29yUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmICh0aGlzLiRjdXJzb3JSb3cgPT09IHBvc2l0aW9uLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kY3Vyc29yUm93ID0gcG9zaXRpb24ucm93O1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS51cGRhdGVMaW5lSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvci5yb3c7XG4gICAgICAgIHRoaXMuJGN1cnNvclJvdyA9IHJvdztcbiAgICAgICAgaWYgKHRoaXMuJGN1cnNvckNlbGwgJiYgdGhpcy4kY3Vyc29yQ2VsbC5yb3cgPT0gcm93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kY3Vyc29yQ2VsbClcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLiRjdXJzb3JDZWxsLmVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoXCJhY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIGNlbGxzID0gdGhpcy4kbGluZXMuY2VsbHM7XG4gICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgICAgICAgaWYgKGNlbGwucm93ID49IHRoaXMuJGN1cnNvclJvdykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnJvdyA+IHRoaXMuJGN1cnNvclJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkTGluZSh0aGlzLiRjdXJzb3JSb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgZm9sZCAmJiBmb2xkLnN0YXJ0LnJvdyA9PSBjZWxsc1tpIC0gMV0ucm93KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IGNlbGxzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9ndXR0ZXItYWN0aXZlLWxpbmUgXCIgKyBjZWxsLmVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLnNjcm9sbExpbmVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JSb3coKTtcbiAgICAgICAgaWYgKHRoaXMuJGxpbmVzLnBhZ2VDaGFuZ2VkKG9sZENvbmZpZywgY29uZmlnKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICB0aGlzLiRsaW5lcy5tb3ZlQ29udGFpbmVyKGNvbmZpZyk7XG4gICAgICAgIHZhciBsYXN0Um93ID0gTWF0aC5taW4oY29uZmlnLmxhc3RSb3cgKyBjb25maWcuZ3V0dGVyT2Zmc2V0LCAvLyBuZWVkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaG9yIHNjb2xsYmFyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICB2YXIgb2xkTGFzdFJvdyA9IHRoaXMub2xkTGFzdFJvdztcbiAgICAgICAgdGhpcy5vbGRMYXN0Um93ID0gbGFzdFJvdztcbiAgICAgICAgaWYgKCFvbGRDb25maWcgfHwgb2xkTGFzdFJvdyA8IGNvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAobGFzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAob2xkQ29uZmlnLmZpcnN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KG9sZENvbmZpZy5maXJzdFJvdywgY29uZmlnLmZpcnN0Um93IC0gMSk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRMYXN0Um93ID4gbGFzdFJvdylcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkZWRSb3dDb3VudChsYXN0Um93ICsgMSwgb2xkTGFzdFJvdyk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnBvcCgpO1xuICAgICAgICBpZiAoY29uZmlnLmZpcnN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lcy51bnNoaWZ0KHRoaXMuJHJlbmRlckxpbmVzKGNvbmZpZywgY29uZmlnLmZpcnN0Um93LCBvbGRDb25maWcuZmlyc3RSb3cgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSb3cgPiBvbGRMYXN0Um93KSB7XG4gICAgICAgICAgICB0aGlzLiRsaW5lcy5wdXNoKHRoaXMuJHJlbmRlckxpbmVzKGNvbmZpZywgb2xkTGFzdFJvdyArIDEsIGxhc3RSb3cpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxpbmVIaWdobGlnaHQoKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUd1dHRlcldpZHRoKGNvbmZpZyk7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLiRyZW5kZXJMaW5lcyA9IGZ1bmN0aW9uIChjb25maWcsIGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IFtdO1xuICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdywgZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID4gbGFzdFJvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy4kbGluZXMuY3JlYXRlQ2VsbChyb3csIGNvbmZpZywgdGhpcy5zZXNzaW9uLCBvbkNyZWF0ZUNlbGwpO1xuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2VsbChjZWxsLCBjb25maWcsIGZvbGRMaW5lLCByb3cpO1xuICAgICAgICAgICAgZnJhZ21lbnQucHVzaChjZWxsKTtcbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuJHJlbmRlckNlbGwgPSBmdW5jdGlvbiAoY2VsbCwgY29uZmlnLCBmb2xkLCByb3cpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjZWxsLmVsZW1lbnQ7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBlbGVtZW50LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHZhciBmb2xkV2lkZ2V0ID0gZWxlbWVudC5jaGlsZE5vZGVzWzFdO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbk5vZGUgPSBlbGVtZW50LmNoaWxkTm9kZXNbMl07XG4gICAgICAgIHZhciBhbm5vdGF0aW9uSWNvbk5vZGUgPSBhbm5vdGF0aW9uTm9kZS5maXJzdENoaWxkO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtYmVyID0gc2Vzc2lvbi4kZmlyc3RMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgYnJlYWtwb2ludHMgPSBzZXNzaW9uLiRicmVha3BvaW50cztcbiAgICAgICAgdmFyIGRlY29yYXRpb25zID0gc2Vzc2lvbi4kZGVjb3JhdGlvbnM7XG4gICAgICAgIHZhciBndXR0ZXJSZW5kZXJlciA9IHNlc3Npb24uZ3V0dGVyUmVuZGVyZXIgfHwgdGhpcy4kcmVuZGVyZXI7XG4gICAgICAgIHZhciBmb2xkV2lkZ2V0cyA9IHRoaXMuJHNob3dGb2xkV2lkZ2V0cyAmJiBzZXNzaW9uLmZvbGRXaWRnZXRzO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBjb25maWcubGluZUhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuJHVzZVN2Z0d1dHRlckljb25zID8gXCJhY2VfZ3V0dGVyLWNlbGxfc3ZnLWljb25zIFwiIDogXCJhY2VfZ3V0dGVyLWNlbGwgXCI7XG4gICAgICAgIHZhciBpY29uQ2xhc3NOYW1lID0gdGhpcy4kdXNlU3ZnR3V0dGVySWNvbnMgPyBcImFjZV9pY29uX3N2Z1wiIDogXCJhY2VfaWNvblwiO1xuICAgICAgICB2YXIgcm93VGV4dCA9IChndXR0ZXJSZW5kZXJlclxuICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRUZXh0KHNlc3Npb24sIHJvdylcbiAgICAgICAgICAgIDogcm93ICsgZmlyc3RMaW5lTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0R3V0dGVyTGluZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA9PSB0aGlzLiRjdXJzb3JSb3cgfHwgKGZvbGQgJiYgcm93IDwgdGhpcy4kY3Vyc29yUm93ICYmIHJvdyA+PSBmb2xkU3RhcnQgJiYgdGhpcy4kY3Vyc29yUm93IDw9IGZvbGQuZW5kLnJvdykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXCJhY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjdXJzb3JDZWxsICE9IGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGN1cnNvckNlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjdXJzb3JDZWxsLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy4kY3Vyc29yQ2VsbC5lbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFwiYWNlX2d1dHRlci1hY3RpdmUtbGluZSBcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGN1cnNvckNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtwb2ludHNbcm93XSlcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBicmVha3BvaW50c1tyb3ddO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnNbcm93XSlcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBkZWNvcmF0aW9uc1tyb3ddO1xuICAgICAgICBpZiAodGhpcy4kYW5ub3RhdGlvbnNbcm93XSAmJiByb3cgIT09IGZvbGRTdGFydClcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSB0aGlzLiRhbm5vdGF0aW9uc1tyb3ddLmNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGZvbGRXaWRnZXRzKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGZvbGRXaWRnZXRzW3Jvd107XG4gICAgICAgICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGMgPSBmb2xkV2lkZ2V0c1tyb3ddID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIHZhciBmb2xkQ2xhc3MgPSBcImFjZV9mb2xkLXdpZGdldCBhY2VfXCIgKyBjO1xuICAgICAgICAgICAgdmFyIGlzQ2xvc2VkRm9sZCA9IGMgPT0gXCJzdGFydFwiICYmIHJvdyA9PSBmb2xkU3RhcnQgJiYgcm93IDwgZm9sZC5lbmQucm93O1xuICAgICAgICAgICAgaWYgKGlzQ2xvc2VkRm9sZCkge1xuICAgICAgICAgICAgICAgIGZvbGRDbGFzcyArPSBcIiBhY2VfY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRBbm5vdGF0aW9uQ2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uSW5Gb2xkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJvdyArIDE7IGkgPD0gZm9sZC5lbmQucm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kYW5ub3RhdGlvbnNbaV0uY2xhc3NOYW1lID09PSBcIiBhY2VfZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkluRm9sZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkQW5ub3RhdGlvbkNsYXNzID0gXCIgYWNlX2Vycm9yX2ZvbGRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRhbm5vdGF0aW9uc1tpXS5jbGFzc05hbWUgPT09IFwiIGFjZV9zZWN1cml0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uSW5Gb2xkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRBbm5vdGF0aW9uQ2xhc3MgPSBcIiBhY2Vfc2VjdXJpdHlfZm9sZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuJGFubm90YXRpb25zW2ldLmNsYXNzTmFtZSA9PT0gXCIgYWNlX3dhcm5pbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZEFubm90YXRpb25DbGFzcyAhPT0gXCIgYWNlX3NlY3VyaXR5X2ZvbGRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkluRm9sZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkQW5ub3RhdGlvbkNsYXNzID0gXCIgYWNlX3dhcm5pbmdfZm9sZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBmb2xkQW5ub3RhdGlvbkNsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvbGRDbGFzcyArPSBcIiBhY2Vfb3BlblwiO1xuICAgICAgICAgICAgaWYgKGZvbGRXaWRnZXQuY2xhc3NOYW1lICE9IGZvbGRDbGFzcylcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LmNsYXNzTmFtZSA9IGZvbGRDbGFzcztcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShmb2xkV2lkZ2V0LnN0eWxlLCBcImhlaWdodFwiLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShmb2xkV2lkZ2V0LnN0eWxlLCBcImRpc3BsYXlcIiwgXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICB2YXIgZm9sZFJhbmdlID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0UmFuZ2Uocm93KTtcbiAgICAgICAgICAgIGlmIChmb2xkUmFuZ2UpXG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG5scyhcImd1dHRlci5jb2RlLWZvbGRpbmcucmFuZ2UuYXJpYS1sYWJlbFwiLCBcIlRvZ2dsZSBjb2RlIGZvbGRpbmcsIHJvd3MgJDAgdGhyb3VnaCAkMVwiLCBbXG4gICAgICAgICAgICAgICAgICAgIGZvbGRSYW5nZS5zdGFydC5yb3cgKyAxLFxuICAgICAgICAgICAgICAgICAgICBmb2xkUmFuZ2UuZW5kLnJvdyArIDFcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZClcbiAgICAgICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG5scyhcImd1dHRlci5jb2RlLWZvbGRpbmcuY2xvc2VkLmFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgY29kZSBmb2xkaW5nLCByb3dzICQwIHRocm91Z2ggJDFcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZC5zdGFydC5yb3cgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZC5lbmQucm93ICsgMVxuICAgICAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbmxzKFwiZ3V0dGVyLmNvZGUtZm9sZGluZy5vcGVuLmFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgY29kZSBmb2xkaW5nLCByb3cgJDBcIiwgW3JvdyArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDbG9zZWRGb2xkKSB7XG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBubHMoXCJndXR0ZXIuY29kZS1mb2xkaW5nLmNsb3NlZC50aXRsZVwiLCBcIlVuZm9sZCBjb2RlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvbGRXaWRnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBubHMoXCJndXR0ZXIuY29kZS1mb2xkaW5nLm9wZW4udGl0bGVcIiwgXCJGb2xkIGNvZGVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvbGRXaWRnZXQpIHtcbiAgICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoZm9sZFdpZGdldC5zdHlsZSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIik7XG4gICAgICAgICAgICAgICAgZm9sZFdpZGdldC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uSW5Gb2xkICYmIHRoaXMuJHNob3dGb2xkZWRBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuY2xhc3NOYW1lID0gXCJhY2VfZ3V0dGVyX2Fubm90YXRpb25cIjtcbiAgICAgICAgICAgIGFubm90YXRpb25JY29uTm9kZS5jbGFzc05hbWUgPSBpY29uQ2xhc3NOYW1lO1xuICAgICAgICAgICAgYW5ub3RhdGlvbkljb25Ob2RlLmNsYXNzTmFtZSArPSBmb2xkQW5ub3RhdGlvbkNsYXNzO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGFubm90YXRpb25JY29uTm9kZS5zdHlsZSwgXCJoZWlnaHRcIiwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbk5vZGUuc3R5bGUsIFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGFubm90YXRpb25Ob2RlLnN0eWxlLCBcImhlaWdodFwiLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBhcmlhTGFiZWw7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvbGRBbm5vdGF0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiIGFjZV9lcnJvcl9mb2xkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IG5scyhcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwuZXJyb3JcIiwgXCJFcnJvciwgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIiwgW3Jvd1RleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBhY2Vfc2VjdXJpdHlfZm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICBhcmlhTGFiZWwgPSBubHMoXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLnNlY3VyaXR5XCIsIFwiU2VjdXJpdHkgZmluZGluZywgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIiwgW3Jvd1RleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBhY2Vfd2FybmluZ19mb2xkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IG5scyhcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwud2FybmluZ1wiLCBcIldhcm5pbmcsIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsIFtyb3dUZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kYW5ub3RhdGlvbnNbcm93XSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuY2xhc3NOYW1lID0gXCJhY2VfZ3V0dGVyX2Fubm90YXRpb25cIjtcbiAgICAgICAgICAgIGFubm90YXRpb25JY29uTm9kZS5jbGFzc05hbWUgPSBpY29uQ2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHVzZVN2Z0d1dHRlckljb25zKVxuICAgICAgICAgICAgICAgIGFubm90YXRpb25JY29uTm9kZS5jbGFzc05hbWUgKz0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XS5jbGFzc05hbWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuJGFubm90YXRpb25zW3Jvd10uY2xhc3NOYW1lLnJlcGxhY2UoXCIgXCIsIFwiXCIpKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShhbm5vdGF0aW9uSWNvbk5vZGUuc3R5bGUsIFwiaGVpZ2h0XCIsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGFubm90YXRpb25Ob2RlLnN0eWxlLCBcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShhbm5vdGF0aW9uTm9kZS5zdHlsZSwgXCJoZWlnaHRcIiwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICB2YXIgYXJpYUxhYmVsO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLiRhbm5vdGF0aW9uc1tyb3ddLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIgYWNlX2Vycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IG5scyhcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwuZXJyb3JcIiwgXCJFcnJvciwgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIiwgW3Jvd1RleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBhY2Vfc2VjdXJpdHlcIjpcbiAgICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsID0gbmxzKFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC5zZWN1cml0eVwiLCBcIlNlY3VyaXR5IGZpbmRpbmcsIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsIFtyb3dUZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIgYWNlX3dhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsID0gbmxzKFwiZ3V0dGVyLmFubm90YXRpb24uYXJpYS1sYWJlbC53YXJuaW5nXCIsIFwiV2FybmluZywgcmVhZCBhbm5vdGF0aW9ucyByb3cgJDBcIiwgW3Jvd1RleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBhY2VfaW5mb1wiOlxuICAgICAgICAgICAgICAgICAgICBhcmlhTGFiZWwgPSBubHMoXCJndXR0ZXIuYW5ub3RhdGlvbi5hcmlhLWxhYmVsLmluZm9cIiwgXCJJbmZvLCByZWFkIGFubm90YXRpb25zIHJvdyAkMFwiLCBbcm93VGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiIGFjZV9oaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbCA9IG5scyhcImd1dHRlci5hbm5vdGF0aW9uLmFyaWEtbGFiZWwuaGludFwiLCBcIlN1Z2dlc3Rpb24sIHJlYWQgYW5ub3RhdGlvbnMgcm93ICQwXCIsIFtyb3dUZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUoYW5ub3RhdGlvbk5vZGUuc3R5bGUsIFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbk5vZGUucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcbiAgICAgICAgICAgIGFubm90YXRpb25Ob2RlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm93VGV4dCAhPT0gdGV4dE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgdGV4dE5vZGUuZGF0YSA9IHJvd1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lICE9IGNsYXNzTmFtZSlcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICBkb20uc2V0U3R5bGUoY2VsbC5lbGVtZW50LnN0eWxlLCBcImhlaWdodFwiLCB0aGlzLiRsaW5lcy5jb21wdXRlTGluZUhlaWdodChyb3csIGNvbmZpZywgc2Vzc2lvbikgKyBcInB4XCIpO1xuICAgICAgICBkb20uc2V0U3R5bGUoY2VsbC5lbGVtZW50LnN0eWxlLCBcInRvcFwiLCB0aGlzLiRsaW5lcy5jb21wdXRlTGluZVRvcChyb3csIGNvbmZpZywgc2Vzc2lvbikgKyBcInB4XCIpO1xuICAgICAgICBjZWxsLnRleHQgPSByb3dUZXh0O1xuICAgICAgICBpZiAoYW5ub3RhdGlvbk5vZGUuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgJiYgZm9sZFdpZGdldC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIilcbiAgICAgICAgICAgIGNlbGwuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2VsbC5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfTtcbiAgICBHdXR0ZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0R3V0dGVyTGluZSkge1xuICAgICAgICB0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lID0gaGlnaGxpZ2h0R3V0dGVyTGluZTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuc2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgdGhpcy4kcmVuZGVyZXIgPSAhc2hvdyAmJiB7XG4gICAgICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCI7IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0xpbmVOdW1iZXJzO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS5zZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICBpZiAoc2hvdylcbiAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2ZvbGRpbmctZW5hYmxlZFwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfZm9sZGluZy1lbmFibGVkXCIpO1xuICAgICAgICB0aGlzLiRzaG93Rm9sZFdpZGdldHMgPSBzaG93O1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gbnVsbDtcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0U2hvd0ZvbGRXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0ZvbGRXaWRnZXRzO1xuICAgIH07XG4gICAgR3V0dGVyLnByb3RvdHlwZS4kY29tcHV0ZVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZSgvKipAdHlwZXtFbGVtZW50fSovICh0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZCkpO1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0ge307XG4gICAgICAgIHRoaXMuJHBhZGRpbmcubGVmdCA9IChwYXJzZUludChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApXG4gICAgICAgICAgICArIChwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCkgfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLiRwYWRkaW5nLnJpZ2h0ID0gKHBhcnNlSW50KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDApXG4gICAgICAgICAgICArIChwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDApO1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFkZGluZztcbiAgICB9O1xuICAgIEd1dHRlci5wcm90b3R5cGUuZ2V0UmVnaW9uID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHBvaW50LnggPCBwYWRkaW5nLmxlZnQgKyByZWN0LmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gXCJtYXJrZXJzXCI7XG4gICAgICAgIGlmICh0aGlzLiRzaG93Rm9sZFdpZGdldHMgJiYgcG9pbnQueCA+IHJlY3QucmlnaHQgLSBwYWRkaW5nLnJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIFwiZm9sZFdpZGdldHNcIjtcbiAgICB9O1xuICAgIHJldHVybiBHdXR0ZXI7XG59KCkpO1xuR3V0dGVyLnByb3RvdHlwZS4kZml4ZWRXaWR0aCA9IGZhbHNlO1xuR3V0dGVyLnByb3RvdHlwZS4kaGlnaGxpZ2h0R3V0dGVyTGluZSA9IHRydWU7XG5HdXR0ZXIucHJvdG90eXBlLiRyZW5kZXJlciA9IFwiXCI7XG5HdXR0ZXIucHJvdG90eXBlLiRzaG93TGluZU51bWJlcnMgPSB0cnVlO1xuR3V0dGVyLnByb3RvdHlwZS4kc2hvd0ZvbGRXaWRnZXRzID0gdHJ1ZTtcbm9vcC5pbXBsZW1lbnQoR3V0dGVyLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIG9uQ3JlYXRlQ2VsbChlbGVtZW50KSB7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIHZhciBmb2xkV2lkZ2V0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9sZFdpZGdldCk7XG4gICAgdmFyIGFubm90YXRpb25Ob2RlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvbk5vZGUpO1xuICAgIHZhciBhbm5vdGF0aW9uSWNvbk5vZGUgPSBkb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYW5ub3RhdGlvbk5vZGUuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvbkljb25Ob2RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmV4cG9ydHMuR3V0dGVyID0gR3V0dGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci9tYXJrZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSByZXF1aXJlKFwiLi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgTWFya2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtlcihwYXJlbnRFbCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX2xheWVyIGFjZV9tYXJrZXItbGF5ZXJcIjtcbiAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgTWFya2VyLnByb3RvdHlwZS5zZXRQYWRkaW5nID0gZnVuY3Rpb24gKHBhZGRpbmcpIHtcbiAgICAgICAgdGhpcy4kcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5zZXRNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZWx0ID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgY3NzKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5pICE9IC0xICYmIHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzW3RoaXMuaV07XG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoeCk7XG4gICAgICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSsrO1xuICAgICAgICB9XG4gICAgICAgIHguc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgeC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKCFjb25maWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB2YXIgaHRtbDtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubWFya2Vycykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMubWFya2Vyc1trZXldO1xuICAgICAgICAgICAgaWYgKCFtYXJrZXIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKGh0bWwsIHRoaXMsIHRoaXMuc2Vzc2lvbiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1hcmtlci5yYW5nZS5jbGlwUm93cyhjb25maWcuZmlyc3RSb3csIGNvbmZpZy5sYXN0Um93KTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlLnRvU2NyZWVuUmFuZ2UodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuJHBhZGRpbmcgKyByYW5nZS5zdGFydC5jb2x1bW4gKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcmVyKGh0bWwsIHJhbmdlLCBsZWZ0LCB0b3AsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXJrZXIudHlwZSA9PSBcImZ1bGxMaW5lXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdGdWxsTGluZU1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFya2VyLnR5cGUgPT0gXCJzY3JlZW5MaW5lXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTY3JlZW5MaW5lTWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci50eXBlID09IFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0TWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdNdWx0aUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiArIFwiIGFjZV9zdGFydFwiICsgXCIgYWNlX2JyMTVcIiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pICE9IC0xKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pIDwgdGhpcy5lbGVtZW50LmNoaWxkRWxlbWVudENvdW50KVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS4kZ2V0VG9wID0gZnVuY3Rpb24gKHJvdywgbGF5ZXJDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIChyb3cgLSBsYXllckNvbmZpZy5maXJzdFJvd1NjcmVlbikgKiBsYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3VGV4dE1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCBleHRyYVN0eWxlKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQucm93O1xuICAgICAgICB2YXIgcm93ID0gc3RhcnQ7XG4gICAgICAgIHZhciBwcmV2ID0gMDtcbiAgICAgICAgdmFyIGN1cnIgPSAwO1xuICAgICAgICB2YXIgbmV4dCA9IHNlc3Npb24uZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbihyb3cpO1xuICAgICAgICB2YXIgbGluZVJhbmdlID0gbmV3IFJhbmdlKHJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCByb3csIGN1cnIpO1xuICAgICAgICBmb3IgKDsgcm93IDw9IGVuZDsgcm93KyspIHtcbiAgICAgICAgICAgIGxpbmVSYW5nZS5zdGFydC5yb3cgPSBsaW5lUmFuZ2UuZW5kLnJvdyA9IHJvdztcbiAgICAgICAgICAgIGxpbmVSYW5nZS5zdGFydC5jb2x1bW4gPSByb3cgPT0gc3RhcnQgPyByYW5nZS5zdGFydC5jb2x1bW4gOiBzZXNzaW9uLmdldFJvd1dyYXBJbmRlbnQocm93KTtcbiAgICAgICAgICAgIGxpbmVSYW5nZS5lbmQuY29sdW1uID0gbmV4dDtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gcm93ICsgMSA8IGVuZCA/IHNlc3Npb24uZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbihyb3cgKyAxKSA6IHJvdyA9PSBlbmQgPyAwIDogcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIoc3RyaW5nQnVpbGRlciwgbGluZVJhbmdlLCBjbGF6eiArIChyb3cgPT0gc3RhcnQgPyBcIiBhY2Vfc3RhcnRcIiA6IFwiXCIpICsgXCIgYWNlX2JyXCJcbiAgICAgICAgICAgICAgICArIGdldEJvcmRlckNsYXNzKHJvdyA9PSBzdGFydCB8fCByb3cgPT0gc3RhcnQgKyAxICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcHJldiA8IGN1cnIsIGN1cnIgPiBuZXh0LCByb3cgPT0gZW5kKSwgbGF5ZXJDb25maWcsIHJvdyA9PSBlbmQgPyAwIDogMSwgZXh0cmFTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZHJhd011bHRpTGluZU1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuJHBhZGRpbmc7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBsZWZ0ID0gcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgZXh0cmFTdHlsZSA9IGV4dHJhU3R5bGUgfHwgXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHJhbmdlLnN0YXJ0LnJvdykpIHtcbiAgICAgICAgICAgIHZhciByYW5nZTEgPSByYW5nZS5jbG9uZSgpO1xuICAgICAgICAgICAgcmFuZ2UxLmVuZC5yb3cgPSByYW5nZTEuc3RhcnQucm93O1xuICAgICAgICAgICAgcmFuZ2UxLmVuZC5jb2x1bW4gPSB0aGlzLnNlc3Npb24uZ2V0TGluZShyYW5nZTEuc3RhcnQucm93KS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZTEsIGNsYXp6ICsgXCIgYWNlX2JyMSBhY2Vfc3RhcnRcIiwgY29uZmlnLCBudWxsLCBleHRyYVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWx0KGNsYXp6ICsgXCIgYWNlX2JyMSBhY2Vfc3RhcnRcIiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICsgXCJyaWdodDpcIiArIHBhZGRpbmcgKyBcInB4O1wiICsgXCJ0b3A6XCIgKyB0b3AgKyBcInB4O2xlZnQ6XCIgKyBsZWZ0ICsgXCJweDtcIiArIChleHRyYVN0eWxlIHx8IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5pc0JpZGlSb3cocmFuZ2UuZW5kLnJvdykpIHtcbiAgICAgICAgICAgIHZhciByYW5nZTEgPSByYW5nZS5jbG9uZSgpO1xuICAgICAgICAgICAgcmFuZ2UxLnN0YXJ0LnJvdyA9IHJhbmdlMS5lbmQucm93O1xuICAgICAgICAgICAgcmFuZ2UxLnN0YXJ0LmNvbHVtbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZTEsIGNsYXp6ICsgXCIgYWNlX2JyMTJcIiwgY29uZmlnLCBudWxsLCBleHRyYVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5lbmQucm93LCBjb25maWcpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmFuZ2UuZW5kLmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWx0KGNsYXp6ICsgXCIgYWNlX2JyMTJcIiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcInRvcDpcIiArIHRvcCArIFwicHg7XCIgK1xuICAgICAgICAgICAgICAgIFwibGVmdDpcIiArIHBhZGRpbmcgKyBcInB4O1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IChyYW5nZS5lbmQucm93IC0gcmFuZ2Uuc3RhcnQucm93IC0gMSkgKiBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgaWYgKGhlaWdodCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93ICsgMSwgY29uZmlnKTtcbiAgICAgICAgdmFyIHJhZGl1c0NsYXNzID0gKHJhbmdlLnN0YXJ0LmNvbHVtbiA/IDEgOiAwKSB8IChyYW5nZS5lbmQuY29sdW1uID8gMCA6IDgpO1xuICAgICAgICB0aGlzLmVsdChjbGF6eiArIChyYWRpdXNDbGFzcyA/IFwiIGFjZV9iclwiICsgcmFkaXVzQ2xhc3MgOiBcIlwiKSwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwicmlnaHQ6XCIgKyBwYWRkaW5nICsgXCJweDtcIiArXG4gICAgICAgICAgICBcInRvcDpcIiArIHRvcCArIFwicHg7XCIgK1xuICAgICAgICAgICAgXCJsZWZ0OlwiICsgcGFkZGluZyArIFwicHg7XCIgKyAoZXh0cmFTdHlsZSB8fCBcIlwiKSk7XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLmRyYXdTaW5nbGVMaW5lTWFya2VyID0gZnVuY3Rpb24gKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYUxlbmd0aCwgZXh0cmFTdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5pc0JpZGlSb3cocmFuZ2Uuc3RhcnQucm93KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdCaWRpU2luZ2xlTGluZU1hcmtlcihzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFMZW5ndGgsIGV4dHJhU3R5bGUpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IChyYW5nZS5lbmQuY29sdW1uICsgKGV4dHJhTGVuZ3RoIHx8IDApIC0gcmFuZ2Uuc3RhcnQuY29sdW1uKSAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy4kcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5lbHQoY2xhenosIFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDtcIiArXG4gICAgICAgICAgICBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6XCIgKyBsZWZ0ICsgXCJweDtcIiArIChleHRyYVN0eWxlIHx8IFwiXCIpKTtcbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUuZHJhd0JpZGlTaW5nbGVMaW5lTWFya2VyID0gZnVuY3Rpb24gKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYUxlbmd0aCwgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQsIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyksIHBhZGRpbmcgPSB0aGlzLiRwYWRkaW5nO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuZ2V0U2VsZWN0aW9ucyhyYW5nZS5zdGFydC5jb2x1bW4sIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lbHQoY2xhenosIFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgXCJ3aWR0aDpcIiArIChzZWxlY3Rpb24ud2lkdGggKyAoZXh0cmFMZW5ndGggfHwgMCkpICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgXCJ0b3A6XCIgKyB0b3AgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcImxlZnQ6XCIgKyAocGFkZGluZyArIHNlbGVjdGlvbi5sZWZ0KSArIFwicHg7XCIgKyAoZXh0cmFTdHlsZSB8fCBcIlwiKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3RnVsbExpbmVNYXJrZXIgPSBmdW5jdGlvbiAoc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBjb25maWcsIGV4dHJhU3R5bGUpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyAhPSByYW5nZS5lbmQucm93KVxuICAgICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuJGdldFRvcChyYW5nZS5lbmQucm93LCBjb25maWcpIC0gdG9wO1xuICAgICAgICB0aGlzLmVsdChjbGF6eiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6MDtyaWdodDowO1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5kcmF3U2NyZWVuTGluZU1hcmtlciA9IGZ1bmN0aW9uIChzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmVsdChjbGF6eiwgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICBcImxlZnQ6MDtyaWdodDowO1wiICsgKGV4dHJhU3R5bGUgfHwgXCJcIikpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtlcjtcbn0oKSk7XG5NYXJrZXIucHJvdG90eXBlLiRwYWRkaW5nID0gMDtcbmZ1bmN0aW9uIGdldEJvcmRlckNsYXNzKHRsLCB0ciwgYnIsIGJsKSB7XG4gICAgcmV0dXJuICh0bCA/IDEgOiAwKSB8ICh0ciA/IDIgOiAwKSB8IChiciA/IDQgOiAwKSB8IChibCA/IDggOiAwKTtcbn1cbmV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci90ZXh0X3V0aWxcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7Ly8gVG9rZW5zIGZvciB3aGljaCBBY2UganVzdCB1c2VzIGEgc2ltcGxlIFRleHROb2RlIGFuZCBkb2VzIG5vdCBhZGQgYW55IHNwZWNpYWwgY2xhc3NOYW1lLlxudmFyIHRleHRUb2tlbnMgPSBuZXcgU2V0KFtcInRleHRcIiwgXCJycGFyZW5cIiwgXCJscGFyZW5cIl0pO1xuZXhwb3J0cy5pc1RleHRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblR5cGUpIHtcbiAgICByZXR1cm4gdGV4dFRva2Vucy5oYXModG9rZW5UeXBlKTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL3RleHRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGF5ZXIvbGluZXNcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xheWVyL3RleHRfdXRpbFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIExpbmVzID0gcmVxdWlyZShcIi4vbGluZXNcIikuTGluZXM7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBubHMgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpLm5scztcbnZhciBpc1RleHRUb2tlbiA9IHJlcXVpcmUoXCIuL3RleHRfdXRpbFwiKS5pc1RleHRUb2tlbjtcbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQocGFyZW50RWwpIHtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9sYXllciBhY2VfdGV4dC1sYXllclwiO1xuICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLiR1cGRhdGVFb2xDaGFyID0gdGhpcy4kdXBkYXRlRW9sQ2hhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiRsaW5lcyA9IG5ldyBMaW5lcyh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS4kdXBkYXRlRW9sQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuc2Vzc2lvbi5kb2M7XG4gICAgICAgIHZhciB1bml4TW9kZSA9IGRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkgPT0gXCJcXG5cIiAmJiBkb2MuZ2V0TmV3TGluZU1vZGUoKSAhPSBcIndpbmRvd3NcIjtcbiAgICAgICAgdmFyIEVPTF9DSEFSID0gdW5peE1vZGUgPyB0aGlzLkVPTF9DSEFSX0xGIDogdGhpcy5FT0xfQ0hBUl9DUkxGO1xuICAgICAgICBpZiAodGhpcy5FT0xfQ0hBUiAhPSBFT0xfQ0hBUikge1xuICAgICAgICAgICAgdGhpcy5FT0xfQ0hBUiA9IEVPTF9DSEFSO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbiA9IFwiMCBcIiArIHBhZGRpbmcgKyBcInB4XCI7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZm9udE1ldHJpY3MuJGNoYXJhY3RlclNpemUuaGVpZ2h0IHx8IDA7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5nZXRDaGFyYWN0ZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnRNZXRyaWNzLiRjaGFyYWN0ZXJTaXplLndpZHRoIHx8IDA7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kc2V0Rm9udE1ldHJpY3MgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgICB0aGlzLiRmb250TWV0cmljcyA9IG1lYXN1cmU7XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzLm9uKFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVwiLCBcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuY2hlY2tGb3JTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kZm9udE1ldHJpY3MuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHBvbGxTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gdGhpcy4kZm9udE1ldHJpY3MuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbiAoc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMgPT0gc2hvd0ludmlzaWJsZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd0ludmlzaWJsZXMgPSBzaG93SW52aXNpYmxlcztcbiAgICAgICAgaWYgKHR5cGVvZiBzaG93SW52aXNpYmxlcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTcGFjZXMgPSAvdGFiL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgICAgICB0aGlzLnNob3dUYWJzID0gL3NwYWNlL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgICAgICB0aGlzLnNob3dFT0wgPSAvZW9sL2kudGVzdChzaG93SW52aXNpYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTcGFjZXMgPSB0aGlzLnNob3dUYWJzID0gdGhpcy5zaG93RU9MID0gc2hvd0ludmlzaWJsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgICBpZiAodGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzID09IGRpc3BsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGxheUluZGVudEd1aWRlcyA9IGRpc3BsYXk7XG4gICAgICAgIHRoaXMuJGNvbXB1dGVUYWJTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5zZXRIaWdobGlnaHRJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZXMgPT09IGhpZ2hsaWdodClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVzID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJGNvbXB1dGVUYWJTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTsgdmFyIHRhYlN0ciA9IHRoaXMuJHRhYlN0cmluZ3MgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGFiU2l6ZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1RhYnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfdGFiXCI7XG4gICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KHRoaXMuVEFCX0NIQVIsIGkpO1xuICAgICAgICAgICAgICAgIHRhYlN0ci5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiU3RyLnB1c2godGhpcy5kb20uY3JlYXRlVGV4dE5vZGUobGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIGkpLCB0aGlzLmVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzKSB7XG4gICAgICAgICAgICB0aGlzLiRpbmRlbnRHdWlkZVJlID0gL1xcc1xcU3wgXFx0fFxcdCB8XFxzJC87XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJhY2VfaW5kZW50LWd1aWRlXCI7XG4gICAgICAgICAgICB2YXIgc3BhY2VDbGFzcyA9IHRoaXMuc2hvd1NwYWNlcyA/IFwiIGFjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV9zcGFjZVwiIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBzcGFjZUNvbnRlbnQgPSB0aGlzLnNob3dTcGFjZXNcbiAgICAgICAgICAgICAgICA/IGxhbmcuc3RyaW5nUmVwZWF0KHRoaXMuU1BBQ0VfQ0hBUiwgdGhpcy50YWJTaXplKVxuICAgICAgICAgICAgICAgIDogbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIHRoaXMudGFiU2l6ZSk7XG4gICAgICAgICAgICB2YXIgdGFiQ2xhc3MgPSB0aGlzLnNob3dUYWJzID8gXCIgYWNlX2ludmlzaWJsZSBhY2VfaW52aXNpYmxlX3RhYlwiIDogXCJcIjtcbiAgICAgICAgICAgIHZhciB0YWJDb250ZW50ID0gdGhpcy5zaG93VGFic1xuICAgICAgICAgICAgICAgID8gbGFuZy5zdHJpbmdSZXBlYXQodGhpcy5UQUJfQ0hBUiwgdGhpcy50YWJTaXplKVxuICAgICAgICAgICAgICAgIDogc3BhY2VDb250ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmRvbS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgc3BhY2VDbGFzcztcbiAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBzcGFjZUNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLiR0YWJTdHJpbmdzW1wiIFwiXSA9IHNwYW47XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyB0YWJDbGFzcztcbiAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0YWJDb250ZW50O1xuICAgICAgICAgICAgdGhpcy4kdGFiU3RyaW5nc1tcIlxcdFwiXSA9IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnVwZGF0ZUxpbmVzID0gZnVuY3Rpb24gKGNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxhc3RSb3cgIT0gY29uZmlnLmxhc3RSb3cgfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmZpcnN0Um93ICE9IGNvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWF4KGZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cpO1xuICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWluKGxhc3RSb3csIGNvbmZpZy5sYXN0Um93KTtcbiAgICAgICAgdmFyIGxpbmVFbGVtZW50cyA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgbGluZUVsZW1lbnRzSWR4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gY29uZmlnLmZpcnN0Um93OyByb3cgPCBmaXJzdDsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lLmNvbnRhaW5zUm93KGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVFbGVtZW50c0lkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciByb3cgPSBmaXJzdDtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3cpO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkTGluZSk7XG4gICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiBsYXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrOyB2YXIgbGluZUVsZW1lbnQgPSBsaW5lRWxlbWVudHNbbGluZUVsZW1lbnRzSWR4KytdO1xuICAgICAgICAgICAgaWYgKGxpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2hpbGRyZW4obGluZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlbmRlckxpbmUobGluZUVsZW1lbnQsIHJvdywgcm93ID09IGZvbGRTdGFydCA/IGZvbGRMaW5lIDogZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRDaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBsaW5lRWxlbWVudC5zdHlsZS50b3AgPSB0aGlzLiRsaW5lcy5jb21wdXRlTGluZVRvcChyb3csIGNvbmZpZywgdGhpcy5zZXNzaW9uKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBpZiAobGluZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB3aGlsZSAobGluZUVsZW1lbnRzSWR4IDwgdGhpcy4kbGluZXMuY2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLiRsaW5lcy5jZWxsc1tsaW5lRWxlbWVudHNJZHgrK107XG4gICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lVG9wKGNlbGwucm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbikgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNjcm9sbExpbmVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAodGhpcy4kbGluZXMucGFnZUNoYW5nZWQob2xkQ29uZmlnLCBjb25maWcpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuJGxpbmVzLm1vdmVDb250YWluZXIoY29uZmlnKTtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIG9sZExhc3RSb3cgPSBvbGRDb25maWcgPyBvbGRDb25maWcubGFzdFJvdyA6IC0xO1xuICAgICAgICBpZiAoIW9sZENvbmZpZyB8fCBvbGRMYXN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmIChsYXN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmICghb2xkQ29uZmlnIHx8IG9sZENvbmZpZy5sYXN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcubGFzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuICAgICAgICBpZiAob2xkQ29uZmlnLmZpcnN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KG9sZENvbmZpZy5maXJzdFJvdywgY29uZmlnLmZpcnN0Um93IC0gMSk7IHJvdyA+IDA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRDb25maWcubGFzdFJvdyA+IGNvbmZpZy5sYXN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KGNvbmZpZy5sYXN0Um93ICsgMSwgb2xkQ29uZmlnLmxhc3RSb3cpOyByb3cgPiAwOyByb3ctLSlcbiAgICAgICAgICAgICAgICB0aGlzLiRsaW5lcy5wb3AoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5maXJzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgdGhpcy4kbGluZXMudW5zaGlmdCh0aGlzLiRyZW5kZXJMaW5lc0ZyYWdtZW50KGNvbmZpZywgY29uZmlnLmZpcnN0Um93LCBvbGRDb25maWcuZmlyc3RSb3cgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5sYXN0Um93ID4gb2xkQ29uZmlnLmxhc3RSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuJGxpbmVzLnB1c2godGhpcy4kcmVuZGVyTGluZXNGcmFnbWVudChjb25maWcsIG9sZENvbmZpZy5sYXN0Um93ICsgMSwgY29uZmlnLmxhc3RSb3cpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlckxpbmVzRnJhZ21lbnQgPSBmdW5jdGlvbiAoY29uZmlnLCBmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBbXTtcbiAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3RSb3cpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuJGxpbmVzLmNyZWF0ZUNlbGwocm93LCBjb25maWcsIHRoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICB2YXIgbGluZUVsID0gbGluZS5lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2hpbGRyZW4obGluZUVsKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsaW5lRWwuc3R5bGUsIFwiaGVpZ2h0XCIsIHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lSGVpZ2h0KHJvdywgY29uZmlnLCB0aGlzLnNlc3Npb24pICsgXCJweFwiKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShsaW5lRWwuc3R5bGUsIFwidG9wXCIsIHRoaXMuJGxpbmVzLmNvbXB1dGVMaW5lVG9wKHJvdywgY29uZmlnLCB0aGlzLnNlc3Npb24pICsgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlckxpbmUobGluZUVsLCByb3csIHJvdyA9PSBmb2xkU3RhcnQgPyBmb2xkTGluZSA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VMaW5lR3JvdXBzKCkpIHtcbiAgICAgICAgICAgICAgICBsaW5lRWwuY2xhc3NOYW1lID0gXCJhY2VfbGluZV9ncm91cFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZUVsLmNsYXNzTmFtZSA9IFwiYWNlX2xpbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWdtZW50LnB1c2gobGluZSk7XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuJGxpbmVzLm1vdmVDb250YWluZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IGNvbmZpZy5maXJzdFJvdztcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kbGluZXM7XG4gICAgICAgIHdoaWxlIChsaW5lcy5nZXRMZW5ndGgoKSlcbiAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuJHJlbmRlckxpbmVzRnJhZ21lbnQoY29uZmlnLCBmaXJzdFJvdywgbGFzdFJvdykpO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlclRva2VuID0gZnVuY3Rpb24gKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmUgPSAvKFxcdCl8KCArKXwoW1xceDAwLVxceDFmXFx4ODAtXFx4YTBcXHhhZFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkNcXHUyMDY2XFx1MjA2N1xcdTIwNjhcXHUyMDJBXFx1MjAyQlxcdTIwMkRcXHUyMDJFXFx1MjAyQ1xcdTIwNjlcXHUyMDYwXFx1MjA2MVxcdTIwNjJcXHUyMDYzXFx1MjA2NFxcdTIwNkFcXHUyMDZCXFx1MjA2QlxcdTIwNkNcXHUyMDZEXFx1MjA2RVxcdTIwNkZdKyl8KFxcdTMwMDApfChbXFx1MTEwMC1cXHUxMTVGXFx1MTFBMy1cXHUxMUE3XFx1MTFGQS1cXHUxMUZGXFx1MjMyOS1cXHUyMzJBXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MkZGMC1cXHUyRkZCXFx1MzAwMS1cXHUzMDNFXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzE5MC1cXHUzMUJBXFx1MzFDMC1cXHUzMUUzXFx1MzFGMC1cXHUzMjFFXFx1MzIyMC1cXHUzMjQ3XFx1MzI1MC1cXHUzMkZFXFx1MzMwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhDXFx1QTQ5MC1cXHVBNEM2XFx1QTk2MC1cXHVBOTdDXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQUZGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTY2XFx1RkU2OC1cXHVGRTZCXFx1RkYwMS1cXHVGRjYwXFx1RkZFMC1cXHVGRkU2XXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKS9nO1xuICAgICAgICB2YXIgdmFsdWVGcmFnbWVudCA9IHRoaXMuZG9tLmNyZWF0ZUZyYWdtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0YWIgPSBtWzFdO1xuICAgICAgICAgICAgdmFyIHNpbXBsZVNwYWNlID0gbVsyXTtcbiAgICAgICAgICAgIHZhciBjb250cm9sQ2hhcmFjdGVyID0gbVszXTtcbiAgICAgICAgICAgIHZhciBjamtTcGFjZSA9IG1bNF07XG4gICAgICAgICAgICB2YXIgY2prID0gbVs1XTtcbiAgICAgICAgICAgIGlmICghc2VsZi5zaG93U3BhY2VzICYmIHNpbXBsZVNwYWNlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGkgIT0gbS5pbmRleCA/IHZhbHVlLnNsaWNlKGksIG0uaW5kZXgpIDogXCJcIjtcbiAgICAgICAgICAgIGkgPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jcmVhdGVUZXh0Tm9kZShiZWZvcmUsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhYikge1xuICAgICAgICAgICAgICAgIHZhciB0YWJTaXplID0gc2VsZi5zZXNzaW9uLmdldFNjcmVlblRhYlNpemUoc2NyZWVuQ29sdW1uICsgbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLiR0YWJTdHJpbmdzW3RhYlNpemVdLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IHRhYlNpemUgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2ltcGxlU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaG93U3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KHNlbGYuU1BBQ0VfQ0hBUiwgc2ltcGxlU3BhY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20uY3JlYXRlVGV4dE5vZGUoc2ltcGxlU3BhY2UsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2UgYWNlX2ludmFsaWRcIjtcbiAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gbGFuZy5zdHJpbmdSZXBlYXQoc2VsZi5TUEFDRV9DSEFSLCBjb250cm9sQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNqa1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmRvbS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gKHNlbGYuY29uZmlnLmNoYXJhY3RlcldpZHRoICogMikgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBzZWxmLnNob3dTcGFjZXMgPyBcImFjZV9jamsgYWNlX2ludmlzaWJsZSBhY2VfaW52aXNpYmxlX3NwYWNlXCIgOiBcImFjZV9jamtcIjtcbiAgICAgICAgICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gc2VsZi5zaG93U3BhY2VzID8gc2VsZi5TUEFDRV9DSEFSIDogY2prU3BhY2U7XG4gICAgICAgICAgICAgICAgdmFsdWVGcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNqaykge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IChzZWxmLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCAqIDIpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJhY2VfY2prXCI7XG4gICAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGNqaztcbiAgICAgICAgICAgICAgICB2YWx1ZUZyYWdtZW50LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlRnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20uY3JlYXRlVGV4dE5vZGUoaSA/IHZhbHVlLnNsaWNlKGkpIDogdmFsdWUsIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICBpZiAoIWlzVGV4dFRva2VuKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFwiYWNlX1wiICsgdG9rZW4udHlwZS5yZXBsYWNlKC9cXC4vZywgXCIgYWNlX1wiKTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PSBcImZvbGRcIikge1xuICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUud2lkdGggPSAodG9rZW4udmFsdWUubGVuZ3RoICogdGhpcy5jb25maWcuY2hhcmFjdGVyV2lkdGgpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgbmxzKFwiaW5saW5lLWZvbGQuY2xvc2VkLnRpdGxlXCIsIFwiVW5mb2xkIGNvZGVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjbGFzc2VzO1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZCh2YWx1ZUZyYWdtZW50KTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh2YWx1ZUZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NyZWVuQ29sdW1uICsgdmFsdWUubGVuZ3RoO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUucmVuZGVySW5kZW50R3VpZGUgPSBmdW5jdGlvbiAocGFyZW50LCB2YWx1ZSwgbWF4KSB7XG4gICAgICAgIHZhciBjb2xzID0gdmFsdWUuc2VhcmNoKHRoaXMuJGluZGVudEd1aWRlUmUpO1xuICAgICAgICBpZiAoY29scyA8PSAwIHx8IGNvbHMgPj0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVbMF0gPT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGNvbHMgLT0gY29scyAlIHRoaXMudGFiU2l6ZTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGNvbHMgLyB0aGlzLnRhYlNpemU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy4kdGFiU3RyaW5nc1tcIiBcIl0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuJHRhYlN0cmluZ3NbXCJcXHRcIl0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRoaWdobGlnaHRJbmRlbnRHdWlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZXMgfHwgIXRoaXMuZGlzcGxheUluZGVudEd1aWRlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIgPSB7XG4gICAgICAgICAgICBpbmRlbnRMZXZlbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGlyOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zZXNzaW9uLmRvYy4kbGluZXM7XG4gICAgICAgIGlmICghbGluZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgaW5pdGlhbEluZGVudCA9IC9eXFxzKi8uZXhlYyh0aGlzLnNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdykpWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIGVsZW1lbnRJbmRlbnRMZXZlbCA9IE1hdGguZmxvb3IoaW5pdGlhbEluZGVudCAvIHRoaXMudGFiU2l6ZSk7XG4gICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyID0ge1xuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IGVsZW1lbnRJbmRlbnRMZXZlbCxcbiAgICAgICAgICAgIHN0YXJ0OiBjdXJzb3Iucm93XG4gICAgICAgIH07XG4gICAgICAgIHZhciBicmFja2V0SGlnaGxpZ2h0ID0gdGhpcy5zZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0O1xuICAgICAgICBpZiAoYnJhY2tldEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodC5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3Iucm93ICE9PSByYW5nZXNbaV0uc3RhcnQucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmVuZCA9IHJhbmdlc1tpXS5zdGFydC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnJvdyA+IHJhbmdlc1tpXS5zdGFydC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmRpciA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZGlyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lc1tjdXJzb3Iucm93XSAhPT0gJycgJiYgY3Vyc29yLmNvbHVtbiA9PT0gbGluZXNbY3Vyc29yLnJvd10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZGlyID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gY3Vyc29yLnJvdyArIDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZW50IDw9IGluaXRpYWxJbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kcmVuZGVySGlnaGxpZ2h0SW5kZW50R3VpZGUoKTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRjbGVhckFjdGl2ZUluZGVudEd1aWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlSW5kZW50R3VpZGVzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNlX2luZGVudC1ndWlkZS1hY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZUluZGVudEd1aWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImFjZV9pbmRlbnQtZ3VpZGUtYWN0aXZlXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRzZXRJbmRlbnRHdWlkZUFjdGl2ZSA9IGZ1bmN0aW9uIChjZWxsLCBpbmRlbnRMZXZlbCkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5kb2MuZ2V0TGluZShjZWxsLnJvdyk7XG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNlbGwuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChjZWxsLmVsZW1lbnQuY2xhc3NMaXN0ICYmIGNlbGwuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJhY2VfbGluZV9ncm91cFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjZWxsLmVsZW1lbnQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZE5vZGVzW2luZGVudExldmVsIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5jbGFzc0xpc3QgJiYgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY2VfaW5kZW50LWd1aWRlXCIpKVxuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoXCJhY2VfaW5kZW50LWd1aWRlLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlckhpZ2hsaWdodEluZGVudEd1aWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLiRsaW5lcy5jZWxscztcbiAgICAgICAgdGhpcy4kY2xlYXJBY3RpdmVJbmRlbnRHdWlkZSgpO1xuICAgICAgICB2YXIgaW5kZW50TGV2ZWwgPSB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5pbmRlbnRMZXZlbDtcbiAgICAgICAgaWYgKGluZGVudExldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZGlyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0SW5kZW50R3VpZGVNYXJrZXIuZW5kICYmIGNlbGwucm93ID49IHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLnN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnJvdyA+PSB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXRJbmRlbnRHdWlkZUFjdGl2ZShjZWxsLCBpbmRlbnRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gY2VsbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLmVuZCAmJiBjZWxsLnJvdyA8IHRoaXMuJGhpZ2hsaWdodEluZGVudEd1aWRlTWFya2VyLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5yb3cgPCB0aGlzLiRoaWdobGlnaHRJbmRlbnRHdWlkZU1hcmtlci5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXRJbmRlbnRHdWlkZUFjdGl2ZShjZWxsLCBpbmRlbnRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLiRjcmVhdGVMaW5lRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGxpbmVFbCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGxpbmVFbC5jbGFzc05hbWUgPSBcImFjZV9saW5lXCI7XG4gICAgICAgIGxpbmVFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmNvbmZpZy5saW5lSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gbGluZUVsO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHJlbmRlcldyYXBwZWRMaW5lID0gZnVuY3Rpb24gKHBhcmVudCwgdG9rZW5zLCBzcGxpdHMpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gMDtcbiAgICAgICAgdmFyIHNwbGl0ID0gMDtcbiAgICAgICAgdmFyIHNwbGl0Q2hhcnMgPSBzcGxpdHNbMF07XG4gICAgICAgIHZhciBzY3JlZW5Db2x1bW4gPSAwO1xuICAgICAgICB2YXIgbGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpID09IDAgJiYgdGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzKSB7XG4gICAgICAgICAgICAgICAgY2hhcnMgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlckluZGVudEd1aWRlKGxpbmVFbCwgdmFsdWUsIHNwbGl0Q2hhcnMpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoYXJzIC09IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFycyArIHZhbHVlLmxlbmd0aCA8IHNwbGl0Q2hhcnMpIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjaGFycyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcnMgKyB2YWx1ZS5sZW5ndGggPj0gc3BsaXRDaGFycykge1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlLnN1YnN0cmluZygwLCBzcGxpdENoYXJzIC0gY2hhcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3BsaXRDaGFycyAtIGNoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBzcGxpdENoYXJzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lRWwgPSB0aGlzLiRjcmVhdGVMaW5lRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobGluZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUVsLmFwcGVuZENoaWxkKHRoaXMuZG9tLmNyZWF0ZVRleHROb2RlKGxhbmcuc3RyaW5nUmVwZWF0KFwiXFx4YTBcIiwgc3BsaXRzLmluZGVudCksIHRoaXMuZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCsrO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdENoYXJzID0gc3BsaXRzW3NwbGl0XSB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihsaW5lRWwsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV0gPiB0aGlzLk1BWF9MSU5FX0xFTkdUSClcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlck92ZXJmbG93TWVzc2FnZShsaW5lRWwsIHNjcmVlbkNvbHVtbiwgbnVsbCwgXCJcIiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyU2ltcGxlTGluZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgc2NyZWVuQ29sdW1uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCAmJiB0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVuZGVySW5kZW50R3VpZGUocGFyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NyZWVuQ29sdW1uICsgdmFsdWUubGVuZ3RoID4gdGhpcy5NQVhfTElORV9MRU5HVEgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHJlbmRlck92ZXJmbG93TWVzc2FnZShwYXJlbnQsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyT3ZlcmZsb3dNZXNzYWdlID0gZnVuY3Rpb24gKHBhcmVudCwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUsIGhpZGUpIHtcbiAgICAgICAgdG9rZW4gJiYgdGhpcy4kcmVuZGVyVG9rZW4ocGFyZW50LCBzY3JlZW5Db2x1bW4sIHRva2VuLCB2YWx1ZS5zbGljZSgwLCB0aGlzLk1BWF9MSU5FX0xFTkdUSCAtIHNjcmVlbkNvbHVtbikpO1xuICAgICAgICB2YXIgb3ZlcmZsb3dFbCA9IHRoaXMuZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBvdmVyZmxvd0VsLmNsYXNzTmFtZSA9IFwiYWNlX2lubGluZV9idXR0b24gYWNlX2tleXdvcmQgYWNlX3RvZ2dsZV93cmFwXCI7XG4gICAgICAgIG92ZXJmbG93RWwudGV4dENvbnRlbnQgPSBoaWRlID8gXCI8aGlkZT5cIiA6IFwiPGNsaWNrIHRvIHNlZSBtb3JlLi4uPlwiO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQob3ZlcmZsb3dFbCk7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kcmVuZGVyTGluZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHJvdywgZm9sZExpbmUpIHtcbiAgICAgICAgaWYgKCFmb2xkTGluZSAmJiBmb2xkTGluZSAhPSBmYWxzZSlcbiAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLiRnZXRGb2xkTGluZVRva2Vucyhyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuc2Vzc2lvbi5nZXRUb2tlbnMocm93KTtcbiAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQ7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy5zZXNzaW9uLmdldFJvd1NwbGl0RGF0YShyb3cpO1xuICAgICAgICAgICAgaWYgKHNwbGl0cyAmJiBzcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVuZGVyV3JhcHBlZExpbmUocGFyZW50LCB0b2tlbnMsIHNwbGl0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lRWwgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHVzZUxpbmVHcm91cHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxhc3RMaW5lRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRyZW5kZXJTaW1wbGVMaW5lKGxhc3RMaW5lRWwsIHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kdXNlTGluZUdyb3VwcygpKSB7XG4gICAgICAgICAgICBsYXN0TGluZUVsID0gdGhpcy4kY3JlYXRlTGluZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChsYXN0TGluZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93RU9MICYmIGxhc3RMaW5lRWwpIHtcbiAgICAgICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICAgICAgdmFyIGludmlzaWJsZUVsID0gdGhpcy5kb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBpbnZpc2libGVFbC5jbGFzc05hbWUgPSBcImFjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV9lb2xcIjtcbiAgICAgICAgICAgIGludmlzaWJsZUVsLnRleHRDb250ZW50ID0gcm93ID09IHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEgPyB0aGlzLkVPRl9DSEFSIDogdGhpcy5FT0xfQ0hBUjtcbiAgICAgICAgICAgIGxhc3RMaW5lRWwuYXBwZW5kQ2hpbGQoaW52aXNpYmxlRWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS4kZ2V0Rm9sZExpbmVUb2tlbnMgPSBmdW5jdGlvbiAocm93LCBmb2xkTGluZSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHJlbmRlclRva2VucyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRUb2tlbnModG9rZW5zLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDAsIGNvbCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGNvbCArIHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aCkgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgY29sICs9IHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID09IHRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgIT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpZHhdLnZhbHVlLnN1YnN0cmluZyhmcm9tIC0gY29sKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gKHRvIC0gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyVG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbnNbaWR4XS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2wgPSBmcm9tICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IHRvICYmIGlkeCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaWR4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICsgY29sID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5zW2lkeF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgdG8gLSBjb2wpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHRva2Vuc1tpZHhdKTtcbiAgICAgICAgICAgICAgICBjb2wgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICBmb2xkTGluZS53YWxrKGZ1bmN0aW9uIChwbGFjZWhvbGRlciwgcm93LCBjb2x1bW4sIGxhc3RDb2x1bW4sIGlzTmV3Um93KSB7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmb2xkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3Um93KVxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRUb2tlbnModG9rZW5zLCBsYXN0Q29sdW1uLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmb2xkTGluZS5lbmQucm93LCB0aGlzLnNlc3Npb24uZ2V0TGluZShmb2xkTGluZS5lbmQucm93KS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVuZGVyVG9rZW5zO1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuJHVzZUxpbmVHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcblRleHQucHJvdG90eXBlLkVPRl9DSEFSID0gXCJcXHhCNlwiO1xuVGV4dC5wcm90b3R5cGUuRU9MX0NIQVJfTEYgPSBcIlxceEFDXCI7XG5UZXh0LnByb3RvdHlwZS5FT0xfQ0hBUl9DUkxGID0gXCJcXHhhNFwiO1xuVGV4dC5wcm90b3R5cGUuRU9MX0NIQVIgPSBUZXh0LnByb3RvdHlwZS5FT0xfQ0hBUl9MRjtcblRleHQucHJvdG90eXBlLlRBQl9DSEFSID0gXCJcXHUyMDE0XCI7IC8vXCJcXHUyMUU1XCI7XG5UZXh0LnByb3RvdHlwZS5TUEFDRV9DSEFSID0gXCJcXHhCN1wiO1xuVGV4dC5wcm90b3R5cGUuJHBhZGRpbmcgPSAwO1xuVGV4dC5wcm90b3R5cGUuTUFYX0xJTkVfTEVOR1RIID0gMTAwMDA7XG5UZXh0LnByb3RvdHlwZS5zaG93SW52aXNpYmxlcyA9IGZhbHNlO1xuVGV4dC5wcm90b3R5cGUuc2hvd1NwYWNlcyA9IGZhbHNlO1xuVGV4dC5wcm90b3R5cGUuc2hvd1RhYnMgPSBmYWxzZTtcblRleHQucHJvdG90eXBlLnNob3dFT0wgPSBmYWxzZTtcblRleHQucHJvdG90eXBlLmRpc3BsYXlJbmRlbnRHdWlkZXMgPSB0cnVlO1xuVGV4dC5wcm90b3R5cGUuJGhpZ2hsaWdodEluZGVudEd1aWRlcyA9IHRydWU7XG5UZXh0LnByb3RvdHlwZS4kdGFiU3RyaW5ncyA9IFtdO1xuVGV4dC5wcm90b3R5cGUuZGVzdHJveSA9IHt9O1xuVGV4dC5wcm90b3R5cGUub25DaGFuZ2VUYWJTaXplID0gVGV4dC5wcm90b3R5cGUuJGNvbXB1dGVUYWJTdHJpbmc7XG5vb3AuaW1wbGVtZW50KFRleHQucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvY3Vyc29yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBDdXJzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3Vyc29yKHBhcmVudEVsKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2VfbGF5ZXIgYWNlX2N1cnNvci1sYXllclwiO1xuICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQmxpbmtpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSAxMDAwO1xuICAgICAgICB0aGlzLnNtb290aEJsaW5raW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29ycyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuYWRkQ3Vyc29yKCk7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JzID0gdGhpcy4kdXBkYXRlT3BhY2l0eS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBDdXJzb3IucHJvdG90eXBlLiR1cGRhdGVPcGFjaXR5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgY3Vyc29ycyA9IHRoaXMuY3Vyc29ycztcbiAgICAgICAgZm9yICh2YXIgaSA9IGN1cnNvcnMubGVuZ3RoOyBpLS07KVxuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGN1cnNvcnNbaV0uc3R5bGUsIFwib3BhY2l0eVwiLCB2YWwgPyBcIlwiIDogXCIwXCIpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS4kc3RhcnRDc3NBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3JzID0gdGhpcy5jdXJzb3JzO1xuICAgICAgICBmb3IgKHZhciBpID0gY3Vyc29ycy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICBjdXJzb3JzW2ldLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy5ibGlua0ludGVydmFsICsgXCJtc1wiO1xuICAgICAgICB0aGlzLiRpc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGlzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfYW5pbWF0ZS1ibGlua2luZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuJHN0b3BDc3NBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2FuaW1hdGUtYmxpbmtpbmdcIik7XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnNldEJsaW5raW5nID0gZnVuY3Rpb24gKGJsaW5raW5nKSB7XG4gICAgICAgIGlmIChibGlua2luZyAhPSB0aGlzLmlzQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCbGlua2luZyA9IGJsaW5raW5nO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zZXRCbGlua0ludGVydmFsID0gZnVuY3Rpb24gKGJsaW5rSW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKGJsaW5rSW50ZXJ2YWwgIT0gdGhpcy5ibGlua0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSBibGlua0ludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zZXRTbW9vdGhCbGlua2luZyA9IGZ1bmN0aW9uIChzbW9vdGhCbGlua2luZykge1xuICAgICAgICBpZiAoc21vb3RoQmxpbmtpbmcgIT0gdGhpcy5zbW9vdGhCbGlua2luZykge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhCbGlua2luZyA9IHNtb290aEJsaW5raW5nO1xuICAgICAgICAgICAgZG9tLnNldENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIsIHNtb290aEJsaW5raW5nKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvcnModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiYWNlX2N1cnNvclwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB0aGlzLmN1cnNvcnMucHVzaChlbCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUucmVtb3ZlQ3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuY3Vyc29ycy5wb3AoKTtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmhpZGVDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5zaG93Q3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgIH07XG4gICAgQ3Vyc29yLnByb3RvdHlwZS5yZXN0YXJ0VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSB0aGlzLiR1cGRhdGVDdXJzb3JzO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuJHN0b3BDc3NBbmltYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGlzU21vb3RoQmxpbmtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX3Ntb290aC1ibGlua2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pc0JsaW5raW5nIHx8ICF0aGlzLmJsaW5rSW50ZXJ2YWwgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLiRzdG9wQ3NzQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGlzU21vb3RoQmxpbmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGlzU21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5IQVNfQ1NTX0FOSU1BVElPTikge1xuICAgICAgICAgICAgdGhpcy4kc3RhcnRDc3NBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBibGluayA9IC8qKkB0aGlze0N1cnNvcn0qLyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LCAwLjYgKiB0aGlzLmJsaW5rSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBibGluaygpO1xuICAgICAgICAgICAgfSwgdGhpcy5ibGlua0ludGVydmFsKTtcbiAgICAgICAgICAgIGJsaW5rKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuZ2V0UGl4ZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgb25TY3JlZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZyB8fCAhdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIGlmICghcG9zaXRpb24pXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGN1cnNvckxlZnQgPSB0aGlzLiRwYWRkaW5nICsgKHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuaXNCaWRpUm93KHBvcy5yb3csIHBvc2l0aW9uLnJvdylcbiAgICAgICAgICAgID8gdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5nZXRQb3NMZWZ0KHBvcy5jb2x1bW4pXG4gICAgICAgICAgICA6IHBvcy5jb2x1bW4gKiB0aGlzLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCk7XG4gICAgICAgIHZhciBjdXJzb3JUb3AgPSAocG9zLnJvdyAtIChvblNjcmVlbiA/IHRoaXMuY29uZmlnLmZpcnN0Um93U2NyZWVuIDogMCkpICpcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGN1cnNvckxlZnQsIHRvcDogY3Vyc29yVG9wIH07XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmlzQ3Vyc29ySW5WaWV3ID0gZnVuY3Rpb24gKHBpeGVsUG9zLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHBpeGVsUG9zLnRvcCA+PSAwICYmIHBpeGVsUG9zLnRvcCA8IGNvbmZpZy5tYXhIZWlnaHQ7XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzO1xuICAgICAgICB2YXIgaSA9IDAsIGN1cnNvckluZGV4ID0gMDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IFt7IGN1cnNvcjogbnVsbCB9XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNlbGVjdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGl4ZWxQb3MgPSB0aGlzLmdldFBpeGVsUG9zaXRpb24oc2VsZWN0aW9uc1tpXS5jdXJzb3IsIHRydWUpO1xuICAgICAgICAgICAgaWYgKChwaXhlbFBvcy50b3AgPiBjb25maWcuaGVpZ2h0ICsgY29uZmlnLm9mZnNldCB8fFxuICAgICAgICAgICAgICAgIHBpeGVsUG9zLnRvcCA8IDApICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3Vyc29yc1tjdXJzb3JJbmRleCsrXSB8fCB0aGlzLmFkZEN1cnNvcigpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmF3Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ3Vyc29ySW5WaWV3KHBpeGVsUG9zLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvbS50cmFuc2xhdGUoZWxlbWVudCwgcGl4ZWxQb3MubGVmdCwgcGl4ZWxQb3MudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHN0eWxlLCBcIndpZHRoXCIsIE1hdGgucm91bmQoY29uZmlnLmNoYXJhY3RlcldpZHRoKSArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJoZWlnaHRcIiwgY29uZmlnLmxpbmVIZWlnaHQgKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0N1cnNvcihlbGVtZW50LCBwaXhlbFBvcywgY29uZmlnLCBzZWxlY3Rpb25zW2ldLCB0aGlzLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnNvcnMubGVuZ3RoID4gY3Vyc29ySW5kZXgpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUN1cnNvcigpO1xuICAgICAgICB2YXIgb3ZlcndyaXRlID0gdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpO1xuICAgICAgICB0aGlzLiRzZXRPdmVyd3JpdGUob3ZlcndyaXRlKTtcbiAgICAgICAgdGhpcy4kcGl4ZWxQb3MgPSBwaXhlbFBvcztcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICB9O1xuICAgIEN1cnNvci5wcm90b3R5cGUuJHNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChvdmVyd3JpdGUpIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSAhPSB0aGlzLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdGhpcy5vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXJzb3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXJzb3I7XG59KCkpO1xuQ3Vyc29yLnByb3RvdHlwZS4kcGFkZGluZyA9IDA7XG5DdXJzb3IucHJvdG90eXBlLmRyYXdDdXJzb3IgPSBudWxsO1xuZXhwb3J0cy5DdXJzb3IgPSBDdXJzb3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Njcm9sbGJhclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgTUFYX1NDUk9MTF9IID0gMHg4MDAwO1xudmFyIFNjcm9sbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIocGFyZW50LCBjbGFzc1N1ZmZpeCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGJhciBhY2Vfc2Nyb2xsYmFyXCIgKyBjbGFzc1N1ZmZpeDtcbiAgICAgICAgdGhpcy5pbm5lciA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmlubmVyLmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGJhci1pbm5lclwiO1xuICAgICAgICB0aGlzLmlubmVyLnRleHRDb250ZW50ID0gXCJcXHhhMFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lcik7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZXZlbnQucHJldmVudERlZmF1bHQpO1xuICAgIH1cbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jb2VmZiA9IDE7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsYmFyO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoU2Nyb2xsYmFyLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBWU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWU2Nyb2xsQmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZTY3JvbGxCYXIocGFyZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsICctdicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIF90aGlzLnNjcm9sbEhlaWdodCA9IDA7XG4gICAgICAgIHJlbmRlcmVyLiRzY3JvbGxiYXJXaWR0aCA9XG4gICAgICAgICAgICBfdGhpcy53aWR0aCA9IGRvbS5zY3JvbGxiYXJXaWR0aChwYXJlbnQub3duZXJEb2N1bWVudCk7XG4gICAgICAgIF90aGlzLmlubmVyLnN0eWxlLndpZHRoID1cbiAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAoX3RoaXMud2lkdGggfHwgMTUpICsgNSArIFwicHhcIjtcbiAgICAgICAgX3RoaXMuJG1pbldpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNraXBFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29lZmYgIT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodCAvIHRoaXMuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3AgKiAoMSAtIGgpIC8gKHRoaXMuY29lZmYgLSBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwLCB0aGlzLiRtaW5XaWR0aCB8fCAwKTtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChoZWlnaHQgPiBNQVhfU0NST0xMX0gpIHtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBNQVhfU0NST0xMX0ggLyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSBNQVhfU0NST0xMX0g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb2VmZiAhPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wICE9IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5za2lwRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICogdGhpcy5jb2VmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZTY3JvbGxCYXI7XG59KFNjcm9sbGJhcikpO1xuVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0SW5uZXJIZWlnaHQgPSBWU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRTY3JvbGxIZWlnaHQ7XG52YXIgSFNjcm9sbEJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFNjcm9sbEJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIU2Nyb2xsQmFyKHBhcmVudCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCAnLWgnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gcmVuZGVyZXIuJHNjcm9sbGJhcldpZHRoO1xuICAgICAgICBfdGhpcy5pbm5lci5zdHlsZS5oZWlnaHQgPVxuICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoX3RoaXMuaGVpZ2h0IHx8IDE1KSArIDUgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcInNjcm9sbFwiLCB7IGRhdGE6IHRoaXMuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBFdmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhlaWdodCA6IDA7XG4gICAgfTtcbiAgICBIU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLnNldElubmVyV2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChzY3JvbGxMZWZ0KSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgIT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgdGhpcy5za2lwRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSFNjcm9sbEJhcjtcbn0oU2Nyb2xsYmFyKSk7XG5leHBvcnRzLlNjcm9sbEJhciA9IFZTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuU2Nyb2xsQmFyViA9IFZTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuU2Nyb2xsQmFySCA9IEhTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuVlNjcm9sbEJhciA9IFZTY3JvbGxCYXI7XG5leHBvcnRzLkhTY3JvbGxCYXIgPSBIU2Nyb2xsQmFyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9zY3JvbGxiYXJfY3VzdG9tXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIGV2ZW50ID0gcmVxdWlyZShcIi4vbGliL2V2ZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbmRvbS5pbXBvcnRDc3NTdHJpbmcoXCIuYWNlX2VkaXRvcj4uYWNlX3NiLXYgZGl2LCAuYWNlX2VkaXRvcj4uYWNlX3NiLWggZGl2e1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjYpO1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNiYmI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB6LWluZGV4OiA4O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLXYsIC5hY2VfZWRpdG9yPi5hY2Vfc2ItaCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA2O1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIG92ZXJmbG93OiBoaWRkZW4haW1wb3J0YW50O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLXYge1xcbiAgei1pbmRleDogNjtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEycHg7XFxufVxcbi5hY2VfZWRpdG9yPi5hY2Vfc2ItdiBkaXYge1xcbiAgei1pbmRleDogODtcXG4gIHJpZ2h0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5hY2VfZWRpdG9yPi5hY2Vfc2ItaCB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgaGVpZ2h0OiAxMnB4O1xcbn1cXG4uYWNlX2VkaXRvcj4uYWNlX3NiLWggZGl2IHtcXG4gIGJvdHRvbTogMDtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLmFjZV9lZGl0b3I+LmFjZV9zYl9ncmFiYmVkIHtcXG4gIHotaW5kZXg6IDg7XFxuICBiYWNrZ3JvdW5kOiAjMDAwO1xcbn1cIiwgXCJhY2Vfc2Nyb2xsYmFyLmNzc1wiLCBmYWxzZSk7XG52YXIgU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbEJhcihwYXJlbnQsIGNsYXNzU3VmZml4KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2Vfc2JcIiArIGNsYXNzU3VmZml4O1xuICAgICAgICB0aGlzLmlubmVyID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuaW5uZXIuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5uZXIpO1xuICAgICAgICB0aGlzLlZTY3JvbGxXaWR0aCA9IDEyO1xuICAgICAgICB0aGlzLkhTY3JvbGxIZWlnaHQgPSAxMjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIodGhpcy5lbGVtZW50LCBbNTAwLCAzMDAsIDMwMF0sIHRoaXMsIFwib25Nb3VzZURvd25cIik7XG4gICAgfVxuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBpc1Zpc2libGUgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgICAgICB0aGlzLmNvZWZmID0gMTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxCYXI7XG59KCkpO1xub29wLmltcGxlbWVudChTY3JvbGxCYXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xudmFyIFZTY3JvbGxCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZTY3JvbGxCYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVlNjcm9sbEJhcihwYXJlbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgJy12JykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgX3RoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLlZTY3JvbGxXaWR0aDtcbiAgICAgICAgX3RoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgX3RoaXMuaW5uZXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKF90aGlzLndpZHRoIHx8IDE1KSArIFwicHhcIjtcbiAgICAgICAgX3RoaXMuJG1pbldpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlVHlwZSwgZSkge1xuICAgICAgICBpZiAoZVR5cGUgIT09IFwibW91c2Vkb3duXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC5nZXRCdXR0b24oZSkgIT09IDAgfHwgZS5kZXRhaWwgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtb3VzZVBhZ2VZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgdmFyIG9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBtb3VzZVBhZ2VZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VG9wID0gdGhpcy50aHVtYlRvcDtcbiAgICAgICAgICAgIHZhciBvblNjcm9sbEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBhZ2VZID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gc2VsZi5zY3JvbGxUb3BGcm9tVGh1bWJUb3Aoc3RhcnRUb3AgKyBtb3VzZVBhZ2VZIC0gc3RhcnRZKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBzZWxmLnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiBzY3JvbGxUb3AgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuY2FwdHVyZSh0aGlzLmlubmVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZVVwKTtcbiAgICAgICAgICAgIHZhciB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25TY3JvbGxJbnRlcnZhbCwgMjApO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3AgPSBlLmNsaWVudFkgLSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy50aHVtYkhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcEZyb21UaHVtYlRvcCh0b3ApIH0pO1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcbiAgICBWU2Nyb2xsQmFyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNjcm9sbFRvcEZyb21UaHVtYlRvcCA9IGZ1bmN0aW9uICh0aHVtYlRvcCkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGh1bWJUb3AgKiAodGhpcy5wYWdlSGVpZ2h0IC0gdGhpcy52aWV3SGVpZ2h0KSAvICh0aGlzLnNsaWRlSGVpZ2h0IC0gdGhpcy50aHVtYkhlaWdodCk7XG4gICAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCA+PiAwO1xuICAgICAgICBpZiAoc2Nyb2xsVG9wIDwgMCkge1xuICAgICAgICAgICAgc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGxUb3AgPiB0aGlzLnBhZ2VIZWlnaHQgLSB0aGlzLnZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwLCB0aGlzLiRtaW5XaWR0aCB8fCAwKTtcbiAgICB9O1xuICAgIFZTY3JvbGxCYXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCgwLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnNsaWRlSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnNldFNjcm9sbEhlaWdodCh0aGlzLnBhZ2VIZWlnaHQsIHRydWUpO1xuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnZUhlaWdodCA9PT0gaGVpZ2h0ICYmICFmb3JjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wYWdlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gdGhpcy5zbGlkZUhlaWdodCAqIHRoaXMudmlld0hlaWdodCAvIHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJIZWlnaHQgPiB0aGlzLnNsaWRlSGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy50aHVtYkhlaWdodCA9IHRoaXMuc2xpZGVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnRodW1iSGVpZ2h0IDwgMTUpXG4gICAgICAgICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gMTU7XG4gICAgICAgIHRoaXMuaW5uZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy50aHVtYkhlaWdodCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID4gKHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gKHRoaXMucGFnZUhlaWdodCAtIHRoaXMudmlld0hlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiB0aGlzLnNjcm9sbFRvcCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVlNjcm9sbEJhci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgaWYgKHNjcm9sbFRvcCA8IDApXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLnRodW1iVG9wID0gc2Nyb2xsVG9wICogKHRoaXMuc2xpZGVIZWlnaHQgLSB0aGlzLnRodW1iSGVpZ2h0KSAvICh0aGlzLnBhZ2VIZWlnaHQgLSB0aGlzLnZpZXdIZWlnaHQpO1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLnRvcCA9IHRoaXMudGh1bWJUb3AgKyBcInB4XCI7XG4gICAgfTtcbiAgICByZXR1cm4gVlNjcm9sbEJhcjtcbn0oU2Nyb2xsQmFyKSk7XG5WU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRJbm5lckhlaWdodCA9IFZTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbEhlaWdodDtcbnZhciBIU2Nyb2xsQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIU2Nyb2xsQmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhTY3JvbGxCYXIocGFyZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsICctaCcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICBfdGhpcy5zY3JvbGxXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLmhlaWdodCA9IF90aGlzLkhTY3JvbGxIZWlnaHQ7XG4gICAgICAgIF90aGlzLmlubmVyLnN0eWxlLmhlaWdodCA9IF90aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKF90aGlzLmhlaWdodCB8fCAxMikgKyBcInB4XCI7XG4gICAgICAgIF90aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZVR5cGUsIGUpIHtcbiAgICAgICAgaWYgKGVUeXBlICE9PSBcIm1vdXNlZG93blwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQuZ2V0QnV0dG9uKGUpICE9PSAwIHx8IGUuZGV0YWlsID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbW91c2VQYWdlWCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBvbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbW91c2VQYWdlWCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25Nb3VzZVVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBzdGFydExlZnQgPSB0aGlzLnRodW1iTGVmdDtcbiAgICAgICAgICAgIHZhciBvblNjcm9sbEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBhZ2VYID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHNlbGYuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQoc3RhcnRMZWZ0ICsgbW91c2VQYWdlWCAtIHN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbExlZnQgPT09IHNlbGYuc2Nyb2xsTGVmdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJzY3JvbGxcIiwgeyBkYXRhOiBzY3JvbGxMZWZ0IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LmNhcHR1cmUodGhpcy5pbm5lciwgb25Nb3VzZU1vdmUsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKG9uU2Nyb2xsSW50ZXJ2YWwsIDIwKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IGUuY2xpZW50WCAtIHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gdGhpcy50aHVtYldpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5fZW1pdChcInNjcm9sbFwiLCB7IGRhdGE6IHRoaXMuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQobGVmdCkgfSk7XG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID8gdGhpcy5oZWlnaHQgOiAwO1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2Nyb2xsTGVmdEZyb21UaHVtYkxlZnQgPSBmdW5jdGlvbiAodGh1bWJMZWZ0KSB7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gdGh1bWJMZWZ0ICogKHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpIC8gKHRoaXMuc2xpZGVXaWR0aCAtIHRoaXMudGh1bWJXaWR0aCk7XG4gICAgICAgIHNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0ID4+IDA7XG4gICAgICAgIGlmIChzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsTGVmdCA+IHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLnBhZ2VXaWR0aCAtIHRoaXMudmlld1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICAgIH07XG4gICAgSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5zbGlkZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy52aWV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFdpZHRoKHRoaXMucGFnZVdpZHRoLCB0cnVlKTtcbiAgICB9O1xuICAgIEhTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5wYWdlV2lkdGggPT09IHdpZHRoICYmICFmb3JjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wYWdlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy50aHVtYldpZHRoID0gdGhpcy5zbGlkZVdpZHRoICogdGhpcy52aWV3V2lkdGggLyB0aGlzLnBhZ2VXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJXaWR0aCA+IHRoaXMuc2xpZGVXaWR0aClcbiAgICAgICAgICAgIHRoaXMudGh1bWJXaWR0aCA9IHRoaXMuc2xpZGVXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJXaWR0aCA8IDE1KVxuICAgICAgICAgICAgdGhpcy50aHVtYldpZHRoID0gMTU7XG4gICAgICAgIHRoaXMuaW5uZXIuc3R5bGUud2lkdGggPSB0aGlzLnRodW1iV2lkdGggKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgPiAodGhpcy5wYWdlV2lkdGggLSB0aGlzLnZpZXdXaWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9ICh0aGlzLnBhZ2VXaWR0aCAtIHRoaXMudmlld1dpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwic2Nyb2xsXCIsIHsgZGF0YTogdGhpcy5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIU2Nyb2xsQmFyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHNjcm9sbExlZnQgPCAwKVxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMudGh1bWJMZWZ0ID0gc2Nyb2xsTGVmdCAqICh0aGlzLnNsaWRlV2lkdGggLSB0aGlzLnRodW1iV2lkdGgpIC8gKHRoaXMucGFnZVdpZHRoIC0gdGhpcy52aWV3V2lkdGgpO1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLmxlZnQgPSAodGhpcy50aHVtYkxlZnQpICsgXCJweFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEhTY3JvbGxCYXI7XG59KFNjcm9sbEJhcikpO1xuSFNjcm9sbEJhci5wcm90b3R5cGUuc2V0SW5uZXJXaWR0aCA9IEhTY3JvbGxCYXIucHJvdG90eXBlLnNldFNjcm9sbFdpZHRoO1xuZXhwb3J0cy5TY3JvbGxCYXIgPSBWU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlNjcm9sbEJhclYgPSBWU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlNjcm9sbEJhckggPSBIU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnRzLlZTY3JvbGxCYXIgPSBWU2Nyb2xsQmFyO1xuZXhwb3J0cy5IU2Nyb2xsQmFyID0gSFNjcm9sbEJhcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcmVuZGVybG9vcFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBSZW5kZXJMb29wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlckxvb3Aob25SZW5kZXIsIHdpbikge1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gb25SZW5kZXI7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLiRyZWN1cnNpb25MaW1pdCA9IDI7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luIHx8IHdpbmRvdztcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fZmx1c2ggPSBmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgICAgIF9zZWxmLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gX3NlbGYuY2hhbmdlcztcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYmxvY2tJZGxlKDEwMCk7XG4gICAgICAgICAgICAgICAgX3NlbGYuY2hhbmdlcyA9IDA7XG4gICAgICAgICAgICAgICAgX3NlbGYub25SZW5kZXIoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3NlbGYuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChfc2VsZi4kcmVjdXJzaW9uTGltaXQtLSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY2hlZHVsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHJlY3Vyc2lvbkxpbWl0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgUmVuZGVyTG9vcC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyB8IGNoYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlcyAmJiAhdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBldmVudC5uZXh0RnJhbWUodGhpcy5fZmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyTG9vcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSAwO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJMb29wO1xufSgpKTtcbmV4cG9ydHMuUmVuZGVyTG9vcCA9IFJlbmRlckxvb3A7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL2ZvbnRfbWV0cmljc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7dmFyIG9vcCA9IHJlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgQ0hBUl9DT1VOVCA9IDUxMjtcbnZhciBVU0VfT0JTRVJWRVIgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiO1xudmFyIEwgPSAyMDA7XG52YXIgRm9udE1ldHJpY3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9udE1ldHJpY3MocGFyZW50RWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLmVsLnN0eWxlLCB0cnVlKTtcbiAgICAgICAgdGhpcy4kbWFpbiA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLiRtYWluLnN0eWxlKTtcbiAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy4kc2V0TWVhc3VyZU5vZGVTdHlsZXModGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUpO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1haW4pO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1lYXN1cmVOb2RlKTtcbiAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuJG1lYXN1cmVOb2RlLnRleHRDb250ZW50ID0gbGFuZy5zdHJpbmdSZXBlYXQoXCJYXCIsIENIQVJfQ09VTlQpO1xuICAgICAgICB0aGlzLiRjaGFyYWN0ZXJTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgIGlmIChVU0VfT0JTRVJWRVIpXG4gICAgICAgICAgICB0aGlzLiRhZGRPYnNlcnZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcbiAgICB9XG4gICAgRm9udE1ldHJpY3MucHJvdG90eXBlLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZSwgaXNSb290KSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzSUUgPCA4KSB7XG4gICAgICAgICAgICBzdHlsZVtcImZvbnQtZmFtaWx5XCJdID0gXCJpbmhlcml0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5mb250ID0gXCJpbmhlcml0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBpc1Jvb3QgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuY2hlY2tGb3JTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzaXplID0gdGhpcy4kbWVhc3VyZVNpemVzKCk7XG4gICAgICAgIGlmIChzaXplICYmICh0aGlzLiRjaGFyYWN0ZXJTaXplLndpZHRoICE9PSBzaXplLndpZHRoIHx8IHRoaXMuJGNoYXJhY3RlclNpemUuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuJG1lYXN1cmVOb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgICAgIHZhciBib2xkU2l6ZSA9IHRoaXMuJG1lYXN1cmVTaXplcygpO1xuICAgICAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUuZm9udFdlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLiRjaGFyYWN0ZXJTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhclNpemVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCb2xkRm9udHMgPSBib2xkU2l6ZSAmJiBib2xkU2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBib2xkU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgeyBkYXRhOiBzaXplIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJGFkZE9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuJG9ic2VydmVyID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRvYnNlcnZlci5vYnNlcnZlKHRoaXMuJG1lYXN1cmVOb2RlKTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS4kcG9sbFNpemVDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIgfHwgdGhpcy4kb2JzZXJ2ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gZXZlbnQub25JZGxlKGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgICAgICAgICBldmVudC5vbklkbGUoY2IsIDUwMCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuc2V0UG9sbGluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJG1lYXN1cmVTaXplcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiAobm9kZSB8fCB0aGlzLiRtZWFzdXJlTm9kZSkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IChub2RlIHx8IHRoaXMuJG1lYXN1cmVOb2RlKS5jbGllbnRXaWR0aCAvIENIQVJfQ09VTlRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpemUud2lkdGggPT09IDAgfHwgc2l6ZS5oZWlnaHQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuJG1lYXN1cmVDaGFyV2lkdGggPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdGhpcy4kbWFpbi50ZXh0Q29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KGNoLCBDSEFSX0NPVU5UKTtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLiRtYWluLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gcmVjdC53aWR0aCAvIENIQVJfQ09VTlQ7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuZ2V0Q2hhcmFjdGVyV2lkdGggPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNoYXJTaXplc1tjaF07XG4gICAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHcgPSB0aGlzLmNoYXJTaXplc1tjaF0gPSB0aGlzLiRtZWFzdXJlQ2hhcldpZHRoKGNoKSAvIHRoaXMuJGNoYXJhY3RlclNpemUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcbiAgICBGb250TWV0cmljcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLiRwb2xsU2l6ZUNoYW5nZXNUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLiRvYnNlcnZlcilcbiAgICAgICAgICAgIHRoaXMuJG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH07XG4gICAgRm9udE1ldHJpY3MucHJvdG90eXBlLiRnZXRab29tID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIChOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbXCJ6b29tXCJdKSB8fCAxKSAqIHRoaXMuJGdldFpvb20oZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS4kaW5pdFRyYW5zZm9ybU1lYXN1cmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbiAodCwgbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInBvc2l0aW9uOiBhYnNvbHV0ZTt0b3A6XCIgKyB0ICsgXCJweDtsZWZ0OlwiICsgbCArIFwicHg7XCJcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbHMgPSBkb20uYnVpbGREb20oW3QoMCwgMCksIHQoTCwgMCksIHQoMCwgTCksIHQoTCwgTCldLCB0aGlzLmVsKTtcbiAgICB9O1xuICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChjbGllbnRQb3MsIGVsUG9zKSB7XG4gICAgICAgIGlmIChjbGllbnRQb3MpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy4kZ2V0Wm9vbSh0aGlzLmVsKTtcbiAgICAgICAgICAgIGNsaWVudFBvcyA9IG11bCgxIC8gem9vbSwgY2xpZW50UG9zKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb2x2ZShsMSwgbDIsIHIpIHtcbiAgICAgICAgICAgIHZhciBkZXQgPSBsMVsxXSAqIGwyWzBdIC0gbDFbMF0gKiBsMlsxXTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKC1sMlsxXSAqIHJbMF0gKyBsMlswXSAqIHJbMV0pIC8gZGV0LFxuICAgICAgICAgICAgICAgICgrbDFbMV0gKiByWzBdIC0gbDFbMF0gKiByWzFdKSAvIGRldFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdWIoYSwgYikgeyByZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV07IH1cbiAgICAgICAgZnVuY3Rpb24gYWRkKGEsIGIpIHsgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV1dOyB9XG4gICAgICAgIGZ1bmN0aW9uIG11bChhLCBiKSB7IHJldHVybiBbYSAqIGJbMF0sIGEgKiBiWzFdXTsgfVxuICAgICAgICBpZiAoIXRoaXMuZWxzKVxuICAgICAgICAgICAgdGhpcy4kaW5pdFRyYW5zZm9ybU1lYXN1cmVOb2RlcygpO1xuICAgICAgICBmdW5jdGlvbiBwKGVsKSB7XG4gICAgICAgICAgICB2YXIgciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIFtyLmxlZnQsIHIudG9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHAodGhpcy5lbHNbMF0pO1xuICAgICAgICB2YXIgYiA9IHAodGhpcy5lbHNbMV0pO1xuICAgICAgICB2YXIgYyA9IHAodGhpcy5lbHNbMl0pO1xuICAgICAgICB2YXIgZCA9IHAodGhpcy5lbHNbM10pO1xuICAgICAgICB2YXIgaCA9IHNvbHZlKHN1YihkLCBiKSwgc3ViKGQsIGMpLCBzdWIoYWRkKGIsIGMpLCBhZGQoZCwgYSkpKTtcbiAgICAgICAgdmFyIG0xID0gbXVsKDEgKyBoWzBdLCBzdWIoYiwgYSkpO1xuICAgICAgICB2YXIgbTIgPSBtdWwoMSArIGhbMV0sIHN1YihjLCBhKSk7XG4gICAgICAgIGlmIChlbFBvcykge1xuICAgICAgICAgICAgdmFyIHggPSBlbFBvcztcbiAgICAgICAgICAgIHZhciBrID0gaFswXSAqIHhbMF0gLyBMICsgaFsxXSAqIHhbMV0gLyBMICsgMTtcbiAgICAgICAgICAgIHZhciB1dCA9IGFkZChtdWwoeFswXSwgbTEpLCBtdWwoeFsxXSwgbTIpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGQobXVsKDEgLyBrIC8gTCwgdXQpLCBhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSA9IHN1YihjbGllbnRQb3MsIGEpO1xuICAgICAgICB2YXIgZiA9IHNvbHZlKHN1YihtMSwgbXVsKGhbMF0sIHUpKSwgc3ViKG0yLCBtdWwoaFsxXSwgdSkpLCB1KTtcbiAgICAgICAgcmV0dXJuIG11bChMLCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBGb250TWV0cmljcztcbn0oKSk7XG5Gb250TWV0cmljcy5wcm90b3R5cGUuJGNoYXJhY3RlclNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbm9vcC5pbXBsZW1lbnQoRm9udE1ldHJpY3MucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5Gb250TWV0cmljcyA9IEZvbnRNZXRyaWNzO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jc3MvZWRpdG9yLWNzc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXsvKlxuc3R5bGVzID0gW11cbmZvciAodmFyIGkgPSAxOyBpIDwgMTY7IGkrKykge1xuICAgIHN0eWxlcy5wdXNoKFwiLmFjZV9iclwiICsgaSArIFwie1wiICsgKFxuICAgICAgICBbXCJ0b3AtbGVmdFwiLCBcInRvcC1yaWdodFwiLCBcImJvdHRvbS1yaWdodFwiLCBcImJvdHRvbS1sZWZ0XCJdXG4gICAgKS5tYXAoZnVuY3Rpb24oeCwgaikge1xuICAgICAgICByZXR1cm4gaSAmICgxPDxqKSA/IFwiYm9yZGVyLVwiICsgeCArIFwiLXJhZGl1czogM3B4O1wiIDogXCJcIlxuICAgIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKSArIFwifVwiKVxufVxuc3R5bGVzLmpvaW4oXCJcXFxcblwiKVxuKi9cbm1vZHVsZS5leHBvcnRzID0gXCJcXG4uYWNlX2JyMSB7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDt9XFxuLmFjZV9icjIge2JvcmRlci10b3AtcmlnaHQtcmFkaXVzICAgOiAzcHg7fVxcbi5hY2VfYnIzIHtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogICAgM3B4O31cXG4uYWNlX2JyNCB7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDt9XFxuLmFjZV9icjUge2JvcmRlci10b3AtbGVmdC1yYWRpdXMgICAgOiAzcHg7IGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7fVxcbi5hY2VfYnI2IHtib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyAgIDogM3B4OyBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4O31cXG4uYWNlX2JyNyB7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDsgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6ICAgIDNweDsgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDt9XFxuLmFjZV9icjgge2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMgOiAzcHg7fVxcbi5hY2VfYnI5IHtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAgM3B4O31cXG4uYWNlX2JyMTB7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXMgICA6IDNweDsgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogIDNweDt9XFxuLmFjZV9icjExe2JvcmRlci10b3AtbGVmdC1yYWRpdXMgICAgOiAzcHg7IGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAgICAzcHg7IGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6ICAzcHg7fVxcbi5hY2VfYnIxMntib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAgM3B4O31cXG4uYWNlX2JyMTN7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1cyAgICA6IDNweDsgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDsgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogIDNweDt9XFxuLmFjZV9icjE0e2JvcmRlci10b3AtcmlnaHQtcmFkaXVzICAgOiAzcHg7IGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAzcHg7IGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6ICAzcHg7fVxcbi5hY2VfYnIxNXtib3JkZXItdG9wLWxlZnQtcmFkaXVzICAgIDogM3B4OyBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogICAgM3B4OyBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4OyBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7fVxcblxcblxcbi5hY2VfZWRpdG9yIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250OiAxMnB4L25vcm1hbCAnTW9uYWNvJywgJ01lbmxvJywgJ1VidW50dSBNb25vJywgJ0NvbnNvbGFzJywgJ1NvdXJjZSBDb2RlIFBybycsICdzb3VyY2UtY29kZS1wcm8nLCBtb25vc3BhY2U7XFxuICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxuICAgIGZvcmNlZC1jb2xvci1hZGp1c3Q6IG5vbmU7XFxufVxcblxcbi5hY2Vfc2Nyb2xsZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5hY2VfY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgICBjb250YWluOiBzdHlsZSBzaXplIGxheW91dDtcXG4gICAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm8tY29tbW9uLWxpZ2F0dXJlcztcXG59XFxuXFxuLmFjZV9rZXlib2FyZC1mb2N1czpmb2N1cyB7XFxuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDJweCAjNUU5RUQ2O1xcbiAgICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4uYWNlX2RyYWdnaW5nIC5hY2Vfc2Nyb2xsZXI6YmVmb3Jle1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjUwLCAyNTAsIDI1MCwgMC4wMSk7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxufVxcbi5hY2VfZHJhZ2dpbmcuYWNlX2RhcmsgLmFjZV9zY3JvbGxlcjpiZWZvcmV7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMSk7XFxufVxcblxcbi5hY2VfZ3V0dGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvdmVyZmxvdyA6IGhpZGRlbjtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgIHotaW5kZXg6IDQ7XFxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGNvbnRhaW46IHN0eWxlIHNpemUgbGF5b3V0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcblxcbi5hY2Vfc2Nyb2xsZXIuYWNlX3Njcm9sbC1sZWZ0OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBib3gtc2hhZG93OiAxN3B4IDAgMTZweCAtMTZweCByZ2JhKDAsIDAsIDAsIDAuNCkgaW5zZXQ7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLCAuYWNlX2d1dHRlci1jZWxsX3N2Zy1pY29ucyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgcGFkZGluZy1sZWZ0OiAxOXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA2cHg7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5hY2VfZ3V0dGVyLWNlbGxfc3ZnLWljb25zIC5hY2VfZ3V0dGVyX2Fubm90YXRpb24ge1xcbiAgICBtYXJnaW4tbGVmdDogLTE0cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsIC5hY2VfZ3V0dGVyX2Fubm90YXRpb24ge1xcbiAgICBtYXJnaW4tbGVmdDogLTE5cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLmFjZV9lcnJvciwgLmFjZV9pY29uLmFjZV9lcnJvciwgLmFjZV9pY29uLmFjZV9lcnJvcl9mb2xkLCAuYWNlX2d1dHRlci1jZWxsLmFjZV9zZWN1cml0eSwgLmFjZV9pY29uLmFjZV9zZWN1cml0eSwgLmFjZV9pY29uLmFjZV9zZWN1cml0eV9mb2xkIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFCT0ZCTVZFWC8vLy8vLy8vL1FSc3dGQWIvVWk0d0ZBWXdGQVl3RkFhV0dBZkRSeW16T1NIL1B4c3dGQWIvU2lVd0ZBWXdGQWJVUFJ2alFpRGxsb2c1SGhIZFJ5YnNUaTMvVHl2OVRpcitTeWovVUMzLy8vL1h1cmViTUJJd0ZBYi9SU0hiUHgvZ1V6ZmR3TDNrek1pdktCQXdGQWJidmJuaFB4NjZOaG93RkFZd0ZBYVpKZzh3RkFheEtCRFp1cmYvUkI2bU14Yi9TQ013RkFZd0ZBYnhRQjMrUkI0d0ZBYi9RaHk0T2grNFFpZmJOUmN3RkFZd0ZBWXdGQWIvUVJ6ZE5oZ3dGQVl3RkFiYXY3di9VeTdvYUU2OE1CSzVMeExld3IvcjJOWGV3THN3RkFheEp3NHdGQWJrUFJ5MlB5WXdGQWF4S2hMbTF0TXdGQWF6UGlRd0ZBYVVHQWIvUUJyZk94M2J2cnYvVkMvbWFFNHdGQWJSUEJxNk1STzhReW5ldzhEcDJ0amZ3YjB3RkFieDZlanU1K2J5NnVuczR1SDkvZjM2K3ZyL0drSGpBQUFBWW5SU1RsTUFHdCs2NHJuV3UvYm84ZUFBNEluSDMrRHdvTjdqNGVMaTR4UDk5TmZnNCtiKy91OUIvZURzMU1EMW1PNys0UEhnMk1YYTM0N2c3dkRpek1MTjRlRytQdjdpNWV2cy92Nzl5dTdTMy9EVjcvNDk4WXYyNGVIKzR1ZlEzT3p1L3Y3K3kxM3NScXdBQUFETFNVUkJWSGphWmMvWERzRmdHSUJodERyc2hsaXRtazJJcmJIRnFMMnB2WGYvKzc4RFBva2o3K0Z6OXFwVS85VVhKSWxobVBhVGFRNlFQYXowbW0rNWd3a2dvdmNWNkdaemQ1SnRDUXdnc3hvSE92Sk8xNWtsZVJMQW5NZ0hGSUVTVUVQbWF3QjluZ21lbFR0aXB3d2ZBU2lseE9MeWlWNVVWVXlWQWZiRzBjQ1BIaWcrR0JrekFFTkhTMEFzdFZGNmJhY1pJT3pnTG14c0hidDJPZWNOZ0pDODNKRVJtZVBVWXE4QVJHa0p4Nlh0RnNkZGRCUWdaRTJuUFI2Q0lDWmhhd2pBNEZiL2NodiszOTlrZlIrTU1NREdPUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggY2VudGVyO1xcbn1cXG5cXG4uYWNlX2d1dHRlci1jZWxsLmFjZV93YXJuaW5nLCAuYWNlX2ljb24uYWNlX3dhcm5pbmcsIC5hY2VfaWNvbi5hY2Vfd2FybmluZ19mb2xkIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBbVZCTVZFWC8vLzhBQUFELy8vOEFBQUFBQUFCUFN6Yi81c0FBQUFCL2JsSC83M3ovdWxrQUFBQUFBQUQ4NXBrQUFBQUFBQUFDQWdQL3ZHei9ya0RlckdiR3JWNy9wa1FJQ0FmLy8vL2UwSXNBQUFEL29FRC9xVHZocm5VQUFBRC95SEQvbmpjQUFBRHV2MnIvbnovL29Uai9wMDY0b0dmL3pIQUFBQUE5TmlyL3RGSUFBQUQvdGxUaXVXZi90a0lBQUFDeW5YRUFBQUFBQUFBdElSVzd6QnBCQUFBQU0zUlNUbE1BQUJSMW03UlhPOExuMzFaMzZ6VCtuZVhlNU96b29SRGZuK1RaNHAzaDJoVGY0dDNrM3VjeXJOMUs1K1hha3M1MlNmczlDWGdyQUFBQWprbEVRVlI0Mm8zUGJRK0NJQlFGWUV3Ym9QaFNZZ29ZdW5JcXFMbjYvejh1WWRIOFZtZG51OXZ6NFd3WGdOL3hUUFJEMitzZ09jWmpzZ2Uvd2hYWmdVYVlZdlQ4UW51SmFVcmpySFVRcmVHY3p1RWFmUUNPL1NKVHVmVGJyb1dzUGdzbGxWaHEzd0pFazJqVVN6WDNDVUVESkM4NDcwN2RqUmM1TVRBUXhvTGd1cFdSd1c2VUI1ZlMrK05WOEFiT1pnbnNDN0JwRUFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMnB4IGNlbnRlcjtcXG59XFxuXFxuLmFjZV9ndXR0ZXItY2VsbC5hY2VfaW5mbywgLmFjZV9pY29uLmFjZV9pbmZvLCAuYWNlX2d1dHRlci1jZWxsLmFjZV9oaW50LCAuYWNlX2ljb24uYWNlX2hpbnQge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBQUFBQUE2bUtDOUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBQUowVWs1VEFBQjJrODA0QUFBQVBrbEVRVlFZMDJOZ0lCNjhRdU8zdGlMem5qQXdwS1RnTnlEYk1lZ3dpc0NIWlVFVFVaVjBacU9xdUJwWGoycnRucFNKVDFBRW5uUm1MMk9nR2dBQUlLa1JRYXAyaHRnQUFBQUFTVVZPUks1Q1lJST1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMnB4IGNlbnRlcjtcXG59XFxuXFxuLmFjZV9kYXJrIC5hY2VfZ3V0dGVyLWNlbGwuYWNlX2luZm8sIC5hY2VfZGFyayAuYWNlX2ljb24uYWNlX2luZm8sIC5hY2VfZGFyayAuYWNlX2d1dHRlci1jZWxsLmFjZV9oaW50LCAuYWNlX2RhcmsgLmFjZV9pY29uLmFjZV9oaW50IHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFCQU1BQUFEdDNlSlNBQUFBSkZCTVZFVUFBQUNob2FHQWdJQXFLaXErdnI2dHJhMVpXVm1VbEpTYm01czhQRHh1Ym01NmVucmRnemczQUFBQUFYUlNUbE1BUU9iWVpnQUFBQ2xKUkVGVWVOcGpZTUFQZHNNWUhlZ3lKWkZRQmxzVWxNRlZDV1VZS2tBWk14WkFHZHhsRE1RQkFHK1RCUDRCNlJ5SkFBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXG59XFxuXFxuLmFjZV9pY29uX3N2Zy5hY2VfZXJyb3Ige1xcbiAgICAtd2Via2l0LW1hc2staW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F4TmlJK0NqeG5JSE4wY205clpTMTNhV1IwYUQwaU1pSWdjM1J5YjJ0bFBTSnlaV1FpSUhOb1lYQmxMWEpsYm1SbGNtbHVaejBpWjJWdmJXVjBjbWxqVUhKbFkybHphVzl1SWo0S1BHTnBjbU5zWlNCbWFXeHNQU0p1YjI1bElpQmplRDBpT0NJZ1kzazlJamdpSUhJOUlqY2lJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUx6NEtQR3hwYm1VZ2VERTlJakV4SWlCNU1UMGlOU0lnZURJOUlqVWlJSGt5UFNJeE1TSXZQZ284YkdsdVpTQjRNVDBpTVRFaUlIa3hQU0l4TVNJZ2VESTlJalVpSUhreVBTSTFJaTgrQ2p3dlp6NEtQQzl6ZG1jK1xcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjcmltc29uO1xcbn1cXG4uYWNlX2ljb25fc3ZnLmFjZV9zZWN1cml0eSB7XFxuICAgIC13ZWJraXQtbWFzay1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIyYVdWM1FtOTRQU0l3SURBZ01qQWdNVFlpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrQ2lBZ0lDQThaeUJ6ZEhKdmEyVXRkMmxrZEdnOUlqSWlJSE4wY205clpUMGlaR0Z5YTI5eVlXNW5aU0lnWm1sc2JEMGlibTl1WlNJZ2MyaGhjR1V0Y21WdVpHVnlhVzVuUFNKblpXOXRaWFJ5YVdOUWNtVmphWE5wYjI0aVBnb2dJQ0FnSUNBZ0lEeHdZWFJvSUdOc1lYTnpQU0p6ZEhKdmEyVXRiR2x1WldwdmFXNHRjbTkxYm1RaUlHUTlJazA0SURFMExqZ3pNRGRET0NBeE5DNDRNekEzSURJZ01USXVPVEEwTnlBeUlEZ3VNRGc1T1RKV015NHlOalUwT0VNMUxqTXhJRE11TWpZMU5EZ2dOeTQ1T0RrNU9TQXhMak0wT1RFNElEY3VPVGc1T1RrZ01TNHpORGt4T0VNM0xqazRPVGs1SURFdU16UTVNVGdnTVRBdU5qa2dNeTR5TmpVME9DQXhOQ0F6TGpJMk5UUTRWamd1TURnNU9USkRNVFFnTVRJdU9UQTBOeUE0SURFMExqZ3pNRGNnT0NBeE5DNDRNekEzV2lJdlBnb2dJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMHlJRGd1TURnNU9USldNeTR5TmpVME9FTTFMak14SURNdU1qWTFORGdnTnk0NU9EazVPU0F4TGpNME9URTRJRGN1T1RnNU9Ua2dNUzR6TkRreE9DSXZQZ29nSUNBZ0lDQWdJRHh3WVhSb0lHUTlJazB4TXk0NU9TQTRMakE0T1RreVZqTXVNalkxTkRoRE1UQXVOamdnTXk0eU5qVTBPQ0E0SURFdU16UTVNVGdnT0NBeExqTTBPVEU0SWk4K0NpQWdJQ0FnSUNBZ1BIQmhkR2dnWTJ4aGMzTTlJbk4wY205clpTMXNhVzVsYW05cGJpMXliM1Z1WkNJZ1pEMGlUVGdnTkZZNUlpOCtDaUFnSUNBZ0lDQWdQSEJoZEdnZ1kyeGhjM005SW5OMGNtOXJaUzFzYVc1bGFtOXBiaTF5YjNWdVpDSWdaRDBpVFRnZ01UQldNVElpTHo0S0lDQWdJRHd2Wno0S1BDOXpkbWMrXFxcIik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGNyaW1zb247XFxufVxcbi5hY2VfaWNvbl9zdmcuYWNlX3dhcm5pbmcge1xcbiAgICAtd2Via2l0LW1hc2staW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F4TmlJK0NqeG5JSE4wY205clpTMTNhV1IwYUQwaU1pSWdjM1J5YjJ0bFBTSmtZWEpyYjNKaGJtZGxJaUJ6YUdGd1pTMXlaVzVrWlhKcGJtYzlJbWRsYjIxbGRISnBZMUJ5WldOcGMybHZiaUkrQ2p4d2IyeDVaMjl1SUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR1pwYkd3OUltNXZibVVpSUhCdmFXNTBjejBpT0NBeElERTFJREUxSURFZ01UVWdPQ0F4SWk4K0NqeHlaV04wSUhnOUlqZ2lJSGs5SWpFeUlpQjNhV1IwYUQwaU1DNHdNU0lnYUdWcFoyaDBQU0l3TGpBeElpOCtDanhzYVc1bElIZ3hQU0k0SWlCNU1UMGlOaUlnZURJOUlqZ2lJSGt5UFNJeE1DSXZQZ284TDJjK0Nqd3ZjM1puUGc9PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBkYXJrb3JhbmdlO1xcbn1cXG4uYWNlX2ljb25fc3ZnLmFjZV9pbmZvIHtcXG4gICAgLXdlYmtpdC1tYXNrLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeE5pSStDanhuSUhOMGNtOXJaUzEzYVdSMGFEMGlNaUlnYzNSeWIydGxQU0ppYkhWbElpQnphR0Z3WlMxeVpXNWtaWEpwYm1jOUltZGxiMjFsZEhKcFkxQnlaV05wYzJsdmJpSStDanhqYVhKamJHVWdabWxzYkQwaWJtOXVaU0lnWTNnOUlqZ2lJR041UFNJNElpQnlQU0kzSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW5KdmRXNWtJaTgrQ2p4d2IyeDViR2x1WlNCd2IybHVkSE05SWpnZ01URWdPQ0E0SWk4K0NqeHdiMng1YkdsdVpTQndiMmx1ZEhNOUlqa2dPQ0EySURnaUx6NEtQR3hwYm1VZ2VERTlJakV3SWlCNU1UMGlNVEVpSUhneVBTSTJJaUI1TWowaU1URWlMejRLUEhKbFkzUWdlRDBpT0NJZ2VUMGlOU0lnZDJsa2RHZzlJakF1TURFaUlHaGxhV2RvZEQwaU1DNHdNU0l2UGdvOEwyYytDand2YzNablBnPT1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcm95YWxibHVlO1xcbn1cXG4uYWNlX2ljb25fc3ZnLmFjZV9oaW50IHtcXG4gICAgLXdlYmtpdC1tYXNrLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjJhV1YzUW05NFBTSXdJREFnTWpBZ01UWWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStDaUFnSUNBOFp5QnpkSEp2YTJVdGQybGtkR2c5SWpJaUlITjBjbTlyWlQwaWMybHNkbVZ5SWlCbWFXeHNQU0p1YjI1bElpQnphR0Z3WlMxeVpXNWtaWEpwYm1jOUltZGxiMjFsZEhKcFkxQnlaV05wYzJsdmJpSStDaUFnSUNBZ0lDQWdQSEJoZEdnZ1kyeGhjM005SW5OMGNtOXJaUzFzYVc1bGFtOXBiaTF5YjNWdVpDSWdaRDBpVFRZZ01UUklNVEFpTHo0S0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk9DQXhNVWc1UXprZ09TNDBOekF3TWlBeE1pQTRMalUwTURBeUlERXlJRFV1TnpZd01ESkRNVEl1TURJZ05DNDBNREF3TWlBeE1TNHpPU0F6TGpNMk1EQXlJREV3TGpReklESXVOamN3TURKRE9TQXhMalkwTURBeUlEY3VNREF3TURFZ01TNDJOREF3TWlBMUxqVTNNREF4SURJdU5qY3dNREpETkM0Mk1UQXdNU0F6TGpNMk1EQXlJRE11T1RnZ05DNDBNREF3TWlBMElEVXVOell3TURKRE5DQTRMalUwTURBeUlEY3VNREF3TURFZ09TNDBOekF3TWlBM0xqQXdNREF4SURFeFNEaGFJaTgrQ2lBZ0lDQThMMmMrQ2p3dmMzWm5QZz09XFxcIik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHNpbHZlcjtcXG59XFxuXFxuLmFjZV9pY29uX3N2Zy5hY2VfZXJyb3JfZm9sZCB7XFxuICAgIC13ZWJraXQtbWFzay1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXhOaUlnWm1sc2JEMGlibTl1WlNJK0NpQWdQSEJoZEdnZ1pEMGliU0F4T0M0NU1qazROVEVzTnk0NE1qazRNRGMySUdNZ01DNHhORFl6TlRNc05pNHpNemMwTmpBMElDMDJMak15TXpFME55dzNMamMzTnpnME5EUWdMVGN1TkRjM09URXlMRGN1TnpjM09EUTBOQ0F0TWk0eE1EY3lOekkyTEMwd0xqRXlPRGMxSURVdU1URTNOamM0TERBdU16VTJNalE1SURVdU1EVXhOams0TEMwM0xqZzNNREEyTVRnZ0xUQXVOakEwTmpjeUxDMDRMakF3TXprM016UTVJQzAzTGpBM056STNNRFlzTFRjdU5UWXpNVEU0T1NBdE5DNDROVGN6TEMwM0xqUXpNRE01TlRVMklERXVOakEyTEMwd0xqRXhOVEUwTWpJMUlEWXVPRGszTkRnMUxERXVNall5TlRRMU9UWWdOeTR5T0RNMU1UUXNOeTQxTWpJMk1USTVOaUI2SWlCbWFXeHNQU0pqY21sdGMyOXVJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqSWlMejRLSUNBOGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGliU0E0TGpFeE5EYzFOaklzTWk0d05USTVPREk0SUdNZ015NHpORGt4TmprNExEQWdOaTR3TmpReE16STRMREl1TmpjMk9EWXlOeUEyTGpBMk5ERXpNamdzTlM0NU56ZzVOVE1nTUN3ekxqTXdNakV4TWpJZ0xUSXVOekUwT1RZekxEVXVPVGM0T1RJd01pQXROaTR3TmpReE16STRMRFV1T1RjNE9USXdNaUF0TXk0ek5Ea3hORGN6TERBZ0xUWXVNRFkwTVRjM01pd3RNaTQyTnpZNE1EZ2dMVFl1TURZME1UYzNNaXd0TlM0NU56ZzVNakF5SURBdU1EQTFNemtzTFRNdU1qazVPRGcyTVNBeUxqY3hOekkyTlRZc0xUVXVPVGN6TmpRd09DQTJMakEyTkRFM056SXNMVFV1T1RjNE9UVXpJSG9nYlNBd0xDMHhMamN6TlRneU56RTVJR01nTFRRdU16SXhORGd6Tml3d0lDMDNMamd5TkRjME1ETTRMRE11TkRVME1ERTRORGtnTFRjdU9ESTBOelF3TXpnc055NDNNVFEzT0RBeE9TQXdMRFF1TWpZd056STRNaUF6TGpVd016STFOamM0TERjdU56RTBOelExTWlBM0xqZ3lORGMwTURNNExEY3VOekUwTnpRMU1pQTBMak15TVRRME9UZ3NNQ0EzTGpneU5EWTVPVGdzTFRNdU5EVTBNREUzSURjdU9ESTBOams1T0N3dE55NDNNVFEzTkRVeUlEQXNMVEl1TURRMk1Ea3hOQ0F0TUM0NE1qUXpPVElzTFRRdU1EQTRNelkzTWlBdE1pNHlPVEUzTlRZc0xUVXVORFUxTVRjME5pQkRJREV5TGpFNE1ESXlOU3d4TGpFeU9UazJORGdnTVRBdU1Ua3dNREV6TERBdU16RTNNVFUxTmpFZ09DNHhNVFEzTlRZeUxEQXVNekUzTVRVMU5qRWdXaUJOSURZdU9UTTNORFUyTXl3NExqSTBNRFU1T0RVZ05DNDJOekU0TmpnMUxERXdMalE0TlRnMU1pQTJMakF3T0RZNE1UUXNNVEV1T0RjMk56STRJRGd1TXpFM01EQXpOU3c1TGpZd01EYzVNVEVnTVRBdU5qSTFNek0zTERFeExqZzNOamN5T0NBeE1TNDVOakl4TXpnc01UQXVORGcxT0RVeUlEa3VOamsyTlRVd09DdzRMakkwTURVNU9EVWdNVEV1T1RZeU1UTTRMRFl1TURBMk9EQTJOaUF4TUM0MU56TXlORFlzTkM0Mk16YzBNek0xSURndU16RTNNREF6TlN3MkxqZzNNelF5T1RjZ05pNHdOakEzTmpBM0xEUXVOak0zTkRNek5TQTBMalkzTVRnMk9EVXNOaTR3TURZNE1EWTJJRm9pSUdacGJHdzlJbU55YVcxemIyNGlJSE4wY205clpTMTNhV1IwYUQwaU1pSXZQZ284TDNOMlp6ND1cXFwiKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY3JpbXNvbjtcXG59XFxuLmFjZV9pY29uX3N2Zy5hY2Vfc2VjdXJpdHlfZm9sZCB7XFxuICAgIC13ZWJraXQtbWFzay1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LENqeHpkbWNnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JaUIyYVdWM1FtOTRQU0l3SURBZ01UY2dNVFFpSUdacGJHdzlJbTV2Ym1VaVBnb2dJQ0FnUEhCaGRHZ2daRDBpVFRFd0xqQXdNREVnTVRNdU5qazVNa014TUM0d01EQXhJREV6TGpZNU9USWdNVEV1T1RJME1TQXhNeTQwTnpZeklERXpJREV5TGpZNU9USkRNVFF1TkRFek9TQXhNUzQyTnpneElERTJJREV3TGpVZ01UWXVNVEkxTVNBMkxqZ3hNVEkyVmpJdU5UZzVPRGRETVRZdU1USTFNU0F5TGpVME56WTRJREUyTGpFeU1qRWdNaTQxTURZeE9TQXhOaTR4TVRZMElESXVORFkxTlRsV01TNDNNVFE0TlVneE5TNHlOREUwVERFMUxqSXpNRGNnTVM0M01UUTRORXd4TkM0Mk1qVXhJREV1TmprNU1qSldOaTQ0TVRFeU0wTXhOQzQyTWpVeElEZ3VOVEV3TmpFZ01UUXVOakkxTVNBNUxqUTJORFl4SURFeUxqYzRNalFnTVRFdU56SXhRekV5TGpFMU9EWWdNVEl1TkRnME9DQXhNQzR3TURBeElERXpMalk1T1RJZ01UQXVNREF3TVNBeE15NDJPVGt5V2lJZ1ptbHNiRDBpWTNKcGJYTnZiaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaTgrQ2lBZ0lDQThjR0YwYUNCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRjdU16TTJNRGtnTUM0ek5qYzBOelZETnk0d016SXhOQ0F3TGpFMU1qWTFNaUEyTGpZeU5UUTRJREF1TVRVek5qRTBJRFl1TXpJeU5UTWdNQzR6TmprNU9UZE1OaTR6TURnMk9TQXdMak0zT1RVMU5FTTJMakk1TlRVeklEQXVNemc0TlRnNElEWXVNamN6T0RnZ01DNDBNRE15TmpZZ05pNHlORFF4TnlBd0xqUXlNamM0T1VNMkxqRTRORGN4SURBdU5EWXhPRFlnTmk0d09UTXlNU0F3TGpVeU1ERTNNU0ExTGprM016RXpJREF1TlRreE16Y3pRelV1TnpNeU5URWdNQzQzTXpRd05Ua2dOUzR6TnprNUlEQXVPVEkyT0RZMElEUXVPVFF5TnprZ01TNHhNakF3T1VNMExqQTJNVFEwSURFdU5UQTVOeUF5TGpnM05UUXhJREV1T0Rnek56Y2dNUzQxT0RrNE5DQXhMamc0TXpjM1NEQXVOekUwT0RRMFZqSXVOelU0TnpkV05pNDVPREF4TlVNd0xqY3hORGcwTkNBNUxqUTVNemMwSURJdU1qZzROallnTVRFdU1UazNNeUF6TGpjd01qVTBJREV5TGpJeE9EVkROQzQwTVRnME5TQXhNaTQzTXpVMUlEVXVNVEk0TnpRZ01UTXVNVEExTXlBMUxqWTFOek16SURFekxqTTBOVGRETlM0NU1qSTROQ0F4TXk0ME5qWTBJRFl1TVRRMU5qWWdNVE11TlRVMU9TQTJMak13TkRZMUlERXpMall4TmpGRE5pNHpPRFF5TXlBeE15NDJORFl5SURZdU5EUTRNRFVnTVRNdU5qWTVJRFl1TkRrek5Ea2dNVE11TmpnME9FTTJMalV4TmpJeUlERXpMalk1TWpjZ05pNDFNelF6T0NBeE15NDJPVGc1SURZdU5UUTNOalFnTVRNdU56QXpNMHcyTGpVMk16Z3lJREV6TGpjd09EZE1OaTQxTmprd09DQXhNeTQzTVRBMFREWXVOVGN3T1RrZ01UTXVOekV4VERZdU9ETTVPRFFnTVRNdU56VXpNMHcyTGpVM01qUXlJREV6TGpjeE1UVkROaTQzTkRZek15QXhNeTQzTmpjeklEWXVPVE16TXpVZ01UTXVOelkzTXlBM0xqRXdOekkzSURFekxqY3hNVFZNTnk0eE1EZzNJREV6TGpjeE1VdzNMakV4TURZeElERXpMamN4TURSTU55NHhNVFU0TnlBeE15NDNNRGczVERjdU1UTXlNRFVnTVRNdU56QXpNME0zTGpFME5UTXhJREV6TGpZNU9Ea2dOeTR4TmpNME5pQXhNeTQyT1RJM0lEY3VNVGcyTVRrZ01UTXVOamcwT0VNM0xqSXpNVFkwSURFekxqWTJPU0EzTGpJNU5UUTJJREV6TGpZME5qSWdOeTR6TnpVd015QXhNeTQyTVRZeFF6Y3VOVE0wTURNZ01UTXVOVFUxT1NBM0xqYzFOamcxSURFekxqUTJOalFnT0M0d01qSXpOaUF4TXk0ek5EVTNRemd1TlRVd09UVWdNVE11TVRBMU15QTVMakkyTVRJeklERXlMamN6TlRVZ09TNDVOemN4TlNBeE1pNHlNVGcxUXpFeExqTTVNU0F4TVM0eE9UY3pJREV5TGprMk5EZ2dPUzQwT1RNM055QXhNaTQ1TmpRNElEWXVPVGd3TVRoV01pNDNOVGc0UXpFeUxqazJORGdnTWk0M01UWTJJREV5TGprMk1Ua2dNaTQyTnpVeE1TQXhNaTQ1TlRZeElESXVOak0wTlRGV01TNDRPRE0zTjBneE1pNHdPREV4UXpFeUxqQTNOelVnTVM0NE9ETTNOeUF4TWk0d056UWdNUzQ0T0RNM055QXhNaTR3TnpBMElERXVPRGd6TnpkRE1UQXVOemszT1NBeExqZzRNREEwSURrdU5qRTVOaklnTVM0MU1URXdNaUE0TGpjek9EazBJREV1TVRJME9EWkRPQzQzTXpVek5DQXhMakV5TXpJM0lEZ3VOek14TnpRZ01TNHhNakUyT0NBNExqY3lPREUwSURFdU1USXdNRGxET0M0eU9URXdNeUF3TGpreU5qZzJOQ0EzTGprek9EUXlJREF1TnpNME1EVTVJRGN1TmprM056a2dNQzQxT1RFek56TkROeTQxTnpjM01pQXdMalV5TURFM01TQTNMalE0TmpJeUlEQXVORFl4T0RZZ055NDBNalkzTmlBd0xqUXlNamM0T1VNM0xqTTVOekExSURBdU5EQXpNalkySURjdU16YzFNemtnTUM0ek9EZzFPRGdnTnk0ek5qSXlOQ0F3TGpNM09UVTFORXczTGpNME9EazJJREF1TXpjd016VkROeTR6TkRnNU5pQXdMak0zTURNMUlEY3VNelE0TkRjZ01DNHpOekF3TWlBM0xqTTBOVFl6SURBdU16YzBNRFUwVERjdU16TTNOemtnTUM0ek5qZzJOVGxNTnk0ek16WXdPU0F3TGpNMk56UTNOVnBOT0M0d016UTNNU0F5TGpjeU5qa3hRemd1T0RZd05DQXpMakE1TURZeklEa3VPVFl3TmpZZ015NDBOak13T1NBeE1TNHlNRFl4SURNdU5UZzVNRGRXTmk0NU9EQXhOVWd4TVM0eU1UUTRRekV4TGpJeE5EZ2dPQzQyTnprMU15QXhNQzR4TmpNM0lEa3VPVEkxTURjZ09DNDVOVEkxTkNBeE1DNDNPVGs0UXpndU16VTFPVFVnTVRFdU1qTXdOaUEzTGpjMU16YzBJREV4TGpVME5UUWdOeTR5T1RjNU5pQXhNUzQzTlRJM1F6Y3VNVEUyTnpFZ01URXVPRE0xTVNBMkxqazJNRFl5SURFeExqZzVPVFlnTmk0NE16azROQ0F4TVM0NU5EWTVRell1TnpFNU1EWWdNVEV1T0RrNU5pQTJMalUyTWprM0lERXhMamd6TlRFZ05pNHpPREUzTXlBeE1TNDNOVEkzUXpVdU9USTFPVFVnTVRFdU5UUTFOQ0ExTGpNeU16Y3pJREV4TGpJek1EWWdOQzQzTWpjeE5TQXhNQzQzT1RrNFF6TXVOVEUyTURNZ09TNDVNalV3TnlBeUxqUTJORGcwSURndU5qYzVOVFVnTWk0ME5qUTROQ0EyTGprNE1ERTRWak11TlRnNU1EbERNeTQzTVRjek9DQXpMalEyTWpNNUlEUXVPREl6TURnZ015NHdPRFl6T1NBMUxqWTFNRE16SURJdU56SXdOekZETmk0eE5ESXlPQ0F5TGpVd016STBJRFl1TlRRME9EVWdNaTR5T0RVek55QTJMamd6TWpVMElESXVNVEUyTWpSRE55NHhNakU0TVNBeUxqSTROVE0xSURjdU5USTNJREl1TlRBek5USWdPQzR3TWpFNU5pQXlMamN5TVRNeFF6Z3VNREkyTWlBeUxqY3lNekUzSURndU1ETXdORFVnTWk0M01qVXdOQ0E0TGpBek5EY3hJREl1TnpJMk9URmFUVFV1T1RZME9EUWdNeTQwTURFME4xWTNMamMzTmpRM1NEY3VOekUwT0RSV015NDBNREUwTjBnMUxqazJORGcwV2swMUxqazJORGcwSURFd0xqUXdNVFZXT0M0Mk5URTBOMGczTGpjeE5EZzBWakV3TGpRd01UVklOUzQ1TmpRNE5Gb2lJR1pwYkd3OUltTnlhVzF6YjI0aUlITjBjbTlyWlMxM2FXUjBhRDBpTWlJdlBnbzhMM04yWno0PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjcmltc29uO1xcbn1cXG4uYWNlX2ljb25fc3ZnLmFjZV93YXJuaW5nX2ZvbGQge1xcbiAgICAtd2Via2l0LW1hc2staW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1UWWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXhOaUlnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkM0M056WTVJREUwTGpjek16ZE1PQzQyTlRFNU1pQXlMalE0TXpZNVF6Z3VNekk1TkRZZ01TNDRNemczTnlBM0xqUXdPVEV6SURFdU9ETTROemNnTnk0d09EWTJOeUF5TGpRNE16WTVUREF1T1RZeE5qWTVJREUwTGpjek16ZERNQzQyTnpBM056VWdNVFV1TXpFMU5TQXhMakE1TXpneklERTJJREV1TnpRME1qa2dNVFpJTVRNdU9UazBNME14TkM0Mk5EUTRJREUySURFMUxqQTJOemdnTVRVdU16RTFOU0F4TkM0M056WTVJREUwTGpjek16ZGFUVE11TVRZd01EY2dNVFF1TWpWTU55NDROamt5T1NBMExqZ3pNVFUyVERFeUxqVTNPRFVnTVRRdU1qVklNeTR4TmpBd04xcE5PQzQzTkRReU9TQXhNUzQyTWpWV01UTXVNemMxU0RZdU9UazBNamxXTVRFdU5qSTFTRGd1TnpRME1qbGFUVFl1T1RrME1qa2dNVEF1TnpWV055NHlOVWc0TGpjME5ESTVWakV3TGpjMVNEWXVPVGswTWpsYUlpQm1hV3hzUFNJalJVTTNNakV4SWk4K0NqeHdZWFJvSUdROUlrMHhNUzR4T1RreElESXVPVFV5TXpoRE1UQXVPRGd3T1NBeUxqTXhORFkzSURFd0xqTTFNemNnTVM0NE1EVXlOaUE1TGpjd05UVWdNUzQxTURsTU1URXVNRFF4SURFdU1EWTVOemhETVRFdU5qZzRNeUF3TGprME9UZ3hOQ0F4TWk0ek16Y2dNUzR5TnpJMk15QXhNaTQyTXpFM0lERXVPRFl4TkRGTU1UY3VOakV6TmlBeE1TNDRNVFl4UXpFNExqTTFNamNnTVRNdU1qa3lPU0F4Tnk0MU9UTTRJREUxTGpBNE1EUWdNVFl1TURFNElERTFMalUzTkRWRE1UWXVOREEwTkNBeE5DNDBOVEEzSURFMkxqTXlNekVnTVRNdU1qRTRPQ0F4TlM0M09USTBJREV5TGpFMU5UVk1NVEV1TVRrNU1TQXlMamsxTWpNNFdpSWdabWxzYkQwaUkwVkROekl4TVNJdlBnbzhMM04yWno0PVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBkYXJrb3JhbmdlO1xcbn1cXG5cXG4uYWNlX3Njcm9sbGJhciB7XFxuICAgIGNvbnRhaW46IHN0cmljdDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICB6LWluZGV4OiA2O1xcbn1cXG5cXG4uYWNlX3Njcm9sbGJhci1pbm5lciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgY3Vyc29yOiB0ZXh0O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxufVxcblxcbi5hY2Vfc2Nyb2xsYmFyLXZ7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgICB0b3A6IDA7XFxufVxcblxcbi5hY2Vfc2Nyb2xsYmFyLWgge1xcbiAgICBvdmVyZmxvdy14OiBzY3JvbGw7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gICAgbGVmdDogMDtcXG59XFxuXFxuLmFjZV9wcmludC1tYXJnaW4ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLmFjZV90ZXh0LWlucHV0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAwO1xcbiAgICB3aWR0aDogMC41ZW07XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHJlc2l6ZTogbm9uZTtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgZm9udDogaW5oZXJpdDtcXG4gICAgcGFkZGluZzogMCAxcHg7XFxuICAgIG1hcmdpbjogMCAtMXB4O1xcbiAgICBjb250YWluOiBzdHJpY3Q7XFxuICAgIC1tcy11c2VyLXNlbGVjdDogdGV4dDtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogdGV4dDtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcXG4gICAgdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAgIC8qd2l0aCBgcHJlLWxpbmVgIGNocm9tZSBpbnNlcnRzICZuYnNwOyBpbnN0ZWFkIG9mIHNwYWNlKi9cXG4gICAgd2hpdGUtc3BhY2U6IHByZSFpbXBvcnRhbnQ7XFxufVxcbi5hY2VfdGV4dC1pbnB1dC5hY2VfY29tcG9zaXRpb24ge1xcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIG9wYWNpdHk6IDE7XFxufVxcbi5hY2VfY29tcG9zaXRpb25fcGxhY2Vob2xkZXIgeyBjb2xvcjogdHJhbnNwYXJlbnQgfVxcbi5hY2VfY29tcG9zaXRpb25fbWFya2VyIHsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxufVxcblxcblthY2Vfbm9jb250ZXh0PXRydWVdIHtcXG4gICAgdHJhbnNmb3JtOiBub25lIWltcG9ydGFudDtcXG4gICAgZmlsdGVyOiBub25lIWltcG9ydGFudDtcXG4gICAgY2xpcC1wYXRoOiBub25lIWltcG9ydGFudDtcXG4gICAgbWFzayA6IG5vbmUhaW1wb3J0YW50O1xcbiAgICBjb250YWluOiBub25lIWltcG9ydGFudDtcXG4gICAgcGVyc3BlY3RpdmU6IG5vbmUhaW1wb3J0YW50O1xcbiAgICBtaXgtYmxlbmQtbW9kZTogaW5pdGlhbCFpbXBvcnRhbnQ7XFxuICAgIHotaW5kZXg6IGF1dG87XFxufVxcblxcbi5hY2VfbGF5ZXIge1xcbiAgICB6LWluZGV4OiAxO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIC8qIHdvcmthcm91bmQgZm9yIGNocm9tZSBidWcgaHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvYWNlL2lzc3Vlcy8yMzEyKi9cXG4gICAgd29yZC13cmFwOiBub3JtYWw7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIC8qIHNldHRpbmcgcG9pbnRlci1ldmVudHM6IGF1dG87IG9uIG5vZGUgdW5kZXIgdGhlIG1vdXNlLCB3aGljaCBjaGFuZ2VzXFxuICAgICAgICBkdXJpbmcgc2Nyb2xsLCB3aWxsIGJyZWFrIG1vdXNlIHdoZWVsIHNjcm9sbGluZyBpbiBTYWZhcmkgKi9cXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hY2VfZ3V0dGVyLWxheWVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDEwMDAwMDBweDtcXG4gICAgY29udGFpbjogc3R5bGUgc2l6ZSBsYXlvdXQ7XFxufVxcblxcbi5hY2VfdGV4dC1sYXllciB7XFxuICAgIGZvbnQ6IGluaGVyaXQgIWltcG9ydGFudDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBoZWlnaHQ6IDEwMDAwMDBweDtcXG4gICAgd2lkdGg6IDEwMDAwMDBweDtcXG4gICAgY29udGFpbjogc3R5bGUgc2l6ZSBsYXlvdXQ7XFxufVxcblxcbi5hY2VfdGV4dC1sYXllciA+IC5hY2VfbGluZSwgLmFjZV90ZXh0LWxheWVyID4gLmFjZV9saW5lX2dyb3VwIHtcXG4gICAgY29udGFpbjogc3R5bGUgc2l6ZSBsYXlvdXQ7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG59XFxuXFxuLmFjZV9oaWRwaSAuYWNlX3RleHQtbGF5ZXIsXFxuLmFjZV9oaWRwaSAuYWNlX2d1dHRlci1sYXllcixcXG4uYWNlX2hpZHBpIC5hY2VfY29udGVudCxcXG4uYWNlX2hpZHBpIC5hY2VfZ3V0dGVyIHtcXG4gICAgY29udGFpbjogc3RyaWN0O1xcbn1cXG4uYWNlX2hpZHBpIC5hY2VfdGV4dC1sYXllciA+IC5hY2VfbGluZSwgXFxuLmFjZV9oaWRwaSAuYWNlX3RleHQtbGF5ZXIgPiAuYWNlX2xpbmVfZ3JvdXAge1xcbiAgICBjb250YWluOiBzdHJpY3Q7XFxufVxcblxcbi5hY2VfY2prIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5hY2VfY3Vyc29yLWxheWVyIHtcXG4gICAgei1pbmRleDogNDtcXG59XFxuXFxuLmFjZV9jdXJzb3Ige1xcbiAgICB6LWluZGV4OiA0O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGJvcmRlci1sZWZ0OiAycHggc29saWQ7XFxuICAgIC8qIHdvcmthcm91bmQgZm9yIHNtb290aCBjdXJzb3IgcmVwYWludG5nIHdob2xlIHNjcmVlbiBpbiBjaHJvbWUgKi9cXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGV6KDApO1xcbn1cXG5cXG4uYWNlX211bHRpc2VsZWN0IC5hY2VfY3Vyc29yIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG59XFxuXFxuLmFjZV9zbGltLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbn1cXG5cXG4uYWNlX292ZXJ3cml0ZS1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZDtcXG59XFxuXFxuLmFjZV9oaWRkZW4tY3Vyc29ycyAuYWNlX2N1cnNvciB7XFxuICAgIG9wYWNpdHk6IDAuMjtcXG59XFxuXFxuLmFjZV9oYXNQbGFjZWhvbGRlciAuYWNlX2hpZGRlbi1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXG4gICAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFjZV9zbW9vdGgtYmxpbmtpbmcgLmFjZV9jdXJzb3Ige1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMThzO1xcbn1cXG5cXG4uYWNlX2FuaW1hdGUtYmxpbmtpbmcgLmFjZV9jdXJzb3Ige1xcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDEwMDBtcztcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogc3RlcC1lbmQ7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiBibGluay1hY2UtYW5pbWF0ZTtcXG4gICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxufVxcblxcbi5hY2VfYW5pbWF0ZS1ibGlua2luZy5hY2Vfc21vb3RoLWJsaW5raW5nIC5hY2VfY3Vyc29yIHtcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcbiAgICBhbmltYXRpb24tbmFtZTogYmxpbmstYWNlLWFuaW1hdGUtc21vb3RoO1xcbn1cXG4gICAgXFxuQGtleWZyYW1lcyBibGluay1hY2UtYW5pbWF0ZSB7XFxuICAgIGZyb20sIHRvIHsgb3BhY2l0eTogMTsgfVxcbiAgICA2MCUgeyBvcGFjaXR5OiAwOyB9XFxufVxcblxcbkBrZXlmcmFtZXMgYmxpbmstYWNlLWFuaW1hdGUtc21vb3RoIHtcXG4gICAgZnJvbSwgdG8geyBvcGFjaXR5OiAxOyB9XFxuICAgIDQ1JSB7IG9wYWNpdHk6IDE7IH1cXG4gICAgNjAlIHsgb3BhY2l0eTogMDsgfVxcbiAgICA4NSUgeyBvcGFjaXR5OiAwOyB9XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc3RlcCwgLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGFjayB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMztcXG59XFxuXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3Rpb24ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDU7XFxufVxcblxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2VfYnJhY2tldCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogNjtcXG59XFxuXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9lcnJvcl9icmFja2V0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0RFNTU1NTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDtcXG59XFxuXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9hY3RpdmUtbGluZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3RlZC13b3JkIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA0O1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4uYWNlX2xpbmUgLmFjZV9mb2xkIHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBoZWlnaHQ6IDExcHg7XFxuICAgIG1hcmdpbi10b3A6IC0ycHg7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6XFxuICAgICAgICB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkVBQUFBSkNBWUFBQURVNk1jTUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSnBKUkVGVWVOcGkvUC8vUHdPbGdBWEdZR1JrbEFWU29rRDhHbWp3WTF3YXNLbGpRcFlBQ3RwQ0ZlQURjSFZRZlF5TVFBd3p3QVpJM3dKS3ZDTGtmS0JhTVNDbEJsUjdCT1Fpa0NGR1FFRXJJSDBWcWthYmlHQ0Fxd1VhZEF6WkpSeFFyLzBnd2lYSWFsOHpRUVBuTlZUZ0oxVGRhd0wwVDVnQklQMU1VSk5oQnYySEtvUUhIanFOckE0V080elkwZ2x5TktMVDJLSWZJTUFBUXNkZ0dpWHZnbllBQUFBQVNVVk9SSzVDWUlJPVxcXCIpLFxcbiAgICAgICAgdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQTNDQVlBQUFETk5pQTVBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUNKSlJFRlVlTnBpK1AvL2Z4Z1RBd1BEQnhEeEQwNzhSU1grWWVFeURGTUNJTUFBSTNJTm1YaXdmMllBQUFBQVNVVk9SSzVDWUlJPVxcXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0LCByZXBlYXQteDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlciwgdG9wIGxlZnQ7XFxuICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcXG5cXG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG5cXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG59XFxuXFxuLmFjZV9kYXJrIC5hY2VfZm9sZCB7XFxufVxcblxcbi5hY2VfZm9sZDpob3ZlcntcXG4gICAgYmFja2dyb3VuZC1pbWFnZTpcXG4gICAgICAgIHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCRUFBQUFKQ0FZQUFBRFU2TWNNQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFKcEpSRUZVZU5waS9QLy9Qd09sZ0FYR1lHUmtsQVZTb2tEOEdtandZMXdhc0tsalFwWUFDdHBDRmVBRGNIVlFmUXlNUUF3endBWkkzd0pLdkNMa2ZLQmFNU0NsQmxSN0JPUWlrQ0ZHUUVFcklIMFZxa2FiaUdDQXF3VWFkQXpaSlJ4UXIvMGd3aVhJYWw4elFRUG5OVlRnSjFUZGF3TDBUNWdCSVAxTVVKTmhCdjJIS29RSEhqcU5yQTRXTzR6WTBnbHlOS0xUMktJZklNQUFRc2RnR2lYdmduWUFBQUFBU1VWT1JLNUNZSUk9XFxcIiksXFxuICAgICAgICB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBM0NBWUFBQUROTmlBNUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBQ0JKUkVGVWVOcGkrUC8vZno0VEF3UERaeER4RDVYNGk1ZkxNRXdKZ0FBREFFUFZEYmpOdzg3WkFBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXG59XFxuXFxuLmFjZV90b29sdGlwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgZ3JheTtcXG4gICAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgICBib3gtc2hhZG93OiAwIDFweCAycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xcbiAgICBjb2xvcjogYmxhY2s7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogM3B4IDRweDtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB6LWluZGV4OiA5OTk5OTk7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICAgIGxpbmUtaGVpZ2h0OiBub3JtYWw7XFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IG5vcm1hbDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICBtYXgtd2lkdGg6IG1pbig2MGVtLCA2NnZ3KTtcXG4gICAgb3ZlcnNjcm9sbC1iZWhhdmlvcjogY29udGFpbjtcXG59XFxuLmFjZV90b29sdGlwIHByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxuXFxuLmFjZV90b29sdGlwLmFjZV9kYXJrIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzYzNjM2MztcXG4gICAgY29sb3I6ICNmZmY7XFxufVxcblxcbi5hY2VfdG9vbHRpcDpmb2N1cyB7XFxuICAgIG91dGxpbmU6IDFweCBzb2xpZCAjNUU5RUQ2O1xcbn1cXG5cXG4uYWNlX2ljb24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiAxOHB4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbn1cXG5cXG4uYWNlX2ljb25fc3ZnIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogMTJweDtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gICAgLXdlYmtpdC1tYXNrLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAtd2Via2l0LW1hc2stc2l6ZTogMTJweDtcXG4gICAgLXdlYmtpdC1tYXNrLXBvc2l0aW9uOiBjZW50ZXI7XFxufVxcblxcbi5hY2VfZm9sZGluZy1lbmFibGVkID4gLmFjZV9ndXR0ZXItY2VsbCwgLmFjZV9mb2xkaW5nLWVuYWJsZWQgPiAuYWNlX2d1dHRlci1jZWxsX3N2Zy1pY29ucyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDEzcHg7XFxufVxcblxcbi5hY2VfZm9sZC13aWRnZXQge1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcbiAgICBtYXJnaW46IDAgLTEycHggMCAxcHg7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIHdpZHRoOiAxMXB4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcblxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFORWxFUVZSNDJtV0tzUTBBTUF6QzhpeExscnpRanptQmlFanAwQTZXd0JDU1BnS0FYb0xrcVNvdDduTjN5TXdSN3BaMzJOenBLa1ZvREJVeEtBQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcXG5cXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBcXG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmFjZV9mb2xkaW5nLWVuYWJsZWQgLmFjZV9mb2xkLXdpZGdldCB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgICBcXG59XFxuXFxuLmFjZV9mb2xkLXdpZGdldC5hY2VfZW5kIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBTkVsRVFWUjQybTNId1FrQU1BaEQwWXpzUmNoRktJN3NBaWtlV2tyeHdTY0VCMG5oNWU3S1RQV2ltWmtpNHRZZlZiWCtNTmw0cHlaWGVqVU8xUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpO1xcbn1cXG5cXG4uYWNlX2ZvbGQtd2lkZ2V0LmFjZV9jbG9zZWQge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQU1BQUFBR0NBWUFBQUFHNVNRTUFBQUFPVWxFUVZSNDJqWEt3UWtBTUFnRHdLd3FLRDRFd1EyNnNTT2tWV2pnSUlIQXpQaUNnYXFpcW5KSFpuS0lDQkVSSE4xOTRPNWI5dmJMdUFWUkwrbDBZV25aQUFBQUFFbEZUa1N1UW1DQ1hBPT1cXFwiKTtcXG59XFxuXFxuLmFjZV9mb2xkLXdpZGdldDpob3ZlciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgICBib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcbn1cXG5cXG4uYWNlX2ZvbGQtd2lkZ2V0OmFjdGl2ZSB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjA1KTtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcXG59XFxuLyoqXFxuICogRGFyayB2ZXJzaW9uIGZvciBmb2xkIHdpZGdldHNcXG4gKi9cXG4uYWNlX2RhcmsgLmFjZV9mb2xkLXdpZGdldCB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhrbEVRVlFJVzJQNC8vOC9Bem9HRVE3b0dDYUxMQWhXaVN3QjE0NkJBUUNTVFBZb2NxVDBBQUFBQUVsRlRrU3VRbUNDXFxcIik7XFxufVxcbi5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0LmFjZV9lbmQge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFIMGxFUVZRSVcyUDQvLzgvQXhRN3dOaklBakRNZ0M0QXhqQ1ZLQmlySUFBRjBrejJybGh4cEFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXG59XFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQuYWNlX2Nsb3NlZCB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBTUFBQUFGQ0FZQUFBQ0FjVmFpQUFBQUhFbEVRVlFJVzJQNC8vKy9BeEF6Z0RBRGxPT0F6bkhBS2dQV0F3QVJqaThVSURUZlFRQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxufVxcbi5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0OmhvdmVyIHtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xcbn1cXG4uYWNlX2RhcmsgLmFjZV9mb2xkLXdpZGdldDphY3RpdmUge1xcbiAgICBib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbn1cXG5cXG4uYWNlX2lubGluZV9idXR0b24ge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBsaWdodGdyYXk7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgbWFyZ2luOiAtMXB4IDhweDtcXG4gICAgcGFkZGluZzogMCA1cHg7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5hY2VfaW5saW5lX2J1dHRvbjpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogZ3JheTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyMDAsMjAwLDIwMCwwLjIpO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbn1cXG5cXG4uYWNlX2ZvbGQtd2lkZ2V0LmFjZV9pbnZhbGlkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGQjRCNDtcXG4gICAgYm9yZGVyLWNvbG9yOiAjREU1NTU1O1xcbn1cXG5cXG4uYWNlX2ZhZGUtZm9sZC13aWRnZXRzIC5hY2VfZm9sZC13aWRnZXQge1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNHMgZWFzZSAwLjA1cztcXG4gICAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFjZV9mYWRlLWZvbGQtd2lkZ2V0czpob3ZlciAuYWNlX2ZvbGQtd2lkZ2V0IHtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjA1cyBlYXNlIDAuMDVzO1xcbiAgICBvcGFjaXR5OjE7XFxufVxcblxcbi5hY2VfdW5kZXJsaW5lIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbi5hY2VfYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4uYWNlX25vYm9sZCAuYWNlX2JvbGQge1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbn1cXG5cXG4uYWNlX2l0YWxpYyB7XFxuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxuXFxuLmFjZV9lcnJvci1tYXJrZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMCwgMCwwLjIpO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDk7XFxufVxcblxcbi5hY2VfaGlnaGxpZ2h0LW1hcmtlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDAsMC4yKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiA4O1xcbn1cXG5cXG4uYWNlX21vYmlsZS1tZW51IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3gtc2hhZG93OiAxcHggM3B4IDJweCBncmV5O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGNkY2RjO1xcbiAgICBjb2xvcjogYmxhY2s7XFxufVxcbi5hY2VfZGFyayA+IC5hY2VfbW9iaWxlLW1lbnUge1xcbiAgICBiYWNrZ3JvdW5kOiAjMzMzO1xcbiAgICBjb2xvcjogI2NjYztcXG4gICAgYm94LXNoYWRvdzogMXB4IDNweCAycHggZ3JleTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzQ0NDtcXG5cXG59XFxuLmFjZV9tb2JpbGUtYnV0dG9uIHtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi5hY2VfbW9iaWxlLWJ1dHRvbjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICAgIG9wYWNpdHk6MTtcXG59XFxuLmFjZV9tb2JpbGUtYnV0dG9uOmFjdGl2ZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxufVxcblxcbi5hY2VfcGxhY2Vob2xkZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZvbnQtZmFtaWx5OiBhcmlhbDtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkpO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0O1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICAgIG1hcmdpbjogMCAxMHB4O1xcbiAgICB6LWluZGV4OiAxO1xcbn1cXG5cXG4uYWNlX2dob3N0X3RleHQge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxuLmFjZV9naG9zdF90ZXh0X2NvbnRhaW5lciA+IGRpdiB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmU7XFxufVxcblxcbi5naG9zdF90ZXh0X2xpbmVfd3JhcHBlZDo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiXFx1MjFBOVxcXCI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLmFjZV9saW5lV2lkZ2V0Q29udGFpbmVyLmFjZV9naG9zdF90ZXh0IHtcXG4gICAgbWFyZ2luOiAwcHggNHB4XFxufVxcblxcbi5hY2Vfc2NyZWVucmVhZGVyLW9ubHkge1xcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gICAgbGVmdDotMTAwMDBweDtcXG4gICAgdG9wOmF1dG87XFxuICAgIHdpZHRoOjFweDtcXG4gICAgaGVpZ2h0OjFweDtcXG4gICAgb3ZlcmZsb3c6aGlkZGVuO1xcbn1cXG5cXG4uYWNlX2hpZGRlbl90b2tlbiB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVwiO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci9kZWNvcmF0b3JzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIERlY29yYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvcmF0b3IocGFyZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvbS5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gcmVuZGVyZXIubGF5ZXJDb25maWcubWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSByZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IHBhcmVudC5wYXJlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodFJhdGlvID0gdGhpcy5jYW52YXNIZWlnaHQgLyB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXNXaWR0aCA9IHBhcmVudC53aWR0aDtcbiAgICAgICAgdGhpcy5taW5EZWNvcmF0aW9uSGVpZ2h0ID0gKDIgKiB0aGlzLnBpeGVsUmF0aW8pIHwgMDtcbiAgICAgICAgdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodCA9ICh0aGlzLm1pbkRlY29yYXRpb25IZWlnaHQgLyAyKSB8IDA7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXNXaWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IDAgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gMCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuekluZGV4ID0gNyArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHRoaXMuY29sb3JzID0ge307XG4gICAgICAgIHRoaXMuY29sb3JzLmRhcmsgPSB7XG4gICAgICAgICAgICBcImVycm9yXCI6IFwicmdiYSgyNTUsIDE4LCAxOCwgMSlcIixcbiAgICAgICAgICAgIFwid2FybmluZ1wiOiBcInJnYmEoMTgsIDEzNiwgMTgsIDEpXCIsXG4gICAgICAgICAgICBcImluZm9cIjogXCJyZ2JhKDE4LCAxOCwgMTM2LCAxKVwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29sb3JzLmxpZ2h0ID0ge1xuICAgICAgICAgICAgXCJlcnJvclwiOiBcInJnYigyNTUsNTEsNTEpXCIsXG4gICAgICAgICAgICBcIndhcm5pbmdcIjogXCJyZ2IoMzIsMTMzLDcyKVwiLFxuICAgICAgICAgICAgXCJpbmZvXCI6IFwicmdiKDM1LDY4LDEzOClcIlxuICAgICAgICB9O1xuICAgICAgICBwYXJlbnQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgfVxuICAgIERlY29yYXRvci5wcm90b3R5cGUuJHVwZGF0ZURlY29yYXRvcnMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBjb2xvcnMgPSAodGhpcy5yZW5kZXJlci50aGVtZS5pc0RhcmsgPT09IHRydWUpID8gdGhpcy5jb2xvcnMuZGFyayA6IHRoaXMuY29sb3JzLmxpZ2h0O1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm1heEhlaWdodCA9IGNvbmZpZy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBhbGxMaW5lSGVpZ2h0ID0gKGNvbmZpZy5sYXN0Um93ICsgMSkgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYWxsTGluZUhlaWdodCA8IHRoaXMuY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRSYXRpbyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFJhdGlvID0gdGhpcy5jYW52YXNIZWlnaHQgLyB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLnByaW9yaXR5IDwgYi5wcmlvcml0eSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYS5wcmlvcml0eSA+IGIucHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnJlbmRlcmVyLnNlc3Npb24uJGFubm90YXRpb25zO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aWVzID0ge1xuICAgICAgICAgICAgICAgIFwiaW5mb1wiOiAxLFxuICAgICAgICAgICAgICAgIFwid2FybmluZ1wiOiAyLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnByaW9yaXR5ID0gcHJpb3JpdGllc1tpdGVtLnR5cGVdIHx8IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuc29ydChjb21wYXJlKTtcbiAgICAgICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMucmVuZGVyZXIuc2Vzc2lvbi4kZm9sZERhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGFubm90YXRpb25zW2ldLnJvdztcbiAgICAgICAgICAgICAgICB2YXIgY29tcGVuc2F0ZUZvbGQgPSB0aGlzLmNvbXBlbnNhdGVGb2xkUm93cyhyb3csIGZvbGREYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFkgPSBNYXRoLnJvdW5kKChyb3cgLSBjb21wZW5zYXRlRm9sZCkgKiB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLmhlaWdodFJhdGlvKTtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnJvdW5kKCgocm93IC0gY29tcGVuc2F0ZUZvbGQpICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5oZWlnaHRSYXRpbykpO1xuICAgICAgICAgICAgICAgIHZhciB5MiA9IE1hdGgucm91bmQoKCgocm93IC0gY29tcGVuc2F0ZUZvbGQpICogdGhpcy5saW5lSGVpZ2h0ICsgdGhpcy5saW5lSGVpZ2h0KSAqIHRoaXMuaGVpZ2h0UmF0aW8pKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0IDwgdGhpcy5taW5EZWNvcmF0aW9uSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5Q2VudGVyID0gKCh5MSArIHkyKSAvIDIpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlDZW50ZXIgPCB0aGlzLmhhbGZNaW5EZWNvcmF0aW9uSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5Q2VudGVyID0gdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh5Q2VudGVyICsgdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodCA+IHRoaXMuY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5Q2VudGVyID0gdGhpcy5jYW52YXNIZWlnaHQgLSB0aGlzLmhhbGZNaW5EZWNvcmF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkxID0gTWF0aC5yb3VuZCh5Q2VudGVyIC0gdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh5Q2VudGVyICsgdGhpcy5oYWxmTWluRGVjb3JhdGlvbkhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcnNbYW5ub3RhdGlvbnNbaV0udHlwZV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgY3VycmVudFksIHRoaXMuY2FudmFzV2lkdGgsIHkyIC0geTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnJlbmRlcmVyLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICB2YXIgY29tcGVuc2F0ZUZvbGQgPSB0aGlzLmNvbXBlbnNhdGVGb2xkUm93cyhjdXJzb3Iucm93LCBmb2xkRGF0YSk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFkgPSBNYXRoLnJvdW5kKChjdXJzb3Iucm93IC0gY29tcGVuc2F0ZUZvbGQpICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5oZWlnaHRSYXRpbyk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCBjdXJyZW50WSwgdGhpcy5jYW52YXNXaWR0aCwgMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlY29yYXRvci5wcm90b3R5cGUuY29tcGVuc2F0ZUZvbGRSb3dzID0gZnVuY3Rpb24gKHJvdywgZm9sZERhdGEpIHtcbiAgICAgICAgdmFyIGNvbXBlbnNhdGVGb2xkID0gMDtcbiAgICAgICAgaWYgKGZvbGREYXRhICYmIGZvbGREYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9sZERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93ID4gZm9sZERhdGFbal0uc3RhcnQucm93ICYmIHJvdyA8IGZvbGREYXRhW2pdLmVuZC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGVuc2F0ZUZvbGQgKz0gcm93IC0gZm9sZERhdGFbal0uc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3cgPj0gZm9sZERhdGFbal0uZW5kLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb21wZW5zYXRlRm9sZCArPSBmb2xkRGF0YVtqXS5lbmQucm93IC0gZm9sZERhdGFbal0uc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGVuc2F0ZUZvbGQ7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb3JhdG9yO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoRGVjb3JhdG9yLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS92aXJ0dWFsX3JlbmRlcmVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xheWVyL2d1dHRlclwiLFwiYWNlL2xheWVyL21hcmtlclwiLFwiYWNlL2xheWVyL3RleHRcIixcImFjZS9sYXllci9jdXJzb3JcIixcImFjZS9zY3JvbGxiYXJcIixcImFjZS9zY3JvbGxiYXJcIixcImFjZS9zY3JvbGxiYXJfY3VzdG9tXCIsXCJhY2Uvc2Nyb2xsYmFyX2N1c3RvbVwiLFwiYWNlL3JlbmRlcmxvb3BcIixcImFjZS9sYXllci9mb250X21ldHJpY3NcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2Nzcy9lZGl0b3ItY3NzXCIsXCJhY2UvbGF5ZXIvZGVjb3JhdG9yc1wiLFwiYWNlL2xpYi91c2VyYWdlbnRcIixcImFjZS9sYXllci90ZXh0X3V0aWxcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgR3V0dGVyTGF5ZXIgPSByZXF1aXJlKFwiLi9sYXllci9ndXR0ZXJcIikuR3V0dGVyO1xudmFyIE1hcmtlckxheWVyID0gcmVxdWlyZShcIi4vbGF5ZXIvbWFya2VyXCIpLk1hcmtlcjtcbnZhciBUZXh0TGF5ZXIgPSByZXF1aXJlKFwiLi9sYXllci90ZXh0XCIpLlRleHQ7XG52YXIgQ3Vyc29yTGF5ZXIgPSByZXF1aXJlKFwiLi9sYXllci9jdXJzb3JcIikuQ3Vyc29yO1xudmFyIEhTY3JvbGxCYXIgPSByZXF1aXJlKFwiLi9zY3JvbGxiYXJcIikuSFNjcm9sbEJhcjtcbnZhciBWU2Nyb2xsQmFyID0gcmVxdWlyZShcIi4vc2Nyb2xsYmFyXCIpLlZTY3JvbGxCYXI7XG52YXIgSFNjcm9sbEJhckN1c3RvbSA9IHJlcXVpcmUoXCIuL3Njcm9sbGJhcl9jdXN0b21cIikuSFNjcm9sbEJhcjtcbnZhciBWU2Nyb2xsQmFyQ3VzdG9tID0gcmVxdWlyZShcIi4vc2Nyb2xsYmFyX2N1c3RvbVwiKS5WU2Nyb2xsQmFyO1xudmFyIFJlbmRlckxvb3AgPSByZXF1aXJlKFwiLi9yZW5kZXJsb29wXCIpLlJlbmRlckxvb3A7XG52YXIgRm9udE1ldHJpY3MgPSByZXF1aXJlKFwiLi9sYXllci9mb250X21ldHJpY3NcIikuRm9udE1ldHJpY3M7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIGVkaXRvckNzcyA9IHJlcXVpcmUoXCIuL2Nzcy9lZGl0b3ItY3NzXCIpO1xudmFyIERlY29yYXRvciA9IHJlcXVpcmUoXCIuL2xheWVyL2RlY29yYXRvcnNcIikuRGVjb3JhdG9yO1xudmFyIHVzZXJhZ2VudCA9IHJlcXVpcmUoXCIuL2xpYi91c2VyYWdlbnRcIik7XG52YXIgaXNUZXh0VG9rZW4gPSByZXF1aXJlKFwiLi9sYXllci90ZXh0X3V0aWxcIikuaXNUZXh0VG9rZW47XG5kb20uaW1wb3J0Q3NzU3RyaW5nKGVkaXRvckNzcywgXCJhY2VfZWRpdG9yLmNzc1wiLCBmYWxzZSk7XG52YXIgVmlydHVhbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxSZW5kZXJlcihjb250YWluZXIsIHRoZW1lKSB7XG4gICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFwiYWNlX2VkaXRvclwiKTtcbiAgICAgICAgaWYgKGRvbS5ISV9EUEkpXG4gICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFwiYWNlX2hpZHBpXCIpO1xuICAgICAgICB0aGlzLnNldFRoZW1lKHRoZW1lKTtcbiAgICAgICAgaWYgKGNvbmZpZy5nZXQoXCJ1c2VTdHJpY3RDU1BcIikgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbmZpZy5zZXQoXCJ1c2VTdHJpY3RDU1BcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLiRndXR0ZXIgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy4kZ3V0dGVyLmNsYXNzTmFtZSA9IFwiYWNlX2d1dHRlclwiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRndXR0ZXIpO1xuICAgICAgICB0aGlzLiRndXR0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNjcm9sbGVyID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xhc3NOYW1lID0gXCJhY2Vfc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxlcik7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJhY2VfY29udGVudFwiO1xuICAgICAgICB0aGlzLnNjcm9sbGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuJGd1dHRlckxheWVyID0gbmV3IEd1dHRlckxheWVyKHRoaXMuJGd1dHRlcik7XG4gICAgICAgIHRoaXMuJGd1dHRlckxheWVyLm9uKFwiY2hhbmdlR3V0dGVyV2lkdGhcIiwgdGhpcy5vbkd1dHRlclJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjayA9IG5ldyBNYXJrZXJMYXllcih0aGlzLmNvbnRlbnQpO1xuICAgICAgICB2YXIgdGV4dExheWVyID0gdGhpcy4kdGV4dExheWVyID0gbmV3IFRleHRMYXllcih0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHRleHRMYXllci5lbGVtZW50O1xuICAgICAgICB0aGlzLiRtYXJrZXJGcm9udCA9IG5ldyBNYXJrZXJMYXllcih0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLiRjdXJzb3JMYXllciA9IG5ldyBDdXJzb3JMYXllcih0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLiRob3JpelNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiR2U2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFyID1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyViA9IG5ldyBWU2Nyb2xsQmFyKHRoaXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJIID0gbmV3IEhTY3JvbGxCYXIodGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYub24oXCJzY3JvbGxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChlLmRhdGEgLSBfc2VsZi5zY3JvbGxNYXJnaW4udG9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFySC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFfc2VsZi4kc2Nyb2xsQW5pbWF0aW9uKVxuICAgICAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChlLmRhdGEgLSBfc2VsZi5zY3JvbGxNYXJnaW4ubGVmdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0ge1xuICAgICAgICAgICAgcm93OiAwLFxuICAgICAgICAgICAgY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzID0gbmV3IEZvbnRNZXRyaWNzKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kdGV4dExheWVyLiRzZXRGb250TWV0cmljcyh0aGlzLiRmb250TWV0cmljcyk7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci5vbihcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF9zZWxmLnVwZGF0ZUNoYXJhY3RlclNpemUoKTtcbiAgICAgICAgICAgIF9zZWxmLm9uUmVzaXplKHRydWUsIF9zZWxmLmd1dHRlcldpZHRoLCBfc2VsZi4kc2l6ZS53aWR0aCwgX3NlbGYuJHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIF9zZWxmLl9zaWduYWwoXCJjaGFuZ2VDaGFyYWN0ZXJTaXplXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQ6IDAsXG4gICAgICAgICAgICBzY3JvbGxlcldpZHRoOiAwLFxuICAgICAgICAgICAgJGRpcnR5OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcgPSB7XG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBmaXJzdFJvdzogMCxcbiAgICAgICAgICAgIGZpcnN0Um93U2NyZWVuOiAwLFxuICAgICAgICAgICAgbGFzdFJvdzogMCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgICAgICAgICBjaGFyYWN0ZXJXaWR0aDogMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogMSxcbiAgICAgICAgICAgIG1heEhlaWdodDogMSxcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIGd1dHRlck9mZnNldDogMVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjcm9sbE1hcmdpbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIHY6IDAsXG4gICAgICAgICAgICBoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFyZ2luID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgdjogMCxcbiAgICAgICAgICAgIGg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSAhdXNlcmFnZW50LmlzSU9TO1xuICAgICAgICB0aGlzLiRsb29wID0gbmV3IFJlbmRlckxvb3AodGhpcy4kcmVuZGVyQ2hhbmdlcy5iaW5kKHRoaXMpLCB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGFyYWN0ZXJTaXplKCk7XG4gICAgICAgIHRoaXMuc2V0UGFkZGluZyg0KTtcbiAgICAgICAgdGhpcy4kYWRkUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICAgICAgY29uZmlnLnJlc2V0T3B0aW9ucyh0aGlzKTtcbiAgICAgICAgY29uZmlnLl9zaWduYWwoXCJyZW5kZXJlclwiLCB0aGlzKTtcbiAgICB9XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVDaGFyYWN0ZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLmFsbG93Qm9sZEZvbnRzICE9IHRoaXMuJGFsbG93Qm9sZEZvbnRzKSB7XG4gICAgICAgICAgICB0aGlzLiRhbGxvd0JvbGRGb250cyA9IHRoaXMuJHRleHRMYXllci5hbGxvd0JvbGRGb250cztcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoXCJhY2Vfbm9ib2xkXCIsICF0aGlzLiRhbGxvd0JvbGRGb250cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllckNvbmZpZy5jaGFyYWN0ZXJXaWR0aCA9XG4gICAgICAgICAgICB0aGlzLmNoYXJhY3RlcldpZHRoID0gdGhpcy4kdGV4dExheWVyLmdldENoYXJhY3RlcldpZHRoKCk7XG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcubGluZUhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSB0aGlzLiR0ZXh0TGF5ZXIuZ2V0TGluZUhlaWdodCgpO1xuICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5zY3JvbGxlci5zdHlsZSwgXCJsaW5lLWhlaWdodFwiLCB0aGlzLmxpbmVIZWlnaHQgKyBcInB4XCIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kb2Mub2ZmKFwiY2hhbmdlTmV3TGluZU1vZGVcIiwgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24gJiYgdGhpcy5zY3JvbGxNYXJnaW4udG9wICYmIHNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgPD0gMClcbiAgICAgICAgICAgIHNlc3Npb24uc2V0U2Nyb2xsVG9wKC10aGlzLnNjcm9sbE1hcmdpbi50b3ApO1xuICAgICAgICB0aGlzLiRjdXJzb3JMYXllci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB0aGlzLiRtYXJrZXJCYWNrLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuJG1hcmtlckZyb250LnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi4kc2V0Rm9udE1ldHJpY3ModGhpcy4kZm9udE1ldHJpY3MpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckguc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQmFyVi5zY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUgPSB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5kb2Mub24oXCJjaGFuZ2VOZXdMaW5lTW9kZVwiLCB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVMaW5lcyA9IGZ1bmN0aW9uIChmaXJzdFJvdywgbGFzdFJvdywgZm9yY2UpIHtcbiAgICAgICAgaWYgKGxhc3RSb3cgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGxhc3RSb3cgPSBJbmZpbml0eTtcbiAgICAgICAgaWYgKCF0aGlzLiRjaGFuZ2VkTGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcyA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdFJvdzogZmlyc3RSb3csXG4gICAgICAgICAgICAgICAgbGFzdFJvdzogbGFzdFJvd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3cgPiBmaXJzdFJvdylcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3cgPSBmaXJzdFJvdztcbiAgICAgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA8IGxhc3RSb3cpXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPSBsYXN0Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA8IHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3cpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA9IHRoaXMubGF5ZXJDb25maWcubGFzdFJvdztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGNoYW5nZWRMaW5lcy5maXJzdFJvdyA+IHRoaXMubGF5ZXJDb25maWcubGFzdFJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9MSU5FUyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLm9uQ2hhbmdlTmV3TGluZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci4kdXBkYXRlRW9sQ2hhcigpO1xuICAgICAgICB0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLnNldEVvbENoYXIodGhpcy4kdGV4dExheWVyLkVPTF9DSEFSKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUub25DaGFuZ2VUYWJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQgfCB0aGlzLkNIQU5HRV9NQVJLRVIpO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIub25DaGFuZ2VUYWJTaXplKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZ1bGwgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlKVxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2hhbmdlcyh0aGlzLkNIQU5HRV9GVUxMLCB0cnVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlRm9udFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiR1cGRhdGVTaXplQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLiRsb29wLnBlbmRpbmcpXG4gICAgICAgICAgICB0aGlzLiRzaXplLiRkaXJ0eSA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoZm9yY2UsIGd1dHRlcldpZHRoLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6aW5nID4gMilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemluZyA+IDApXG4gICAgICAgICAgICB0aGlzLnJlc2l6aW5nKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSBmb3JjZSA/IDEgOiAwO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFoZWlnaHQpXG4gICAgICAgICAgICBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQgfHwgZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBpZiAoIWhlaWdodCAmJiB0aGlzLiRtYXhMaW5lcyAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSB7XG4gICAgICAgICAgICBpZiAoIWVsLnN0eWxlLmhlaWdodCB8fCBlbC5zdHlsZS5oZWlnaHQgPT0gXCIwcHhcIikge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0IHx8IGVsLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdpZHRoKVxuICAgICAgICAgICAgd2lkdGggPSBlbC5jbGllbnRXaWR0aCB8fCBlbC5zY3JvbGxXaWR0aDtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKGZvcmNlLCBndXR0ZXJXaWR0aCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLiRyZXNpemVUaW1lcilcbiAgICAgICAgICAgIHRoaXMuJHJlc2l6ZVRpbWVyLmNhbmNlbCgpO1xuICAgICAgICBpZiAoIXRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgfHwgKCF3aWR0aCAmJiAhaGVpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2l6aW5nID0gMDtcbiAgICAgICAgaWYgKGZvcmNlKVxuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuJHBhZGRpbmcgPSBudWxsO1xuICAgICAgICBpZiAoZm9yY2UpXG4gICAgICAgICAgICB0aGlzLiRyZW5kZXJDaGFuZ2VzKGNoYW5nZXMgfCB0aGlzLiRjaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZShjaGFuZ2VzIHwgdGhpcy4kY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6aW5nKVxuICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxCYXJWLnNjcm9sbFRvcCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLiRjdXN0b21TY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1c3RvbVNjcm9sbGJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlQ2FjaGVkU2l6ZSA9IGZ1bmN0aW9uIChmb3JjZSwgZ3V0dGVyV2lkdGgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaGVpZ2h0IC09ICh0aGlzLiRleHRyYUhlaWdodCB8fCAwKTtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSAwO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuJHNpemU7XG4gICAgICAgIHZhciBvbGRTaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQ6IHNpemUuc2Nyb2xsZXJIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxlcldpZHRoOiBzaXplLnNjcm9sbGVyV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlaWdodCAmJiAoZm9yY2UgfHwgc2l6ZS5oZWlnaHQgIT0gaGVpZ2h0KSkge1xuICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjaGFuZ2VzIHw9IHRoaXMuQ0hBTkdFX1NJWkU7XG4gICAgICAgICAgICBzaXplLnNjcm9sbGVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy4kaG9yaXpTY3JvbGwpXG4gICAgICAgICAgICAgICAgc2l6ZS5zY3JvbGxlckhlaWdodCAtPSB0aGlzLnNjcm9sbEJhckguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0SGVpZ2h0KHNpemUuc2Nyb2xsZXJIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLmVsZW1lbnQuc3R5bGUuYm90dG9tID0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpICsgXCJweFwiO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfCB0aGlzLkNIQU5HRV9TQ1JPTEw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICYmIChmb3JjZSB8fCBzaXplLndpZHRoICE9IHdpZHRoKSkge1xuICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLkNIQU5HRV9TSVpFO1xuICAgICAgICAgICAgc2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgaWYgKGd1dHRlcldpZHRoID09IG51bGwpXG4gICAgICAgICAgICAgICAgZ3V0dGVyV2lkdGggPSB0aGlzLiRzaG93R3V0dGVyID8gdGhpcy4kZ3V0dGVyLm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVyV2lkdGggPSBndXR0ZXJXaWR0aDtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLnNjcm9sbEJhckguZWxlbWVudC5zdHlsZSwgXCJsZWZ0XCIsIGd1dHRlcldpZHRoICsgXCJweFwiKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLnNjcm9sbGVyLnN0eWxlLCBcImxlZnRcIiwgZ3V0dGVyV2lkdGggKyB0aGlzLm1hcmdpbi5sZWZ0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJXaWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gZ3V0dGVyV2lkdGggLSB0aGlzLnNjcm9sbEJhclYuZ2V0V2lkdGgoKSAtIHRoaXMubWFyZ2luLmgpO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuJGd1dHRlci5zdHlsZSwgXCJsZWZ0XCIsIHRoaXMubWFyZ2luLmxlZnQgKyBcInB4XCIpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5zY3JvbGxCYXJWLmdldFdpZHRoKCkgKyBcInB4XCI7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5zY3JvbGxCYXJILmVsZW1lbnQuc3R5bGUsIFwicmlnaHRcIiwgcmlnaHQpO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwicmlnaHRcIiwgcmlnaHQpO1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwiYm90dG9tXCIsIHRoaXMuc2Nyb2xsQmFySC5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0V2lkdGgoc2l6ZS5zY3JvbGxlcldpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLmdldFVzZVdyYXBNb2RlKCkgJiYgdGhpcy5hZGp1c3RXcmFwTGltaXQoKSB8fCBmb3JjZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy5DSEFOR0VfRlVMTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaXplLiRkaXJ0eSA9ICF3aWR0aCB8fCAhaGVpZ2h0O1xuICAgICAgICBpZiAoY2hhbmdlcylcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcInJlc2l6ZVwiLCBvbGRTaXplKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLm9uR3V0dGVyUmVzaXplID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICAgIHZhciBndXR0ZXJXaWR0aCA9IHRoaXMuJHNob3dHdXR0ZXIgPyB3aWR0aCA6IDA7XG4gICAgICAgIGlmIChndXR0ZXJXaWR0aCAhPSB0aGlzLmd1dHRlcldpZHRoKVxuICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyB8PSB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKHRydWUsIGd1dHRlcldpZHRoLCB0aGlzLiRzaXplLndpZHRoLCB0aGlzLiRzaXplLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSAmJiB0aGlzLmFkanVzdFdyYXBMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuJHNpemUuJGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY29tcHV0ZUxheWVyQ29uZmlnKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB0aGlzLiRwYWRkaW5nICogMjtcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5mbG9vcihhdmFpbGFibGVXaWR0aCAvIHRoaXMuY2hhcmFjdGVyV2lkdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmFkanVzdFdyYXBMaW1pdChsaW1pdCwgdGhpcy4kc2hvd1ByaW50TWFyZ2luICYmIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0QW5pbWF0ZWRTY3JvbGwgPSBmdW5jdGlvbiAoc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImFuaW1hdGVkU2Nyb2xsXCIsIHNob3VsZEFuaW1hdGUpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGFuaW1hdGVkU2Nyb2xsO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRTaG93SW52aXNpYmxlcyA9IGZ1bmN0aW9uIChzaG93SW52aXNpYmxlcykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInNob3dJbnZpc2libGVzXCIsIHNob3dJbnZpc2libGVzKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci5zZXRTaG93SW52aXNpYmxlcyhzaG93SW52aXNpYmxlcyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJzaG93SW52aXNpYmxlc1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZGlzcGxheUluZGVudEd1aWRlc1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZGlzcGxheUluZGVudEd1aWRlc1wiLCBkaXNwbGF5KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0SW5kZW50R3VpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRJbmRlbnRHdWlkZXNcIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodEluZGVudEd1aWRlcyA9IGZ1bmN0aW9uIChoaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJoaWdobGlnaHRJbmRlbnRHdWlkZXNcIiwgaGlnaGxpZ2h0KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24gKHNob3dQcmludE1hcmdpbikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInNob3dQcmludE1hcmdpblwiLCBzaG93UHJpbnRNYXJnaW4pO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaG93UHJpbnRNYXJnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dQcmludE1hcmdpblwiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbiAocHJpbnRNYXJnaW5Db2x1bW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJwcmludE1hcmdpbkNvbHVtblwiLCBwcmludE1hcmdpbkNvbHVtbik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJwcmludE1hcmdpbkNvbHVtblwiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hvd0d1dHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwic2hvd0d1dHRlclwiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2hvd0d1dHRlciA9IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldE9wdGlvbihcInNob3dHdXR0ZXJcIiwgc2hvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiZmFkZUZvbGRXaWRnZXRzXCIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImZhZGVGb2xkV2lkZ2V0c1wiLCBzaG93KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uIChzaG91bGRIaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJoaWdobGlnaHRHdXR0ZXJMaW5lXCIsIHNob3VsZEhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImhpZ2hsaWdodEd1dHRlckxpbmVcIik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiR1cGRhdGVQcmludE1hcmdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgIXRoaXMuJHByaW50TWFyZ2luRWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy4kcHJpbnRNYXJnaW5FbCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXJFbC5jbGFzc05hbWUgPSBcImFjZV9sYXllciBhY2VfcHJpbnQtbWFyZ2luLWxheWVyXCI7XG4gICAgICAgICAgICB0aGlzLiRwcmludE1hcmdpbkVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLiRwcmludE1hcmdpbkVsLmNsYXNzTmFtZSA9IFwiYWNlX3ByaW50LW1hcmdpblwiO1xuICAgICAgICAgICAgY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodGhpcy4kcHJpbnRNYXJnaW5FbCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lckVsLCB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy4kcHJpbnRNYXJnaW5FbC5zdHlsZTtcbiAgICAgICAgc3R5bGUubGVmdCA9IE1hdGgucm91bmQodGhpcy5jaGFyYWN0ZXJXaWR0aCAqIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uICsgdGhpcy4kcGFkZGluZykgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLiRzaG93UHJpbnRNYXJnaW4gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLiR3cmFwID09IC0xKVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RXcmFwTGltaXQoKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRNb3VzZUV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxlcjtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dEFyZWFDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kaXNNb3VzZVByZXNzZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMudGV4dGFyZWEuc3R5bGU7XG4gICAgICAgIHZhciBjb21wb3NpdGlvbiA9IHRoaXMuJGNvbXBvc2l0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yICYmICFjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLnRleHRhcmVhLCAtMTAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGl4ZWxQb3MgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3M7XG4gICAgICAgIGlmICghcGl4ZWxQb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5tYXJrZXJSYW5nZSlcbiAgICAgICAgICAgIHBpeGVsUG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbihjb21wb3NpdGlvbi5tYXJrZXJSYW5nZS5zdGFydCwgdHJ1ZSk7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmxheWVyQ29uZmlnO1xuICAgICAgICB2YXIgcG9zVG9wID0gcGl4ZWxQb3MudG9wO1xuICAgICAgICB2YXIgcG9zTGVmdCA9IHBpeGVsUG9zLmxlZnQ7XG4gICAgICAgIHBvc1RvcCAtPSBjb25maWcub2Zmc2V0O1xuICAgICAgICB2YXIgaCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnVzZVRleHRhcmVhRm9ySU1FIHx8IHVzZXJhZ2VudC5pc01vYmlsZSA/IHRoaXMubGluZUhlaWdodCA6IDE7XG4gICAgICAgIGlmIChwb3NUb3AgPCAwIHx8IHBvc1RvcCA+IGNvbmZpZy5oZWlnaHQgLSBoKSB7XG4gICAgICAgICAgICBkb20udHJhbnNsYXRlKHRoaXMudGV4dGFyZWEsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ID0gMTtcbiAgICAgICAgdmFyIG1heFRvcCA9IHRoaXMuJHNpemUuaGVpZ2h0IC0gaDtcbiAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgcG9zVG9wICs9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbi51c2VUZXh0YXJlYUZvcklNRSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnRleHRhcmVhLnZhbHVlO1xuICAgICAgICAgICAgICAgIHcgPSB0aGlzLmNoYXJhY3RlcldpZHRoICogKHRoaXMuc2Vzc2lvbi4kZ2V0U3RyaW5nU2NyZWVuV2lkdGgodmFsKVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NUb3AgKz0gdGhpcy5saW5lSGVpZ2h0ICsgMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NMZWZ0IC09IHRoaXMuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHBvc0xlZnQgPiB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3KVxuICAgICAgICAgICAgcG9zTGVmdCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCAtIHc7XG4gICAgICAgIHBvc0xlZnQgKz0gdGhpcy5ndXR0ZXJXaWR0aCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJoZWlnaHRcIiwgaCArIFwicHhcIik7XG4gICAgICAgIGRvbS5zZXRTdHlsZShzdHlsZSwgXCJ3aWR0aFwiLCB3ICsgXCJweFwiKTtcbiAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLnRleHRhcmVhLCBNYXRoLm1pbihwb3NMZWZ0LCB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3KSwgTWF0aC5taW4ocG9zVG9wLCBtYXhUb3ApKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0Rmlyc3RWaXNpYmxlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdztcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0Rmlyc3RGdWxseVZpc2libGVSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93ICsgKHRoaXMubGF5ZXJDb25maWcub2Zmc2V0ID09PSAwID8gMCA6IDEpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXN0RnVsbHlWaXNpYmxlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBjb25maWcubGFzdFJvdztcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KGxhc3RSb3csIDApICogY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIGlmICh0b3AgLSB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgPiBjb25maWcuaGVpZ2h0IC0gY29uZmlnLmxpbmVIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdFJvdyAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0Um93O1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJDb25maWcubGFzdFJvdztcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0UGFkZGluZyA9IGZ1bmN0aW9uIChwYWRkaW5nKSB7XG4gICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRQYWRkaW5nKHBhZGRpbmcpO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRTY3JvbGxNYXJnaW4gPSBmdW5jdGlvbiAodG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2Nyb2xsTWFyZ2luO1xuICAgICAgICBzbS50b3AgPSB0b3AgfCAwO1xuICAgICAgICBzbS5ib3R0b20gPSBib3R0b20gfCAwO1xuICAgICAgICBzbS5yaWdodCA9IHJpZ2h0IHwgMDtcbiAgICAgICAgc20ubGVmdCA9IGxlZnQgfCAwO1xuICAgICAgICBzbS52ID0gc20udG9wICsgc20uYm90dG9tO1xuICAgICAgICBzbS5oID0gc20ubGVmdCArIHNtLnJpZ2h0O1xuICAgICAgICBpZiAoc20udG9wICYmIHRoaXMuc2Nyb2xsVG9wIDw9IDAgJiYgdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCgtc20udG9wKTtcbiAgICAgICAgdGhpcy51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldE1hcmdpbiA9IGZ1bmN0aW9uICh0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5tYXJnaW47XG4gICAgICAgIHNtLnRvcCA9IHRvcCB8IDA7XG4gICAgICAgIHNtLmJvdHRvbSA9IGJvdHRvbSB8IDA7XG4gICAgICAgIHNtLnJpZ2h0ID0gcmlnaHQgfCAwO1xuICAgICAgICBzbS5sZWZ0ID0gbGVmdCB8IDA7XG4gICAgICAgIHNtLnYgPSBzbS50b3AgKyBzbS5ib3R0b207XG4gICAgICAgIHNtLmggPSBzbS5sZWZ0ICsgc20ucmlnaHQ7XG4gICAgICAgIHRoaXMuJHVwZGF0ZUNhY2hlZFNpemUodHJ1ZSwgdGhpcy5ndXR0ZXJXaWR0aCwgdGhpcy4kc2l6ZS53aWR0aCwgdGhpcy4kc2l6ZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0SFNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0SFNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbiAoYWx3YXlzVmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhTY3JvbGxCYXJBbHdheXNWaXNpYmxlXCIsIGFsd2F5c1Zpc2libGUpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRWU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRWU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSA9IGZ1bmN0aW9uIChhbHdheXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidlNjcm9sbEJhckFsd2F5c1Zpc2libGVcIiwgYWx3YXlzVmlzaWJsZSk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiR1cGRhdGVTY3JvbGxCYXJWID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5sYXllckNvbmZpZy5tYXhIZWlnaHQ7XG4gICAgICAgIHZhciBzY3JvbGxlckhlaWdodCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQ7XG4gICAgICAgIGlmICghdGhpcy4kbWF4TGluZXMgJiYgdGhpcy4kc2Nyb2xsUGFzdEVuZCkge1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0IC09IChzY3JvbGxlckhlaWdodCAtIHRoaXMubGluZUhlaWdodCkgKiB0aGlzLiRzY3JvbGxQYXN0RW5kO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID4gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSB0aGlzLnNjcm9sbFRvcCArIHNjcm9sbGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRTY3JvbGxIZWlnaHQoc2Nyb2xsSGVpZ2h0ICsgdGhpcy5zY3JvbGxNYXJnaW4udik7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRTY3JvbGxUb3AodGhpcy5zY3JvbGxUb3AgKyB0aGlzLnNjcm9sbE1hcmdpbi50b3ApO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlU2Nyb2xsQmFySCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILnNldFNjcm9sbFdpZHRoKHRoaXMubGF5ZXJDb25maWcud2lkdGggKyAyICogdGhpcy4kcGFkZGluZyArIHRoaXMuc2Nyb2xsTWFyZ2luLmgpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0U2Nyb2xsTGVmdCh0aGlzLnNjcm9sbExlZnQgKyB0aGlzLnNjcm9sbE1hcmdpbi5sZWZ0KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRmcm96ZW4gPSB0cnVlO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51bmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kZnJvemVuID0gZmFsc2U7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRyZW5kZXJDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMsIGZvcmNlKSB7XG4gICAgICAgIGlmICh0aGlzLiRjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjaGFuZ2VzIHw9IHRoaXMuJGNoYW5nZXM7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF0aGlzLnNlc3Npb24gfHwgIXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IHRoaXMuJGZyb3plbikgfHwgKCFjaGFuZ2VzICYmICFmb3JjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgfD0gY2hhbmdlcztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kc2l6ZS4kZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgfD0gY2hhbmdlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUmVzaXplKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5saW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImJlZm9yZVJlbmRlclwiLCBjaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlci51cGRhdGVDaGFyYWN0ZXJXaWR0aHModGhpcy4kZm9udE1ldHJpY3MpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9GVUxMIHx8XG4gICAgICAgICAgICBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfU0laRSB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHxcbiAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9MSU5FUyB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1NDUk9MTCB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0hfU0NST0xMKSB7XG4gICAgICAgICAgICBjaGFuZ2VzIHw9IHRoaXMuJGNvbXB1dGVMYXllckNvbmZpZygpIHwgdGhpcy4kbG9vcC5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5maXJzdFJvdyAhPSB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93ICYmIGNvbmZpZy5maXJzdFJvd1NjcmVlbiA9PSB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93U2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpcy5zY3JvbGxUb3AgKyAoY29uZmlnLmZpcnN0Um93IC0gTWF0aC5tYXgodGhpcy5sYXllckNvbmZpZy5maXJzdFJvdywgMCkpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzdDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfCB0aGlzLkNIQU5HRV9TQ1JPTEw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kY29tcHV0ZUxheWVyQ29uZmlnKCkgfCB0aGlzLiRsb29wLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhclYoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfSF9TQ1JPTEwpXG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlU2Nyb2xsQmFySCgpO1xuICAgICAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLmNvbnRlbnQsIC10aGlzLnNjcm9sbExlZnQsIC1jb25maWcub2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbmZpZy53aWR0aCArIDIgKiB0aGlzLiRwYWRkaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGNvbmZpZy5taW5IZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICBkb20uc2V0U3R5bGUodGhpcy5jb250ZW50LnN0eWxlLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0aGlzLmNvbnRlbnQuc3R5bGUsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9IX1NDUk9MTCkge1xuICAgICAgICAgICAgZG9tLnRyYW5zbGF0ZSh0aGlzLmNvbnRlbnQsIC10aGlzLnNjcm9sbExlZnQsIC1jb25maWcub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xhc3NOYW1lID0gdGhpcy5zY3JvbGxMZWZ0IDw9IDAgPyBcImFjZV9zY3JvbGxlciBcIiA6IFwiYWNlX3Njcm9sbGVyIGFjZV9zY3JvbGwtbGVmdCBcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUtleWJvYXJkQWNjZXNzaWJpbGl0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmNsYXNzTmFtZSArPSB0aGlzLmtleWJvYXJkRm9jdXNDbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9GVUxMKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VzdG9tU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJCYWNrLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRjdXJzb3JMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJhZnRlclJlbmRlclwiLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1NDUk9MTCkge1xuICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfVEVYVCB8fCBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfTElORVMpXG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci5zY3JvbGxMaW5lcyhjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0dVVFRFUiB8fCBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfTElORVMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuc2Nyb2xsTGluZXMoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRjdXN0b21TY3JvbGxiYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzY3JvbGxEZWNvcmF0b3IuJHVwZGF0ZURlY29yYXRvcnMoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJG1hcmtlckJhY2sudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImFmdGVyUmVuZGVyXCIsIGNoYW5nZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfVEVYVCkge1xuICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1c3RvbVNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbERlY29yYXRvci4kdXBkYXRlRGVjb3JhdG9ycyhjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9MSU5FUykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHVwZGF0ZUxpbmVzKCkgfHwgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9HVVRURVIpICYmIHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VzdG9tU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0dVVFRFUikge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3VzdG9tU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0NVUlNPUikge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlTGluZUhpZ2hsaWdodChjb25maWcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGN1c3RvbVNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcm9sbERlY29yYXRvci4kdXBkYXRlRGVjb3JhdG9ycyhjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfQ1VSU09SKSB7XG4gICAgICAgICAgICB0aGlzLiRjdXJzb3JMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiAodGhpcy5DSEFOR0VfTUFSS0VSIHwgdGhpcy5DSEFOR0VfTUFSS0VSX0ZST05UKSkge1xuICAgICAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiAodGhpcy5DSEFOR0VfTUFSS0VSIHwgdGhpcy5DSEFOR0VfTUFSS0VSX0JBQ0spKSB7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJCYWNrLnVwZGF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImFmdGVyUmVuZGVyXCIsIGNoYW5nZXMpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kYXV0b3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnNlc3Npb24uZ2V0U2NyZWVuTGVuZ3RoKCkgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLiRtYXhMaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGRlc2lyZWRIZWlnaHQgPSBNYXRoLm1pbihtYXhIZWlnaHQsIE1hdGgubWF4KCh0aGlzLiRtaW5MaW5lcyB8fCAxKSAqIHRoaXMubGluZUhlaWdodCwgaGVpZ2h0KSkgKyB0aGlzLnNjcm9sbE1hcmdpbi52ICsgKHRoaXMuJGV4dHJhSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAodGhpcy4kaG9yaXpTY3JvbGwpXG4gICAgICAgICAgICBkZXNpcmVkSGVpZ2h0ICs9IHRoaXMuc2Nyb2xsQmFySC5nZXRIZWlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuJG1heFBpeGVsSGVpZ2h0ICYmIGRlc2lyZWRIZWlnaHQgPiB0aGlzLiRtYXhQaXhlbEhlaWdodClcbiAgICAgICAgICAgIGRlc2lyZWRIZWlnaHQgPSB0aGlzLiRtYXhQaXhlbEhlaWdodDtcbiAgICAgICAgdmFyIGhpZGVTY3JvbGxiYXJzID0gZGVzaXJlZEhlaWdodCA8PSAyICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgdlNjcm9sbCA9ICFoaWRlU2Nyb2xsYmFycyAmJiBoZWlnaHQgPiBtYXhIZWlnaHQ7XG4gICAgICAgIGlmIChkZXNpcmVkSGVpZ2h0ICE9IHRoaXMuZGVzaXJlZEhlaWdodCB8fFxuICAgICAgICAgICAgdGhpcy4kc2l6ZS5oZWlnaHQgIT0gdGhpcy5kZXNpcmVkSGVpZ2h0IHx8IHZTY3JvbGwgIT0gdGhpcy4kdlNjcm9sbCkge1xuICAgICAgICAgICAgaWYgKHZTY3JvbGwgIT0gdGhpcy4kdlNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHZTY3JvbGwgPSB2U2Nyb2xsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRWaXNpYmxlKHZTY3JvbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGRlc2lyZWRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKHRydWUsIHRoaXMuJGd1dHRlcldpZHRoLCB3LCBkZXNpcmVkSGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZGVzaXJlZEhlaWdodCA9IGRlc2lyZWRIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJhdXRvc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kY29tcHV0ZUxheWVyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLiRzaXplO1xuICAgICAgICB2YXIgaGlkZVNjcm9sbGJhcnMgPSBzaXplLmhlaWdodCA8PSAyICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgc2NyZWVuTGluZXMgPSB0aGlzLnNlc3Npb24uZ2V0U2NyZWVuTGVuZ3RoKCk7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBzY3JlZW5MaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGxvbmdlc3RMaW5lID0gdGhpcy4kZ2V0TG9uZ2VzdExpbmUoKTtcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsID0gIWhpZGVTY3JvbGxiYXJzICYmICh0aGlzLiRoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fFxuICAgICAgICAgICAgc2l6ZS5zY3JvbGxlcldpZHRoIC0gbG9uZ2VzdExpbmUgLSAyICogdGhpcy4kcGFkZGluZyA8IDApO1xuICAgICAgICB2YXIgaFNjcm9sbENoYW5nZWQgPSB0aGlzLiRob3JpelNjcm9sbCAhPT0gaG9yaXpTY3JvbGw7XG4gICAgICAgIGlmIChoU2Nyb2xsQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBob3JpelNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zZXRWaXNpYmxlKGhvcml6U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdlNjcm9sbEJlZm9yZSA9IHRoaXMuJHZTY3JvbGw7IC8vIGF1dG9zaXplIGNhbiBjaGFuZ2UgdnNjcm9sbCB2YWx1ZSBpbiB3aGljaCBjYXNlIHdlIG5lZWQgdG8gdXBkYXRlIGxvbmdlc3RMaW5lXG4gICAgICAgIGlmICh0aGlzLiRtYXhMaW5lcyAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLiRhdXRvc2l6ZSgpO1xuICAgICAgICAgICAgaGlkZVNjcm9sbGJhcnMgPSBzaXplLmhlaWdodCA8PSAyICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5IZWlnaHQgPSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgc2Nyb2xsUGFzdEVuZCA9ICF0aGlzLiRtYXhMaW5lcyAmJiB0aGlzLiRzY3JvbGxQYXN0RW5kXG4gICAgICAgICAgICA/IChzaXplLnNjcm9sbGVySGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0KSAqIHRoaXMuJHNjcm9sbFBhc3RFbmRcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgbWF4SGVpZ2h0ICs9IHNjcm9sbFBhc3RFbmQ7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2Nyb2xsTWFyZ2luO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKE1hdGgubWF4KC1zbS50b3AsIE1hdGgubWluKHRoaXMuc2Nyb2xsVG9wLCBtYXhIZWlnaHQgLSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgc20uYm90dG9tKSkpO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChNYXRoLm1heCgtc20ubGVmdCwgTWF0aC5taW4odGhpcy5zY3JvbGxMZWZ0LCBsb25nZXN0TGluZSArIDIgKiB0aGlzLiRwYWRkaW5nIC0gc2l6ZS5zY3JvbGxlcldpZHRoICsgc20ucmlnaHQpKSk7XG4gICAgICAgIHZhciB2U2Nyb2xsID0gIWhpZGVTY3JvbGxiYXJzICYmICh0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fFxuICAgICAgICAgICAgc2l6ZS5zY3JvbGxlckhlaWdodCAtIG1heEhlaWdodCArIHNjcm9sbFBhc3RFbmQgPCAwIHx8IHRoaXMuc2Nyb2xsVG9wID4gc20udG9wKTtcbiAgICAgICAgdmFyIHZTY3JvbGxDaGFuZ2VkID0gdlNjcm9sbEJlZm9yZSAhPT0gdlNjcm9sbDtcbiAgICAgICAgaWYgKHZTY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLiR2U2Nyb2xsID0gdlNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRWaXNpYmxlKHZTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnNjcm9sbFRvcCAlIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IE1hdGguY2VpbChtaW5IZWlnaHQgLyB0aGlzLmxpbmVIZWlnaHQpIC0gMTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgodGhpcy5zY3JvbGxUb3AgLSBvZmZzZXQpIC8gdGhpcy5saW5lSGVpZ2h0KSk7XG4gICAgICAgIHZhciBsYXN0Um93ID0gZmlyc3RSb3cgKyBsaW5lQ291bnQ7XG4gICAgICAgIHZhciBmaXJzdFJvd1NjcmVlbiwgZmlyc3RSb3dIZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBmaXJzdFJvdyA9IHNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFJvdyhmaXJzdFJvdywgMCk7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHNlc3Npb24uZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xuICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgIGZpcnN0Um93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Um93U2NyZWVuID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KGZpcnN0Um93LCAwKTtcbiAgICAgICAgZmlyc3RSb3dIZWlnaHQgPSBzZXNzaW9uLmdldFJvd0xlbmd0aChmaXJzdFJvdykgKiBsaW5lSGVpZ2h0O1xuICAgICAgICBsYXN0Um93ID0gTWF0aC5taW4oc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50Um93KGxhc3RSb3csIDApLCBzZXNzaW9uLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIG1pbkhlaWdodCA9IHNpemUuc2Nyb2xsZXJIZWlnaHQgKyBzZXNzaW9uLmdldFJvd0xlbmd0aChsYXN0Um93KSAqIGxpbmVIZWlnaHQgK1xuICAgICAgICAgICAgZmlyc3RSb3dIZWlnaHQ7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuc2Nyb2xsVG9wIC0gZmlyc3RSb3dTY3JlZW4gKiBsaW5lSGVpZ2h0O1xuICAgICAgICB2YXIgY2hhbmdlcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheWVyQ29uZmlnLndpZHRoICE9IGxvbmdlc3RMaW5lIHx8IGhTY3JvbGxDaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlcyA9IHRoaXMuQ0hBTkdFX0hfU0NST0xMO1xuICAgICAgICBpZiAoaFNjcm9sbENoYW5nZWQgfHwgdlNjcm9sbENoYW5nZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCB0aGlzLmd1dHRlcldpZHRoLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJzY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZFwiKTtcbiAgICAgICAgICAgIGlmICh2U2Nyb2xsQ2hhbmdlZClcbiAgICAgICAgICAgICAgICBsb25nZXN0TGluZSA9IHRoaXMuJGdldExvbmdlc3RMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllckNvbmZpZyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBsb25nZXN0TGluZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRoaXMuJHBhZGRpbmcsXG4gICAgICAgICAgICBmaXJzdFJvdzogZmlyc3RSb3csXG4gICAgICAgICAgICBmaXJzdFJvd1NjcmVlbjogZmlyc3RSb3dTY3JlZW4sXG4gICAgICAgICAgICBsYXN0Um93OiBsYXN0Um93LFxuICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoOiB0aGlzLmNoYXJhY3RlcldpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiBtaW5IZWlnaHQsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgZ3V0dGVyT2Zmc2V0OiBsaW5lSGVpZ2h0ID8gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChvZmZzZXQgKyBzaXplLmhlaWdodCAtIHNpemUuc2Nyb2xsZXJIZWlnaHQpIC8gbGluZUhlaWdodCkpIDogMCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRiaWRpSGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuc2V0Q29udGVudFdpZHRoKGxvbmdlc3RMaW5lIC0gdGhpcy4kcGFkZGluZyk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kY2hhbmdlZExpbmVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSB0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3c7XG4gICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3c7XG4gICAgICAgIHRoaXMuJGNoYW5nZWRMaW5lcyA9IG51bGw7XG4gICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgIGlmIChmaXJzdFJvdyA+IGxheWVyQ29uZmlnLmxhc3RSb3cgKyAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSb3cgPCBsYXllckNvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Um93ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGxheWVyQ29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUobGF5ZXJDb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGVMaW5lcyhsYXllckNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGdldExvbmdlc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhckNvdW50ID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbldpZHRoKCk7XG4gICAgICAgIGlmICh0aGlzLnNob3dJbnZpc2libGVzICYmICF0aGlzLnNlc3Npb24uJHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgY2hhckNvdW50ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIgJiYgY2hhckNvdW50ID4gdGhpcy4kdGV4dExheWVyLk1BWF9MSU5FX0xFTkdUSClcbiAgICAgICAgICAgIGNoYXJDb3VudCA9IHRoaXMuJHRleHRMYXllci5NQVhfTElORV9MRU5HVEggKyAzMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCAtIDIgKiB0aGlzLiRwYWRkaW5nLCBNYXRoLnJvdW5kKGNoYXJDb3VudCAqIHRoaXMuY2hhcmFjdGVyV2lkdGgpKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlRnJvbnRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKHRydWUpKTtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9NQVJLRVJfRlJPTlQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVCYWNrTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKCkpO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX01BUktFUl9CQUNLKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYWRkR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5hZGRHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uIChyb3csIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQnJlYWtwb2ludHMgPSBmdW5jdGlvbiAocm93cykge1xuICAgICAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9HVVRURVIpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyk7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0NVUlNPUik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmhpZGVDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmhpZGVDdXJzb3IoKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2hvd0N1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuc2hvd0N1cnNvcigpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGZ1bmN0aW9uIChhbmNob3IsIGxlYWQsIG9mZnNldCkge1xuICAgICAgICB0aGlzLnNjcm9sbEN1cnNvckludG9WaWV3KGFuY2hvciwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zY3JvbGxDdXJzb3JJbnRvVmlldyhsZWFkLCBvZmZzZXQpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxDdXJzb3JJbnRvVmlldyA9IGZ1bmN0aW9uIChjdXJzb3IsIG9mZnNldCwgJHZpZXdNYXJnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGN1cnNvcik7XG4gICAgICAgIHZhciBuZXdMZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgIHZhciBuZXdUb3AgPSBwb3MudG9wO1xuICAgICAgICB2YXIgdG9wTWFyZ2luID0gJHZpZXdNYXJnaW4gJiYgJHZpZXdNYXJnaW4udG9wIHx8IDA7XG4gICAgICAgIHZhciBib3R0b21NYXJnaW4gPSAkdmlld01hcmdpbiAmJiAkdmlld01hcmdpbi5ib3R0b20gfHwgMDtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy4kc3RvcEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB0aGlzLiRzY3JvbGxBbmltYXRpb24gPyB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgOiB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKGN1cnJlbnRUb3AgKyB0b3BNYXJnaW4gPiBuZXdUb3ApIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgJiYgY3VycmVudFRvcCArIHRvcE1hcmdpbiA+IG5ld1RvcCArIHRoaXMubGluZUhlaWdodClcbiAgICAgICAgICAgICAgICBuZXdUb3AgLT0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIGlmIChuZXdUb3AgPT09IDApXG4gICAgICAgICAgICAgICAgbmV3VG9wID0gLXRoaXMuc2Nyb2xsTWFyZ2luLnRvcDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AobmV3VG9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50VG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IG5ld1RvcCArIHRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCAmJiBjdXJyZW50VG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IG5ld1RvcCAtIHRoaXMubGluZUhlaWdodClcbiAgICAgICAgICAgICAgICBuZXdUb3AgKz0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AobmV3VG9wICsgdGhpcy5saW5lSGVpZ2h0ICsgYm90dG9tTWFyZ2luIC0gdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgdHdvQ2hhcnNXaWR0aCA9IDIgKiB0aGlzLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICBpZiAobmV3TGVmdCAtIHR3b0NoYXJzV2lkdGggPCBjdXJyZW50TGVmdCkge1xuICAgICAgICAgICAgbmV3TGVmdCAtPSB0d29DaGFyc1dpZHRoO1xuICAgICAgICAgICAgaWYgKG5ld0xlZnQgPCB0aGlzLiRwYWRkaW5nICsgdHdvQ2hhcnNXaWR0aCkge1xuICAgICAgICAgICAgICAgIG5ld0xlZnQgPSAtdGhpcy5zY3JvbGxNYXJnaW4ubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KG5ld0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3TGVmdCArPSB0d29DaGFyc1dpZHRoO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWZ0ICsgdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIDwgbmV3TGVmdCArIHRoaXMuY2hhcmFjdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChNYXRoLnJvdW5kKG5ld0xlZnQgKyB0aGlzLmNoYXJhY3RlcldpZHRoIC0gdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGVmdCA8PSB0aGlzLiRwYWRkaW5nICYmIG5ld0xlZnQgLSBjdXJyZW50TGVmdCA8IHRoaXMuY2hhcmFjdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3BSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcCAvIHRoaXMubGluZUhlaWdodDtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2Nyb2xsQm90dG9tUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigodGhpcy5zY3JvbGxUb3AgKyB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0KSAvIHRoaXMubGluZUhlaWdodCkgLSAxKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2Nyb2xsVG9Sb3cgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aocm93ICogdGhpcy5saW5lSGVpZ2h0KTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYWxpZ25DdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yLCBhbGlnbm1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJzb3IgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIGN1cnNvciA9IHsgcm93OiBjdXJzb3IsIGNvbHVtbjogMCB9O1xuICAgICAgICB2YXIgcG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgLSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwb3MudG9wIC0gaCAqIChhbGlnbm1lbnQgfHwgMCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGNhbGNTdGVwcyA9IGZ1bmN0aW9uIChmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbCA9IHRoaXMuU1RFUFM7XG4gICAgICAgIHZhciBzdGVwcyA9IFtdO1xuICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uICh0LCB4X21pbiwgZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBkeCAqIChNYXRoLnBvdyh0IC0gMSwgMykgKyAxKSArIHhfbWluO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKVxuICAgICAgICAgICAgc3RlcHMucHVzaChmdW5jKGkgLyB0aGlzLlNURVBTLCBmcm9tVmFsdWUsIHRvVmFsdWUgLSBmcm9tVmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHN0ZXBzO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb0xpbmUgPSBmdW5jdGlvbiAobGluZSwgY2VudGVyLCBhbmltYXRlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbih7IHJvdzogbGluZSwgY29sdW1uOiAwIH0pO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcG9zLnRvcDtcbiAgICAgICAgaWYgKGNlbnRlcilcbiAgICAgICAgICAgIG9mZnNldCAtPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGluaXRpYWxTY3JvbGwgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcChvZmZzZXQpO1xuICAgICAgICBpZiAoYW5pbWF0ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVTY3JvbGxpbmcoaW5pdGlhbFNjcm9sbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlU2Nyb2xsaW5nID0gZnVuY3Rpb24gKGZyb21WYWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRvVmFsdWUgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKCF0aGlzLiRhbmltYXRlZFNjcm9sbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGZyb21WYWx1ZSA9PSB0b1ZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RlcHMgPSB0aGlzLiRzY3JvbGxBbmltYXRpb24uc3RlcHM7XG4gICAgICAgICAgICBpZiAob2xkU3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gb2xkU3RlcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSA9PSB0b1ZhbHVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBzID0gX3NlbGYuJGNhbGNTdGVwcyhmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgICAgICB0aGlzLiRzY3JvbGxBbmltYXRpb24gPSB7IGZyb206IGZyb21WYWx1ZSwgdG86IHRvVmFsdWUsIHN0ZXBzOiBzdGVwcyB9O1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHRpbWVyKTtcbiAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aoc3RlcHMuc2hpZnQoKSk7XG4gICAgICAgIF9zZWxmLnNlc3Npb24uJHNjcm9sbFRvcCA9IHRvVmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGVuZEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIF9zZWxmLiR0aW1lciA9IGNsZWFySW50ZXJ2YWwoX3NlbGYuJHRpbWVyKTtcbiAgICAgICAgICAgIF9zZWxmLiRzY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgX3NlbGYuJHN0b3BBbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3NlbGYuJHN0b3BBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBlbmRBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV9zZWxmLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoX3NlbGYuJHRpbWVyKTtcbiAgICAgICAgICAgIGlmIChzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChzdGVwcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSB0b1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi4kc2Nyb2xsVG9wID0gLTE7XG4gICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3AodG9WYWx1ZSk7XG4gICAgICAgICAgICAgICAgdG9WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTApO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb1kgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5zY3JvbGxUb1ggPSBmdW5jdGlvbiAoc2Nyb2xsTGVmdCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0ICE9PSBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9IX1NDUk9MTCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCh5KTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbExlZnQoeCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIGRlbHRhWSAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKSArIGRlbHRhWSk7XG4gICAgICAgIGRlbHRhWCAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpICsgZGVsdGFYKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuaXNTY3JvbGxhYmxlQnkgPSBmdW5jdGlvbiAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgaWYgKGRlbHRhWSA8IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpID49IDEgLSB0aGlzLnNjcm9sbE1hcmdpbi50b3ApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlbHRhWSA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodFxuICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLm1heEhlaWdodCA8IC0xICsgdGhpcy5zY3JvbGxNYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChkZWx0YVggPCAwICYmIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxMZWZ0KCkgPj0gMSAtIHRoaXMuc2Nyb2xsTWFyZ2luLmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlbHRhWCA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKSArIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aFxuICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLndpZHRoIDwgLTEgKyB0aGlzLnNjcm9sbE1hcmdpbi5yaWdodClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgY2FudmFzUG9zO1xuICAgICAgICBpZiAodGhpcy4kaGFzQ3NzVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgY2FudmFzUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy4kZm9udE1ldHJpY3MudHJhbnNmb3JtQ29vcmRpbmF0ZXMoW3gsIHldKTtcbiAgICAgICAgICAgIHggPSBwWzFdIC0gdGhpcy5ndXR0ZXJXaWR0aCAtIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICB5ID0gcFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhc1BvcyA9IHRoaXMuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldFggPSB4ICsgdGhpcy5zY3JvbGxMZWZ0IC0gY2FudmFzUG9zLmxlZnQgLSB0aGlzLiRwYWRkaW5nO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WCAvIHRoaXMuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh5ICsgdGhpcy5zY3JvbGxUb3AgLSBjYW52YXNQb3MudG9wKSAvIHRoaXMubGluZUhlaWdodCk7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLiRibG9ja0N1cnNvciA/IE1hdGguZmxvb3Iob2Zmc2V0KSA6IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHsgcm93OiByb3csIGNvbHVtbjogY29sLCBzaWRlOiBvZmZzZXQgLSBjb2wgPiAwID8gMSA6IC0xLCBvZmZzZXRYOiBvZmZzZXRYIH07XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGNhbnZhc1BvcztcbiAgICAgICAgaWYgKHRoaXMuJGhhc0Nzc1RyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgIGNhbnZhc1BvcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuJGZvbnRNZXRyaWNzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKFt4LCB5XSk7XG4gICAgICAgICAgICB4ID0gcFsxXSAtIHRoaXMuZ3V0dGVyV2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICAgICAgeSA9IHBbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNQb3MgPSB0aGlzLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXRYID0geCArIHRoaXMuc2Nyb2xsTGVmdCAtIGNhbnZhc1Bvcy5sZWZ0IC0gdGhpcy4kcGFkZGluZztcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFggLyB0aGlzLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICB2YXIgY29sID0gdGhpcy4kYmxvY2tDdXJzb3IgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLnJvdW5kKG9mZnNldCk7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh5ICsgdGhpcy5zY3JvbGxUb3AgLSBjYW52YXNQb3MudG9wKSAvIHRoaXMubGluZUhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHJvdywgTWF0aC5tYXgoY29sLCAwKSwgb2Zmc2V0WCk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnRleHRUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgICAgIHZhciB4ID0gdGhpcy4kcGFkZGluZyArICh0aGlzLnNlc3Npb24uJGJpZGlIYW5kbGVyLmlzQmlkaVJvdyhwb3Mucm93LCByb3cpXG4gICAgICAgICAgICA/IHRoaXMuc2Vzc2lvbi4kYmlkaUhhbmRsZXIuZ2V0UG9zTGVmdChwb3MuY29sdW1uKVxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHBvcy5jb2x1bW4gKiB0aGlzLmNoYXJhY3RlcldpZHRoKSk7XG4gICAgICAgIHZhciB5ID0gcG9zLnJvdyAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VYOiBjYW52YXNQb3MubGVmdCArIHggLSB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBwYWdlWTogY2FudmFzUG9zLnRvcCArIHkgLSB0aGlzLnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS52aXN1YWxpemVGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9mb2N1c1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudmlzdWFsaXplQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKHRoaXMuY29udGFpbmVyLCBcImFjZV9mb2N1c1wiKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2hvd0NvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuJGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb247XG4gICAgICAgIGlmICghY29tcG9zaXRpb24uY3NzVGV4dCkge1xuICAgICAgICAgICAgY29tcG9zaXRpb24uY3NzVGV4dCA9IHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29tcG9zaXRpb24udXNlVGV4dGFyZWFGb3JJTUUgPSB0aGlzLiR1c2VUZXh0YXJlYUZvcklNRTtcbiAgICAgICAgaWYgKHRoaXMuJHVzZVRleHRhcmVhRm9ySU1FKSB7XG4gICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy50ZXh0YXJlYSwgXCJhY2VfY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICB0aGlzLnRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcG9zaXRpb24ubWFya2VySWQgPSB0aGlzLnNlc3Npb24uYWRkTWFya2VyKGNvbXBvc2l0aW9uLm1hcmtlclJhbmdlLCBcImFjZV9jb21wb3NpdGlvbl9tYXJrZXJcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldENvbXBvc2l0aW9uVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvcjtcbiAgICAgICAgdGhpcy5hZGRUb2tlbih0ZXh0LCBcImNvbXBvc2l0aW9uX3BsYWNlaG9sZGVyXCIsIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5oaWRlQ29tcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy4kY29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLiRjb21wb3NpdGlvbi5tYXJrZXJJZClcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy4kY29tcG9zaXRpb24ubWFya2VySWQpO1xuICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy50ZXh0YXJlYSwgXCJhY2VfY29tcG9zaXRpb25cIik7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9IHRoaXMuJGNvbXBvc2l0aW9uLmNzc1RleHQ7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmN1cnNvcjtcbiAgICAgICAgdGhpcy5yZW1vdmVFeHRyYVRva2VuKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRjb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldEdob3N0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5zZXNzaW9uLnNlbGVjdGlvbi5jdXJzb3I7XG4gICAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHsgcm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4gfTtcbiAgICAgICAgdGhpcy5yZW1vdmVHaG9zdFRleHQoKTtcbiAgICAgICAgdmFyIHRleHRDaHVua3MgPSB0aGlzLiRjYWxjdWxhdGVXcmFwcGVkVGV4dENodW5rcyh0ZXh0LCBpbnNlcnRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYWRkVG9rZW4odGV4dENodW5rc1swXS50ZXh0LCBcImdob3N0X3RleHRcIiwgaW5zZXJ0UG9zaXRpb24ucm93LCBpbnNlcnRQb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB0aGlzLiRnaG9zdFRleHQgPSB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICByb3c6IGluc2VydFBvc2l0aW9uLnJvdyxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluc2VydFBvc2l0aW9uLmNvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd2lkZ2V0RGl2ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0ZXh0Q2h1bmtzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBoaWRkZW5Ub2tlbnMgPSB0aGlzLmhpZGVUb2tlbnNBZnRlclBvc2l0aW9uKGluc2VydFBvc2l0aW9uLnJvdywgaW5zZXJ0UG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBsYXN0TGluZURpdjtcbiAgICAgICAgICAgIHRleHRDaHVua3Muc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtEaXYgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtTcGFuID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIGNodW5rU3Bhbi5jbGFzc05hbWUgPSBcImFjZV9naG9zdF90ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKGVsLndyYXBwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNodW5rRGl2LmNsYXNzTmFtZSA9IFwiZ2hvc3RfdGV4dF9saW5lX3dyYXBwZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHQgPSBcIiBcIjtcbiAgICAgICAgICAgICAgICBjaHVua1NwYW4uYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZVRleHROb2RlKGVsLnRleHQpKTtcbiAgICAgICAgICAgICAgICBjaHVua0Rpdi5hcHBlbmRDaGlsZChjaHVua1NwYW4pO1xuICAgICAgICAgICAgICAgIHdpZGdldERpdi5hcHBlbmRDaGlsZChjaHVua0Rpdik7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVEaXYgPSBjaHVua0RpdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGlkZGVuVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RleHRUb2tlbih0b2tlbi50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9cIiArIHRva2VuLnR5cGUucmVwbGFjZSgvXFwuL2csIFwiIGFjZV9cIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb20uY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZURpdi5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kZ2hvc3RUZXh0V2lkZ2V0ID0ge1xuICAgICAgICAgICAgICAgIGVsOiB3aWRnZXREaXYsXG4gICAgICAgICAgICAgICAgcm93OiBpbnNlcnRQb3NpdGlvbi5yb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbnNlcnRQb3NpdGlvbi5jb2x1bW4sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFjZV9naG9zdF90ZXh0X2NvbnRhaW5lclwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLndpZGdldE1hbmFnZXIuYWRkTGluZVdpZGdldCh0aGlzLiRnaG9zdFRleHRXaWRnZXQpO1xuICAgICAgICAgICAgdmFyIHBpeGVsUG9zaXRpb24gPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGluc2VydFBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBnaG9zdFRleHRIZWlnaHQgPSB0ZXh0Q2h1bmtzLmxlbmd0aCAqIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgICAgIHZhciBmaXRzWSA9IGdob3N0VGV4dEhlaWdodCA8IChoZWlnaHQgLSBwaXhlbFBvc2l0aW9uLnRvcCk7XG4gICAgICAgICAgICBpZiAoZml0c1kpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGdob3N0VGV4dEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoMCwgKHRleHRDaHVua3MubGVuZ3RoIC0gMSkgKiB0aGlzLmxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1JvdyhpbnNlcnRQb3NpdGlvbi5yb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRjYWxjdWxhdGVXcmFwcGVkVGV4dENodW5rcyA9IGZ1bmN0aW9uICh0ZXh0LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB0aGlzLiRwYWRkaW5nICogMjtcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5mbG9vcihhdmFpbGFibGVXaWR0aCAvIHRoaXMuY2hhcmFjdGVyV2lkdGgpIC0gMjtcbiAgICAgICAgbGltaXQgPSBsaW1pdCA8PSAwID8gNjAgOiBsaW1pdDsgLy8gdGhpcyBpcyBhIGhhY2sgdG8gcHJldmVudCB0aGUgZWRpdG9yIGZyb20gY3Jhc2hpbmcgd2hlbiB0aGUgd2luZG93IGlzIHRvbyBzbWFsbFxuICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICB2YXIgdGV4dENodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlUb2tlbnMgPSB0aGlzLnNlc3Npb24uJGdldERpc3BsYXlUb2tlbnModGV4dExpbmVzW2ldLCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHdyYXBTcGxpdHMgPSB0aGlzLnNlc3Npb24uJGNvbXB1dGVXcmFwU3BsaXRzKGRpc3BsYXlUb2tlbnMsIGxpbWl0LCB0aGlzLnNlc3Npb24uJHRhYlNpemUpO1xuICAgICAgICAgICAgaWYgKHdyYXBTcGxpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd3JhcFNwbGl0cy5wdXNoKHRleHRMaW5lc1tpXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd3JhcFNwbGl0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFNsaWNlID0gdGV4dExpbmVzW2ldLnNsaWNlKHN0YXJ0LCB3cmFwU3BsaXRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dENodW5rcy5wdXNoKHsgdGV4dDogdGV4dFNsaWNlLCB3cmFwcGVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHdyYXBTcGxpdHNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dENodW5rcy5wdXNoKHsgdGV4dDogdGV4dExpbmVzW2ldLCB3cmFwcGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dENodW5rcztcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlR2hvc3RUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGdob3N0VGV4dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZ2hvc3RUZXh0LnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnJlbW92ZUV4dHJhVG9rZW4ocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy4kZ2hvc3RUZXh0V2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ud2lkZ2V0TWFuYWdlci5yZW1vdmVMaW5lV2lkZ2V0KHRoaXMuJGdob3N0VGV4dFdpZGdldCk7XG4gICAgICAgICAgICB0aGlzLiRnaG9zdFRleHRXaWRnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGdob3N0VGV4dCA9IG51bGw7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmFkZFRva2VuID0gZnVuY3Rpb24gKHRleHQsIHR5cGUsIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBzZXNzaW9uLmJnVG9rZW5pemVyLmxpbmVzW3Jvd10gPSBudWxsO1xuICAgICAgICB2YXIgbmV3VG9rZW4gPSB7IHR5cGU6IHR5cGUsIHZhbHVlOiB0ZXh0IH07XG4gICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuICAgICAgICBpZiAoY29sdW1uID09IG51bGwgfHwgIXRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ld1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIGwgKz0gdG9rZW4udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPD0gbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHRva2VuLnZhbHVlLmxlbmd0aCAtIChsIC0gY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRva2VuLnZhbHVlLnNsaWNlKDAsIGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0b2tlbi52YWx1ZS5zbGljZShkaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCB7IHR5cGU6IHRva2VuLnR5cGUsIHZhbHVlOiBiZWZvcmUgfSwgbmV3VG9rZW4sIHsgdHlwZTogdG9rZW4udHlwZSwgdmFsdWU6IGFmdGVyIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVMaW5lcyhyb3csIHJvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmhpZGVUb2tlbnNBZnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgdmFyIGhhc1Bhc3NlZEN1cnNvciA9IGZhbHNlO1xuICAgICAgICB2YXIgaGlkZGVuVG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBsICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImdob3N0X3RleHRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChoYXNQYXNzZWRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5Ub2tlbnMucHVzaCh7IHR5cGU6IHRva2VuLnR5cGUsIHZhbHVlOiB0b2tlbi52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJoaWRkZW5fdG9rZW5cIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBoYXNQYXNzZWRDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlTGluZXMocm93LCByb3cpO1xuICAgICAgICByZXR1cm4gaGlkZGVuVG9rZW5zO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVFeHRyYVRva2VuID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5iZ1Rva2VuaXplci5saW5lc1tyb3ddID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVMaW5lcyhyb3csIHJvdyk7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lLCBjYikge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiR0aGVtZUlkID0gdGhlbWU7XG4gICAgICAgIF9zZWxmLl9kaXNwYXRjaEV2ZW50KCd0aGVtZUNoYW5nZScsIHsgdGhlbWU6IHRoZW1lIH0pO1xuICAgICAgICBpZiAoIXRoZW1lIHx8IHR5cGVvZiB0aGVtZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IHRoZW1lIHx8IHRoaXMuJG9wdGlvbnMudGhlbWUuaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoW1widGhlbWVcIiwgbW9kdWxlTmFtZV0sIGFmdGVyTG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZnRlckxvYWQodGhlbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyTG9hZChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChfc2VsZi4kdGhlbWVJZCAhPSB0aGVtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlIHx8ICFtb2R1bGUuY3NzQ2xhc3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgbG9hZCBtb2R1bGUgXCIgKyB0aGVtZSArIFwiIG9yIGl0IGRpZG4ndCBjYWxsIGRlZmluZVwiKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuJGlkKVxuICAgICAgICAgICAgICAgIF9zZWxmLiR0aGVtZUlkID0gbW9kdWxlLiRpZDtcbiAgICAgICAgICAgIGRvbS5pbXBvcnRDc3NTdHJpbmcobW9kdWxlLmNzc1RleHQsIG1vZHVsZS5jc3NDbGFzcywgX3NlbGYuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChfc2VsZi50aGVtZSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3MoX3NlbGYuY29udGFpbmVyLCBfc2VsZi50aGVtZS5jc3NDbGFzcyk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IFwicGFkZGluZ1wiIGluIG1vZHVsZSA/IG1vZHVsZS5wYWRkaW5nXG4gICAgICAgICAgICAgICAgOiBcInBhZGRpbmdcIiBpbiAoX3NlbGYudGhlbWUgfHwge30pID8gNCA6IF9zZWxmLiRwYWRkaW5nO1xuICAgICAgICAgICAgaWYgKF9zZWxmLiRwYWRkaW5nICYmIHBhZGRpbmcgIT0gX3NlbGYuJHBhZGRpbmcpXG4gICAgICAgICAgICAgICAgX3NlbGYuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgICAgIF9zZWxmLiR0aGVtZSA9IG1vZHVsZS5jc3NDbGFzcztcbiAgICAgICAgICAgIF9zZWxmLnRoZW1lID0gbW9kdWxlO1xuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKF9zZWxmLmNvbnRhaW5lciwgbW9kdWxlLmNzc0NsYXNzKTtcbiAgICAgICAgICAgIGRvbS5zZXRDc3NDbGFzcyhfc2VsZi5jb250YWluZXIsIFwiYWNlX2RhcmtcIiwgbW9kdWxlLmlzRGFyayk7XG4gICAgICAgICAgICBpZiAoX3NlbGYuJHNpemUpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi4kc2l6ZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHVwZGF0ZVNpemVBc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NlbGYuX2Rpc3BhdGNoRXZlbnQoJ3RoZW1lTG9hZGVkJywgeyB0aGVtZTogbW9kdWxlIH0pO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNTYWZhcmkgJiYgX3NlbGYuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY3JvbGxlci5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICBfc2VsZi5zY3JvbGxlci5zdHlsZS5iYWNrZ3JvdW5kID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaGVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRoZW1lSWQ7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCBpbmNsdWRlKSB7XG4gICAgICAgIGRvbS5zZXRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUsIGluY2x1ZGUgIT09IGZhbHNlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUudW5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIHN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwiY3Vyc29yXCIsIHN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuc2V0TW91c2VDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKHRoaXMuc2Nyb2xsZXIuc3R5bGUsIFwiY3Vyc29yXCIsIGN1cnNvclN0eWxlKTtcbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVG9TaGFkb3dSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb20uaW1wb3J0Q3NzU3RyaW5nKGVkaXRvckNzcywgXCJhY2VfZWRpdG9yLmNzc1wiLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJlZXplKCk7XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidXNlUmVzaXplT2JzZXJ2ZXJcIiwgZmFsc2UpO1xuICAgIH07XG4gICAgVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kdXBkYXRlQ3VzdG9tU2Nyb2xsYmFyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRob3JpelNjcm9sbCA9IHRoaXMuJHZTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRzY3JvbGxEZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWID0gbmV3IFZTY3JvbGxCYXJDdXN0b20odGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJIID0gbmV3IEhTY3JvbGxCYXJDdXN0b20odGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLnNldEhlaWdodCh0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zZXRXaWR0aCh0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9zZWxmLiRzY3JvbGxBbmltYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uc2V0U2Nyb2xsVG9wKGUuZGF0YSAtIF9zZWxmLnNjcm9sbE1hcmdpbi50b3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KGUuZGF0YSAtIF9zZWxmLnNjcm9sbE1hcmdpbi5sZWZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yID0gbmV3IERlY29yYXRvcih0aGlzLnNjcm9sbEJhclYsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsRGVjb3JhdG9yLiR1cGRhdGVEZWNvcmF0b3JzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYgPSBuZXcgVlNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckggPSBuZXcgSFNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLnRvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfc2VsZi4kc2Nyb2xsQW5pbWF0aW9uKVxuICAgICAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbExlZnQoZS5kYXRhIC0gX3NlbGYuc2Nyb2xsTWFyZ2luLmxlZnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGFkZFJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdpbmRvdy5SZXNpemVPYnNlcnZlciB8fCB0aGlzLiRyZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRyZXNpemVUaW1lciA9IGxhbmcuZGVsYXllZENhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICBzZWxmLm9uUmVzaXplKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICAgICAgdGhpcy4kcmVzaXplT2JzZXJ2ZXIgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGVbMF0uY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgaCA9IGVbMF0uY29udGVudFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlbGYuJHNpemUud2lkdGggLSB3KSA+IDFcbiAgICAgICAgICAgICAgICB8fCBNYXRoLmFicyhzZWxmLiRzaXplLmhlaWdodCAtIGgpID4gMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuJHJlc2l6ZVRpbWVyLmRlbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLiRyZXNpemVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpcnR1YWxSZW5kZXJlcjtcbn0oKSk7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLkNIQU5HRV9DVVJTT1IgPSAxO1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTUFSS0VSID0gMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX0dVVFRFUiA9IDQ7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLkNIQU5HRV9TQ1JPTEwgPSA4O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTElORVMgPSAxNjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX1RFWFQgPSAzMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX1NJWkUgPSA2NDtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX01BUktFUl9CQUNLID0gMTI4O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfTUFSS0VSX0ZST05UID0gMjU2O1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS5DSEFOR0VfRlVMTCA9IDUxMjtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuQ0hBTkdFX0hfU0NST0xMID0gMTAyNDtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuJGNoYW5nZXMgPSAwO1xuVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZS4kcGFkZGluZyA9IG51bGw7XG5WaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLiRmcm96ZW4gPSBmYWxzZTtcblZpcnR1YWxSZW5kZXJlci5wcm90b3R5cGUuU1RFUFMgPSA4O1xub29wLmltcGxlbWVudChWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuY29uZmlnLmRlZmluZU9wdGlvbnMoVmlydHVhbFJlbmRlcmVyLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCB7XG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy4kcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzaXplVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzaXplVGltZXIgPSB0aGlzLiRyZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiAhdGhpcy4kcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhZGRSZXNpemVPYnNlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRlZFNjcm9sbDogeyBpbml0aWFsVmFsdWU6IGZhbHNlIH0sXG4gICAgc2hvd0ludmlzaWJsZXM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuc2V0U2hvd0ludmlzaWJsZXModmFsdWUpKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHNob3dQcmludE1hcmdpbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBwcmludE1hcmdpbkNvbHVtbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiA4MFxuICAgIH0sXG4gICAgcHJpbnRNYXJnaW46IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4kc2hvd1ByaW50TWFyZ2luID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgdGhpcy4kcHJpbnRNYXJnaW5Db2x1bW47XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNob3dHdXR0ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdykge1xuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICAgICAgdGhpcy5vbkd1dHRlclJlc2l6ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVzZVN2Z0d1dHRlckljb25zOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci4kdXNlU3ZnR3V0dGVySWNvbnMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0ZvbGRlZEFubm90YXRpb25zOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci4kc2hvd0ZvbGRlZEFubm90YXRpb25zID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGZhZGVGb2xkV2lkZ2V0czoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy4kZ3V0dGVyLCBcImFjZV9mYWRlLWZvbGQtd2lkZ2V0c1wiLCBzaG93KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0ZvbGRXaWRnZXRzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnNldFNob3dGb2xkV2lkZ2V0cyhzaG93KTtcbiAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBkaXNwbGF5SW5kZW50R3VpZGVzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuc2V0RGlzcGxheUluZGVudEd1aWRlcyhzaG93KSlcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhpZ2hsaWdodEluZGVudEd1aWRlczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLnNldEhpZ2hsaWdodEluZGVudEd1aWRlcyhzaG93KSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLiRoaWdobGlnaHRJbmRlbnRHdWlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLiRjbGVhckFjdGl2ZUluZGVudEd1aWRlKHRoaXMuJHRleHRMYXllci4kbGluZXMuY2VsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhpZ2hsaWdodEd1dHRlckxpbmU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lKHNob3VsZEhpZ2hsaWdodCk7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgaFNjcm9sbEJhckFsd2F5c1Zpc2libGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8ICF0aGlzLiRob3JpelNjcm9sbClcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fCAhdGhpcy4kdlNjcm9sbClcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIGZvbnRTaXplOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IDEyXG4gICAgfSxcbiAgICBmb250RmFtaWx5OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXhMaW5lczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnVsbCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtaW5MaW5lczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuJG1pbkxpbmVzIDwgMHgxZmZmZmZmZmZmZmZmKSlcbiAgICAgICAgICAgICAgICB0aGlzLiRtaW5MaW5lcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4UGl4ZWxIZWlnaHQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAwXG4gICAgfSxcbiAgICBzY3JvbGxQYXN0RW5kOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFsID0gK3ZhbCB8fCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFBhc3RFbmQgPT0gdmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhc3RFbmQgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogMCxcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxuICAgIH0sXG4gICAgZml4ZWRXaWR0aEd1dHRlcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLiRmaXhlZFdpZHRoID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1c3RvbVNjcm9sbGJhcjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1c3RvbVNjcm9sbGJhcih2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB0aGVtZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5zZXRUaGVtZSh2YWwpOyB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJHRoZW1lSWQgfHwgdGhpcy50aGVtZTsgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBcIi4vdGhlbWUvdGV4dG1hdGVcIixcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxuICAgIH0sXG4gICAgaGFzQ3NzVHJhbnNmb3Jtczoge30sXG4gICAgdXNlVGV4dGFyZWFGb3JJTUU6IHtcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAhdXNlcmFnZW50LmlzTW9iaWxlICYmICF1c2VyYWdlbnQuaXNJRVxuICAgIH1cbn0pO1xuZXhwb3J0cy5WaXJ0dWFsUmVuZGVyZXIgPSBWaXJ0dWFsUmVuZGVyZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9uZXRcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IHJlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIG5ldCA9IHJlcXVpcmUoXCIuLi9saWIvbmV0XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxuZnVuY3Rpb24gJHdvcmtlckJsb2Iod29ya2VyVXJsKSB7XG4gICAgdmFyIHNjcmlwdCA9IFwiaW1wb3J0U2NyaXB0cygnXCIgKyBuZXQucXVhbGlmeVVSTCh3b3JrZXJVcmwpICsgXCInKTtcIjtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3NjcmlwdF0sIHtcInR5cGVcIjogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJ9KTtcbiAgICB9IGNhdGNoIChlKSB7IC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyO1xuICAgICAgICB2YXIgYmxvYkJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYkJ1aWxkZXIuYXBwZW5kKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih3b3JrZXJVcmwpIHtcbiAgICBpZiAodHlwZW9mIFdvcmtlciA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4geyBwb3N0TWVzc2FnZTogZnVuY3Rpb24oKSB7fSwgdGVybWluYXRlOiBmdW5jdGlvbigpIHt9IH07XG4gICAgaWYgKGNvbmZpZy5nZXQoXCJsb2FkV29ya2VyRnJvbUJsb2JcIikpIHtcbiAgICAgICAgdmFyIGJsb2IgPSAkd29ya2VyQmxvYih3b3JrZXJVcmwpO1xuICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICB2YXIgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKGJsb2JVUkwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xufVxuXG52YXIgV29ya2VyQ2xpZW50ID0gZnVuY3Rpb24od29ya2VyKSB7XG4gICAgaWYgKCF3b3JrZXIucG9zdE1lc3NhZ2UpXG4gICAgICAgIHdvcmtlciA9IHRoaXMuJGNyZWF0ZVdvcmtlckZyb21PbGRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuJHdvcmtlciA9IHdvcmtlcjtcbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IHRoaXMuY2hhbmdlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG5cbiAgICB0aGlzLiR3b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2U7XG59O1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMuJGNyZWF0ZVdvcmtlckZyb21PbGRDb25maWcgPSBmdW5jdGlvbih0b3BMZXZlbE5hbWVzcGFjZXMsIG1vZCwgY2xhc3NuYW1lLCB3b3JrZXJVcmwsIGltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgaWYgKHJlcXVpcmUubmFtZVRvVXJsICYmICFyZXF1aXJlLnRvVXJsKVxuICAgICAgICAgICAgcmVxdWlyZS50b1VybCA9IHJlcXVpcmUubmFtZVRvVXJsO1xuXG4gICAgICAgIGlmIChjb25maWcuZ2V0KFwicGFja2FnZWRcIikgfHwgIXJlcXVpcmUudG9VcmwpIHtcbiAgICAgICAgICAgIHdvcmtlclVybCA9IHdvcmtlclVybCB8fCBjb25maWcubW9kdWxlVXJsKG1vZCwgXCJ3b3JrZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplUGF0aCA9IHRoaXMuJG5vcm1hbGl6ZVBhdGg7XG4gICAgICAgICAgICB3b3JrZXJVcmwgPSB3b3JrZXJVcmwgfHwgbm9ybWFsaXplUGF0aChyZXF1aXJlLnRvVXJsKFwiYWNlL3dvcmtlci93b3JrZXIuanNcIiwgbnVsbCwgXCJfXCIpKTtcblxuICAgICAgICAgICAgdmFyIHRsbnMgPSB7fTtcbiAgICAgICAgICAgIHRvcExldmVsTmFtZXNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKG5zKSB7XG4gICAgICAgICAgICAgICAgdGxuc1tuc10gPSBub3JtYWxpemVQYXRoKHJlcXVpcmUudG9VcmwobnMsIG51bGwsIFwiX1wiKS5yZXBsYWNlKC8oXFwuanMpPyhcXD8uKik/JC8sIFwiXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kd29ya2VyID0gY3JlYXRlV29ya2VyKHdvcmtlclVybCk7XG4gICAgICAgIGlmIChpbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJpbXBvcnRTY3JpcHRzXCIsIGltcG9ydFNjcmlwdHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpbml0IDogdHJ1ZSxcbiAgICAgICAgICAgIHRsbnMgOiB0bG5zLFxuICAgICAgICAgICAgbW9kdWxlIDogbW9kLFxuICAgICAgICAgICAgY2xhc3NuYW1lIDogY2xhc3NuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy4kd29ya2VyO1xuICAgIH07XG5cbiAgICB0aGlzLm9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IGUuZGF0YTtcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKG1zZy5uYW1lLCB7ZGF0YTogbXNnLmRhdGF9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbbXNnLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbbXNnLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBtc2cuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIHRoaXMuJG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXQucXVhbGlmeVVSTChwYXRoKTtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXJtaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwidGVybWluYXRlXCIsIHt9KTtcbiAgICAgICAgdGhpcy5kZWx0YVF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLiR3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4kd29ya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuJGRvYylcbiAgICAgICAgICAgIHRoaXMuJGRvYy5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuJGRvYyA9IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGNtZCwgYXJncykge1xuICAgICAgICB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6IGNtZCwgYXJnczogYXJnc30pO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbihjbWQsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGFyZ3MucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kKGNtZCwgYXJncyk7XG4gICAgfTtcblxuICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5lcnIpXG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmVyciA9IHttZXNzYWdlOiBkYXRhLmRhdGEuZXJyLm1lc3NhZ2UsIHN0YWNrOiBkYXRhLmRhdGEuZXJyLnN0YWNrLCBjb2RlOiBkYXRhLmRhdGEuZXJyLmNvZGV9O1xuICAgICAgICAgICAgICAgIHRoaXMuJHdvcmtlciAmJiB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldmVudCwgZGF0YToge2RhdGE6IGRhdGEuZGF0YX19KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChleCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hdHRhY2hUb0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLiRkb2MpXG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgIHRoaXMuJGRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jYWxsKFwic2V0VmFsdWVcIiwgW2RvYy5nZXRWYWx1ZSgpXSk7XG4gICAgICAgIGRvYy5vbihcImNoYW5nZVwiLCB0aGlzLmNoYW5nZUxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWx0YVF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy4kc2VuZERlbHRhUXVldWUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRcIilcbiAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGRlbHRhLnN0YXJ0LCBkZWx0YS5saW5lcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGRlbHRhLnN0YXJ0LCBkZWx0YS5lbmQpO1xuICAgIH07XG5cbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcSA9IHRoaXMuZGVsdGFRdWV1ZTtcbiAgICAgICAgaWYgKCFxKSByZXR1cm47XG4gICAgICAgIHRoaXMuZGVsdGFRdWV1ZSA9IG51bGw7XG4gICAgICAgIGlmIChxLmxlbmd0aCA+IDUwICYmIHEubGVuZ3RoID4gdGhpcy4kZG9jLmdldExlbmd0aCgpID4+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbChcInNldFZhbHVlXCIsIFt0aGlzLiRkb2MuZ2V0VmFsdWUoKV0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7ZGF0YTogcX0pO1xuICAgIH07XG5cbn0pLmNhbGwoV29ya2VyQ2xpZW50LnByb3RvdHlwZSk7XG5cblxudmFyIFVJV29ya2VyQ2xpZW50ID0gZnVuY3Rpb24odG9wTGV2ZWxOYW1lc3BhY2VzLCBtb2QsIGNsYXNzbmFtZSkge1xuICAgIHZhciBtYWluID0gbnVsbDtcbiAgICB2YXIgZW1pdFN5bmMgPSBmYWxzZTtcbiAgICB2YXIgc2VuZGVyID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIpO1xuXG4gICAgdmFyIG1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICB2YXIgd29ya2VyQ2xpZW50ID0gbmV3IFdvcmtlckNsaWVudCh7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXI6IG1lc3NhZ2VCdWZmZXIsXG4gICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIucHVzaChlKTtcbiAgICAgICAgICAgIGlmICghbWFpbikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVtaXRTeW5jKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocHJvY2Vzc05leHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHdvcmtlckNsaWVudC5zZXRFbWl0U3luYyA9IGZ1bmN0aW9uKHZhbCkgeyBlbWl0U3luYyA9IHZhbDsgfTtcblxuICAgIHZhciBwcm9jZXNzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICBpZiAobXNnLmNvbW1hbmQpXG4gICAgICAgICAgICBtYWluW21zZy5jb21tYW5kXS5hcHBseShtYWluLCBtc2cuYXJncyk7XG4gICAgICAgIGVsc2UgaWYgKG1zZy5ldmVudClcbiAgICAgICAgICAgIHNlbmRlci5fc2lnbmFsKG1zZy5ldmVudCwgbXNnLmRhdGEpO1xuICAgIH07XG5cbiAgICBzZW5kZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgd29ya2VyQ2xpZW50Lm9uTWVzc2FnZSh7ZGF0YTogbXNnfSk7XG4gICAgfTtcbiAgICBzZW5kZXIuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFja0lkKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiY2FsbFwiLCBpZDogY2FsbGJhY2tJZCwgZGF0YTogZGF0YX0pO1xuICAgIH07XG4gICAgc2VuZGVyLmVtaXQgPSBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiZXZlbnRcIiwgbmFtZTogbmFtZSwgZGF0YTogZGF0YX0pO1xuICAgIH07XG5cbiAgICBjb25maWcubG9hZE1vZHVsZShbXCJ3b3JrZXJcIiwgbW9kXSwgZnVuY3Rpb24oTWFpbikge1xuICAgICAgICBtYWluID0gbmV3IE1haW5bY2xhc3NuYW1lXShzZW5kZXIpO1xuICAgICAgICB3aGlsZSAobWVzc2FnZUJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHdvcmtlckNsaWVudDtcbn07XG5cbmV4cG9ydHMuVUlXb3JrZXJDbGllbnQgPSBVSVdvcmtlckNsaWVudDtcbmV4cG9ydHMuV29ya2VyQ2xpZW50ID0gV29ya2VyQ2xpZW50O1xuZXhwb3J0cy5jcmVhdGVXb3JrZXIgPSBjcmVhdGVXb3JrZXI7XG5cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcGxhY2Vob2xkZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvbGliL29vcFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBvb3AgPSByZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIFBsYWNlSG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlSG9sZGVyKHNlc3Npb24sIGxlbmd0aCwgcG9zLCBvdGhlcnMsIG1haW5DbGFzcywgb3RoZXJzQ2xhc3MpIHtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZG9jID0gc2Vzc2lvbi5nZXREb2N1bWVudCgpO1xuICAgICAgICB0aGlzLm1haW5DbGFzcyA9IG1haW5DbGFzcztcbiAgICAgICAgdGhpcy5vdGhlcnNDbGFzcyA9IG90aGVyc0NsYXNzO1xuICAgICAgICB0aGlzLiRvblVwZGF0ZSA9IHRoaXMub25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2Mub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25VcGRhdGUsIHRydWUpO1xuICAgICAgICB0aGlzLiRvdGhlcnMgPSBvdGhlcnM7XG4gICAgICAgIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYub25DdXJzb3JDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRwb3MgPSBwb3M7XG4gICAgICAgIHZhciB1bmRvU3RhY2sgPSBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9TdGFjayB8fCBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKClbXCIkdW5kb3N0YWNrXCJdIHx8IHsgbGVuZ3RoOiAtMSB9O1xuICAgICAgICB0aGlzLiR1bmRvU3RhY2tEZXB0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24ub24oXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgIH1cbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQmVmb3JlID0gc2Vzc2lvbi5zZWxlY3Rpb24udG9KU09OKCk7XG4gICAgICAgIGlmIChzZXNzaW9uLnNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSlcbiAgICAgICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBkb2MuY3JlYXRlQW5jaG9yKHRoaXMuJHBvcy5yb3csIHRoaXMuJHBvcy5jb2x1bW4pO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHBvcy4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuICAgICAgICBwb3MuZGV0YWNoKCk7XG4gICAgICAgIHBvcy5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgdGhpcy5sZW5ndGgpLCB0aGlzLm1haW5DbGFzcywgbnVsbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLm90aGVycyA9IFtdO1xuICAgICAgICB0aGlzLiRvdGhlcnMuZm9yRWFjaChmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2MuY3JlYXRlQW5jaG9yKG90aGVyLnJvdywgb3RoZXIuY29sdW1uKTtcbiAgICAgICAgICAgIGFuY2hvci4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgYW5jaG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgX3NlbGYub3RoZXJzLnB1c2goYW5jaG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24uc2V0VW5kb1NlbGVjdChmYWxzZSk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuc2hvd090aGVyTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3RoZXJzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vdGhlcnNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm90aGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvci5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShhbmNob3Iucm93LCBhbmNob3IuY29sdW1uLCBhbmNob3Iucm93LCBhbmNob3IuY29sdW1uICsgX3NlbGYubGVuZ3RoKSwgX3NlbGYub3RoZXJzQ2xhc3MsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuaGlkZU90aGVyTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm90aGVyc0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vdGhlcnNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm90aGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcih0aGlzLm90aGVyc1tpXS5tYXJrZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVBbmNob3JzKGRlbHRhKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGE7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgIT09IHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgIT09IHRoaXMucG9zLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgbGVuZ3RoRGlmZiA9IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHJhbmdlLmVuZC5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW4gOiByYW5nZS5zdGFydC5jb2x1bW4gLSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB2YXIgaW5NYWluUmFuZ2UgPSByYW5nZS5zdGFydC5jb2x1bW4gPj0gdGhpcy5wb3MuY29sdW1uICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiA8PSB0aGlzLnBvcy5jb2x1bW4gKyB0aGlzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21TdGFydCA9IHJhbmdlLnN0YXJ0LmNvbHVtbiAtIHRoaXMucG9zLmNvbHVtbjtcbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3JzKGRlbHRhKTtcbiAgICAgICAgaWYgKGluTWFpblJhbmdlKVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gbGVuZ3RoRGlmZjtcbiAgICAgICAgaWYgKGluTWFpblJhbmdlICYmICF0aGlzLnNlc3Npb24uJGZyb21VbmRvKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm90aGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHsgcm93OiBvdGhlclBvcy5yb3csIGNvbHVtbjogb3RoZXJQb3MuY29sdW1uICsgZGlzdGFuY2VGcm9tU3RhcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuaW5zZXJ0TWVyZ2VkTGluZXMobmV3UG9zLCBkZWx0YS5saW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm90aGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHsgcm93OiBvdGhlclBvcy5yb3csIGNvbHVtbjogb3RoZXJQb3MuY29sdW1uICsgZGlzdGFuY2VGcm9tU3RhcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MucmVtb3ZlKG5ldyBSYW5nZShuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uLCBuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uIC0gbGVuZ3RoRGlmZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR1cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS51cGRhdGVBbmNob3JzID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMucG9zLm9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMub3RoZXJzLmxlbmd0aDsgaS0tOylcbiAgICAgICAgICAgIHRoaXMub3RoZXJzW2ldLm9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUudXBkYXRlTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHVwZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHVwZGF0ZU1hcmtlciA9IGZ1bmN0aW9uIChwb3MsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIocG9zLm1hcmtlcklkKTtcbiAgICAgICAgICAgIHBvcy5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgX3NlbGYubGVuZ3RoKSwgY2xhc3NOYW1lLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZU1hcmtlcih0aGlzLnBvcywgdGhpcy5tYWluQ2xhc3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoOyBpLS07KVxuICAgICAgICAgICAgdXBkYXRlTWFya2VyKHRoaXMub3RoZXJzW2ldLCB0aGlzLm90aGVyc0NsYXNzKTtcbiAgICB9O1xuICAgIFBsYWNlSG9sZGVyLnByb3RvdHlwZS5vbkN1cnNvckNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmcgfHwgIXRoaXMuc2Vzc2lvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChwb3Mucm93ID09PSB0aGlzLnBvcy5yb3cgJiYgcG9zLmNvbHVtbiA+PSB0aGlzLnBvcy5jb2x1bW4gJiYgcG9zLmNvbHVtbiA8PSB0aGlzLnBvcy5jb2x1bW4gKyB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaG93T3RoZXJNYXJrZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY3Vyc29yRW50ZXJcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlT3RoZXJNYXJrZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY3Vyc29yTGVhdmVcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlTWFya2VyKHRoaXMucG9zICYmIHRoaXMucG9zLm1hcmtlcklkKTtcbiAgICAgICAgdGhpcy5oaWRlT3RoZXJNYXJrZXJzKCk7XG4gICAgICAgIHRoaXMuZG9jLm9mZihcImNoYW5nZVwiLCB0aGlzLiRvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24ub2ZmKFwiY2hhbmdlQ3Vyc29yXCIsIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNldFVuZG9TZWxlY3QodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgfTtcbiAgICBQbGFjZUhvbGRlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy4kdW5kb1N0YWNrRGVwdGggPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdW5kb01hbmFnZXIgPSB0aGlzLnNlc3Npb24uZ2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgdmFyIHVuZG9zUmVxdWlyZWQgPSAodW5kb01hbmFnZXIuJHVuZG9TdGFjayB8fCB1bmRvTWFuYWdlcltcIiR1bmRvc3RhY2tcIl0pLmxlbmd0aCAtIHRoaXMuJHVuZG9TdGFja0RlcHRoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZG9zUmVxdWlyZWQ7IGkrKykge1xuICAgICAgICAgICAgdW5kb01hbmFnZXIudW5kbyh0aGlzLnNlc3Npb24sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkJlZm9yZSlcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZnJvbUpTT04odGhpcy5zZWxlY3Rpb25CZWZvcmUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlSG9sZGVyO1xufSgpKTtcbm9vcC5pbXBsZW1lbnQoUGxhY2VIb2xkZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5QbGFjZUhvbGRlciA9IFBsYWNlSG9sZGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7dmFyIGV2ZW50ID0gcmVxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciB1c2VyYWdlbnQgPSByZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbmZ1bmN0aW9uIGlzU2FtZVBvaW50KHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgPT0gcDIucm93ICYmIHAxLmNvbHVtbiA9PSBwMi5jb2x1bW47XG59XG5mdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgdmFyIGV2ID0gZS5kb21FdmVudDtcbiAgICB2YXIgYWx0ID0gZXYuYWx0S2V5O1xuICAgIHZhciBzaGlmdCA9IGV2LnNoaWZ0S2V5O1xuICAgIHZhciBjdHJsID0gZXYuY3RybEtleTtcbiAgICB2YXIgYWNjZWwgPSBlLmdldEFjY2VsS2V5KCk7XG4gICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XG4gICAgaWYgKGN0cmwgJiYgdXNlcmFnZW50LmlzTWFjKVxuICAgICAgICBidXR0b24gPSBldi5idXR0b247XG4gICAgaWYgKGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlICYmIGJ1dHRvbiA9PSAyKSB7XG4gICAgICAgIGUuZWRpdG9yLnRleHRJbnB1dC5vbkNvbnRleHRNZW51KGUuZG9tRXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3RybCAmJiAhYWx0ICYmICFhY2NlbCkge1xuICAgICAgICBpZiAoYnV0dG9uID09PSAwICYmIGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgZS5lZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidXR0b24gIT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIGlzTXVsdGlTZWxlY3QgPSBlZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGU7XG4gICAgdmFyIHBvcyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgIHZhciBjdXJzb3IgPSBzZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgdmFyIGluU2VsZWN0aW9uID0gZS5pblNlbGVjdGlvbigpIHx8IChzZWxlY3Rpb24uaXNFbXB0eSgpICYmIGlzU2FtZVBvaW50KHBvcywgY3Vyc29yKSk7XG4gICAgdmFyIG1vdXNlWCA9IGUueCwgbW91c2VZID0gZS55O1xuICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgICAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgfTtcbiAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgIHZhciBzY3JlZW5BbmNob3IgPSBlZGl0b3IucmVuZGVyZXIucGl4ZWxUb1NjcmVlbkNvb3JkaW5hdGVzKG1vdXNlWCwgbW91c2VZKTtcbiAgICB2YXIgc2NyZWVuQ3Vyc29yID0gc2NyZWVuQW5jaG9yO1xuICAgIHZhciBzZWxlY3Rpb25Nb2RlO1xuICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci4kZW5hYmxlSnVtcFRvRGVmKSB7XG4gICAgICAgIGlmIChjdHJsICYmIGFsdCB8fCBhY2NlbCAmJiBhbHQpXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gc2hpZnQgPyBcImJsb2NrXCIgOiBcImFkZFwiO1xuICAgICAgICBlbHNlIGlmIChhbHQgJiYgZWRpdG9yLiRibG9ja1NlbGVjdEVuYWJsZWQpXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gXCJibG9ja1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFjY2VsICYmICFhbHQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUgPSBcImFkZFwiO1xuICAgICAgICAgICAgaWYgKCFpc011bHRpU2VsZWN0ICYmIHNoaWZ0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbHQgJiYgZWRpdG9yLiRibG9ja1NlbGVjdEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbk1vZGUgJiYgdXNlcmFnZW50LmlzTWFjICYmIGV2LmN0cmxLZXkpIHtcbiAgICAgICAgZWRpdG9yLiRtb3VzZUhhbmRsZXIuY2FuY2VsQ29udGV4dE1lbnUoKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gXCJhZGRcIikge1xuICAgICAgICBpZiAoIWlzTXVsdGlTZWxlY3QgJiYgaW5TZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47IC8vIGRyYWdnaW5nXG4gICAgICAgIGlmICghaXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgZWRpdG9yLmFkZFNlbGVjdGlvbk1hcmtlcihyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFJhbmdlID0gc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZUF0UG9pbnQocG9zKTtcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgIG9sZFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLnJhbmdlc1swXSB8fCByYW5nZTtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5vbmNlKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG1wU2VsID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKG9sZFJhbmdlICYmIHRtcFNlbC5pc0VtcHR5KCkgJiYgaXNTYW1lUG9pbnQob2xkUmFuZ2UuY3Vyc29yLCB0bXBTZWwuY3Vyc29yKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc3Vic3RyYWN0UG9pbnQodG1wU2VsLmN1cnNvcik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnN1YnN0cmFjdFBvaW50KHJhbmdlLmN1cnNvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UodG1wU2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiYmxvY2tcIikge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgaW5pdGlhbFJhbmdlO1xuICAgICAgICB2YXIgcmVjdFNlbCA9IFtdO1xuICAgICAgICB2YXIgYmxvY2tTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q3Vyc29yID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcyhtb3VzZVgsIG1vdXNlWSk7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24obmV3Q3Vyc29yLnJvdywgbmV3Q3Vyc29yLmNvbHVtbiwgbmV3Q3Vyc29yLm9mZnNldFgpO1xuICAgICAgICAgICAgaWYgKGlzU2FtZVBvaW50KHNjcmVlbkN1cnNvciwgbmV3Q3Vyc29yKSAmJiBpc1NhbWVQb2ludChjdXJzb3IsIHNlbGVjdGlvbi5sZWFkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzY3JlZW5DdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKGN1cnNvcik7XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzKHJlY3RTZWwpO1xuICAgICAgICAgICAgcmVjdFNlbCA9IHNlbGVjdGlvbi5yZWN0YW5ndWxhclJhbmdlQmxvY2soc2NyZWVuQ3Vyc29yLCBzY3JlZW5BbmNob3IpO1xuICAgICAgICAgICAgaWYgKGVkaXRvci4kbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbiAmJiByZWN0U2VsLmxlbmd0aCA9PSAxICYmIHJlY3RTZWxbMF0uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHJlY3RTZWxbMF0gPSBlZGl0b3IuJG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHJlY3RTZWwuZm9yRWFjaChlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZVNlbGVjdGlvbk1hcmtlcnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzTXVsdGlTZWxlY3QgJiYgIWFjY2VsKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24udG9TaW5nbGVSYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc011bHRpU2VsZWN0ICYmIGFjY2VsKSB7XG4gICAgICAgICAgICBpbml0aWFsUmFuZ2UgPSBzZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgICAgICBlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyKGluaXRpYWxSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoaWZ0KVxuICAgICAgICAgICAgc2NyZWVuQW5jaG9yID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oc2VsZWN0aW9uLmxlYWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgc2NyZWVuQ3Vyc29yID0geyByb3c6IC0xLCBjb2x1bW46IC0xIH07XG4gICAgICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0KCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMocmVjdFNlbCk7XG4gICAgICAgICAgICBpZiAoIXJlY3RTZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlY3RTZWwgPSBbc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpXTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlU2VsZWN0aW9uTWFya2VyKGluaXRpYWxSYW5nZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoaW5pdGlhbFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdFNlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmVjdFNlbFtpXSk7XG4gICAgICAgICAgICBlZGl0b3IuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgZWRpdG9yLiRtb3VzZUhhbmRsZXIuJGNsaWNrU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU2VsZWN0aW9uSW50ZXJ2YWwgPSBibG9ja1NlbGVjdDtcbiAgICAgICAgZXZlbnQuY2FwdHVyZShlZGl0b3IuY29udGFpbmVyLCBvbk1vdXNlU2VsZWN0aW9uLCBvbk1vdXNlU2VsZWN0aW9uRW5kKTtcbiAgICAgICAgdmFyIHRpbWVySWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IG9uU2VsZWN0aW9uSW50ZXJ2YWwoKTsgfSwgMjApO1xuICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMub25Nb3VzZURvd24gPSBvbk1vdXNlRG93bjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvY29tbWFuZHMvbXVsdGlfc2VsZWN0X2NvbW1hbmRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8qKlxuICogY29tbWFuZHMgdG8gZW50ZXIgbXVsdGlzZWxlY3QgbW9kZVxuICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2FjZS1pbnRlcm5hbFwiKS5BY2UuQ29tbWFuZFtdfVxuICovXG5leHBvcnRzLmRlZmF1bHRDb21tYW5kcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQWJvdmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkIGN1cnNvciBhYm92ZVwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoLTEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1VcFwiLCBtYWM6IFwiQ3RybC1BbHQtVXBcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQmVsb3dcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkIGN1cnNvciBiZWxvd1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoMSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LURvd25cIiwgbWFjOiBcIkN0cmwtQWx0LURvd25cIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYWRkQ3Vyc29yQWJvdmVTa2lwQ3VycmVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBZGQgY3Vyc29yIGFib3ZlIChza2lwIGN1cnJlbnQpXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmVMaW5lcygtMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LVVwXCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1VcFwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhZGRDdXJzb3JCZWxvd1NraXBDdXJyZW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFkZCBjdXJzb3IgYmVsb3cgKHNraXAgY3VycmVudClcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKDEsIHRydWUpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1TaGlmdC1Eb3duXCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1Eb3duXCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdE1vcmVCZWZvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VsZWN0IG1vcmUgYmVmb3JlXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoLTEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1MZWZ0XCIsIG1hYzogXCJDdHJsLUFsdC1MZWZ0XCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlbGVjdE1vcmVBZnRlclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbW9yZSBhZnRlclwiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlKDEpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1SaWdodFwiLCBtYWM6IFwiQ3RybC1BbHQtUmlnaHRcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0TmV4dEJlZm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWxlY3QgbmV4dCBiZWZvcmVcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZSgtMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LUxlZnRcIiwgbWFjOiBcIkN0cmwtQWx0LVNoaWZ0LUxlZnRcIiB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0TmV4dEFmdGVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbGVjdCBuZXh0IGFmdGVyXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoMSwgdHJ1ZSk7IH0sXG4gICAgICAgIGJpbmRLZXk6IHsgd2luOiBcIkN0cmwtQWx0LVNoaWZ0LVJpZ2h0XCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1SaWdodFwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJ0b2dnbGVTcGxpdFNlbGVjdGlvbkludG9MaW5lc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTcGxpdCBzZWxlY3Rpb24gaW50byBsaW5lc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLm11bHRpU2VsZWN0LnJhbmdlQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5qb2luU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5zcGxpdEludG9MaW5lcygpO1xuICAgICAgICB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1MXCIsIG1hYzogXCJDdHJsLUFsdC1MXCIgfSxcbiAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwic3BsaXRTZWxlY3Rpb25JbnRvTGluZXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3BsaXQgaW50byBsaW5lc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5tdWx0aVNlbGVjdC5zcGxpdEludG9MaW5lcygpOyB9LFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhbGlnbkN1cnNvcnNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWxpZ24gY3Vyc29yc1wiLFxuICAgICAgICBleGVjOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5hbGlnbkN1cnNvcnMoKTsgfSxcbiAgICAgICAgYmluZEtleTogeyB3aW46IFwiQ3RybC1BbHQtQVwiLCBtYWM6IFwiQ3RybC1BbHQtQVwiIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG4gICAgfSwge1xuICAgICAgICBuYW1lOiBcImZpbmRBbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmluZCBhbGxcIixcbiAgICAgICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuZmluZEFsbCgpOyB9LFxuICAgICAgICBiaW5kS2V5OiB7IHdpbjogXCJDdHJsLUFsdC1LXCIsIG1hYzogXCJDdHJsLUFsdC1HXCIgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfV07XG5leHBvcnRzLm11bHRpU2VsZWN0Q29tbWFuZHMgPSBbe1xuICAgICAgICBuYW1lOiBcInNpbmdsZVNlbGVjdGlvblwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTaW5nbGUgc2VsZWN0aW9uXCIsXG4gICAgICAgIGJpbmRLZXk6IFwiZXNjXCIsXG4gICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTsgfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24gKGVkaXRvcikgeyByZXR1cm4gZWRpdG9yICYmIGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZTsgfVxuICAgIH1dO1xudmFyIEhhc2hIYW5kbGVyID0gcmVxdWlyZShcIi4uL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiKS5IYXNoSGFuZGxlcjtcbmV4cG9ydHMua2V5Ym9hcmRIYW5kbGVyID0gbmV3IEhhc2hIYW5kbGVyKGV4cG9ydHMubXVsdGlTZWxlY3RDb21tYW5kcyk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL211bHRpX3NlbGVjdFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlX2xpc3RcIixcImFjZS9yYW5nZVwiLFwiYWNlL3NlbGVjdGlvblwiLFwiYWNlL21vdXNlL211bHRpX3NlbGVjdF9oYW5kbGVyXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIixcImFjZS9zZWFyY2hcIixcImFjZS9lZGl0X3Nlc3Npb25cIixcImFjZS9lZGl0b3JcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7LyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9hbmNob3JcIikuQW5jaG9yfSBBbmNob3JcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9hY2UtaW50ZXJuYWxcIikuQWNlLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL2FjZS1pbnRlcm5hbFwiKS5BY2UuU2NyZWVuQ29vcmRpbmF0ZXN9IFNjcmVlbkNvb3JkaW5hdGVzXG4gKi9cbnZhciBSYW5nZUxpc3QgPSByZXF1aXJlKFwiLi9yYW5nZV9saXN0XCIpLlJhbmdlTGlzdDtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvblwiKS5TZWxlY3Rpb247XG52YXIgb25Nb3VzZURvd24gPSByZXF1aXJlKFwiLi9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiKS5vbk1vdXNlRG93bjtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgY29tbWFuZHMgPSByZXF1aXJlKFwiLi9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIik7XG5leHBvcnRzLmNvbW1hbmRzID0gY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzLmNvbmNhdChjb21tYW5kcy5tdWx0aVNlbGVjdENvbW1hbmRzKTtcbnZhciBTZWFyY2ggPSByZXF1aXJlKFwiLi9zZWFyY2hcIikuU2VhcmNoO1xudmFyIHNlYXJjaCA9IG5ldyBTZWFyY2goKTtcbmZ1bmN0aW9uIGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpIHtcbiAgICBzZWFyY2guJG9wdGlvbnMud3JhcCA9IHRydWU7XG4gICAgc2VhcmNoLiRvcHRpb25zLm5lZWRsZSA9IG5lZWRsZTtcbiAgICBzZWFyY2guJG9wdGlvbnMuYmFja3dhcmRzID0gZGlyID09IC0xO1xuICAgIHJldHVybiBzZWFyY2guZmluZChzZXNzaW9uKTtcbn1cbnZhciBFZGl0U2Vzc2lvbiA9IHJlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvblwiKS5FZGl0U2Vzc2lvbjtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0aW9uTWFya2VycztcbiAgICB9O1xufSkuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJhbmdlcyA9IG51bGw7XG4gICAgdGhpcy5yYW5nZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsICRibG9ja0NoYW5nZUV2ZW50cykge1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgdGhpcy5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgb2xkUmFuZ2UgPSB0aGlzLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKG9sZFJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QucmFuZ2VzLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRibG9ja0NoYW5nZUV2ZW50cyB8fCB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKG9sZFJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuJG9uQWRkUmFuZ2Uob2xkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UuY3Vyc29yKVxuICAgICAgICAgICAgcmFuZ2UuY3Vyc29yID0gcmFuZ2UuZW5kO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XG4gICAgICAgIHRoaXMuJG9uQWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID4gMSAmJiAhdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwibXVsdGlTZWxlY3RcIik7XG4gICAgICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYXR0YWNoKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRibG9ja0NoYW5nZUV2ZW50cyB8fCB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMudG9TaW5nbGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByYW5nZSA9IHJhbmdlIHx8IHRoaXMucmFuZ2VzWzBdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuICAgICAgICByYW5nZSAmJiB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic3RyYWN0UG9pbnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yYW5nZUxpc3Quc3Vic3RyYWN0UG9pbnQocG9zKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZFswXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZXJnZU92ZXJsYXBwaW5nUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0Lm1lcmdlKCk7XG4gICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XG4gICAgfTtcbiAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMucmFuZ2VzLnVuc2hpZnQocmFuZ2UpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZGRSYW5nZVwiLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICB9O1xuICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAocmVtb3ZlZCkge1xuICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IDEgJiYgdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5wb3AoKTtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChsYXN0UmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMucmFuZ2VzLmluZGV4T2YocmVtb3ZlZFtpXSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInJlbW92ZVJhbmdlXCIsIHsgcmFuZ2VzOiByZW1vdmVkIH0pO1xuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09PSAwICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcInNpbmdsZVNlbGVjdFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5kZXRhY2godGhpcy5zZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmFuZ2UgPSBsYXN0UmFuZ2UgfHwgdGhpcy5yYW5nZXNbMF07XG4gICAgICAgIGlmIChsYXN0UmFuZ2UgJiYgIWxhc3RSYW5nZS5pc0VxdWFsKHRoaXMuZ2V0UmFuZ2UoKSkpXG4gICAgICAgICAgICB0aGlzLmZyb21PcmllbnRlZFJhbmdlKGxhc3RSYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLiRpbml0UmFuZ2VMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmFuZ2VMaXN0ID0gbmV3IFJhbmdlTGlzdCgpO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRBbGxSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlQ291bnQgPyB0aGlzLnJhbmdlTGlzdC5yYW5nZXMuY29uY2F0KCkgOiBbdGhpcy5nZXRSYW5nZSgpXTtcbiAgICB9O1xuICAgIHRoaXMuc3BsaXRJbnRvTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcy5sZW5ndGggPyB0aGlzLnJhbmdlcyA6IFt0aGlzLmdldFJhbmdlKCldO1xuICAgICAgICB2YXIgbmV3UmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICB2YXIgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJhbmdlLmVuZC5yb3c7XG4gICAgICAgICAgICBpZiAocm93ID09PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChyYW5nZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ldyBSYW5nZShyb3csIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcm93LCB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3cpLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK3JvdyA8IGVuZFJvdylcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2godGhpcy5nZXRMaW5lUmFuZ2Uocm93LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKGVuZFJvdywgMCwgZW5kUm93LCByYW5nZS5lbmQuY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSAwICYmICF0aGlzLmlzQmFja3dhcmRzKCkpXG4gICAgICAgICAgICAgICAgbmV3UmFuZ2VzID0gbmV3UmFuZ2VzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5ld1Jhbmdlcy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICB0aGlzLmFkZFJhbmdlKG5ld1Jhbmdlc1tpXSk7XG4gICAgfTtcbiAgICB0aGlzLmpvaW5TZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICB2YXIgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZXNbMF0uc3RhcnQsIGxhc3RSYW5nZS5lbmQpO1xuICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgbGFzdFJhbmdlLmN1cnNvciA9PSBsYXN0UmFuZ2Uuc3RhcnQpO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGVCbG9ja1NlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCBsYXN0UmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHRoaXMudG9TaW5nbGVSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgbGFzdFJhbmdlLmN1cnNvciA9PSBsYXN0UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5jdXJzb3IpO1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5hbmNob3IpO1xuICAgICAgICAgICAgdmFyIHJlY3RTZWwgPSB0aGlzLnJlY3Rhbmd1bGFyUmFuZ2VCbG9jayhjdXJzb3IsIGFuY2hvcik7XG4gICAgICAgICAgICByZWN0U2VsLmZvckVhY2godGhpcy5hZGRSYW5nZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVjdGFuZ3VsYXJSYW5nZUJsb2NrID0gZnVuY3Rpb24gKHNjcmVlbkN1cnNvciwgc2NyZWVuQW5jaG9yLCBpbmNsdWRlRW1wdHlMaW5lcykge1xuICAgICAgICB2YXIgcmVjdFNlbCA9IFtdO1xuICAgICAgICB2YXIgeEJhY2t3YXJkcyA9IHNjcmVlbkN1cnNvci5jb2x1bW4gPCBzY3JlZW5BbmNob3IuY29sdW1uO1xuICAgICAgICBpZiAoeEJhY2t3YXJkcykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gc2NyZWVuQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBlbmRDb2x1bW4gPSBzY3JlZW5BbmNob3IuY29sdW1uO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0WCA9IHNjcmVlbkN1cnNvci5vZmZzZXRYO1xuICAgICAgICAgICAgdmFyIGVuZE9mZnNldFggPSBzY3JlZW5BbmNob3Iub2Zmc2V0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IHNjcmVlbkFuY2hvci5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2NyZWVuQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldFggPSBzY3JlZW5BbmNob3Iub2Zmc2V0WDtcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXRYID0gc2NyZWVuQ3Vyc29yLm9mZnNldFg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlCYWNrd2FyZHMgPSBzY3JlZW5DdXJzb3Iucm93IDwgc2NyZWVuQW5jaG9yLnJvdztcbiAgICAgICAgaWYgKHlCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IHNjcmVlbkN1cnNvci5yb3c7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQW5jaG9yLnJvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IHNjcmVlbkFuY2hvci5yb3c7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQ3Vyc29yLnJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPCAwKVxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoc3RhcnRSb3cgPCAwKVxuICAgICAgICAgICAgc3RhcnRSb3cgPSAwO1xuICAgICAgICBpZiAoc3RhcnRSb3cgPT0gZW5kUm93KVxuICAgICAgICAgICAgaW5jbHVkZUVtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgZG9jRW5kO1xuICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDw9IGVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHModGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihyb3csIHN0YXJ0Q29sdW1uLCBzdGFydE9mZnNldFgpLCB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHJvdywgZW5kQ29sdW1uLCBlbmRPZmZzZXRYKSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY0VuZCAmJiBpc1NhbWVQb2ludChyYW5nZS5lbmQsIGRvY0VuZCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRvY0VuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHhCYWNrd2FyZHMgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHJlY3RTZWwucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlCYWNrd2FyZHMpXG4gICAgICAgICAgICByZWN0U2VsLnJldmVyc2UoKTtcbiAgICAgICAgaWYgKCFpbmNsdWRlRW1wdHlMaW5lcykge1xuICAgICAgICAgICAgdmFyIGVuZCA9IHJlY3RTZWwubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChyZWN0U2VsW2VuZF0uaXNFbXB0eSgpICYmIGVuZCA+IDApXG4gICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICBpZiAoZW5kID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlY3RTZWxbc3RhcnRdLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbmQ7IGkgPj0gc3RhcnQ7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0U2VsW2ldLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgcmVjdFNlbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RTZWw7XG4gICAgfTtcbn0pLmNhbGwoU2VsZWN0aW9uLnByb3RvdHlwZSk7XG52YXIgRWRpdG9yID0gcmVxdWlyZShcIi4vZWRpdG9yXCIpLkVkaXRvcjtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZFNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uIChvcmllbnRlZFJhbmdlKSB7XG4gICAgICAgIGlmICghb3JpZW50ZWRSYW5nZS5jdXJzb3IpXG4gICAgICAgICAgICBvcmllbnRlZFJhbmdlLmN1cnNvciA9IG9yaWVudGVkUmFuZ2UuZW5kO1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlKCk7XG4gICAgICAgIG9yaWVudGVkUmFuZ2UubWFya2VyID0gdGhpcy5zZXNzaW9uLmFkZE1hcmtlcihvcmllbnRlZFJhbmdlLCBcImFjZV9zZWxlY3Rpb25cIiwgc3R5bGUpO1xuICAgICAgICB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMucHVzaChvcmllbnRlZFJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9yaWVudGVkUmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAoIXJhbmdlLm1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMuaW5kZXhPZihyYW5nZSk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSlcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2VsZWN0aW9uTWFya2VyQ291bnQgPSB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMubGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24gKHJhbmdlcykge1xuICAgICAgICB2YXIgbWFya2VyTGlzdCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UubWFya2VyKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbWFya2VyTGlzdC5pbmRleE9mKHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSlcbiAgICAgICAgICAgICAgICBtYXJrZXJMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gbWFya2VyTGlzdC5sZW5ndGg7XG4gICAgfTtcbiAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5hZGRTZWxlY3Rpb25NYXJrZXIoZS5yYW5nZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcbiAgICB9O1xuICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMoZS5yYW5nZXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLiRvbk11bHRpU2VsZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0eWxlKFwiYWNlX211bHRpc2VsZWN0XCIpO1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKGNvbW1hbmRzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuc2V0RGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgIH07XG4gICAgdGhpcy4kb25TaW5nbGVTZWxlY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLm11bHRpU2VsZWN0LmluVmlydHVhbE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnNldFN0eWxlKFwiYWNlX211bHRpc2VsZWN0XCIpO1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGNvbW1hbmRzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlRGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgIH07XG4gICAgdGhpcy4kb25NdWx0aVNlbGVjdEV4ZWMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGUuY29tbWFuZDtcbiAgICAgICAgdmFyIGVkaXRvciA9IGUuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvci5tdWx0aVNlbGVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbWFuZC5leGVjKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcbiAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5hZGRSYW5nZShlZGl0b3IubXVsdGlTZWxlY3QudG9PcmllbnRlZFJhbmdlKCkpO1xuICAgICAgICAgICAgZWRpdG9yLm11bHRpU2VsZWN0Lm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uID09IFwiZm9yRWFjaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihjb21tYW5kLCBlLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXCJmb3JFYWNoTGluZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihjb21tYW5kLCBlLmFyZ3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbW1hbmQuZXhlYyhlZGl0b3IsIGUuYXJncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kLm11bHRpU2VsZWN0QWN0aW9uKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdGhpcy5mb3JFYWNoU2VsZWN0aW9uID0gZnVuY3Rpb24gKGNtZCwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2VlcE9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmtlZXBPcmRlcjtcbiAgICAgICAgdmFyICRieUxpbmVzID0gb3B0aW9ucyA9PSB0cnVlIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy4kYnlMaW5lcztcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHJhbmdlTGlzdCA9IHNlbGVjdGlvbi5yYW5nZUxpc3Q7XG4gICAgICAgIHZhciByYW5nZXMgPSAoa2VlcE9yZGVyID8gc2VsZWN0aW9uIDogcmFuZ2VMaXN0KS5yYW5nZXM7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBjbWQuZXhlYyA/IGNtZC5leGVjKHRoaXMsIGFyZ3MgfHwge30pIDogY21kKHRoaXMsIGFyZ3MgfHwge30pO1xuICAgICAgICB2YXIgcmVnID0gc2VsZWN0aW9uLl9ldmVudFJlZ2lzdHJ5O1xuICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSB7fTtcbiAgICAgICAgdmFyIHRtcFNlbCA9IG5ldyBTZWxlY3Rpb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBpZiAoJGJ5TGluZXMpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgcmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PSByYW5nZXNbaSAtIDFdLmVuZC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcFNlbC5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgdG1wU2VsLmluZGV4ID0gaTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2Vzc2lvbi5zZWxlY3Rpb24gPSB0bXBTZWw7XG4gICAgICAgICAgICB2YXIgY21kUmVzdWx0ID0gY21kLmV4ZWMgPyBjbWQuZXhlYyh0aGlzLCBhcmdzIHx8IHt9KSA6IGNtZCh0aGlzLCBhcmdzIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGNtZFJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNtZFJlc3VsdDtcbiAgICAgICAgICAgIHRtcFNlbC50b09yaWVudGVkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0bXBTZWwuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2Vzc2lvbi5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSByZWc7XG4gICAgICAgIHNlbGVjdGlvbi5tZXJnZU92ZXJsYXBwaW5nUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VzWzBdKVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHNlbGVjdGlvbi5yYW5nZXNbMF0pO1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMucmVuZGVyZXIuJHNjcm9sbEFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5vbkN1cnNvckNoYW5nZSgpO1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIGlmIChhbmltICYmIGFuaW0uZnJvbSA9PSBhbmltLnRvKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hbmltYXRlU2Nyb2xsaW5nKGFuaW0uZnJvbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB0aGlzLmV4aXRNdWx0aVNlbGVjdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbk11bHRpU2VsZWN0TW9kZSB8fCB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgIXRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMubXVsdGlTZWxlY3QucmFuZ2VMaXN0LnJhbmdlcztcbiAgICAgICAgICAgIHZhciBidWYgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmLnB1c2godGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBubCA9IHRoaXMuc2Vzc2lvbi5nZXREb2N1bWVudCgpLmdldE5ld0xpbmVDaGFyYWN0ZXIoKTtcbiAgICAgICAgICAgIHRleHQgPSBidWYuam9pbihubCk7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gKGJ1Zi5sZW5ndGggLSAxKSAqIG5sLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uIChlLCBhbmNob3IpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgIXRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5tdWx0aVNlbGVjdC5yYW5nZXNbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdC5pc0VtcHR5KCkgJiYgYW5jaG9yID09IHRoaXMubXVsdGlTZWxlY3QuYW5jaG9yKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwb3MgPSBhbmNob3IgPT0gdGhpcy5tdWx0aVNlbGVjdC5hbmNob3JcbiAgICAgICAgICAgICAgICA/IHJhbmdlLmN1cnNvciA9PSByYW5nZS5zdGFydCA/IHJhbmdlLmVuZCA6IHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICAgICAgOiByYW5nZS5jdXJzb3I7XG4gICAgICAgICAgICBpZiAocG9zLnJvdyAhPSBhbmNob3Iucm93XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5zZXNzaW9uLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHBvcy5yb3csIHBvcy5jb2x1bW4pLmNvbHVtbiAhPSBhbmNob3IuY29sdW1uKVxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSh0aGlzLm11bHRpU2VsZWN0LnRvT3JpZW50ZWRSYW5nZSgpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0Lm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5maW5kQWxsID0gZnVuY3Rpb24gKG5lZWRsZSwgb3B0aW9ucywgYWRkaXRpdmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMubmVlZGxlID0gbmVlZGxlIHx8IG9wdGlvbnMubmVlZGxlO1xuICAgICAgICBpZiAob3B0aW9ucy5uZWVkbGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2VsZWN0aW9uLmdldFdvcmRSYW5nZSgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzZWFyY2guc2V0KG9wdGlvbnMpO1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy4kc2VhcmNoLmZpbmRBbGwodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm11bHRpU2VsZWN0O1xuICAgICAgICBpZiAoIWFkZGl0aXZlKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspXG4gICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2VzW2ldLCB0cnVlKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VBdFBvaW50KHJhbmdlLnN0YXJ0KSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByYW5nZXMubGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RNb3JlTGluZXMgPSBmdW5jdGlvbiAoZGlyLCBza2lwKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSByYW5nZS5jdXJzb3IgPT0gcmFuZ2UuZW5kO1xuICAgICAgICB2YXIgc2NyZWVuTGVhZCA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocmFuZ2UuY3Vyc29yKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLiRkZXNpcmVkQ29sdW1uKVxuICAgICAgICAgICAgc2NyZWVuTGVhZC5jb2x1bW4gPSB0aGlzLnNlbGVjdGlvbi4kZGVzaXJlZENvbHVtbjtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlbkxlYWQucm93ICsgZGlyLCBzY3JlZW5MZWFkLmNvbHVtbik7XG4gICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuQW5jaG9yID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihpc0JhY2t3YXJkcyA/IHJhbmdlLmVuZCA6IHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlbkFuY2hvci5yb3cgKyBkaXIsIHNjcmVlbkFuY2hvci5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmFja3dhcmRzKSB7XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGxlYWQsIGFuY2hvcik7XG4gICAgICAgICAgICBuZXdSYW5nZS5jdXJzb3IgPSBuZXdSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoYW5jaG9yLCBsZWFkKTtcbiAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IG5ld1JhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBuZXdSYW5nZS5kZXNpcmVkQ29sdW1uID0gc2NyZWVuTGVhZC5jb2x1bW47XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IHJhbmdlLmN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnN1YnN0cmFjdFBvaW50KHRvUmVtb3ZlKTtcbiAgICB9O1xuICAgIHRoaXMudHJhbnNwb3NlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWwgPSBzZXNzaW9uLm11bHRpU2VsZWN0O1xuICAgICAgICB2YXIgYWxsID0gc2VsLnJhbmdlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFsbFtpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wXzEgPSBzZXNzaW9uLmdldFdvcmRSYW5nZShyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gdG1wXzEuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRtcF8xLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQucm93ID0gdG1wXzEuZW5kLnJvdztcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdG1wXzEuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWwubWVyZ2VPdmVybGFwcGluZ1JhbmdlcygpO1xuICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFsbFtpXTtcbiAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQoc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQod29yZHMucG9wKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmRzLnNoaWZ0KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gYWxsLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gYWxsW2ldO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHJhbmdlLmNsb25lKCk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHdvcmRzW2ldKTtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdyA9IHRtcC5zdGFydC5yb3c7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSB0bXAuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5mcm9tT3JpZW50ZWRSYW5nZShzZWwucmFuZ2VzWzBdKTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0TW9yZSA9IGZ1bmN0aW9uIChkaXIsIHNraXAsIHN0b3BBdEZpcnN0KSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5tdWx0aVNlbGVjdDtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlc3Npb24uZ2V0V29yZFJhbmdlKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZiAoc3RvcEF0Rmlyc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWVkbGUgPSBzZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHZhciBuZXdSYW5nZSA9IGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpO1xuICAgICAgICBpZiAobmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IG5ld1JhbmdlLnN0YXJ0IDogbmV3UmFuZ2UuZW5kO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVuZm9sZChuZXdSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcClcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3Quc3Vic3RyYWN0UG9pbnQocmFuZ2UuY3Vyc29yKTtcbiAgICB9O1xuICAgIHRoaXMuYWxpZ25DdXJzb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHNlbCA9IHNlc3Npb24ubXVsdGlTZWxlY3Q7XG4gICAgICAgIHZhciByYW5nZXMgPSBzZWwucmFuZ2VzO1xuICAgICAgICB2YXIgcm93ID0gLTE7XG4gICAgICAgIHZhciBzYW1lUm93UmFuZ2VzID0gcmFuZ2VzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgaWYgKHIuY3Vyc29yLnJvdyA9PSByb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByb3cgPSByLmN1cnNvci5yb3c7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgc2FtZVJvd1Jhbmdlcy5sZW5ndGggPT0gcmFuZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgZnIgPSByYW5nZS5zdGFydC5yb3csIGxyID0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgIHZhciBndWVzc1JhbmdlID0gZnIgPT0gbHI7XG4gICAgICAgICAgICBpZiAoZ3Vlc3NSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUobHIpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC9bPTpdLy50ZXN0KGxpbmUpICYmICsrbHIgPCBtYXgpO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGZyKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgvWz06XS8udGVzdChsaW5lKSAmJiAtLWZyID4gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZnIgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChsciA+PSBtYXgpXG4gICAgICAgICAgICAgICAgICAgIGxyID0gbWF4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuc2Vzc2lvbi5yZW1vdmVGdWxsTGluZXMoZnIsIGxyKTtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy4kcmVBbGlnblRleHQobGluZXMsIGd1ZXNzUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmluc2VydCh7IHJvdzogZnIsIGNvbHVtbjogMCB9LCBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoIWd1ZXNzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzYW1lUm93UmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICBzZWwuc3Vic3RyYWN0UG9pbnQoci5jdXJzb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWF4Q29sID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5TcGFjZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHNwYWNlT2Zmc2V0cyA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHIuY3Vyc29yO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHAucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VPZmZzZXQgPSBsaW5lLnN1YnN0cihwLmNvbHVtbikuc2VhcmNoKC9cXFMvZyk7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHAuY29sdW1uID4gbWF4Q29sKVxuICAgICAgICAgICAgICAgICAgICBtYXhDb2wgPSBwLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VPZmZzZXQgPCBtaW5TcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgbWluU3BhY2UgPSBzcGFjZU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByLmN1cnNvcjtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IG1heENvbCAtIHAuY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBkID0gc3BhY2VPZmZzZXRzW2ldIC0gbWluU3BhY2U7XG4gICAgICAgICAgICAgICAgaWYgKGwgPiBkKVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmluc2VydChwLCBsYW5nLnN0cmluZ1JlcGVhdChcIiBcIiwgbCAtIGQpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKG5ldyBSYW5nZShwLnJvdywgcC5jb2x1bW4sIHAucm93LCBwLmNvbHVtbiAtIGwgKyBkKSk7XG4gICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gPSByLmVuZC5jb2x1bW4gPSBtYXhDb2w7XG4gICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSByLmVuZC5yb3cgPSBwLnJvdztcbiAgICAgICAgICAgICAgICByLmN1cnNvciA9IHIuZW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWwuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJHJlQWxpZ25UZXh0ID0gZnVuY3Rpb24gKGxpbmVzLCBmb3JjZUxlZnQpIHtcbiAgICAgICAgdmFyIGlzTGVmdEFsaWduZWQgPSB0cnVlLCBpc1JpZ2h0QWxpZ25lZCA9IHRydWU7XG4gICAgICAgIHZhciBzdGFydFcsIHRleHRXLCBlbmRXO1xuICAgICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goLyhcXHMqKSguKj8pKFxccyopKFs9Ol0uKikvKTtcbiAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xpbmVdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRXID0gbVsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGV4dFcgPSBtWzJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlbmRXID0gbVszXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRXICsgdGV4dFcgKyBlbmRXICE9IG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGggKyBtWzNdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc1JpZ2h0QWxpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VyAhPSBtWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc0xlZnRBbGlnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhcnRXID4gbVsxXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc3RhcnRXID0gbVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGV4dFcgPCBtWzJdLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0ZXh0VyA9IG1bMl0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZFcgPiBtWzNdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBlbmRXID0gbVszXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSkubWFwKGZvcmNlTGVmdCA/IGFsaWduTGVmdCA6XG4gICAgICAgICAgICBpc0xlZnRBbGlnbmVkID8gaXNSaWdodEFsaWduZWQgPyBhbGlnblJpZ2h0IDogYWxpZ25MZWZ0IDogdW5BbGlnbik7XG4gICAgICAgIGZ1bmN0aW9uIHNwYWNlcyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsaWduTGVmdChtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VykgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXModGV4dFcgLSBtWzJdLmxlbmd0aCArIGVuZFcpXG4gICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXHMrLywgXCIkMSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxpZ25SaWdodChtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VyArIHRleHRXIC0gbVsyXS5sZW5ndGgpICsgbVsyXVxuICAgICAgICAgICAgICAgICsgc3BhY2VzKGVuZFcpXG4gICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXHMrLywgXCIkMSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5BbGlnbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VykgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVylcbiAgICAgICAgICAgICAgICArIG1bNF0ucmVwbGFjZSgvXihbPTpdKVxccysvLCBcIiQxIFwiKTtcbiAgICAgICAgfVxuICAgIH07XG59KS5jYWxsKEVkaXRvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNTYW1lUG9pbnQocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyA9PSBwMi5yb3cgJiYgcDEuY29sdW1uID09IHAyLmNvbHVtbjtcbn1cbmV4cG9ydHMub25TZXNzaW9uQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IGUuc2Vzc2lvbjtcbiAgICBpZiAoc2Vzc2lvbiAmJiAhc2Vzc2lvbi5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzID0gW107XG4gICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLiRpbml0UmFuZ2VMaXN0KCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QgPSBzZXNzaW9uLnNlbGVjdGlvbjtcbiAgICB9XG4gICAgdGhpcy5tdWx0aVNlbGVjdCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5tdWx0aVNlbGVjdDtcbiAgICB2YXIgb2xkU2Vzc2lvbiA9IGUub2xkU2Vzc2lvbjtcbiAgICBpZiAob2xkU2Vzc2lvbikge1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcImFkZFJhbmdlXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcInJlbW92ZVJhbmdlXCIsIHRoaXMuJG9uUmVtb3ZlUmFuZ2UpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcIm11bHRpU2VsZWN0XCIsIHRoaXMuJG9uTXVsdGlTZWxlY3QpO1xuICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcInNpbmdsZVNlbGVjdFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3QubGVhZC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3QuYW5jaG9yLm9mZihcImNoYW5nZVwiLCB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcImFkZFJhbmdlXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xuICAgICAgICBzZXNzaW9uLm11bHRpU2VsZWN0Lm9uKFwicmVtb3ZlUmFuZ2VcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3Qub24oXCJtdWx0aVNlbGVjdFwiLCB0aGlzLiRvbk11bHRpU2VsZWN0KTtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcInNpbmdsZVNlbGVjdFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QubGVhZC5vbihcImNoYW5nZVwiLCB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5hbmNob3Iub24oXCJjaGFuZ2VcIiwgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgfVxuICAgIGlmIChzZXNzaW9uICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgIT0gc2Vzc2lvbi5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgaWYgKHNlc3Npb24uc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgdGhpcy4kb25NdWx0aVNlbGVjdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRvblNpbmdsZVNlbGVjdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBNdWx0aVNlbGVjdChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGVkaXRvci4kb25BZGRSYW5nZSA9IGVkaXRvci4kb25BZGRSYW5nZS5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRvblJlbW92ZVJhbmdlID0gZWRpdG9yLiRvblJlbW92ZVJhbmdlLmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJG9uTXVsdGlTZWxlY3QgPSBlZGl0b3IuJG9uTXVsdGlTZWxlY3QuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci4kb25TaW5nbGVTZWxlY3QgPSBlZGl0b3IuJG9uU2luZ2xlU2VsZWN0LmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlID0gZXhwb3J0cy5vblNlc3Npb25DaGFuZ2UuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZS5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZShlZGl0b3IpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSk7XG4gICAgZWRpdG9yLm9uKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duKTtcbiAgICBlZGl0b3IuY29tbWFuZHMuYWRkQ29tbWFuZHMoY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzKTtcbiAgICBhZGRBbHRDdXJzb3JMaXN0ZW5lcnMoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGFkZEFsdEN1cnNvckxpc3RlbmVycyhlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci50ZXh0SW5wdXQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZWwgPSBlZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKTtcbiAgICB2YXIgYWx0Q3Vyc29yID0gZmFsc2U7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYWx0RG93biA9IGUua2V5Q29kZSA9PSAxOCAmJiAhKGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSk7XG4gICAgICAgIGlmIChlZGl0b3IuJGJsb2NrU2VsZWN0RW5hYmxlZCAmJiBhbHREb3duKSB7XG4gICAgICAgICAgICBpZiAoIWFsdEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRNb3VzZUN1cnNvcihcImNyb3NzaGFpclwiKTtcbiAgICAgICAgICAgICAgICBhbHRDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsdEN1cnNvcikge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwia2V5dXBcIiwgcmVzZXQsIGVkaXRvcik7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwiYmx1clwiLCByZXNldCwgZWRpdG9yKTtcbiAgICBmdW5jdGlvbiByZXNldChlKSB7XG4gICAgICAgIGlmIChhbHRDdXJzb3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRNb3VzZUN1cnNvcihcIlwiKTtcbiAgICAgICAgICAgIGFsdEN1cnNvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aVNlbGVjdCA9IE11bHRpU2VsZWN0O1xucmVxdWlyZShcIi4vY29uZmlnXCIpLmRlZmluZU9wdGlvbnMoRWRpdG9yLnByb3RvdHlwZSwgXCJlZGl0b3JcIiwge1xuICAgIGVuYWJsZU11bHRpc2VsZWN0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgTXVsdGlTZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBlbmFibGVCbG9ja1NlbGVjdDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGJsb2NrU2VsZWN0RW5hYmxlZCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9XG59KTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9mb2xkaW5nL2ZvbGRfbW9kZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uLy4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIEZvbGRNb2RlID0gZXhwb3J0cy5Gb2xkTW9kZSA9IGZ1bmN0aW9uICgpIHsgfTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZ1bmN0aW9uIChzZXNzaW9uLCBmb2xkU3R5bGUsIHJvdykge1xuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xuICAgICAgICBpZiAodGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIudGVzdChsaW5lKSlcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgIGlmIChmb2xkU3R5bGUgPT0gXCJtYXJrYmVnaW5lbmRcIlxuICAgICAgICAgICAgJiYgdGhpcy5mb2xkaW5nU3RvcE1hcmtlclxuICAgICAgICAgICAgJiYgdGhpcy5mb2xkaW5nU3RvcE1hcmtlci50ZXN0KGxpbmUpKVxuICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG4gICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgZm9sZFN0eWxlLCByb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmluZGVudGF0aW9uQmxvY2sgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgcm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHJlID0gL1xcUy87XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBzdGFydExldmVsID0gbGluZS5zZWFyY2gocmUpO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gY29sdW1uIHx8IGxpbmUubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4Um93ID0gc2Vzc2lvbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gcm93O1xuICAgICAgICB2YXIgZW5kUm93ID0gcm93O1xuICAgICAgICB3aGlsZSAoKytyb3cgPCBtYXhSb3cpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHNlc3Npb24uZ2V0TGluZShyb3cpLnNlYXJjaChyZSk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gc3RhcnRMZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChyb3csIDApO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRSb3cgPSByb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFJvdyA+IHN0YXJ0Um93KSB7XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2Vzc2lvbi5nZXRMaW5lKGVuZFJvdykubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFJvdywgc3RhcnRDb2x1bW4sIGVuZFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuaW5nQnJhY2tldEJsb2NrID0gZnVuY3Rpb24gKHNlc3Npb24sIGJyYWNrZXQsIHJvdywgY29sdW1uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0geyByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4gKyAxIH07XG4gICAgICAgIHZhciBlbmQgPSBzZXNzaW9uLiRmaW5kQ2xvc2luZ0JyYWNrZXQoYnJhY2tldCwgc3RhcnQsIHR5cGVSZSk7XG4gICAgICAgIGlmICghZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZncgPSBzZXNzaW9uLmZvbGRXaWRnZXRzW2VuZC5yb3ddO1xuICAgICAgICBpZiAoZncgPT0gbnVsbClcbiAgICAgICAgICAgIGZ3ID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KGVuZC5yb3cpO1xuICAgICAgICBpZiAoZncgPT0gXCJzdGFydFwiICYmIGVuZC5yb3cgPiBzdGFydC5yb3cpIHtcbiAgICAgICAgICAgIGVuZC5yb3ctLTtcbiAgICAgICAgICAgIGVuZC5jb2x1bW4gPSBzZXNzaW9uLmdldExpbmUoZW5kLnJvdykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgdGhpcy5jbG9zaW5nQnJhY2tldEJsb2NrID0gZnVuY3Rpb24gKHNlc3Npb24sIGJyYWNrZXQsIHJvdywgY29sdW1uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIGVuZCA9IHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgICAgIHZhciBzdGFydCA9IHNlc3Npb24uJGZpbmRPcGVuaW5nQnJhY2tldChicmFja2V0LCBlbmQpO1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGFydC5jb2x1bW4rKztcbiAgICAgICAgZW5kLmNvbHVtbi0tO1xuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgZW5kKTtcbiAgICB9O1xufSkuY2FsbChGb2xkTW9kZS5wcm90b3R5cGUpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvY29uZmlnXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIG5scyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIikubmxzO1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBuZWVkbGUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgZmlyc3QgPSAwO1xuICAgIHZhciBsYXN0ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3QgPD0gbGFzdCkge1xuICAgICAgICB2YXIgbWlkID0gKGZpcnN0ICsgbGFzdCkgPj4gMTtcbiAgICAgICAgdmFyIGMgPSBjb21wYXJhdG9yKG5lZWRsZSwgYXJyYXlbbWlkXSk7XG4gICAgICAgIGlmIChjID4gMClcbiAgICAgICAgICAgIGZpcnN0ID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDApXG4gICAgICAgICAgICBsYXN0ID0gbWlkIC0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIC0oZmlyc3QgKyAxKTtcbn1cbmZ1bmN0aW9uIGZpbmRBbm5vdGF0aW9ucyhzZXNzaW9uLCByb3csIGRpcikge1xuICAgIHZhciBhbm5vdGF0aW9ucyA9IHNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKS5zb3J0KFJhbmdlLmNvbXBhcmVQb2ludHMpO1xuICAgIGlmICghYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGkgPSBiaW5hcnlTZWFyY2goYW5ub3RhdGlvbnMsIHsgcm93OiByb3csIGNvbHVtbjogLTEgfSwgUmFuZ2UuY29tcGFyZVBvaW50cyk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgICBpID0gLWkgLSAxO1xuICAgIGlmIChpID49IGFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgaSA9IGRpciA+IDAgPyAwIDogYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICBlbHNlIGlmIChpID09PSAwICYmIGRpciA8IDApXG4gICAgICAgIGkgPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xuICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgaWYgKCFhbm5vdGF0aW9uIHx8ICFkaXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYW5ub3RhdGlvbi5yb3cgPT09IHJvdykge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaSArPSBkaXJdO1xuICAgICAgICB9IHdoaWxlIChhbm5vdGF0aW9uICYmIGFubm90YXRpb24ucm93ID09PSByb3cpO1xuICAgICAgICBpZiAoIWFubm90YXRpb24pXG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICByb3cgPSBhbm5vdGF0aW9uLnJvdztcbiAgICBkbyB7XG4gICAgICAgIG1hdGNoZWRbZGlyIDwgMCA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGFubm90YXRpb24pO1xuICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaSArPSBkaXJdO1xuICAgIH0gd2hpbGUgKGFubm90YXRpb24gJiYgYW5ub3RhdGlvbi5yb3cgPT0gcm93KTtcbiAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGggJiYgbWF0Y2hlZDtcbn1cbmV4cG9ydHMuc2hvd0Vycm9yTWFya2VyID0gZnVuY3Rpb24gKGVkaXRvciwgZGlyKSB7XG4gICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICB2YXIgcG9zID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgdmFyIHJvdyA9IHBvcy5yb3c7XG4gICAgdmFyIG9sZFdpZGdldCA9IHNlc3Npb24ud2lkZ2V0TWFuYWdlci5nZXRXaWRnZXRzQXRSb3cocm93KS5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHcudHlwZSA9PSBcImVycm9yTWFya2VyXCI7XG4gICAgfSlbMF07XG4gICAgaWYgKG9sZFdpZGdldCkge1xuICAgICAgICBvbGRXaWRnZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm93IC09IGRpcjtcbiAgICB9XG4gICAgdmFyIGFubm90YXRpb25zID0gZmluZEFubm90YXRpb25zKHNlc3Npb24sIHJvdywgZGlyKTtcbiAgICB2YXIgZ3V0dGVyQW5ubztcbiAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1swXTtcbiAgICAgICAgcG9zLmNvbHVtbiA9IChhbm5vdGF0aW9uLnBvcyAmJiB0eXBlb2YgYW5ub3RhdGlvbi5jb2x1bW4gIT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBhbm5vdGF0aW9uLnBvcy5zY1xuICAgICAgICAgICAgOiBhbm5vdGF0aW9uLmNvbHVtbikgfHwgMDtcbiAgICAgICAgcG9zLnJvdyA9IGFubm90YXRpb24ucm93O1xuICAgICAgICBndXR0ZXJBbm5vID0gZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXJMYXllci4kYW5ub3RhdGlvbnNbcG9zLnJvd107XG4gICAgfVxuICAgIGVsc2UgaWYgKG9sZFdpZGdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBndXR0ZXJBbm5vID0ge1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IFtubHMoXCJlcnJvci1tYXJrZXIuZ29vZC1zdGF0ZVwiLCBcIkxvb2tzIGdvb2QhXCIpXSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhY2Vfb2tcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBlZGl0b3Iuc2Vzc2lvbi51bmZvbGQocG9zLnJvdyk7XG4gICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgIHZhciB3ID0ge1xuICAgICAgICByb3c6IHBvcy5yb3csXG4gICAgICAgIGZpeGVkV2lkdGg6IHRydWUsXG4gICAgICAgIGNvdmVyR3V0dGVyOiB0cnVlLFxuICAgICAgICBlbDogZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIHR5cGU6IFwiZXJyb3JNYXJrZXJcIlxuICAgIH07XG4gICAgdmFyIGVsID0gdy5lbC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgdmFyIGFycm93ID0gdy5lbC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gXCJlcnJvcl93aWRnZXRfYXJyb3cgXCIgKyBndXR0ZXJBbm5vLmNsYXNzTmFtZTtcbiAgICB2YXIgbGVmdCA9IGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXJcbiAgICAgICAgLmdldFBpeGVsUG9zaXRpb24ocG9zKS5sZWZ0O1xuICAgIGFycm93LnN0eWxlLmxlZnQgPSBsZWZ0ICsgZWRpdG9yLnJlbmRlcmVyLmd1dHRlcldpZHRoIC0gNSArIFwicHhcIjtcbiAgICB3LmVsLmNsYXNzTmFtZSA9IFwiZXJyb3Jfd2lkZ2V0X3dyYXBwZXJcIjtcbiAgICBlbC5jbGFzc05hbWUgPSBcImVycm9yX3dpZGdldCBcIiArIGd1dHRlckFubm8uY2xhc3NOYW1lO1xuICAgIGd1dHRlckFubm8uZGlzcGxheVRleHQuZm9yRWFjaChmdW5jdGlvbiAoYW5ub1RleHRMaW5lLCBpKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGRvbS5jcmVhdGVUZXh0Tm9kZShhbm5vVGV4dExpbmUpKTtcbiAgICAgICAgaWYgKGkgPCBndXR0ZXJBbm5vLmRpc3BsYXlUZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRvbS5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIHZhciBrYiA9IGZ1bmN0aW9uIChfLCBoYXNoSWQsIGtleVN0cmluZykge1xuICAgICAgICBpZiAoaGFzaElkID09PSAwICYmIChrZXlTdHJpbmcgPT09IFwiZXNjXCIgfHwga2V5U3RyaW5nID09PSBcInJldHVyblwiKSkge1xuICAgICAgICAgICAgdy5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4geyBjb21tYW5kOiBcIm51bGxcIiB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3LmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci5pc01vdXNlUHJlc3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWRpdG9yLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGtiKTtcbiAgICAgICAgc2Vzc2lvbi53aWRnZXRNYW5hZ2VyLnJlbW92ZUxpbmVXaWRnZXQodyk7XG4gICAgICAgIGVkaXRvci5vZmYoXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdy5kZXN0cm95KTtcbiAgICAgICAgZWRpdG9yLm9mZihcImNoYW5nZVNlc3Npb25cIiwgdy5kZXN0cm95KTtcbiAgICAgICAgZWRpdG9yLm9mZihcIm1vdXNldXBcIiwgdy5kZXN0cm95KTtcbiAgICAgICAgZWRpdG9yLm9mZihcImNoYW5nZVwiLCB3LmRlc3Ryb3kpO1xuICAgIH07XG4gICAgZWRpdG9yLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiKTtcbiAgICBlZGl0b3Iub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdy5kZXN0cm95KTtcbiAgICBlZGl0b3Iub24oXCJjaGFuZ2VTZXNzaW9uXCIsIHcuZGVzdHJveSk7XG4gICAgZWRpdG9yLm9uKFwibW91c2V1cFwiLCB3LmRlc3Ryb3kpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVwiLCB3LmRlc3Ryb3kpO1xuICAgIGVkaXRvci5zZXNzaW9uLndpZGdldE1hbmFnZXIuYWRkTGluZVdpZGdldCh3KTtcbiAgICB3LmVsLm9ubW91c2Vkb3duID0gZWRpdG9yLmZvY3VzLmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41LCB7IGJvdHRvbTogdy5lbC5vZmZzZXRIZWlnaHQgfSk7XG59O1xuZG9tLmltcG9ydENzc1N0cmluZyhcIlxcbiAgICAuZXJyb3Jfd2lkZ2V0X3dyYXBwZXIge1xcbiAgICAgICAgYmFja2dyb3VuZDogaW5oZXJpdDtcXG4gICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgYm9yZGVyOm5vbmVcXG4gICAgfVxcbiAgICAuZXJyb3Jfd2lkZ2V0IHtcXG4gICAgICAgIGJvcmRlci10b3A6IHNvbGlkIDJweDtcXG4gICAgICAgIGJvcmRlci1ib3R0b206IHNvbGlkIDJweDtcXG4gICAgICAgIG1hcmdpbjogNXB4IDA7XFxuICAgICAgICBwYWRkaW5nOiAxMHB4IDQwcHg7XFxuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICAgIH1cXG4gICAgLmVycm9yX3dpZGdldC5hY2VfZXJyb3IsIC5lcnJvcl93aWRnZXRfYXJyb3cuYWNlX2Vycm9ye1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjZmY1YTVhXFxuICAgIH1cXG4gICAgLmVycm9yX3dpZGdldC5hY2Vfd2FybmluZywgLmVycm9yX3dpZGdldF9hcnJvdy5hY2Vfd2FybmluZ3tcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0YxRDgxN1xcbiAgICB9XFxuICAgIC5lcnJvcl93aWRnZXQuYWNlX2luZm8sIC5lcnJvcl93aWRnZXRfYXJyb3cuYWNlX2luZm97XFxuICAgICAgICBib3JkZXItY29sb3I6ICM1YTVhNWFcXG4gICAgfVxcbiAgICAuZXJyb3Jfd2lkZ2V0LmFjZV9vaywgLmVycm9yX3dpZGdldF9hcnJvdy5hY2Vfb2t7XFxuICAgICAgICBib3JkZXItY29sb3I6ICM1YWFhNWFcXG4gICAgfVxcbiAgICAuZXJyb3Jfd2lkZ2V0X2Fycm93IHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIGJvcmRlcjogc29saWQgNXB4O1xcbiAgICAgICAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQhaW1wb3J0YW50O1xcbiAgICAgICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxuICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogdHJhbnNwYXJlbnQhaW1wb3J0YW50O1xcbiAgICAgICAgdG9wOiAtNXB4O1xcbiAgICB9XFxuXCIsIFwiZXJyb3JfbWFya2VyLmNzc1wiLCBmYWxzZSk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2FjZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9yYW5nZVwiLFwiYWNlL2VkaXRvclwiLFwiYWNlL2VkaXRfc2Vzc2lvblwiLFwiYWNlL3VuZG9tYW5hZ2VyXCIsXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvcGxhY2Vob2xkZXJcIixcImFjZS9tdWx0aV9zZWxlY3RcIixcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXCIsXCJhY2UvdGhlbWUvdGV4dG1hdGVcIixcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbG9hZGVyX2J1aWxkXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpey8qKlxuICogVGhlIG1haW4gY2xhc3MgcmVxdWlyZWQgdG8gc2V0IHVwIGFuIEFjZSBpbnN0YW5jZSBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAbmFtZXNwYWNlIEFjZVxuICoqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKFwiLi9sb2FkZXJfYnVpbGRcIikoZXhwb3J0cylcbnZhciBkb20gPSByZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgRWRpdG9yID0gcmVxdWlyZShcIi4vZWRpdG9yXCIpLkVkaXRvcjtcbnZhciBFZGl0U2Vzc2lvbiA9IHJlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvblwiKS5FZGl0U2Vzc2lvbjtcbnZhciBVbmRvTWFuYWdlciA9IHJlcXVpcmUoXCIuL3VuZG9tYW5hZ2VyXCIpLlVuZG9NYW5hZ2VyO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZShcIi4vdmlydHVhbF9yZW5kZXJlclwiKS5WaXJ0dWFsUmVuZGVyZXI7XG5yZXF1aXJlKFwiLi93b3JrZXIvd29ya2VyX2NsaWVudFwiKTtcbnJlcXVpcmUoXCIuL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiKTtcbnJlcXVpcmUoXCIuL3BsYWNlaG9sZGVyXCIpO1xucmVxdWlyZShcIi4vbXVsdGlfc2VsZWN0XCIpO1xucmVxdWlyZShcIi4vbW9kZS9mb2xkaW5nL2ZvbGRfbW9kZVwiKTtcbnJlcXVpcmUoXCIuL3RoZW1lL3RleHRtYXRlXCIpO1xucmVxdWlyZShcIi4vZXh0L2Vycm9yX21hcmtlclwiKTtcbmV4cG9ydHMuY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuZXhwb3J0cy5lZGl0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBfaWQgPSBlbDtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfaWQpO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWNlLmVkaXQgY2FuJ3QgZmluZCBkaXYgI1wiICsgX2lkKTtcbiAgICB9XG4gICAgaWYgKGVsICYmIGVsLmVudiAmJiBlbC5lbnYuZWRpdG9yIGluc3RhbmNlb2YgRWRpdG9yKVxuICAgICAgICByZXR1cm4gZWwuZW52LmVkaXRvcjtcbiAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgIGlmIChlbCAmJiAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGVsLnRhZ05hbWUpKSB7XG4gICAgICAgIHZhciBvbGROb2RlID0gZWw7XG4gICAgICAgIHZhbHVlID0gb2xkTm9kZS52YWx1ZTtcbiAgICAgICAgZWwgPSBkb20uY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbCwgb2xkTm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsKSB7XG4gICAgICAgIHZhbHVlID0gZWwudGV4dENvbnRlbnQ7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfVxuICAgIHZhciBkb2MgPSBleHBvcnRzLmNyZWF0ZUVkaXRTZXNzaW9uKHZhbHVlKTtcbiAgICB2YXIgZWRpdG9yID0gbmV3IEVkaXRvcihuZXcgUmVuZGVyZXIoZWwpLCBkb2MsIG9wdGlvbnMpO1xuICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGRvY3VtZW50OiBkb2MsXG4gICAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgICBvblJlc2l6ZTogZWRpdG9yLnJlc2l6ZS5iaW5kKGVkaXRvciwgbnVsbClcbiAgICB9O1xuICAgIGlmIChvbGROb2RlKVxuICAgICAgICBlbnYudGV4dGFyZWEgPSBvbGROb2RlO1xuICAgIGVkaXRvci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbnYuZWRpdG9yLmNvbnRhaW5lci5lbnYgPSBudWxsOyAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrIG9uIG9sZCBpZVxuICAgIH0pO1xuICAgIGVkaXRvci5jb250YWluZXIuZW52ID0gZWRpdG9yLmVudiA9IGVudjtcbiAgICByZXR1cm4gZWRpdG9yO1xufTtcbmV4cG9ydHMuY3JlYXRlRWRpdFNlc3Npb24gPSBmdW5jdGlvbiAodGV4dCwgbW9kZSkge1xuICAgIHZhciBkb2MgPSBuZXcgRWRpdFNlc3Npb24odGV4dCwgbW9kZSk7XG4gICAgZG9jLnNldFVuZG9NYW5hZ2VyKG5ldyBVbmRvTWFuYWdlcigpKTtcbiAgICByZXR1cm4gZG9jO1xufTtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuRWRpdG9yID0gRWRpdG9yO1xuZXhwb3J0cy5FZGl0U2Vzc2lvbiA9IEVkaXRTZXNzaW9uO1xuZXhwb3J0cy5VbmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyO1xuZXhwb3J0cy5WaXJ0dWFsUmVuZGVyZXIgPSBSZW5kZXJlcjtcbnZhciB2ZXJzaW9uID0gZXhwb3J0cy5jb25maWcudmVyc2lvbjtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbn0pOyAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhY2UucmVxdWlyZShbXCJhY2UvYWNlXCJdLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmNvbmZpZy5pbml0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZpbmUgPSBhY2UuZGVmaW5lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbG9iYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsICYmIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsID0gd2luZG93OyAvLyBjYW4gaGFwcGVuIGluIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsICYmIHR5cGVvZiBzZWxmICE9IFwidW5kZWZpbmVkXCIpIGdsb2JhbCA9IHNlbGY7IC8vIGNhbiBoYXBwZW4gaW4gd2Vid29ya2VyXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbC5hY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwuYWNlID0gYTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIGlmIChhLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwuYWNlW2tleV0gPSBhW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5hY2VbXCJkZWZhdWx0XCJdID0gZ2xvYmFsLmFjZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuYWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ace-builds/src-noconflict/ace.js\n");

/***/ })

};
;