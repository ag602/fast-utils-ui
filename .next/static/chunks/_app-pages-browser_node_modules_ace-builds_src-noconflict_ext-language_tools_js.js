/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_ace-builds_src-noconflict_ext-language_tools_js"],{

/***/ "(app-pages-browser)/./node_modules/ace-builds/src-noconflict/ext-language_tools.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ext-language_tools.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\nace.define(\"ace/snippets\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/lib/lang\",\"ace/range\",\"ace/range_list\",\"ace/keyboard/hash_handler\",\"ace/tokenizer\",\"ace/clipboard\",\"ace/editor\"], function(require, exports, module){\"use strict\";\nvar dom = require(\"./lib/dom\");\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar lang = require(\"./lib/lang\");\nvar Range = require(\"./range\").Range;\nvar RangeList = require(\"./range_list\").RangeList;\nvar HashHandler = require(\"./keyboard/hash_handler\").HashHandler;\nvar Tokenizer = require(\"./tokenizer\").Tokenizer;\nvar clipboard = require(\"./clipboard\");\nvar VARIABLES = {\n    CURRENT_WORD: function (editor) {\n        return editor.session.getTextRange(editor.session.getWordRange());\n    },\n    SELECTION: function (editor, name, indentation) {\n        var text = editor.session.getTextRange();\n        if (indentation)\n            return text.replace(/\\n\\r?([ \\t]*\\S)/g, \"\\n\" + indentation + \"$1\");\n        return text;\n    },\n    CURRENT_LINE: function (editor) {\n        return editor.session.getLine(editor.getCursorPosition().row);\n    },\n    PREV_LINE: function (editor) {\n        return editor.session.getLine(editor.getCursorPosition().row - 1);\n    },\n    LINE_INDEX: function (editor) {\n        return editor.getCursorPosition().row;\n    },\n    LINE_NUMBER: function (editor) {\n        return editor.getCursorPosition().row + 1;\n    },\n    SOFT_TABS: function (editor) {\n        return editor.session.getUseSoftTabs() ? \"YES\" : \"NO\";\n    },\n    TAB_SIZE: function (editor) {\n        return editor.session.getTabSize();\n    },\n    CLIPBOARD: function (editor) {\n        return clipboard.getText && clipboard.getText();\n    },\n    FILENAME: function (editor) {\n        return /[^/\\\\]*$/.exec(this.FILEPATH(editor))[0];\n    },\n    FILENAME_BASE: function (editor) {\n        return /[^/\\\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\\.[^.]*$/, \"\");\n    },\n    DIRECTORY: function (editor) {\n        return this.FILEPATH(editor).replace(/[^/\\\\]*$/, \"\");\n    },\n    FILEPATH: function (editor) { return \"/not implemented.txt\"; },\n    WORKSPACE_NAME: function () { return \"Unknown\"; },\n    FULLNAME: function () { return \"Unknown\"; },\n    BLOCK_COMMENT_START: function (editor) {\n        var mode = editor.session.$mode || {};\n        return mode.blockComment && mode.blockComment.start || \"\";\n    },\n    BLOCK_COMMENT_END: function (editor) {\n        var mode = editor.session.$mode || {};\n        return mode.blockComment && mode.blockComment.end || \"\";\n    },\n    LINE_COMMENT: function (editor) {\n        var mode = editor.session.$mode || {};\n        return mode.lineCommentStart || \"\";\n    },\n    CURRENT_YEAR: date.bind(null, { year: \"numeric\" }),\n    CURRENT_YEAR_SHORT: date.bind(null, { year: \"2-digit\" }),\n    CURRENT_MONTH: date.bind(null, { month: \"numeric\" }),\n    CURRENT_MONTH_NAME: date.bind(null, { month: \"long\" }),\n    CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: \"short\" }),\n    CURRENT_DATE: date.bind(null, { day: \"2-digit\" }),\n    CURRENT_DAY_NAME: date.bind(null, { weekday: \"long\" }),\n    CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: \"short\" }),\n    CURRENT_HOUR: date.bind(null, { hour: \"2-digit\", hour12: false }),\n    CURRENT_MINUTE: date.bind(null, { minute: \"2-digit\" }),\n    CURRENT_SECOND: date.bind(null, { second: \"2-digit\" })\n};\nVARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;\nfunction date(dateFormat) {\n    var str = new Date().toLocaleString(\"en-us\", dateFormat);\n    return str.length == 1 ? \"0\" + str : str;\n}\nvar SnippetManager = /** @class */ (function () {\n    function SnippetManager() {\n        this.snippetMap = {};\n        this.snippetNameMap = {};\n        this.variables = VARIABLES;\n    }\n    SnippetManager.prototype.getTokenizer = function () {\n        return SnippetManager[\"$tokenizer\"] || this.createTokenizer();\n    };\n    SnippetManager.prototype.createTokenizer = function () {\n        function TabstopToken(str) {\n            str = str.substr(1);\n            if (/^\\d+$/.test(str))\n                return [{ tabstopId: parseInt(str, 10) }];\n            return [{ text: str }];\n        }\n        function escape(ch) {\n            return \"(?:[^\\\\\\\\\" + ch + \"]|\\\\\\\\.)\";\n        }\n        var formatMatcher = {\n            regex: \"/(\" + escape(\"/\") + \"+)/\",\n            onMatch: function (val, state, stack) {\n                var ts = stack[0];\n                ts.fmtString = true;\n                ts.guard = val.slice(1, -1);\n                ts.flag = \"\";\n                return \"\";\n            },\n            next: \"formatString\"\n        };\n        SnippetManager[\"$tokenizer\"] = new Tokenizer({\n            start: [\n                { regex: /\\\\./, onMatch: function (val, state, stack) {\n                        var ch = val[1];\n                        if (ch == \"}\" && stack.length) {\n                            val = ch;\n                        }\n                        else if (\"`$\\\\\".indexOf(ch) != -1) {\n                            val = ch;\n                        }\n                        return [val];\n                    } },\n                { regex: /}/, onMatch: function (val, state, stack) {\n                        return [stack.length ? stack.shift() : val];\n                    } },\n                { regex: /\\$(?:\\d+|\\w+)/, onMatch: TabstopToken },\n                { regex: /\\$\\{[\\dA-Z_a-z]+/, onMatch: function (str, state, stack) {\n                        var t = TabstopToken(str.substr(1));\n                        stack.unshift(t[0]);\n                        return t;\n                    }, next: \"snippetVar\" },\n                { regex: /\\n/, token: \"newline\", merge: false }\n            ],\n            snippetVar: [\n                { regex: \"\\\\|\" + escape(\"\\\\|\") + \"*\\\\|\", onMatch: function (val, state, stack) {\n                        var choices = val.slice(1, -1).replace(/\\\\[,|\\\\]|,/g, function (operator) {\n                            return operator.length == 2 ? operator[1] : \"\\x00\";\n                        }).split(\"\\x00\").map(function (value) {\n                            return { value: value };\n                        });\n                        stack[0].choices = choices;\n                        return [choices[0]];\n                    }, next: \"start\" },\n                formatMatcher,\n                { regex: \"([^:}\\\\\\\\]|\\\\\\\\.)*:?\", token: \"\", next: \"start\" }\n            ],\n            formatString: [\n                { regex: /:/, onMatch: function (val, state, stack) {\n                        if (stack.length && stack[0].expectElse) {\n                            stack[0].expectElse = false;\n                            stack[0].ifEnd = { elseEnd: stack[0] };\n                            return [stack[0].ifEnd];\n                        }\n                        return \":\";\n                    } },\n                { regex: /\\\\./, onMatch: function (val, state, stack) {\n                        var ch = val[1];\n                        if (ch == \"}\" && stack.length)\n                            val = ch;\n                        else if (\"`$\\\\\".indexOf(ch) != -1)\n                            val = ch;\n                        else if (ch == \"n\")\n                            val = \"\\n\";\n                        else if (ch == \"t\")\n                            val = \"\\t\";\n                        else if (\"ulULE\".indexOf(ch) != -1)\n                            val = { changeCase: ch, local: ch > \"a\" };\n                        return [val];\n                    } },\n                { regex: \"/\\\\w*}\", onMatch: function (val, state, stack) {\n                        var next = stack.shift();\n                        if (next)\n                            next.flag = val.slice(1, -1);\n                        this.next = next && next.tabstopId ? \"start\" : \"\";\n                        return [next || val];\n                    }, next: \"start\" },\n                { regex: /\\$(?:\\d+|\\w+)/, onMatch: function (val, state, stack) {\n                        return [{ text: val.slice(1) }];\n                    } },\n                { regex: /\\${\\w+/, onMatch: function (val, state, stack) {\n                        var token = { text: val.slice(2) };\n                        stack.unshift(token);\n                        return [token];\n                    }, next: \"formatStringVar\" },\n                { regex: /\\n/, token: \"newline\", merge: false },\n                { regex: /}/, onMatch: function (val, state, stack) {\n                        var next = stack.shift();\n                        this.next = next && next.tabstopId ? \"start\" : \"\";\n                        return [next || val];\n                    }, next: \"start\" }\n            ],\n            formatStringVar: [\n                { regex: /:\\/\\w+}/, onMatch: function (val, state, stack) {\n                        var ts = stack[0];\n                        ts.formatFunction = val.slice(2, -1);\n                        return [stack.shift()];\n                    }, next: \"formatString\" },\n                formatMatcher,\n                { regex: /:[\\?\\-+]?/, onMatch: function (val, state, stack) {\n                        if (val[1] == \"+\")\n                            stack[0].ifEnd = stack[0];\n                        if (val[1] == \"?\")\n                            stack[0].expectElse = true;\n                    }, next: \"formatString\" },\n                { regex: \"([^:}\\\\\\\\]|\\\\\\\\.)*:?\", token: \"\", next: \"formatString\" }\n            ]\n        });\n        return SnippetManager[\"$tokenizer\"];\n    };\n    SnippetManager.prototype.tokenizeTmSnippet = function (str, startState) {\n        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function (x) {\n            return x.value || x;\n        });\n    };\n    SnippetManager.prototype.getVariableValue = function (editor, name, indentation) {\n        if (/^\\d+$/.test(name))\n            return (this.variables.__ || {})[name] || \"\";\n        if (/^[A-Z]\\d+$/.test(name))\n            return (this.variables[name[0] + \"__\"] || {})[name.substr(1)] || \"\";\n        name = name.replace(/^TM_/, \"\");\n        if (!this.variables.hasOwnProperty(name))\n            return \"\";\n        var value = this.variables[name];\n        if (typeof value == \"function\")\n            value = this.variables[name](editor, name, indentation);\n        return value == null ? \"\" : value;\n    };\n    SnippetManager.prototype.tmStrFormat = function (str, ch, editor) {\n        if (!ch.fmt)\n            return str;\n        var flag = ch.flag || \"\";\n        var re = ch.guard;\n        re = new RegExp(re, flag.replace(/[^gim]/g, \"\"));\n        var fmtTokens = typeof ch.fmt == \"string\" ? this.tokenizeTmSnippet(ch.fmt, \"formatString\") : ch.fmt;\n        var _self = this;\n        var formatted = str.replace(re, function () {\n            var oldArgs = _self.variables.__;\n            _self.variables.__ = [].slice.call(arguments);\n            var fmtParts = _self.resolveVariables(fmtTokens, editor);\n            var gChangeCase = \"E\";\n            for (var i = 0; i < fmtParts.length; i++) {\n                var ch = fmtParts[i];\n                if (typeof ch == \"object\") {\n                    fmtParts[i] = \"\";\n                    if (ch.changeCase && ch.local) {\n                        var next = fmtParts[i + 1];\n                        if (next && typeof next == \"string\") {\n                            if (ch.changeCase == \"u\")\n                                fmtParts[i] = next[0].toUpperCase();\n                            else\n                                fmtParts[i] = next[0].toLowerCase();\n                            fmtParts[i + 1] = next.substr(1);\n                        }\n                    }\n                    else if (ch.changeCase) {\n                        gChangeCase = ch.changeCase;\n                    }\n                }\n                else if (gChangeCase == \"U\") {\n                    fmtParts[i] = ch.toUpperCase();\n                }\n                else if (gChangeCase == \"L\") {\n                    fmtParts[i] = ch.toLowerCase();\n                }\n            }\n            _self.variables.__ = oldArgs;\n            return fmtParts.join(\"\");\n        });\n        return formatted;\n    };\n    SnippetManager.prototype.tmFormatFunction = function (str, ch, editor) {\n        if (ch.formatFunction == \"upcase\")\n            return str.toUpperCase();\n        if (ch.formatFunction == \"downcase\")\n            return str.toLowerCase();\n        return str;\n    };\n    SnippetManager.prototype.resolveVariables = function (snippet, editor) {\n        var result = [];\n        var indentation = \"\";\n        var afterNewLine = true;\n        for (var i = 0; i < snippet.length; i++) {\n            var ch = snippet[i];\n            if (typeof ch == \"string\") {\n                result.push(ch);\n                if (ch == \"\\n\") {\n                    afterNewLine = true;\n                    indentation = \"\";\n                }\n                else if (afterNewLine) {\n                    indentation = /^\\t*/.exec(ch)[0];\n                    afterNewLine = /\\S/.test(ch);\n                }\n                continue;\n            }\n            if (!ch)\n                continue;\n            afterNewLine = false;\n            if (ch.fmtString) {\n                var j = snippet.indexOf(ch, i + 1);\n                if (j == -1)\n                    j = snippet.length;\n                ch.fmt = snippet.slice(i + 1, j);\n                i = j;\n            }\n            if (ch.text) {\n                var value = this.getVariableValue(editor, ch.text, indentation) + \"\";\n                if (ch.fmtString)\n                    value = this.tmStrFormat(value, ch, editor);\n                if (ch.formatFunction)\n                    value = this.tmFormatFunction(value, ch, editor);\n                if (value && !ch.ifEnd) {\n                    result.push(value);\n                    gotoNext(ch);\n                }\n                else if (!value && ch.ifEnd) {\n                    gotoNext(ch.ifEnd);\n                }\n            }\n            else if (ch.elseEnd) {\n                gotoNext(ch.elseEnd);\n            }\n            else if (ch.tabstopId != null) {\n                result.push(ch);\n            }\n            else if (ch.changeCase != null) {\n                result.push(ch);\n            }\n        }\n        function gotoNext(ch) {\n            var i1 = snippet.indexOf(ch, i + 1);\n            if (i1 != -1)\n                i = i1;\n        }\n        return result;\n    };\n    SnippetManager.prototype.getDisplayTextForSnippet = function (editor, snippetText) {\n        var processedSnippet = processSnippetText.call(this, editor, snippetText);\n        return processedSnippet.text;\n    };\n    SnippetManager.prototype.insertSnippetForSelection = function (editor, snippetText, options) {\n        if (options === void 0) { options = {}; }\n        var processedSnippet = processSnippetText.call(this, editor, snippetText, options);\n        var range = editor.getSelectionRange();\n        var end = editor.session.replace(range, processedSnippet.text);\n        var tabstopManager = new TabstopManager(editor);\n        var selectionId = editor.inVirtualSelectionMode && editor.selection.index;\n        tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);\n    };\n    SnippetManager.prototype.insertSnippet = function (editor, snippetText, options) {\n        if (options === void 0) { options = {}; }\n        var self = this;\n        if (editor.inVirtualSelectionMode)\n            return self.insertSnippetForSelection(editor, snippetText, options);\n        editor.forEachSelection(function () {\n            self.insertSnippetForSelection(editor, snippetText, options);\n        }, null, { keepOrder: true });\n        if (editor.tabstopManager)\n            editor.tabstopManager.tabNext();\n    };\n    SnippetManager.prototype.$getScope = function (editor) {\n        var scope = editor.session.$mode.$id || \"\";\n        scope = scope.split(\"/\").pop();\n        if (scope === \"html\" || scope === \"php\") {\n            if (scope === \"php\" && !editor.session.$mode.inlinePhp)\n                scope = \"html\";\n            var c = editor.getCursorPosition();\n            var state = editor.session.getState(c.row);\n            if (typeof state === \"object\") {\n                state = state[0];\n            }\n            if (state.substring) {\n                if (state.substring(0, 3) == \"js-\")\n                    scope = \"javascript\";\n                else if (state.substring(0, 4) == \"css-\")\n                    scope = \"css\";\n                else if (state.substring(0, 4) == \"php-\")\n                    scope = \"php\";\n            }\n        }\n        return scope;\n    };\n    SnippetManager.prototype.getActiveScopes = function (editor) {\n        var scope = this.$getScope(editor);\n        var scopes = [scope];\n        var snippetMap = this.snippetMap;\n        if (snippetMap[scope] && snippetMap[scope].includeScopes) {\n            scopes.push.apply(scopes, snippetMap[scope].includeScopes);\n        }\n        scopes.push(\"_\");\n        return scopes;\n    };\n    SnippetManager.prototype.expandWithTab = function (editor, options) {\n        var self = this;\n        var result = editor.forEachSelection(function () {\n            return self.expandSnippetForSelection(editor, options);\n        }, null, { keepOrder: true });\n        if (result && editor.tabstopManager)\n            editor.tabstopManager.tabNext();\n        return result;\n    };\n    SnippetManager.prototype.expandSnippetForSelection = function (editor, options) {\n        var cursor = editor.getCursorPosition();\n        var line = editor.session.getLine(cursor.row);\n        var before = line.substring(0, cursor.column);\n        var after = line.substr(cursor.column);\n        var snippetMap = this.snippetMap;\n        var snippet;\n        this.getActiveScopes(editor).some(function (scope) {\n            var snippets = snippetMap[scope];\n            if (snippets)\n                snippet = this.findMatchingSnippet(snippets, before, after);\n            return !!snippet;\n        }, this);\n        if (!snippet)\n            return false;\n        if (options && options.dryRun)\n            return true;\n        editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);\n        this.variables.M__ = snippet.matchBefore;\n        this.variables.T__ = snippet.matchAfter;\n        this.insertSnippetForSelection(editor, snippet.content);\n        this.variables.M__ = this.variables.T__ = null;\n        return true;\n    };\n    SnippetManager.prototype.findMatchingSnippet = function (snippetList, before, after) {\n        for (var i = snippetList.length; i--;) {\n            var s = snippetList[i];\n            if (s.startRe && !s.startRe.test(before))\n                continue;\n            if (s.endRe && !s.endRe.test(after))\n                continue;\n            if (!s.startRe && !s.endRe)\n                continue;\n            s.matchBefore = s.startRe ? s.startRe.exec(before) : [\"\"];\n            s.matchAfter = s.endRe ? s.endRe.exec(after) : [\"\"];\n            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : \"\";\n            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : \"\";\n            return s;\n        }\n    };\n    SnippetManager.prototype.register = function (snippets, scope) {\n        var snippetMap = this.snippetMap;\n        var snippetNameMap = this.snippetNameMap;\n        var self = this;\n        if (!snippets)\n            snippets = [];\n        function wrapRegexp(src) {\n            if (src && !/^\\^?\\(.*\\)\\$?$|^\\\\b$/.test(src))\n                src = \"(?:\" + src + \")\";\n            return src || \"\";\n        }\n        function guardedRegexp(re, guard, opening) {\n            re = wrapRegexp(re);\n            guard = wrapRegexp(guard);\n            if (opening) {\n                re = guard + re;\n                if (re && re[re.length - 1] != \"$\")\n                    re = re + \"$\";\n            }\n            else {\n                re = re + guard;\n                if (re && re[0] != \"^\")\n                    re = \"^\" + re;\n            }\n            return new RegExp(re);\n        }\n        function addSnippet(s) {\n            if (!s.scope)\n                s.scope = scope || \"_\";\n            scope = s.scope;\n            if (!snippetMap[scope]) {\n                snippetMap[scope] = [];\n                snippetNameMap[scope] = {};\n            }\n            var map = snippetNameMap[scope];\n            if (s.name) {\n                var old = map[s.name];\n                if (old)\n                    self.unregister(old);\n                map[s.name] = s;\n            }\n            snippetMap[scope].push(s);\n            if (s.prefix)\n                s.tabTrigger = s.prefix;\n            if (!s.content && s.body)\n                s.content = Array.isArray(s.body) ? s.body.join(\"\\n\") : s.body;\n            if (s.tabTrigger && !s.trigger) {\n                if (!s.guard && /^\\w/.test(s.tabTrigger))\n                    s.guard = \"\\\\b\";\n                s.trigger = lang.escapeRegExp(s.tabTrigger);\n            }\n            if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)\n                return;\n            s.startRe = guardedRegexp(s.trigger, s.guard, true);\n            s.triggerRe = new RegExp(s.trigger);\n            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);\n            s.endTriggerRe = new RegExp(s.endTrigger);\n        }\n        if (Array.isArray(snippets)) {\n            snippets.forEach(addSnippet);\n        }\n        else {\n            Object.keys(snippets).forEach(function (key) {\n                addSnippet(snippets[key]);\n            });\n        }\n        this._signal(\"registerSnippets\", { scope: scope });\n    };\n    SnippetManager.prototype.unregister = function (snippets, scope) {\n        var snippetMap = this.snippetMap;\n        var snippetNameMap = this.snippetNameMap;\n        function removeSnippet(s) {\n            var nameMap = snippetNameMap[s.scope || scope];\n            if (nameMap && nameMap[s.name]) {\n                delete nameMap[s.name];\n                var map = snippetMap[s.scope || scope];\n                var i = map && map.indexOf(s);\n                if (i >= 0)\n                    map.splice(i, 1);\n            }\n        }\n        if (snippets.content)\n            removeSnippet(snippets);\n        else if (Array.isArray(snippets))\n            snippets.forEach(removeSnippet);\n    };\n    SnippetManager.prototype.parseSnippetFile = function (str) {\n        str = str.replace(/\\r/g, \"\");\n        var list = [], /**@type{Snippet}*/ snippet = {};\n        var re = /^#.*|^({[\\s\\S]*})\\s*$|^(\\S+) (.*)$|^((?:\\n*\\t.*)+)/gm;\n        var m;\n        while (m = re.exec(str)) {\n            if (m[1]) {\n                try {\n                    snippet = JSON.parse(m[1]);\n                    list.push(snippet);\n                }\n                catch (e) { }\n            }\n            if (m[4]) {\n                snippet.content = m[4].replace(/^\\t/gm, \"\");\n                list.push(snippet);\n                snippet = {};\n            }\n            else {\n                var key = m[2], val = m[3];\n                if (key == \"regex\") {\n                    var guardRe = /\\/((?:[^\\/\\\\]|\\\\.)*)|$/g;\n                    snippet.guard = guardRe.exec(val)[1];\n                    snippet.trigger = guardRe.exec(val)[1];\n                    snippet.endTrigger = guardRe.exec(val)[1];\n                    snippet.endGuard = guardRe.exec(val)[1];\n                }\n                else if (key == \"snippet\") {\n                    snippet.tabTrigger = val.match(/^\\S*/)[0];\n                    if (!snippet.name)\n                        snippet.name = val;\n                }\n                else if (key) {\n                    snippet[key] = val;\n                }\n            }\n        }\n        return list;\n    };\n    SnippetManager.prototype.getSnippetByName = function (name, editor) {\n        var snippetMap = this.snippetNameMap;\n        var snippet;\n        this.getActiveScopes(editor).some(function (scope) {\n            var snippets = snippetMap[scope];\n            if (snippets)\n                snippet = snippets[name];\n            return !!snippet;\n        }, this);\n        return snippet;\n    };\n    return SnippetManager;\n}());\noop.implement(SnippetManager.prototype, EventEmitter);\nvar processSnippetText = function (editor, snippetText, options) {\n    if (options === void 0) { options = {}; }\n    var cursor = editor.getCursorPosition();\n    var line = editor.session.getLine(cursor.row);\n    var tabString = editor.session.getTabString();\n    var indentString = line.match(/^\\s*/)[0];\n    if (cursor.column < indentString.length)\n        indentString = indentString.slice(0, cursor.column);\n    snippetText = snippetText.replace(/\\r/g, \"\");\n    var tokens = this.tokenizeTmSnippet(snippetText);\n    tokens = this.resolveVariables(tokens, editor);\n    tokens = tokens.map(function (x) {\n        if (x == \"\\n\" && !options.excludeExtraIndent)\n            return x + indentString;\n        if (typeof x == \"string\")\n            return x.replace(/\\t/g, tabString);\n        return x;\n    });\n    var tabstops = [];\n    tokens.forEach(function (p, i) {\n        if (typeof p != \"object\")\n            return;\n        var id = p.tabstopId;\n        var ts = tabstops[id];\n        if (!ts) {\n            ts = tabstops[id] = [];\n            ts.index = id;\n            ts.value = \"\";\n            ts.parents = {};\n        }\n        if (ts.indexOf(p) !== -1)\n            return;\n        if (p.choices && !ts.choices)\n            ts.choices = p.choices;\n        ts.push(p);\n        var i1 = tokens.indexOf(p, i + 1);\n        if (i1 === -1)\n            return;\n        var value = tokens.slice(i + 1, i1);\n        var isNested = value.some(function (t) { return typeof t === \"object\"; });\n        if (isNested && !ts.value) {\n            ts.value = value;\n        }\n        else if (value.length && (!ts.value || typeof ts.value !== \"string\")) {\n            ts.value = value.join(\"\");\n        }\n    });\n    tabstops.forEach(function (ts) { ts.length = 0; });\n    var expanding = {};\n    function copyValue(val) {\n        var copy = [];\n        for (var i = 0; i < val.length; i++) {\n            var p = val[i];\n            if (typeof p == \"object\") {\n                if (expanding[p.tabstopId])\n                    continue;\n                var j = val.lastIndexOf(p, i - 1);\n                p = copy[j] || { tabstopId: p.tabstopId };\n            }\n            copy[i] = p;\n        }\n        return copy;\n    }\n    for (var i = 0; i < tokens.length; i++) {\n        var p = tokens[i];\n        if (typeof p != \"object\")\n            continue;\n        var id = p.tabstopId;\n        var ts = tabstops[id];\n        var i1 = tokens.indexOf(p, i + 1);\n        if (expanding[id]) {\n            if (expanding[id] === p) {\n                delete expanding[id];\n                Object.keys(expanding).forEach(function (parentId) {\n                    ts.parents[parentId] = true;\n                });\n            }\n            continue;\n        }\n        expanding[id] = p;\n        var value = ts.value;\n        if (typeof value !== \"string\")\n            value = copyValue(value);\n        else if (p.fmt)\n            value = this.tmStrFormat(value, p, editor);\n        tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));\n        if (ts.indexOf(p) === -1)\n            ts.push(p);\n    }\n    var row = 0, column = 0;\n    var text = \"\";\n    tokens.forEach(function (t) {\n        if (typeof t === \"string\") {\n            var lines = t.split(\"\\n\");\n            if (lines.length > 1) {\n                column = lines[lines.length - 1].length;\n                row += lines.length - 1;\n            }\n            else\n                column += t.length;\n            text += t;\n        }\n        else if (t) {\n            if (!t.start)\n                t.start = { row: row, column: column };\n            else\n                t.end = { row: row, column: column };\n        }\n    });\n    return {\n        text: text,\n        tabstops: tabstops,\n        tokens: tokens\n    };\n};\nvar TabstopManager = /** @class */ (function () {\n    function TabstopManager(editor) {\n        this.index = 0;\n        this.ranges = [];\n        this.tabstops = [];\n        if (editor.tabstopManager)\n            return editor.tabstopManager;\n        editor.tabstopManager = this;\n        this.$onChange = this.onChange.bind(this);\n        this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;\n        this.$onChangeSession = this.onChangeSession.bind(this);\n        this.$onAfterExec = this.onAfterExec.bind(this);\n        this.attach(editor);\n    }\n    TabstopManager.prototype.attach = function (editor) {\n        this.$openTabstops = null;\n        this.selectedTabstop = null;\n        this.editor = editor;\n        this.session = editor.session;\n        this.editor.on(\"change\", this.$onChange);\n        this.editor.on(\"changeSelection\", this.$onChangeSelection);\n        this.editor.on(\"changeSession\", this.$onChangeSession);\n        this.editor.commands.on(\"afterExec\", this.$onAfterExec);\n        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n    };\n    TabstopManager.prototype.detach = function () {\n        this.tabstops.forEach(this.removeTabstopMarkers, this);\n        this.ranges.length = 0;\n        this.tabstops.length = 0;\n        this.selectedTabstop = null;\n        this.editor.off(\"change\", this.$onChange);\n        this.editor.off(\"changeSelection\", this.$onChangeSelection);\n        this.editor.off(\"changeSession\", this.$onChangeSession);\n        this.editor.commands.off(\"afterExec\", this.$onAfterExec);\n        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);\n        this.editor.tabstopManager = null;\n        this.session = null;\n        this.editor = null;\n    };\n    TabstopManager.prototype.onChange = function (delta) {\n        var isRemove = delta.action[0] == \"r\";\n        var selectedTabstop = this.selectedTabstop || {};\n        var parents = selectedTabstop.parents || {};\n        var tabstops = this.tabstops.slice();\n        for (var i = 0; i < tabstops.length; i++) {\n            var ts = tabstops[i];\n            var active = ts == selectedTabstop || parents[ts.index];\n            ts.rangeList.$bias = active ? 0 : 1;\n            if (delta.action == \"remove\" && ts !== selectedTabstop) {\n                var parentActive = ts.parents && ts.parents[selectedTabstop.index];\n                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);\n                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;\n                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);\n                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;\n                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);\n                for (var j = 0; j < toRemove.length; j++)\n                    this.removeRange(toRemove[j]);\n            }\n            ts.rangeList.$onChange(delta);\n        }\n        var session = this.session;\n        if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())\n            this.detach();\n    };\n    TabstopManager.prototype.updateLinkedFields = function () {\n        var ts = this.selectedTabstop;\n        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)\n            return;\n        this.$inChange = true;\n        var session = this.session;\n        var text = session.getTextRange(ts.firstNonLinked);\n        for (var i = 0; i < ts.length; i++) {\n            var range = ts[i];\n            if (!range.linked)\n                continue;\n            var original = range.original;\n            var fmt = exports.snippetManager.tmStrFormat(text, original, this.editor);\n            session.replace(range, fmt);\n        }\n        this.$inChange = false;\n    };\n    TabstopManager.prototype.onAfterExec = function (e) {\n        if (e.command && !e.command.readOnly)\n            this.updateLinkedFields();\n    };\n    TabstopManager.prototype.onChangeSelection = function () {\n        if (!this.editor)\n            return;\n        var lead = this.editor.selection.lead;\n        var anchor = this.editor.selection.anchor;\n        var isEmpty = this.editor.selection.isEmpty();\n        for (var i = 0; i < this.ranges.length; i++) {\n            if (this.ranges[i].linked)\n                continue;\n            var containsLead = this.ranges[i].contains(lead.row, lead.column);\n            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);\n            if (containsLead && containsAnchor)\n                return;\n        }\n        this.detach();\n    };\n    TabstopManager.prototype.onChangeSession = function () {\n        this.detach();\n    };\n    TabstopManager.prototype.tabNext = function (dir) {\n        var max = this.tabstops.length;\n        var index = this.index + (dir || 1);\n        index = Math.min(Math.max(index, 1), max);\n        if (index == max)\n            index = 0;\n        this.selectTabstop(index);\n        this.updateTabstopMarkers();\n        if (index === 0) {\n            this.detach();\n        }\n    };\n    TabstopManager.prototype.selectTabstop = function (index) {\n        this.$openTabstops = null;\n        var ts = this.tabstops[this.index];\n        if (ts)\n            this.addTabstopMarkers(ts);\n        this.index = index;\n        ts = this.tabstops[this.index];\n        if (!ts || !ts.length)\n            return;\n        this.selectedTabstop = ts;\n        var range = ts.firstNonLinked || ts;\n        if (ts.choices)\n            range.cursor = range.start;\n        if (!this.editor.inVirtualSelectionMode) {\n            var sel = this.editor.multiSelect;\n            sel.toSingleRange(range);\n            for (var i = 0; i < ts.length; i++) {\n                if (ts.hasLinkedRanges && ts[i].linked)\n                    continue;\n                sel.addRange(ts[i].clone(), true);\n            }\n        }\n        else {\n            this.editor.selection.fromOrientedRange(range);\n        }\n        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n        if (this.selectedTabstop && this.selectedTabstop.choices)\n            this.editor.execCommand(\"startAutocomplete\", { matches: this.selectedTabstop.choices });\n    };\n    TabstopManager.prototype.addTabstops = function (tabstops, start, end) {\n        var useLink = this.useLink || !this.editor.getOption(\"enableMultiselect\");\n        if (!this.$openTabstops)\n            this.$openTabstops = [];\n        if (!tabstops[0]) {\n            var p = Range.fromPoints(end, end);\n            moveRelative(p.start, start);\n            moveRelative(p.end, start);\n            tabstops[0] = [p];\n            tabstops[0].index = 0;\n        }\n        var i = this.index;\n        var arg = [i + 1, 0];\n        var ranges = this.ranges;\n        var snippetId = this.snippetId = (this.snippetId || 0) + 1;\n        tabstops.forEach(function (ts, index) {\n            var dest = this.$openTabstops[index] || ts;\n            dest.snippetId = snippetId;\n            for (var i = 0; i < ts.length; i++) {\n                var p = ts[i];\n                var range = Range.fromPoints(p.start, p.end || p.start);\n                movePoint(range.start, start);\n                movePoint(range.end, start);\n                range.original = p;\n                range.tabstop = dest;\n                ranges.push(range);\n                if (dest != ts)\n                    dest.unshift(range);\n                else\n                    dest[i] = range;\n                if (p.fmtString || (dest.firstNonLinked && useLink)) {\n                    range.linked = true;\n                    dest.hasLinkedRanges = true;\n                }\n                else if (!dest.firstNonLinked)\n                    dest.firstNonLinked = range;\n            }\n            if (!dest.firstNonLinked)\n                dest.hasLinkedRanges = false;\n            if (dest === ts) {\n                arg.push(dest);\n                this.$openTabstops[index] = dest;\n            }\n            this.addTabstopMarkers(dest);\n            dest.rangeList = dest.rangeList || new RangeList();\n            dest.rangeList.$bias = 0;\n            dest.rangeList.addList(dest);\n        }, this);\n        if (arg.length > 2) {\n            if (this.tabstops.length)\n                arg.push(arg.splice(2, 1)[0]);\n            this.tabstops.splice.apply(this.tabstops, arg);\n        }\n    };\n    TabstopManager.prototype.addTabstopMarkers = function (ts) {\n        var session = this.session;\n        ts.forEach(function (range) {\n            if (!range.markerId)\n                range.markerId = session.addMarker(range, \"ace_snippet-marker\", \"text\");\n        });\n    };\n    TabstopManager.prototype.removeTabstopMarkers = function (ts) {\n        var session = this.session;\n        ts.forEach(function (range) {\n            session.removeMarker(range.markerId);\n            range.markerId = null;\n        });\n    };\n    TabstopManager.prototype.updateTabstopMarkers = function () {\n        if (!this.selectedTabstop)\n            return;\n        var currentSnippetId = this.selectedTabstop.snippetId;\n        if (this.selectedTabstop.index === 0) {\n            currentSnippetId--;\n        }\n        this.tabstops.forEach(function (ts) {\n            if (ts.snippetId === currentSnippetId)\n                this.addTabstopMarkers(ts);\n            else\n                this.removeTabstopMarkers(ts);\n        }, this);\n    };\n    TabstopManager.prototype.removeRange = function (range) {\n        var i = range.tabstop.indexOf(range);\n        if (i != -1)\n            range.tabstop.splice(i, 1);\n        i = this.ranges.indexOf(range);\n        if (i != -1)\n            this.ranges.splice(i, 1);\n        i = range.tabstop.rangeList.ranges.indexOf(range);\n        if (i != -1)\n            range.tabstop.splice(i, 1);\n        this.session.removeMarker(range.markerId);\n        if (!range.tabstop.length) {\n            i = this.tabstops.indexOf(range.tabstop);\n            if (i != -1)\n                this.tabstops.splice(i, 1);\n            if (!this.tabstops.length)\n                this.detach();\n        }\n    };\n    return TabstopManager;\n}());\nTabstopManager.prototype.keyboardHandler = new HashHandler();\nTabstopManager.prototype.keyboardHandler.bindKeys({\n    \"Tab\": function (editor) {\n        if (exports.snippetManager && exports.snippetManager.expandWithTab(editor))\n            return;\n        editor.tabstopManager.tabNext(1);\n        editor.renderer.scrollCursorIntoView();\n    },\n    \"Shift-Tab\": function (editor) {\n        editor.tabstopManager.tabNext(-1);\n        editor.renderer.scrollCursorIntoView();\n    },\n    \"Esc\": function (editor) {\n        editor.tabstopManager.detach();\n    }\n});\nvar movePoint = function (point, diff) {\n    if (point.row == 0)\n        point.column += diff.column;\n    point.row += diff.row;\n};\nvar moveRelative = function (point, start) {\n    if (point.row == start.row)\n        point.column -= start.column;\n    point.row -= start.row;\n};\ndom.importCssString(\"\\n.ace_snippet-marker {\\n    -moz-box-sizing: border-box;\\n    box-sizing: border-box;\\n    background: rgba(194, 193, 208, 0.09);\\n    border: 1px dotted rgba(211, 208, 235, 0.62);\\n    position: absolute;\\n}\", \"snippets.css\", false);\nexports.snippetManager = new SnippetManager();\nvar Editor = require(\"./editor\").Editor;\n(function () {\n    this.insertSnippet = function (content, options) {\n        return exports.snippetManager.insertSnippet(this, content, options);\n    };\n    this.expandSnippet = function (options) {\n        return exports.snippetManager.expandWithTab(this, options);\n    };\n}).call(Editor.prototype);\n\n});\n\nace.define(\"ace/autocomplete/popup\",[\"require\",\"exports\",\"module\",\"ace/virtual_renderer\",\"ace/editor\",\"ace/range\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/lib/dom\",\"ace/config\",\"ace/lib/useragent\"], function(require, exports, module){\"use strict\";\nvar Renderer = require(\"../virtual_renderer\").VirtualRenderer;\nvar Editor = require(\"../editor\").Editor;\nvar Range = require(\"../range\").Range;\nvar event = require(\"../lib/event\");\nvar lang = require(\"../lib/lang\");\nvar dom = require(\"../lib/dom\");\nvar nls = require(\"../config\").nls;\nvar userAgent = require(\"./../lib/useragent\");\nvar getAriaId = function (index) {\n    return \"suggest-aria-id:\".concat(index);\n};\nvar popupAriaRole = userAgent.isSafari ? \"menu\" : \"listbox\";\nvar optionAriaRole = userAgent.isSafari ? \"menuitem\" : \"option\";\nvar ariaActiveState = userAgent.isSafari ? \"aria-current\" : \"aria-selected\";\nvar $singleLineEditor = function (el) {\n    var renderer = new Renderer(el);\n    renderer.$maxLines = 4;\n    var editor = new Editor(renderer);\n    editor.setHighlightActiveLine(false);\n    editor.setShowPrintMargin(false);\n    editor.renderer.setShowGutter(false);\n    editor.renderer.setHighlightGutterLine(false);\n    editor.$mouseHandler.$focusTimeout = 0;\n    editor.$highlightTagPending = true;\n    return editor;\n};\nvar AcePopup = /** @class */ (function () {\n    function AcePopup(parentNode) {\n        var el = dom.createElement(\"div\");\n        var popup = $singleLineEditor(el);\n        if (parentNode) {\n            parentNode.appendChild(el);\n        }\n        el.style.display = \"none\";\n        popup.renderer.content.style.cursor = \"default\";\n        popup.renderer.setStyle(\"ace_autocomplete\");\n        popup.renderer.$textLayer.element.setAttribute(\"role\", popupAriaRole);\n        popup.renderer.$textLayer.element.setAttribute(\"aria-roledescription\", nls(\"autocomplete.popup.aria-roledescription\", \"Autocomplete suggestions\"));\n        popup.renderer.$textLayer.element.setAttribute(\"aria-label\", nls(\"autocomplete.popup.aria-label\", \"Autocomplete suggestions\"));\n        popup.renderer.textarea.setAttribute(\"aria-hidden\", \"true\");\n        popup.setOption(\"displayIndentGuides\", false);\n        popup.setOption(\"dragDelay\", 150);\n        var noop = function () { };\n        popup.focus = noop;\n        popup.$isFocused = true;\n        popup.renderer.$cursorLayer.restartTimer = noop;\n        popup.renderer.$cursorLayer.element.style.opacity = \"0\";\n        popup.renderer.$maxLines = 8;\n        popup.renderer.$keepTextAreaAtCursor = false;\n        popup.setHighlightActiveLine(false);\n        popup.session.highlight(\"\");\n        popup.session.$searchHighlight.clazz = \"ace_highlight-marker\";\n        popup.on(\"mousedown\", function (e) {\n            var pos = e.getDocumentPosition();\n            popup.selection.moveToPosition(pos);\n            selectionMarker.start.row = selectionMarker.end.row = pos.row;\n            e.stop();\n        });\n        var lastMouseEvent;\n        var hoverMarker = new Range(-1, 0, -1, Infinity);\n        var selectionMarker = new Range(-1, 0, -1, Infinity);\n        selectionMarker.id = popup.session.addMarker(selectionMarker, \"ace_active-line\", \"fullLine\");\n        popup.setSelectOnHover = function (val) {\n            if (!val) {\n                hoverMarker.id = popup.session.addMarker(hoverMarker, \"ace_line-hover\", \"fullLine\");\n            }\n            else if (hoverMarker.id) {\n                popup.session.removeMarker(hoverMarker.id);\n                hoverMarker.id = null;\n            }\n        };\n        popup.setSelectOnHover(false);\n        popup.on(\"mousemove\", function (e) {\n            if (!lastMouseEvent) {\n                lastMouseEvent = e;\n                return;\n            }\n            if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {\n                return;\n            }\n            lastMouseEvent = e;\n            lastMouseEvent.scrollTop = popup.renderer.scrollTop;\n            popup.isMouseOver = true;\n            var row = lastMouseEvent.getDocumentPosition().row;\n            if (hoverMarker.start.row != row) {\n                if (!hoverMarker.id)\n                    popup.setRow(row);\n                setHoverMarker(row);\n            }\n        });\n        popup.renderer.on(\"beforeRender\", function () {\n            if (lastMouseEvent && hoverMarker.start.row != -1) {\n                lastMouseEvent.$pos = null;\n                var row = lastMouseEvent.getDocumentPosition().row;\n                if (!hoverMarker.id)\n                    popup.setRow(row);\n                setHoverMarker(row, true);\n            }\n        });\n        popup.renderer.on(\"afterRender\", function () {\n            var t = popup.renderer.$textLayer;\n            for (var row = t.config.firstRow, l = t.config.lastRow; row <= l; row++) {\n                var popupRowElement = /** @type {HTMLElement|null} */ (t.element.childNodes[row - t.config.firstRow]);\n                popupRowElement.setAttribute(\"role\", optionAriaRole);\n                popupRowElement.setAttribute(\"aria-roledescription\", nls(\"autocomplete.popup.item.aria-roledescription\", \"item\"));\n                popupRowElement.setAttribute(\"aria-setsize\", popup.data.length);\n                popupRowElement.setAttribute(\"aria-describedby\", \"doc-tooltip\");\n                popupRowElement.setAttribute(\"aria-posinset\", row + 1);\n                var rowData = popup.getData(row);\n                if (rowData) {\n                    var ariaLabel = \"\".concat(rowData.caption || rowData.value).concat(rowData.meta ? \", \".concat(rowData.meta) : '');\n                    popupRowElement.setAttribute(\"aria-label\", ariaLabel);\n                }\n                var highlightedSpans = popupRowElement.querySelectorAll(\".ace_completion-highlight\");\n                highlightedSpans.forEach(function (span) {\n                    span.setAttribute(\"role\", \"mark\");\n                });\n            }\n        });\n        popup.renderer.on(\"afterRender\", function () {\n            var row = popup.getRow();\n            var t = popup.renderer.$textLayer;\n            var selected = /** @type {HTMLElement|null} */ (t.element.childNodes[row - t.config.firstRow]);\n            var el = document.activeElement; // Active element is textarea of main editor\n            if (selected !== popup.selectedNode && popup.selectedNode) {\n                dom.removeCssClass(popup.selectedNode, \"ace_selected\");\n                popup.selectedNode.removeAttribute(ariaActiveState);\n                popup.selectedNode.removeAttribute(\"id\");\n            }\n            el.removeAttribute(\"aria-activedescendant\");\n            popup.selectedNode = selected;\n            if (selected) {\n                var ariaId = getAriaId(row);\n                dom.addCssClass(selected, \"ace_selected\");\n                selected.id = ariaId;\n                t.element.setAttribute(\"aria-activedescendant\", ariaId);\n                el.setAttribute(\"aria-activedescendant\", ariaId);\n                selected.setAttribute(ariaActiveState, \"true\");\n            }\n        });\n        var hideHoverMarker = function () { setHoverMarker(-1); };\n        var setHoverMarker = function (row, suppressRedraw) {\n            if (row !== hoverMarker.start.row) {\n                hoverMarker.start.row = hoverMarker.end.row = row;\n                if (!suppressRedraw)\n                    popup.session._emit(\"changeBackMarker\");\n                popup._emit(\"changeHoverMarker\");\n            }\n        };\n        popup.getHoveredRow = function () {\n            return hoverMarker.start.row;\n        };\n        event.addListener(popup.container, \"mouseout\", function () {\n            popup.isMouseOver = false;\n            hideHoverMarker();\n        });\n        popup.on(\"hide\", hideHoverMarker);\n        popup.on(\"changeSelection\", hideHoverMarker);\n        popup.session.doc.getLength = function () {\n            return popup.data.length;\n        };\n        popup.session.doc.getLine = function (i) {\n            var data = popup.data[i];\n            if (typeof data == \"string\")\n                return data;\n            return (data && data.value) || \"\";\n        };\n        var bgTokenizer = popup.session.bgTokenizer;\n        bgTokenizer.$tokenizeRow = function (row) {\n            var data = popup.data[row];\n            var tokens = [];\n            if (!data)\n                return tokens;\n            if (typeof data == \"string\")\n                data = { value: data };\n            var caption = data.caption || data.value || data.name;\n            function addToken(value, className) {\n                value && tokens.push({\n                    type: (data.className || \"\") + (className || \"\"),\n                    value: value\n                });\n            }\n            var lower = caption.toLowerCase();\n            var filterText = (popup.filterText || \"\").toLowerCase();\n            var lastIndex = 0;\n            var lastI = 0;\n            for (var i = 0; i <= filterText.length; i++) {\n                if (i != lastI && (data.matchMask & (1 << i) || i == filterText.length)) {\n                    var sub = filterText.slice(lastI, i);\n                    lastI = i;\n                    var index = lower.indexOf(sub, lastIndex);\n                    if (index == -1)\n                        continue;\n                    addToken(caption.slice(lastIndex, index), \"\");\n                    lastIndex = index + sub.length;\n                    addToken(caption.slice(index, lastIndex), \"completion-highlight\");\n                }\n            }\n            addToken(caption.slice(lastIndex, caption.length), \"\");\n            tokens.push({ type: \"completion-spacer\", value: \" \" });\n            if (data.meta)\n                tokens.push({ type: \"completion-meta\", value: data.meta });\n            if (data.message)\n                tokens.push({ type: \"completion-message\", value: data.message });\n            return tokens;\n        };\n        bgTokenizer.$updateOnChange = noop;\n        bgTokenizer.start = noop;\n        popup.session.$computeWidth = function () {\n            return this.screenWidth = 0;\n        };\n        popup.isOpen = false;\n        popup.isTopdown = false;\n        popup.autoSelect = true;\n        popup.filterText = \"\";\n        popup.isMouseOver = false;\n        popup.data = [];\n        popup.setData = function (list, filterText) {\n            popup.filterText = filterText || \"\";\n            popup.setValue(lang.stringRepeat(\"\\n\", list.length), -1);\n            popup.data = list || [];\n            popup.setRow(0);\n        };\n        popup.getData = function (row) {\n            return popup.data[row];\n        };\n        popup.getRow = function () {\n            return selectionMarker.start.row;\n        };\n        popup.setRow = function (line) {\n            line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));\n            if (selectionMarker.start.row != line) {\n                popup.selection.clearSelection();\n                selectionMarker.start.row = selectionMarker.end.row = line || 0;\n                popup.session._emit(\"changeBackMarker\");\n                popup.moveCursorTo(line || 0, 0);\n                if (popup.isOpen)\n                    popup._signal(\"select\");\n            }\n        };\n        popup.on(\"changeSelection\", function () {\n            if (popup.isOpen)\n                popup.setRow(popup.selection.lead.row);\n            popup.renderer.scrollCursorIntoView();\n        });\n        popup.hide = function () {\n            this.container.style.display = \"none\";\n            popup.anchorPos = null;\n            popup.anchor = null;\n            if (popup.isOpen) {\n                popup.isOpen = false;\n                this._signal(\"hide\");\n            }\n        };\n        popup.tryShow = function (pos, lineHeight, anchor, forceShow) {\n            if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor &&\n                popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left &&\n                popup.anchor === anchor) {\n                return true;\n            }\n            var el = this.container;\n            var screenHeight = window.innerHeight;\n            var screenWidth = window.innerWidth;\n            var renderer = this.renderer;\n            var maxH = renderer.$maxLines * lineHeight * 1.4;\n            var dims = { top: 0, bottom: 0, left: 0 };\n            var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;\n            var spaceAbove = pos.top - 3 * this.$borderSize;\n            if (!anchor) {\n                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {\n                    anchor = \"bottom\";\n                }\n                else {\n                    anchor = \"top\";\n                }\n            }\n            if (anchor === \"top\") {\n                dims.bottom = pos.top - this.$borderSize;\n                dims.top = dims.bottom - maxH;\n            }\n            else if (anchor === \"bottom\") {\n                dims.top = pos.top + lineHeight + this.$borderSize;\n                dims.bottom = dims.top + maxH;\n            }\n            var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;\n            if (!forceShow && !fitsX) {\n                return false;\n            }\n            if (!fitsX) {\n                if (anchor === \"top\") {\n                    renderer.$maxPixelHeight = spaceAbove;\n                }\n                else {\n                    renderer.$maxPixelHeight = spaceBelow;\n                }\n            }\n            else {\n                renderer.$maxPixelHeight = null;\n            }\n            if (anchor === \"top\") {\n                el.style.top = \"\";\n                el.style.bottom = (screenHeight - dims.bottom) + \"px\";\n                popup.isTopdown = false;\n            }\n            else {\n                el.style.top = dims.top + \"px\";\n                el.style.bottom = \"\";\n                popup.isTopdown = true;\n            }\n            el.style.display = \"\";\n            var left = pos.left;\n            if (left + el.offsetWidth > screenWidth)\n                left = screenWidth - el.offsetWidth;\n            el.style.left = left + \"px\";\n            el.style.right = \"\";\n            if (!popup.isOpen) {\n                popup.isOpen = true;\n                this._signal(\"show\");\n                lastMouseEvent = null;\n            }\n            popup.anchorPos = pos;\n            popup.anchor = anchor;\n            return true;\n        };\n        popup.show = function (pos, lineHeight, topdownOnly) {\n            this.tryShow(pos, lineHeight, topdownOnly ? \"bottom\" : undefined, true);\n        };\n        popup.goTo = function (where) {\n            var row = this.getRow();\n            var max = this.session.getLength() - 1;\n            switch (where) {\n                case \"up\":\n                    row = row <= 0 ? max : row - 1;\n                    break;\n                case \"down\":\n                    row = row >= max ? -1 : row + 1;\n                    break;\n                case \"start\":\n                    row = 0;\n                    break;\n                case \"end\":\n                    row = max;\n                    break;\n            }\n            this.setRow(row);\n        };\n        popup.getTextLeftOffset = function () {\n            return this.$borderSize + this.renderer.$padding + this.$imageSize;\n        };\n        popup.$imageSize = 0;\n        popup.$borderSize = 1;\n        return popup;\n    }\n    return AcePopup;\n}());\ndom.importCssString(\"\\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\\n    background-color: #CAD6FA;\\n    z-index: 1;\\n}\\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\\n    background-color: #3a674e;\\n}\\n.ace_editor.ace_autocomplete .ace_line-hover {\\n    border: 1px solid #abbffe;\\n    margin-top: -1px;\\n    background: rgba(233,233,253,0.4);\\n    position: absolute;\\n    z-index: 2;\\n}\\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\\n    border: 1px solid rgba(109, 150, 13, 0.8);\\n    background: rgba(58, 103, 78, 0.62);\\n}\\n.ace_completion-meta {\\n    opacity: 0.5;\\n    margin-left: 0.9em;\\n}\\n.ace_completion-message {\\n    margin-left: 0.9em;\\n    color: blue;\\n}\\n.ace_editor.ace_autocomplete .ace_completion-highlight{\\n    color: #2d69c7;\\n}\\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\\n    color: #93ca12;\\n}\\n.ace_editor.ace_autocomplete {\\n    width: 300px;\\n    z-index: 200000;\\n    border: 1px lightgray solid;\\n    position: fixed;\\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\\n    line-height: 1.4;\\n    background: #fefefe;\\n    color: #111;\\n}\\n.ace_dark.ace_editor.ace_autocomplete {\\n    border: 1px #484747 solid;\\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\\n    line-height: 1.4;\\n    background: #25282c;\\n    color: #c1c1c1;\\n}\\n.ace_autocomplete .ace_text-layer  {\\n    width: calc(100% - 8px);\\n}\\n.ace_autocomplete .ace_line {\\n    display: flex;\\n    align-items: center;\\n}\\n.ace_autocomplete .ace_line > * {\\n    min-width: 0;\\n    flex: 0 0 auto;\\n}\\n.ace_autocomplete .ace_line .ace_ {\\n    flex: 0 1 auto;\\n    overflow: hidden;\\n    text-overflow: ellipsis;\\n}\\n.ace_autocomplete .ace_completion-spacer {\\n    flex: 1;\\n}\\n.ace_autocomplete.ace_loading:after  {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0px;\\n    height: 2px;\\n    width: 8%;\\n    background: blue;\\n    z-index: 100;\\n    animation: ace_progress 3s infinite linear;\\n    animation-delay: 300ms;\\n    transform: translateX(-100%) scaleX(1);\\n}\\n@keyframes ace_progress {\\n    0% { transform: translateX(-100%) scaleX(1) }\\n    50% { transform: translateX(625%) scaleX(2) } \\n    100% { transform: translateX(1500%) scaleX(3) } \\n}\\n@media (prefers-reduced-motion) {\\n    .ace_autocomplete.ace_loading:after {\\n        transform: translateX(625%) scaleX(2);\\n        animation: none;\\n     }\\n}\\n\", \"autocompletion.css\", false);\nexports.AcePopup = AcePopup;\nexports.$singleLineEditor = $singleLineEditor;\nexports.getAriaId = getAriaId;\n\n});\n\nace.define(\"ace/autocomplete/inline_screenreader\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nvar AceInlineScreenReader = /** @class */ (function () {\n    function AceInlineScreenReader(editor) {\n        this.editor = editor;\n        this.screenReaderDiv = document.createElement(\"div\");\n        this.screenReaderDiv.classList.add(\"ace_screenreader-only\");\n        this.editor.container.appendChild(this.screenReaderDiv);\n    }\n    AceInlineScreenReader.prototype.setScreenReaderContent = function (content) {\n        if (!this.popup && this.editor.completer && /**@type{import(\"../autocomplete\").Autocomplete}*/ (this.editor.completer).popup) {\n            this.popup = /**@type{import(\"../autocomplete\").Autocomplete}*/ (this.editor.completer).popup;\n            this.popup.renderer.on(\"afterRender\", function () {\n                var row = this.popup.getRow();\n                var t = this.popup.renderer.$textLayer;\n                var selected = t.element.childNodes[row - t.config.firstRow];\n                if (selected) {\n                    var idString = \"doc-tooltip \";\n                    for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {\n                        idString += \"ace-inline-screenreader-line-\".concat(lineIndex, \" \");\n                    }\n                    selected.setAttribute(\"aria-describedby\", idString);\n                }\n            }.bind(this));\n        }\n        while (this.screenReaderDiv.firstChild) {\n            this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);\n        }\n        this._lines = content.split(/\\r\\n|\\r|\\n/);\n        var codeElement = this.createCodeBlock();\n        this.screenReaderDiv.appendChild(codeElement);\n    };\n    AceInlineScreenReader.prototype.destroy = function () {\n        this.screenReaderDiv.remove();\n    };\n    AceInlineScreenReader.prototype.createCodeBlock = function () {\n        var container = document.createElement(\"pre\");\n        container.setAttribute(\"id\", \"ace-inline-screenreader\");\n        for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {\n            var codeElement = document.createElement(\"code\");\n            codeElement.setAttribute(\"id\", \"ace-inline-screenreader-line-\".concat(lineIndex));\n            var line = document.createTextNode(this._lines[lineIndex]);\n            codeElement.appendChild(line);\n            container.appendChild(codeElement);\n        }\n        return container;\n    };\n    return AceInlineScreenReader;\n}());\nexports.AceInlineScreenReader = AceInlineScreenReader;\n\n});\n\nace.define(\"ace/autocomplete/inline\",[\"require\",\"exports\",\"module\",\"ace/snippets\",\"ace/autocomplete/inline_screenreader\"], function(require, exports, module){\"use strict\";\nvar snippetManager = require(\"../snippets\").snippetManager;\nvar AceInlineScreenReader = require(\"./inline_screenreader\").AceInlineScreenReader;\nvar AceInline = /** @class */ (function () {\n    function AceInline() {\n        this.editor = null;\n    }\n    AceInline.prototype.show = function (editor, completion, prefix) {\n        prefix = prefix || \"\";\n        if (editor && this.editor && this.editor !== editor) {\n            this.hide();\n            this.editor = null;\n            this.inlineScreenReader = null;\n        }\n        if (!editor || !completion) {\n            return false;\n        }\n        if (!this.inlineScreenReader) {\n            this.inlineScreenReader = new AceInlineScreenReader(editor);\n        }\n        var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;\n        if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {\n            return false;\n        }\n        this.editor = editor;\n        this.inlineScreenReader.setScreenReaderContent(displayText);\n        displayText = displayText.slice(prefix.length);\n        if (displayText === \"\") {\n            editor.removeGhostText();\n        }\n        else {\n            editor.setGhostText(displayText);\n        }\n        return true;\n    };\n    AceInline.prototype.isOpen = function () {\n        if (!this.editor) {\n            return false;\n        }\n        return !!this.editor.renderer.$ghostText;\n    };\n    AceInline.prototype.hide = function () {\n        if (!this.editor) {\n            return false;\n        }\n        this.editor.removeGhostText();\n        return true;\n    };\n    AceInline.prototype.destroy = function () {\n        this.hide();\n        this.editor = null;\n        if (this.inlineScreenReader) {\n            this.inlineScreenReader.destroy();\n            this.inlineScreenReader = null;\n        }\n    };\n    return AceInline;\n}());\nexports.AceInline = AceInline;\n\n});\n\nace.define(\"ace/autocomplete/util\",[\"require\",\"exports\",\"module\"], function(require, exports, module){\"use strict\";\nexports.parForEach = function (array, fn, callback) {\n    var completed = 0;\n    var arLength = array.length;\n    if (arLength === 0)\n        callback();\n    for (var i = 0; i < arLength; i++) {\n        fn(array[i], function (result, err) {\n            completed++;\n            if (completed === arLength)\n                callback(result, err);\n        });\n    }\n};\nvar ID_REGEX = /[a-zA-Z_0-9\\$\\-\\u00A2-\\u2000\\u2070-\\uFFFF]/;\nexports.retrievePrecedingIdentifier = function (text, pos, regex) {\n    regex = regex || ID_REGEX;\n    var buf = [];\n    for (var i = pos - 1; i >= 0; i--) {\n        if (regex.test(text[i]))\n            buf.push(text[i]);\n        else\n            break;\n    }\n    return buf.reverse().join(\"\");\n};\nexports.retrieveFollowingIdentifier = function (text, pos, regex) {\n    regex = regex || ID_REGEX;\n    var buf = [];\n    for (var i = pos; i < text.length; i++) {\n        if (regex.test(text[i]))\n            buf.push(text[i]);\n        else\n            break;\n    }\n    return buf;\n};\nexports.getCompletionPrefix = function (editor) {\n    var pos = editor.getCursorPosition();\n    var line = editor.session.getLine(pos.row);\n    var prefix;\n    editor.completers.forEach(function (completer) {\n        if (completer.identifierRegexps) {\n            completer.identifierRegexps.forEach(function (identifierRegex) {\n                if (!prefix && identifierRegex)\n                    prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);\n            }.bind(this));\n        }\n    }.bind(this));\n    return prefix || this.retrievePrecedingIdentifier(line, pos.column);\n};\nexports.triggerAutocomplete = function (editor, previousChar) {\n    var previousChar = previousChar == null\n        ? editor.session.getPrecedingCharacter()\n        : previousChar;\n    return editor.completers.some(function (completer) {\n        if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {\n            return completer.triggerCharacters.includes(previousChar);\n        }\n    });\n};\n\n});\n\nace.define(\"ace/autocomplete\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\",\"ace/autocomplete/popup\",\"ace/autocomplete/inline\",\"ace/autocomplete/popup\",\"ace/autocomplete/util\",\"ace/lib/lang\",\"ace/lib/dom\",\"ace/snippets\",\"ace/config\",\"ace/lib/event\",\"ace/lib/scroll\"], function(require, exports, module){\"use strict\";\nvar HashHandler = require(\"./keyboard/hash_handler\").HashHandler;\nvar AcePopup = require(\"./autocomplete/popup\").AcePopup;\nvar AceInline = require(\"./autocomplete/inline\").AceInline;\nvar getAriaId = require(\"./autocomplete/popup\").getAriaId;\nvar util = require(\"./autocomplete/util\");\nvar lang = require(\"./lib/lang\");\nvar dom = require(\"./lib/dom\");\nvar snippetManager = require(\"./snippets\").snippetManager;\nvar config = require(\"./config\");\nvar event = require(\"./lib/event\");\nvar preventParentScroll = require(\"./lib/scroll\").preventParentScroll;\nvar destroyCompleter = function (e, editor) {\n    editor.completer && editor.completer.destroy();\n};\nvar Autocomplete = /** @class */ (function () {\n    function Autocomplete() {\n        this.autoInsert = false;\n        this.autoSelect = true;\n        this.autoShown = false;\n        this.exactMatch = false;\n        this.inlineEnabled = false;\n        this.keyboardHandler = new HashHandler();\n        this.keyboardHandler.bindKeys(this.commands);\n        this.parentNode = null;\n        this.setSelectOnHover = false;\n        this.hasSeen = new Set();\n        this.showLoadingState = false;\n        this.stickySelectionDelay = 500;\n        this.blurListener = this.blurListener.bind(this);\n        this.changeListener = this.changeListener.bind(this);\n        this.mousedownListener = this.mousedownListener.bind(this);\n        this.mousewheelListener = this.mousewheelListener.bind(this);\n        this.onLayoutChange = this.onLayoutChange.bind(this);\n        this.changeTimer = lang.delayedCall(function () {\n            this.updateCompletions(true);\n        }.bind(this));\n        this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);\n        this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);\n        this.stickySelectionTimer = lang.delayedCall(function () {\n            this.stickySelection = true;\n        }.bind(this), this.stickySelectionDelay);\n        this.$firstOpenTimer = lang.delayedCall(/**@this{Autocomplete}*/ function () {\n            var initialPosition = this.completionProvider && this.completionProvider.initialPosition;\n            if (this.autoShown || (this.popup && this.popup.isOpen) || !initialPosition || this.editor.completers.length === 0)\n                return;\n            this.completions = new FilteredList(Autocomplete.completionsForLoading);\n            this.openPopup(this.editor, initialPosition.prefix, false);\n            this.popup.renderer.setStyle(\"ace_loading\", true);\n        }.bind(this), this.stickySelectionDelay);\n    }\n    Object.defineProperty(Autocomplete, \"completionsForLoading\", {\n        get: function () {\n            return [{\n                    caption: config.nls(\"autocomplete.loading\", \"Loading...\"),\n                    value: \"\"\n                }];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Autocomplete.prototype.$init = function () {\n        this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);\n        this.popup.on(\"click\", function (e) {\n            this.insertMatch();\n            e.stop();\n        }.bind(this));\n        this.popup.focus = this.editor.focus.bind(this.editor);\n        this.popup.on(\"show\", this.$onPopupShow.bind(this));\n        this.popup.on(\"hide\", this.$onHidePopup.bind(this));\n        this.popup.on(\"select\", this.$onPopupChange.bind(this));\n        event.addListener(this.popup.container, \"mouseout\", this.mouseOutListener.bind(this));\n        this.popup.on(\"changeHoverMarker\", this.tooltipTimer.bind(null, null));\n        this.popup.renderer.on(\"afterRender\", this.$onPopupRender.bind(this));\n        return this.popup;\n    };\n    Autocomplete.prototype.$initInline = function () {\n        if (!this.inlineEnabled || this.inlineRenderer)\n            return;\n        this.inlineRenderer = new AceInline();\n        return this.inlineRenderer;\n    };\n    Autocomplete.prototype.getPopup = function () {\n        return this.popup || this.$init();\n    };\n    Autocomplete.prototype.$onHidePopup = function () {\n        if (this.inlineRenderer) {\n            this.inlineRenderer.hide();\n        }\n        this.hideDocTooltip();\n        this.stickySelectionTimer.cancel();\n        this.popupTimer.cancel();\n        this.stickySelection = false;\n    };\n    Autocomplete.prototype.$seen = function (completion) {\n        if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === \"function\") {\n            completion.completer.onSeen(this.editor, completion);\n            this.hasSeen.add(completion);\n        }\n    };\n    Autocomplete.prototype.$onPopupChange = function (hide) {\n        if (this.inlineRenderer && this.inlineEnabled) {\n            var completion = hide ? null : this.popup.getData(this.popup.getRow());\n            this.$updateGhostText(completion);\n            if (this.popup.isMouseOver && this.setSelectOnHover) {\n                this.tooltipTimer.call(null, null);\n                return;\n            }\n            this.popupTimer.schedule();\n            this.tooltipTimer.schedule();\n        }\n        else {\n            this.popupTimer.call(null, null);\n            this.tooltipTimer.call(null, null);\n        }\n    };\n    Autocomplete.prototype.$updateGhostText = function (completion) {\n        var row = this.base.row;\n        var column = this.base.column;\n        var cursorColumn = this.editor.getCursorPosition().column;\n        var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);\n        if (!this.inlineRenderer.show(this.editor, completion, prefix)) {\n            this.inlineRenderer.hide();\n        }\n        else {\n            this.$seen(completion);\n        }\n    };\n    Autocomplete.prototype.$onPopupRender = function () {\n        var inlineEnabled = this.inlineRenderer && this.inlineEnabled;\n        if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {\n            for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {\n                var completion = this.popup.getData(i);\n                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {\n                    this.$seen(completion);\n                }\n            }\n        }\n    };\n    Autocomplete.prototype.$onPopupShow = function (hide) {\n        this.$onPopupChange(hide);\n        this.stickySelection = false;\n        if (this.stickySelectionDelay >= 0)\n            this.stickySelectionTimer.schedule(this.stickySelectionDelay);\n    };\n    Autocomplete.prototype.observeLayoutChanges = function () {\n        if (this.$elements || !this.editor)\n            return;\n        window.addEventListener(\"resize\", this.onLayoutChange, { passive: true });\n        window.addEventListener(\"wheel\", this.mousewheelListener);\n        var el = this.editor.container.parentNode;\n        var elements = [];\n        while (el) {\n            elements.push(el);\n            el.addEventListener(\"scroll\", this.onLayoutChange, { passive: true });\n            el = el.parentNode;\n        }\n        this.$elements = elements;\n    };\n    Autocomplete.prototype.unObserveLayoutChanges = function () {\n        var _this = this;\n        window.removeEventListener(\"resize\", this.onLayoutChange, { passive: true });\n        window.removeEventListener(\"wheel\", this.mousewheelListener);\n        this.$elements && this.$elements.forEach(function (el) {\n            el.removeEventListener(\"scroll\", _this.onLayoutChange, { passive: true });\n        });\n        this.$elements = null;\n    };\n    Autocomplete.prototype.onLayoutChange = function () {\n        if (!this.popup.isOpen)\n            return this.unObserveLayoutChanges();\n        this.$updatePopupPosition();\n        this.updateDocTooltip();\n    };\n    Autocomplete.prototype.$updatePopupPosition = function () {\n        var editor = this.editor;\n        var renderer = editor.renderer;\n        var lineHeight = renderer.layerConfig.lineHeight;\n        var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);\n        pos.left -= this.popup.getTextLeftOffset();\n        var rect = editor.container.getBoundingClientRect();\n        pos.top += rect.top - renderer.layerConfig.offset;\n        pos.left += rect.left - editor.renderer.scrollLeft;\n        pos.left += renderer.gutterWidth;\n        var posGhostText = {\n            top: pos.top,\n            left: pos.left\n        };\n        if (renderer.$ghostText && renderer.$ghostTextWidget) {\n            if (this.base.row === renderer.$ghostText.position.row) {\n                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;\n            }\n        }\n        var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;\n        var lowestPosition = editorContainerBottom < posGhostText.top ?\n            { top: editorContainerBottom, left: posGhostText.left } :\n            posGhostText;\n        if (this.popup.tryShow(lowestPosition, lineHeight, \"bottom\")) {\n            return;\n        }\n        if (this.popup.tryShow(pos, lineHeight, \"top\")) {\n            return;\n        }\n        this.popup.show(pos, lineHeight);\n    };\n    Autocomplete.prototype.openPopup = function (editor, prefix, keepPopupPosition) {\n        this.$firstOpenTimer.cancel();\n        if (!this.popup)\n            this.$init();\n        if (this.inlineEnabled && !this.inlineRenderer)\n            this.$initInline();\n        this.popup.autoSelect = this.autoSelect;\n        this.popup.setSelectOnHover(this.setSelectOnHover);\n        var oldRow = this.popup.getRow();\n        var previousSelectedItem = this.popup.data[oldRow];\n        this.popup.setData(this.completions.filtered, this.completions.filterText);\n        if (this.editor.textInput.setAriaOptions) {\n            this.editor.textInput.setAriaOptions({\n                activeDescendant: getAriaId(this.popup.getRow()),\n                inline: this.inlineEnabled\n            });\n        }\n        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n        var newRow;\n        if (this.stickySelection)\n            newRow = this.popup.data.indexOf(previousSelectedItem);\n        if (!newRow || newRow === -1)\n            newRow = 0;\n        this.popup.setRow(this.autoSelect ? newRow : -1);\n        if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])\n            this.$onPopupChange();\n        var inlineEnabled = this.inlineRenderer && this.inlineEnabled;\n        if (newRow === oldRow && inlineEnabled) {\n            var completion = this.popup.getData(this.popup.getRow());\n            this.$updateGhostText(completion);\n        }\n        if (!keepPopupPosition) {\n            this.popup.setTheme(editor.getTheme());\n            this.popup.setFontSize(editor.getFontSize());\n            this.$updatePopupPosition();\n            if (this.tooltipNode) {\n                this.updateDocTooltip();\n            }\n        }\n        this.changeTimer.cancel();\n        this.observeLayoutChanges();\n    };\n    Autocomplete.prototype.detach = function () {\n        if (this.editor) {\n            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);\n            this.editor.off(\"changeSelection\", this.changeListener);\n            this.editor.off(\"blur\", this.blurListener);\n            this.editor.off(\"mousedown\", this.mousedownListener);\n            this.editor.off(\"mousewheel\", this.mousewheelListener);\n        }\n        this.$firstOpenTimer.cancel();\n        this.changeTimer.cancel();\n        this.hideDocTooltip();\n        if (this.completionProvider) {\n            this.completionProvider.detach();\n        }\n        if (this.popup && this.popup.isOpen)\n            this.popup.hide();\n        if (this.popup && this.popup.renderer) {\n            this.popup.renderer.off(\"afterRender\", this.$onPopupRender);\n        }\n        if (this.base)\n            this.base.detach();\n        this.activated = false;\n        this.completionProvider = this.completions = this.base = null;\n        this.unObserveLayoutChanges();\n    };\n    Autocomplete.prototype.changeListener = function (e) {\n        var cursor = this.editor.selection.lead;\n        if (cursor.row != this.base.row || cursor.column < this.base.column) {\n            this.detach();\n        }\n        if (this.activated)\n            this.changeTimer.schedule();\n        else\n            this.detach();\n    };\n    Autocomplete.prototype.blurListener = function (e) {\n        var el = document.activeElement;\n        var text = this.editor.textInput.getElement();\n        var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);\n        var container = this.popup && this.popup.container;\n        if (el != text && el.parentNode != container && !fromTooltip\n            && el != this.tooltipNode && e.relatedTarget != text) {\n            this.detach();\n        }\n    };\n    Autocomplete.prototype.mousedownListener = function (e) {\n        this.detach();\n    };\n    Autocomplete.prototype.mousewheelListener = function (e) {\n        if (this.popup && !this.popup.isMouseOver)\n            this.detach();\n    };\n    Autocomplete.prototype.mouseOutListener = function (e) {\n        if (this.popup.isOpen)\n            this.$updatePopupPosition();\n    };\n    Autocomplete.prototype.goTo = function (where) {\n        this.popup.goTo(where);\n    };\n    Autocomplete.prototype.insertMatch = function (data, options) {\n        if (!data)\n            data = this.popup.getData(this.popup.getRow());\n        if (!data)\n            return false;\n        if (data.value === \"\") // Explicitly given nothing to insert, e.g. \"No suggestion state\"\n            return this.detach();\n        var completions = this.completions;\n        var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);\n        if (this.completions == completions)\n            this.detach();\n        return result;\n    };\n    Autocomplete.prototype.showPopup = function (editor, options) {\n        if (this.editor)\n            this.detach();\n        this.activated = true;\n        this.editor = editor;\n        if (editor.completer != this) {\n            if (editor.completer)\n                editor.completer.detach();\n            editor.completer = this;\n        }\n        editor.on(\"changeSelection\", this.changeListener);\n        editor.on(\"blur\", this.blurListener);\n        editor.on(\"mousedown\", this.mousedownListener);\n        editor.on(\"mousewheel\", this.mousewheelListener);\n        this.updateCompletions(false, options);\n    };\n    Autocomplete.prototype.getCompletionProvider = function (initialPosition) {\n        if (!this.completionProvider)\n            this.completionProvider = new CompletionProvider(initialPosition);\n        return this.completionProvider;\n    };\n    Autocomplete.prototype.gatherCompletions = function (editor, callback) {\n        return this.getCompletionProvider().gatherCompletions(editor, callback);\n    };\n    Autocomplete.prototype.updateCompletions = function (keepPopupPosition, options) {\n        if (keepPopupPosition && this.base && this.completions) {\n            var pos = this.editor.getCursorPosition();\n            var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });\n            if (prefix == this.completions.filterText)\n                return;\n            this.completions.setFilter(prefix);\n            if (!this.completions.filtered.length)\n                return this.detach();\n            if (this.completions.filtered.length == 1\n                && this.completions.filtered[0].value == prefix\n                && !this.completions.filtered[0].snippet)\n                return this.detach();\n            this.openPopup(this.editor, prefix, keepPopupPosition);\n            return;\n        }\n        if (options && options.matches) {\n            var pos = this.editor.getSelectionRange().start;\n            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);\n            this.base.$insertRight = true;\n            this.completions = new FilteredList(options.matches);\n            this.getCompletionProvider().completions = this.completions;\n            return this.openPopup(this.editor, \"\", keepPopupPosition);\n        }\n        var session = this.editor.getSession();\n        var pos = this.editor.getCursorPosition();\n        var prefix = util.getCompletionPrefix(this.editor);\n        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);\n        this.base.$insertRight = true;\n        var completionOptions = {\n            exactMatch: this.exactMatch,\n            ignoreCaption: this.ignoreCaption\n        };\n        this.getCompletionProvider({\n            prefix: prefix,\n            pos: pos\n        }).provideCompletions(this.editor, completionOptions, \n        function (err, completions, finished) {\n            var filtered = completions.filtered;\n            var prefix = util.getCompletionPrefix(this.editor);\n            this.$firstOpenTimer.cancel();\n            if (finished) {\n                if (!filtered.length) {\n                    var emptyMessage = !this.autoShown && this.emptyMessage;\n                    if (typeof emptyMessage == \"function\")\n                        emptyMessage = this.emptyMessage(prefix);\n                    if (emptyMessage) {\n                        var completionsForEmpty = [{\n                                caption: emptyMessage,\n                                value: \"\"\n                            }\n                        ];\n                        this.completions = new FilteredList(completionsForEmpty);\n                        this.openPopup(this.editor, prefix, keepPopupPosition);\n                        this.popup.renderer.setStyle(\"ace_loading\", false);\n                        this.popup.renderer.setStyle(\"ace_empty-message\", true);\n                        return;\n                    }\n                    return this.detach();\n                }\n                if (filtered.length == 1 && filtered[0].value == prefix\n                    && !filtered[0].snippet)\n                    return this.detach();\n                if (this.autoInsert && !this.autoShown && filtered.length == 1)\n                    return this.insertMatch(filtered[0]);\n            }\n            this.completions = !finished && this.showLoadingState ?\n                new FilteredList(Autocomplete.completionsForLoading.concat(filtered), completions.filterText) :\n                completions;\n            this.openPopup(this.editor, prefix, keepPopupPosition);\n            this.popup.renderer.setStyle(\"ace_empty-message\", false);\n            this.popup.renderer.setStyle(\"ace_loading\", !finished);\n        }.bind(this));\n        if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {\n            this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);\n        }\n    };\n    Autocomplete.prototype.cancelContextMenu = function () {\n        this.editor.$mouseHandler.cancelContextMenu();\n    };\n    Autocomplete.prototype.updateDocTooltip = function () {\n        var popup = this.popup;\n        var all = this.completions.filtered;\n        var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);\n        var doc = null;\n        if (!selected || !this.editor || !this.popup.isOpen)\n            return this.hideDocTooltip();\n        var completersLength = this.editor.completers.length;\n        for (var i = 0; i < completersLength; i++) {\n            var completer = this.editor.completers[i];\n            if (completer.getDocTooltip && selected.completerId === completer.id) {\n                doc = completer.getDocTooltip(selected);\n                break;\n            }\n        }\n        if (!doc && typeof selected != \"string\")\n            doc = selected;\n        if (typeof doc == \"string\")\n            doc = { docText: doc };\n        if (!doc || !(doc.docHTML || doc.docText))\n            return this.hideDocTooltip();\n        this.showDocTooltip(doc);\n    };\n    Autocomplete.prototype.showDocTooltip = function (item) {\n        if (!this.tooltipNode) {\n            this.tooltipNode = dom.createElement(\"div\");\n            this.tooltipNode.style.margin = \"0\";\n            this.tooltipNode.style.pointerEvents = \"auto\";\n            this.tooltipNode.style.overscrollBehavior = \"contain\";\n            this.tooltipNode.tabIndex = -1;\n            this.tooltipNode.onblur = this.blurListener.bind(this);\n            this.tooltipNode.onclick = this.onTooltipClick.bind(this);\n            this.tooltipNode.id = \"doc-tooltip\";\n            this.tooltipNode.setAttribute(\"role\", \"tooltip\");\n            this.tooltipNode.addEventListener(\"wheel\", preventParentScroll);\n        }\n        var theme = this.editor.renderer.theme;\n        this.tooltipNode.className = \"ace_tooltip ace_doc-tooltip \" +\n            (theme.isDark ? \"ace_dark \" : \"\") + (theme.cssClass || \"\");\n        var tooltipNode = this.tooltipNode;\n        if (item.docHTML) {\n            tooltipNode.innerHTML = item.docHTML;\n        }\n        else if (item.docText) {\n            tooltipNode.textContent = item.docText;\n        }\n        if (!tooltipNode.parentNode)\n            this.popup.container.appendChild(this.tooltipNode);\n        var popup = this.popup;\n        var rect = popup.container.getBoundingClientRect();\n        tooltipNode.style.top = popup.container.style.top;\n        tooltipNode.style.bottom = popup.container.style.bottom;\n        tooltipNode.style.display = \"block\";\n        if (window.innerWidth - rect.right < 320) {\n            if (rect.left < 320) {\n                if (popup.isTopdown) {\n                    tooltipNode.style.top = rect.bottom + \"px\";\n                    tooltipNode.style.left = rect.left + \"px\";\n                    tooltipNode.style.right = \"\";\n                    tooltipNode.style.bottom = \"\";\n                }\n                else {\n                    tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + \"px\";\n                    tooltipNode.style.left = rect.left + \"px\";\n                    tooltipNode.style.right = \"\";\n                    tooltipNode.style.bottom = \"\";\n                }\n            }\n            else {\n                tooltipNode.style.right = window.innerWidth - rect.left + \"px\";\n                tooltipNode.style.left = \"\";\n            }\n        }\n        else {\n            tooltipNode.style.left = (rect.right + 1) + \"px\";\n            tooltipNode.style.right = \"\";\n        }\n    };\n    Autocomplete.prototype.hideDocTooltip = function () {\n        this.tooltipTimer.cancel();\n        if (!this.tooltipNode)\n            return;\n        var el = this.tooltipNode;\n        if (!this.editor.isFocused() && document.activeElement == el)\n            this.editor.focus();\n        this.tooltipNode = null;\n        if (el.parentNode)\n            el.parentNode.removeChild(el);\n    };\n    Autocomplete.prototype.onTooltipClick = function (e) {\n        var a = e.target;\n        while (a && a != this.tooltipNode) {\n            if (a.nodeName == \"A\" && a.href) {\n                a.rel = \"noreferrer\";\n                a.target = \"_blank\";\n                break;\n            }\n            a = a.parentNode;\n        }\n    };\n    Autocomplete.prototype.destroy = function () {\n        this.detach();\n        if (this.popup) {\n            this.popup.destroy();\n            var el = this.popup.container;\n            if (el && el.parentNode)\n                el.parentNode.removeChild(el);\n        }\n        if (this.editor && this.editor.completer == this) {\n            this.editor.off(\"destroy\", destroyCompleter);\n            this.editor.completer = null;\n        }\n        this.inlineRenderer = this.popup = this.editor = null;\n    };\n    Autocomplete.for = function (editor) {\n        if (editor.completer instanceof Autocomplete) {\n            return editor.completer;\n        }\n        if (editor.completer) {\n            editor.completer.destroy();\n            editor.completer = null;\n        }\n        if (config.get(\"sharedPopups\")) {\n            if (!Autocomplete[\"$sharedInstance\"])\n                Autocomplete[\"$sharedInstance\"] = new Autocomplete();\n            editor.completer = Autocomplete[\"$sharedInstance\"];\n        }\n        else {\n            editor.completer = new Autocomplete();\n            editor.once(\"destroy\", destroyCompleter);\n        }\n        return editor.completer;\n    };\n    return Autocomplete;\n}());\nAutocomplete.prototype.commands = {\n    \"Up\": function (editor) { editor.completer.goTo(\"up\"); },\n    \"Down\": function (editor) { editor.completer.goTo(\"down\"); },\n    \"Ctrl-Up|Ctrl-Home\": function (editor) { editor.completer.goTo(\"start\"); },\n    \"Ctrl-Down|Ctrl-End\": function (editor) { editor.completer.goTo(\"end\"); },\n    \"Esc\": function (editor) { editor.completer.detach(); },\n    \"Return\": function (editor) { return editor.completer.insertMatch(); },\n    \"Shift-Return\": function (editor) { editor.completer.insertMatch(null, { deleteSuffix: true }); },\n    \"Tab\": function (editor) {\n        var result = editor.completer.insertMatch();\n        if (!result && !editor.tabstopManager)\n            editor.completer.goTo(\"down\");\n        else\n            return result;\n    },\n    \"Backspace\": function (editor) {\n        editor.execCommand(\"backspace\");\n        var prefix = util.getCompletionPrefix(editor);\n        if (!prefix && editor.completer)\n            editor.completer.detach();\n    },\n    \"PageUp\": function (editor) { editor.completer.popup.gotoPageUp(); },\n    \"PageDown\": function (editor) { editor.completer.popup.gotoPageDown(); }\n};\nAutocomplete.startCommand = {\n    name: \"startAutocomplete\",\n    exec: function (editor, options) {\n        var completer = Autocomplete.for(editor);\n        completer.autoInsert = false;\n        completer.autoSelect = true;\n        completer.autoShown = false;\n        completer.showPopup(editor, options);\n        completer.cancelContextMenu();\n    },\n    bindKey: \"Ctrl-Space|Ctrl-Shift-Space|Alt-Space\"\n};\nvar CompletionProvider = /** @class */ (function () {\n    function CompletionProvider(initialPosition) {\n        this.initialPosition = initialPosition;\n        this.active = true;\n    }\n    CompletionProvider.prototype.insertByIndex = function (editor, index, options) {\n        if (!this.completions || !this.completions.filtered) {\n            return false;\n        }\n        return this.insertMatch(editor, this.completions.filtered[index], options);\n    };\n    CompletionProvider.prototype.insertMatch = function (editor, data, options) {\n        if (!data)\n            return false;\n        editor.startOperation({ command: { name: \"insertMatch\" } });\n        if (data.completer && data.completer.insertMatch) {\n            data.completer.insertMatch(editor, data);\n        }\n        else {\n            if (!this.completions)\n                return false;\n            var replaceBefore = this.completions.filterText.length;\n            var replaceAfter = 0;\n            if (data.range && data.range.start.row === data.range.end.row) {\n                replaceBefore -= this.initialPosition.prefix.length;\n                replaceBefore += this.initialPosition.pos.column - data.range.start.column;\n                replaceAfter += data.range.end.column - this.initialPosition.pos.column;\n            }\n            if (replaceBefore || replaceAfter) {\n                var ranges;\n                if (editor.selection.getAllRanges) {\n                    ranges = editor.selection.getAllRanges();\n                }\n                else {\n                    ranges = [editor.getSelectionRange()];\n                }\n                for (var i = 0, range; range = ranges[i]; i++) {\n                    range.start.column -= replaceBefore;\n                    range.end.column += replaceAfter;\n                    editor.session.remove(range);\n                }\n            }\n            if (data.snippet) {\n                snippetManager.insertSnippet(editor, data.snippet);\n            }\n            else {\n                this.$insertString(editor, data);\n            }\n            if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == \"function\") {\n                data.completer.onInsert(editor, data);\n            }\n            if (data.command && data.command === \"startAutocomplete\") {\n                editor.execCommand(data.command);\n            }\n        }\n        editor.endOperation();\n        return true;\n    };\n    CompletionProvider.prototype.$insertString = function (editor, data) {\n        var text = data.value || data;\n        editor.execCommand(\"insertstring\", text);\n    };\n    CompletionProvider.prototype.gatherCompletions = function (editor, callback) {\n        var session = editor.getSession();\n        var pos = editor.getCursorPosition();\n        var prefix = util.getCompletionPrefix(editor);\n        var matches = [];\n        this.completers = editor.completers;\n        var total = editor.completers.length;\n        editor.completers.forEach(function (completer, i) {\n            completer.getCompletions(editor, session, pos, prefix, function (err, results) {\n                if (completer.hideInlinePreview)\n                    results = results.map(function (result) {\n                        return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });\n                    });\n                if (!err && results)\n                    matches = matches.concat(results);\n                callback(null, {\n                    prefix: util.getCompletionPrefix(editor),\n                    matches: matches,\n                    finished: (--total === 0)\n                });\n            });\n        });\n        return true;\n    };\n    CompletionProvider.prototype.provideCompletions = function (editor, options, callback) {\n        var processResults = function (results) {\n            var prefix = results.prefix;\n            var matches = results.matches;\n            this.completions = new FilteredList(matches);\n            if (options.exactMatch)\n                this.completions.exactMatch = true;\n            if (options.ignoreCaption)\n                this.completions.ignoreCaption = true;\n            this.completions.setFilter(prefix);\n            if (results.finished || this.completions.filtered.length)\n                callback(null, this.completions, results.finished);\n        }.bind(this);\n        var isImmediate = true;\n        var immediateResults = null;\n        this.gatherCompletions(editor, function (err, results) {\n            if (!this.active) {\n                return;\n            }\n            if (err) {\n                callback(err, [], true);\n                this.detach();\n            }\n            var prefix = results.prefix;\n            if (prefix.indexOf(results.prefix) !== 0)\n                return;\n            if (isImmediate) {\n                immediateResults = results;\n                return;\n            }\n            processResults(results);\n        }.bind(this));\n        isImmediate = false;\n        if (immediateResults) {\n            var results = immediateResults;\n            immediateResults = null;\n            processResults(results);\n        }\n    };\n    CompletionProvider.prototype.detach = function () {\n        this.active = false;\n        this.completers && this.completers.forEach(function (completer) {\n            if (typeof completer.cancel === \"function\") {\n                completer.cancel();\n            }\n        });\n    };\n    return CompletionProvider;\n}());\nvar FilteredList = /** @class */ (function () {\n    function FilteredList(array, filterText) {\n        this.all = array;\n        this.filtered = array;\n        this.filterText = filterText || \"\";\n        this.exactMatch = false;\n        this.ignoreCaption = false;\n    }\n    FilteredList.prototype.setFilter = function (str) {\n        if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)\n            var matches = this.filtered;\n        else\n            var matches = this.all;\n        this.filterText = str;\n        matches = this.filterCompletions(matches, this.filterText);\n        matches = matches.sort(function (a, b) {\n            return b.exactMatch - a.exactMatch || b.$score - a.$score\n                || (a.caption || a.value).localeCompare(b.caption || b.value);\n        });\n        var prev = null;\n        matches = matches.filter(function (item) {\n            var caption = item.snippet || item.caption || item.value;\n            if (caption === prev)\n                return false;\n            prev = caption;\n            return true;\n        });\n        this.filtered = matches;\n    };\n    FilteredList.prototype.filterCompletions = function (items, needle) {\n        var results = [];\n        var upper = needle.toUpperCase();\n        var lower = needle.toLowerCase();\n        loop: for (var i = 0, item; item = items[i]; i++) {\n            if (item.skipFilter) {\n                item.$score = item.score;\n                results.push(item);\n                continue;\n            }\n            var caption = (!this.ignoreCaption && item.caption) || item.value || item.snippet;\n            if (!caption)\n                continue;\n            var lastIndex = -1;\n            var matchMask = 0;\n            var penalty = 0;\n            var index, distance;\n            if (this.exactMatch) {\n                if (needle !== caption.substr(0, needle.length))\n                    continue loop;\n            }\n            else {\n                var fullMatchIndex = caption.toLowerCase().indexOf(lower);\n                if (fullMatchIndex > -1) {\n                    penalty = fullMatchIndex;\n                }\n                else {\n                    for (var j = 0; j < needle.length; j++) {\n                        var i1 = caption.indexOf(lower[j], lastIndex + 1);\n                        var i2 = caption.indexOf(upper[j], lastIndex + 1);\n                        index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;\n                        if (index < 0)\n                            continue loop;\n                        distance = index - lastIndex - 1;\n                        if (distance > 0) {\n                            if (lastIndex === -1)\n                                penalty += 10;\n                            penalty += distance;\n                            matchMask = matchMask | (1 << j);\n                        }\n                        lastIndex = index;\n                    }\n                }\n            }\n            item.matchMask = matchMask;\n            item.exactMatch = penalty ? 0 : 1;\n            item.$score = (item.score || 0) - penalty;\n            results.push(item);\n        }\n        return results;\n    };\n    return FilteredList;\n}());\nexports.Autocomplete = Autocomplete;\nexports.CompletionProvider = CompletionProvider;\nexports.FilteredList = FilteredList;\n\n});\n\nace.define(\"ace/autocomplete/text_completer\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){var Range = require(\"../range\").Range;\nvar splitRegex = /[^a-zA-Z_0-9\\$\\-\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]+/;\nfunction getWordIndex(doc, pos) {\n    var textBefore = doc.getTextRange(Range.fromPoints({\n        row: 0,\n        column: 0\n    }, pos));\n    return textBefore.split(splitRegex).length - 1;\n}\nfunction wordDistance(doc, pos) {\n    var prefixPos = getWordIndex(doc, pos);\n    var words = doc.getValue().split(splitRegex);\n    var wordScores = Object.create(null);\n    var currentWord = words[prefixPos];\n    words.forEach(function (word, idx) {\n        if (!word || word === currentWord)\n            return;\n        var distance = Math.abs(prefixPos - idx);\n        var score = words.length - distance;\n        if (wordScores[word]) {\n            wordScores[word] = Math.max(score, wordScores[word]);\n        }\n        else {\n            wordScores[word] = score;\n        }\n    });\n    return wordScores;\n}\nexports.getCompletions = function (editor, session, pos, prefix, callback) {\n    var wordScore = wordDistance(session, pos);\n    var wordList = Object.keys(wordScore);\n    callback(null, wordList.map(function (word) {\n        return {\n            caption: word,\n            value: word,\n            score: wordScore[word],\n            meta: \"local\"\n        };\n    }));\n};\n\n});\n\nace.define(\"ace/ext/language_tools\",[\"require\",\"exports\",\"module\",\"ace/snippets\",\"ace/autocomplete\",\"ace/config\",\"ace/lib/lang\",\"ace/autocomplete/util\",\"ace/autocomplete/text_completer\",\"ace/editor\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar snippetManager = require(\"../snippets\").snippetManager;\nvar Autocomplete = require(\"../autocomplete\").Autocomplete;\nvar config = require(\"../config\");\nvar lang = require(\"../lib/lang\");\nvar util = require(\"../autocomplete/util\");\nvar textCompleter = require(\"../autocomplete/text_completer\");\nvar keyWordCompleter = {\n    getCompletions: function (editor, session, pos, prefix, callback) {\n        if (session.$mode.completer) {\n            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);\n        }\n        var state = editor.session.getState(pos.row);\n        var completions = session.$mode.getCompletions(state, session, pos, prefix);\n        completions = completions.map(function (el) {\n            el.completerId = keyWordCompleter.id;\n            return el;\n        });\n        callback(null, completions);\n    },\n    id: \"keywordCompleter\"\n};\nvar transformSnippetTooltip = function (str) {\n    var record = {};\n    return str.replace(/\\${(\\d+)(:(.*?))?}/g, function (_, p1, p2, p3) {\n        return (record[p1] = p3 || '');\n    }).replace(/\\$(\\d+?)/g, function (_, p1) {\n        return record[p1];\n    });\n};\nvar snippetCompleter = {\n    getCompletions: function (editor, session, pos, prefix, callback) {\n        var scopes = [];\n        var token = session.getTokenAt(pos.row, pos.column);\n        if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\\.xml$/))\n            scopes.push('html-tag');\n        else\n            scopes = snippetManager.getActiveScopes(editor);\n        var snippetMap = snippetManager.snippetMap;\n        var completions = [];\n        scopes.forEach(function (scope) {\n            var snippets = snippetMap[scope] || [];\n            for (var i = snippets.length; i--;) {\n                var s = snippets[i];\n                var caption = s.name || s.tabTrigger;\n                if (!caption)\n                    continue;\n                completions.push({\n                    caption: caption,\n                    snippet: s.content,\n                    meta: s.tabTrigger && !s.name ? s.tabTrigger + \"\\u21E5 \" : \"snippet\",\n                    completerId: snippetCompleter.id\n                });\n            }\n        }, this);\n        callback(null, completions);\n    },\n    getDocTooltip: function (item) {\n        if (item.snippet && !item.docHTML) {\n            item.docHTML = [\n                \"<b>\", lang.escapeHTML(item.caption), \"</b>\", \"<hr></hr>\",\n                lang.escapeHTML(transformSnippetTooltip(item.snippet))\n            ].join(\"\");\n        }\n    },\n    id: \"snippetCompleter\"\n};\nvar completers = [snippetCompleter, textCompleter, keyWordCompleter];\nexports.setCompleters = function (val) {\n    completers.length = 0;\n    if (val)\n        completers.push.apply(completers, val);\n};\nexports.addCompleter = function (completer) {\n    completers.push(completer);\n};\nexports.textCompleter = textCompleter;\nexports.keyWordCompleter = keyWordCompleter;\nexports.snippetCompleter = snippetCompleter;\nvar expandSnippet = {\n    name: \"expandSnippet\",\n    exec: function (editor) {\n        return snippetManager.expandWithTab(editor);\n    },\n    bindKey: \"Tab\"\n};\nvar onChangeMode = function (e, editor) {\n    loadSnippetsForMode(editor.session.$mode);\n};\nvar loadSnippetsForMode = function (mode) {\n    if (typeof mode == \"string\")\n        mode = config.$modes[mode];\n    if (!mode)\n        return;\n    if (!snippetManager.files)\n        snippetManager.files = {};\n    loadSnippetFile(mode.$id, mode.snippetFileId);\n    if (mode.modes)\n        mode.modes.forEach(loadSnippetsForMode);\n};\nvar loadSnippetFile = function (id, snippetFilePath) {\n    if (!snippetFilePath || !id || snippetManager.files[id])\n        return;\n    snippetManager.files[id] = {};\n    config.loadModule(snippetFilePath, function (m) {\n        if (!m)\n            return;\n        snippetManager.files[id] = m;\n        if (!m.snippets && m.snippetText)\n            m.snippets = snippetManager.parseSnippetFile(m.snippetText);\n        snippetManager.register(m.snippets || [], m.scope);\n        if (m.includeScopes) {\n            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;\n            m.includeScopes.forEach(function (x) {\n                loadSnippetsForMode(\"ace/mode/\" + x);\n            });\n        }\n    });\n};\nvar doLiveAutocomplete = function (e) {\n    var editor = e.editor;\n    var hasCompleter = editor.completer && editor.completer.activated;\n    if (e.command.name === \"backspace\") {\n        if (hasCompleter && !util.getCompletionPrefix(editor))\n            editor.completer.detach();\n    }\n    else if (e.command.name === \"insertstring\" && !hasCompleter) {\n        lastExecEvent = e;\n        var delay = e.editor.$liveAutocompletionDelay;\n        if (delay) {\n            liveAutocompleteTimer.delay(delay);\n        }\n        else {\n            showLiveAutocomplete(e);\n        }\n    }\n};\nvar lastExecEvent;\nvar liveAutocompleteTimer = lang.delayedCall(function () {\n    showLiveAutocomplete(lastExecEvent);\n}, 0);\nvar showLiveAutocomplete = function (e) {\n    var editor = e.editor;\n    var prefix = util.getCompletionPrefix(editor);\n    var previousChar = e.args;\n    var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);\n    if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {\n        var completer = Autocomplete.for(editor);\n        completer.autoShown = true;\n        completer.showPopup(editor);\n    }\n};\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    enableBasicAutocompletion: {\n        set: function (val) {\n            if (val) {\n                if (!this.completers)\n                    this.completers = Array.isArray(val) ? val : completers;\n                this.commands.addCommand(Autocomplete.startCommand);\n            }\n            else {\n                this.commands.removeCommand(Autocomplete.startCommand);\n            }\n        },\n        value: false\n    },\n    enableLiveAutocompletion: {\n        set: function (val) {\n            if (val) {\n                if (!this.completers)\n                    this.completers = Array.isArray(val) ? val : completers;\n                this.commands.on('afterExec', doLiveAutocomplete);\n            }\n            else {\n                this.commands.off('afterExec', doLiveAutocomplete);\n            }\n        },\n        value: false\n    },\n    liveAutocompletionDelay: {\n        initialValue: 0\n    },\n    liveAutocompletionThreshold: {\n        initialValue: 0\n    },\n    enableSnippets: {\n        set: function (val) {\n            if (val) {\n                this.commands.addCommand(expandSnippet);\n                this.on(\"changeMode\", onChangeMode);\n                onChangeMode(null, this);\n            }\n            else {\n                this.commands.removeCommand(expandSnippet);\n                this.off(\"changeMode\", onChangeMode);\n            }\n        },\n        value: false\n    }\n});\n\n});                (function() {\n                    ace.require([\"ace/ext/language_tools\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hY2UtYnVpbGRzL3NyYy1ub2NvbmZsaWN0L2V4dC1sYW5ndWFnZV90b29scy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsc1FBQXNRO0FBQ3RRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDLGdDQUFnQztBQUNsRSxrQ0FBa0MsbUJBQW1CO0FBQ3JELDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLGlCQUFpQjtBQUNyRCwwQ0FBMEMsaUJBQWlCO0FBQzNELHFDQUFxQyxrQkFBa0I7QUFDdkQsMENBQTBDLGVBQWU7QUFDekQsZ0RBQWdELGdCQUFnQjtBQUNoRSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELHdDQUF3QyxpQkFBaUI7QUFDekQsOENBQThDLGtCQUFrQjtBQUNoRSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFLHNDQUFzQyxtQkFBbUI7QUFDekQsc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixrQkFBa0IsU0FBUztBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QixrQkFBa0IsK0NBQStDO0FBQ2pFLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQ0FBcUM7QUFDckMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHVCQUF1QjtBQUN2QixrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QyxrQkFBa0I7QUFDbEIsa0NBQWtDLG9CQUFvQjtBQUN0RCx1QkFBdUI7QUFDdkIsa0JBQWtCLFdBQVc7QUFDN0Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hELGtCQUFrQiw2Q0FBNkM7QUFDL0Qsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QyxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQ0FBa0MsNkJBQTZCLDRDQUE0QyxtREFBbUQseUJBQXlCLEdBQUc7QUFDdE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOztBQUVELHFPQUFxTztBQUNyTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUUsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekU7QUFDQSw4QkFBOEIsaURBQWlEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0ZBQXdGLGdDQUFnQyxpQkFBaUIsR0FBRyw0RUFBNEUsZ0NBQWdDLEdBQUcsZ0RBQWdELGdDQUFnQyx1QkFBdUIsd0NBQXdDLHlCQUF5QixpQkFBaUIsR0FBRyx5REFBeUQsZ0RBQWdELDBDQUEwQyxHQUFHLHdCQUF3QixtQkFBbUIseUJBQXlCLEdBQUcsMkJBQTJCLHlCQUF5QixrQkFBa0IsR0FBRyx5REFBeUQscUJBQXFCLEdBQUcsa0VBQWtFLHFCQUFxQixHQUFHLGdDQUFnQyxtQkFBbUIsc0JBQXNCLGtDQUFrQyxzQkFBc0IsNkNBQTZDLHVCQUF1QiwwQkFBMEIsa0JBQWtCLEdBQUcseUNBQXlDLGdDQUFnQyxrREFBa0QsdUJBQXVCLDBCQUEwQixxQkFBcUIsR0FBRyxzQ0FBc0MsOEJBQThCLEdBQUcsK0JBQStCLG9CQUFvQiwwQkFBMEIsR0FBRyxtQ0FBbUMsbUJBQW1CLHFCQUFxQixHQUFHLHFDQUFxQyxxQkFBcUIsdUJBQXVCLDhCQUE4QixHQUFHLDRDQUE0QyxjQUFjLEdBQUcsd0NBQXdDLG9CQUFvQix5QkFBeUIsZUFBZSxrQkFBa0IsZ0JBQWdCLHVCQUF1QixtQkFBbUIsaURBQWlELDZCQUE2Qiw2Q0FBNkMsR0FBRywyQkFBMkIsV0FBVyx3Q0FBd0MsWUFBWSx3Q0FBd0MsYUFBYSx5Q0FBeUMsR0FBRyxtQ0FBbUMsMkNBQTJDLGdEQUFnRCwwQkFBMEIsUUFBUSxHQUFHO0FBQ2gyRTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxxSEFBcUg7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx1Q0FBdUM7QUFDcEcsa0NBQWtDLHVDQUF1QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0NBQWdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOztBQUVELDhKQUE4SjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7O0FBRUQsc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQzs7QUFFRCwyVEFBMlQ7QUFDM1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5REFBeUQsYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxlQUFlO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDRCQUE0QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELGdDQUFnQyxnQ0FBZ0M7QUFDaEUsNkNBQTZDLGlDQUFpQztBQUM5RSw4Q0FBOEMsK0JBQStCO0FBQzdFLCtCQUErQiw0QkFBNEI7QUFDM0Qsa0NBQWtDLHdDQUF3QztBQUMxRSx3Q0FBd0MscUNBQXFDLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyxzQ0FBc0M7QUFDeEUsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdEQUFnRDtBQUN2RyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQzs7QUFFRCx5UEFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBLDRCQUE0QixLQUF1RDtBQUNuRjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9leHQtbGFuZ3VhZ2VfdG9vbHMuanM/NDIxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJhY2UuZGVmaW5lKFwiYWNlL3NuaXBwZXRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9yYW5nZV9saXN0XCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvdG9rZW5pemVyXCIsXCJhY2UvY2xpcGJvYXJkXCIsXCJhY2UvZWRpdG9yXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgb29wID0gcmVxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIFJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgUmFuZ2VMaXN0ID0gcmVxdWlyZShcIi4vcmFuZ2VfbGlzdFwiKS5SYW5nZUxpc3Q7XG52YXIgSGFzaEhhbmRsZXIgPSByZXF1aXJlKFwiLi9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIikuSGFzaEhhbmRsZXI7XG52YXIgVG9rZW5pemVyID0gcmVxdWlyZShcIi4vdG9rZW5pemVyXCIpLlRva2VuaXplcjtcbnZhciBjbGlwYm9hcmQgPSByZXF1aXJlKFwiLi9jbGlwYm9hcmRcIik7XG52YXIgVkFSSUFCTEVTID0ge1xuICAgIENVUlJFTlRfV09SRDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLnNlc3Npb24uZ2V0VGV4dFJhbmdlKGVkaXRvci5zZXNzaW9uLmdldFdvcmRSYW5nZSgpKTtcbiAgICB9LFxuICAgIFNFTEVDVElPTjogZnVuY3Rpb24gKGVkaXRvciwgbmFtZSwgaW5kZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHRleHQgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoKTtcbiAgICAgICAgaWYgKGluZGVudGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxuXFxyPyhbIFxcdF0qXFxTKS9nLCBcIlxcblwiICsgaW5kZW50YXRpb24gKyBcIiQxXCIpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9LFxuICAgIENVUlJFTlRfTElORTogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLnNlc3Npb24uZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKS5yb3cpO1xuICAgIH0sXG4gICAgUFJFVl9MSU5FOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdyAtIDEpO1xuICAgIH0sXG4gICAgTElORV9JTkRFWDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCkucm93O1xuICAgIH0sXG4gICAgTElORV9OVU1CRVI6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdyArIDE7XG4gICAgfSxcbiAgICBTT0ZUX1RBQlM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5zZXNzaW9uLmdldFVzZVNvZnRUYWJzKCkgPyBcIllFU1wiIDogXCJOT1wiO1xuICAgIH0sXG4gICAgVEFCX1NJWkU6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICB9LFxuICAgIENMSVBCT0FSRDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gY2xpcGJvYXJkLmdldFRleHQgJiYgY2xpcGJvYXJkLmdldFRleHQoKTtcbiAgICB9LFxuICAgIEZJTEVOQU1FOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiAvW14vXFxcXF0qJC8uZXhlYyh0aGlzLkZJTEVQQVRIKGVkaXRvcikpWzBdO1xuICAgIH0sXG4gICAgRklMRU5BTUVfQkFTRTogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gL1teL1xcXFxdKiQvLmV4ZWModGhpcy5GSUxFUEFUSChlZGl0b3IpKVswXS5yZXBsYWNlKC9cXC5bXi5dKiQvLCBcIlwiKTtcbiAgICB9LFxuICAgIERJUkVDVE9SWTogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5GSUxFUEFUSChlZGl0b3IpLnJlcGxhY2UoL1teL1xcXFxdKiQvLCBcIlwiKTtcbiAgICB9LFxuICAgIEZJTEVQQVRIOiBmdW5jdGlvbiAoZWRpdG9yKSB7IHJldHVybiBcIi9ub3QgaW1wbGVtZW50ZWQudHh0XCI7IH0sXG4gICAgV09SS1NQQUNFX05BTUU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVW5rbm93blwiOyB9LFxuICAgIEZVTExOQU1FOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlVua25vd25cIjsgfSxcbiAgICBCTE9DS19DT01NRU5UX1NUQVJUOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciBtb2RlID0gZWRpdG9yLnNlc3Npb24uJG1vZGUgfHwge307XG4gICAgICAgIHJldHVybiBtb2RlLmJsb2NrQ29tbWVudCAmJiBtb2RlLmJsb2NrQ29tbWVudC5zdGFydCB8fCBcIlwiO1xuICAgIH0sXG4gICAgQkxPQ0tfQ09NTUVOVF9FTkQ6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBlZGl0b3Iuc2Vzc2lvbi4kbW9kZSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG1vZGUuYmxvY2tDb21tZW50ICYmIG1vZGUuYmxvY2tDb21tZW50LmVuZCB8fCBcIlwiO1xuICAgIH0sXG4gICAgTElORV9DT01NRU5UOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciBtb2RlID0gZWRpdG9yLnNlc3Npb24uJG1vZGUgfHwge307XG4gICAgICAgIHJldHVybiBtb2RlLmxpbmVDb21tZW50U3RhcnQgfHwgXCJcIjtcbiAgICB9LFxuICAgIENVUlJFTlRfWUVBUjogZGF0ZS5iaW5kKG51bGwsIHsgeWVhcjogXCJudW1lcmljXCIgfSksXG4gICAgQ1VSUkVOVF9ZRUFSX1NIT1JUOiBkYXRlLmJpbmQobnVsbCwgeyB5ZWFyOiBcIjItZGlnaXRcIiB9KSxcbiAgICBDVVJSRU5UX01PTlRIOiBkYXRlLmJpbmQobnVsbCwgeyBtb250aDogXCJudW1lcmljXCIgfSksXG4gICAgQ1VSUkVOVF9NT05USF9OQU1FOiBkYXRlLmJpbmQobnVsbCwgeyBtb250aDogXCJsb25nXCIgfSksXG4gICAgQ1VSUkVOVF9NT05USF9OQU1FX1NIT1JUOiBkYXRlLmJpbmQobnVsbCwgeyBtb250aDogXCJzaG9ydFwiIH0pLFxuICAgIENVUlJFTlRfREFURTogZGF0ZS5iaW5kKG51bGwsIHsgZGF5OiBcIjItZGlnaXRcIiB9KSxcbiAgICBDVVJSRU5UX0RBWV9OQU1FOiBkYXRlLmJpbmQobnVsbCwgeyB3ZWVrZGF5OiBcImxvbmdcIiB9KSxcbiAgICBDVVJSRU5UX0RBWV9OQU1FX1NIT1JUOiBkYXRlLmJpbmQobnVsbCwgeyB3ZWVrZGF5OiBcInNob3J0XCIgfSksXG4gICAgQ1VSUkVOVF9IT1VSOiBkYXRlLmJpbmQobnVsbCwgeyBob3VyOiBcIjItZGlnaXRcIiwgaG91cjEyOiBmYWxzZSB9KSxcbiAgICBDVVJSRU5UX01JTlVURTogZGF0ZS5iaW5kKG51bGwsIHsgbWludXRlOiBcIjItZGlnaXRcIiB9KSxcbiAgICBDVVJSRU5UX1NFQ09ORDogZGF0ZS5iaW5kKG51bGwsIHsgc2Vjb25kOiBcIjItZGlnaXRcIiB9KVxufTtcblZBUklBQkxFUy5TRUxFQ1RFRF9URVhUID0gVkFSSUFCTEVTLlNFTEVDVElPTjtcbmZ1bmN0aW9uIGRhdGUoZGF0ZUZvcm1hdCkge1xuICAgIHZhciBzdHIgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKFwiZW4tdXNcIiwgZGF0ZUZvcm1hdCk7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT0gMSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxudmFyIFNuaXBwZXRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNuaXBwZXRNYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLnNuaXBwZXRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5zbmlwcGV0TmFtZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFZBUklBQkxFUztcbiAgICB9XG4gICAgU25pcHBldE1hbmFnZXIucHJvdG90eXBlLmdldFRva2VuaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNuaXBwZXRNYW5hZ2VyW1wiJHRva2VuaXplclwiXSB8fCB0aGlzLmNyZWF0ZVRva2VuaXplcigpO1xuICAgIH07XG4gICAgU25pcHBldE1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGFic3RvcFRva2VuKHN0cikge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHN0cikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IHRhYnN0b3BJZDogcGFyc2VJbnQoc3RyLCAxMCkgfV07XG4gICAgICAgICAgICByZXR1cm4gW3sgdGV4dDogc3RyIH1dO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVzY2FwZShjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiKD86W15cXFxcXFxcXFwiICsgY2ggKyBcIl18XFxcXFxcXFwuKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXRNYXRjaGVyID0ge1xuICAgICAgICAgICAgcmVnZXg6IFwiLyhcIiArIGVzY2FwZShcIi9cIikgKyBcIispL1wiLFxuICAgICAgICAgICAgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgdHMuZm10U3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cy5ndWFyZCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgdHMuZmxhZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogXCJmb3JtYXRTdHJpbmdcIlxuICAgICAgICB9O1xuICAgICAgICBTbmlwcGV0TWFuYWdlcltcIiR0b2tlbml6ZXJcIl0gPSBuZXcgVG9rZW5pemVyKHtcbiAgICAgICAgICAgIHN0YXJ0OiBbXG4gICAgICAgICAgICAgICAgeyByZWdleDogL1xcXFwuLywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSB2YWxbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJ9XCIgJiYgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcImAkXFxcXFwiLmluZGV4T2YoY2gpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbF07XG4gICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICB7IHJlZ2V4OiAvfS8sIG9uTWF0Y2g6IGZ1bmN0aW9uICh2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFjay5sZW5ndGggPyBzdGFjay5zaGlmdCgpIDogdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC9cXCQoPzpcXGQrfFxcdyspLywgb25NYXRjaDogVGFic3RvcFRva2VuIH0sXG4gICAgICAgICAgICAgICAgeyByZWdleDogL1xcJFxce1tcXGRBLVpfYS16XSsvLCBvbk1hdGNoOiBmdW5jdGlvbiAoc3RyLCBzdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gVGFic3RvcFRva2VuKHN0ci5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdCh0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0OiBcInNuaXBwZXRWYXJcIiB9LFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC9cXG4vLCB0b2tlbjogXCJuZXdsaW5lXCIsIG1lcmdlOiBmYWxzZSB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc25pcHBldFZhcjogW1xuICAgICAgICAgICAgICAgIHsgcmVnZXg6IFwiXFxcXHxcIiArIGVzY2FwZShcIlxcXFx8XCIpICsgXCIqXFxcXHxcIiwgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlcyA9IHZhbC5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXFssfFxcXFxdfCwvZywgZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmxlbmd0aCA9PSAyID8gb3BlcmF0b3JbMV0gOiBcIlxceDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5zcGxpdChcIlxceDAwXCIpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbMF0uY2hvaWNlcyA9IGNob2ljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Nob2ljZXNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0OiBcInN0YXJ0XCIgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXRNYXRjaGVyLFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IFwiKFteOn1cXFxcXFxcXF18XFxcXFxcXFwuKSo6P1wiLCB0b2tlbjogXCJcIiwgbmV4dDogXCJzdGFydFwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmc6IFtcbiAgICAgICAgICAgICAgICB7IHJlZ2V4OiAvOi8sIG9uTWF0Y2g6IGZ1bmN0aW9uICh2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAmJiBzdGFja1swXS5leHBlY3RFbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbMF0uZXhwZWN0RWxzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmlmRW5kID0geyBlbHNlRW5kOiBzdGFja1swXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RhY2tbMF0uaWZFbmRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiOlwiO1xuICAgICAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgeyByZWdleDogL1xcXFwuLywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSB2YWxbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJ9XCIgJiYgc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJgJFxcXFxcIi5pbmRleE9mKGNoKSAhPSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IFwiblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBcInRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJ1bFVMRVwiLmluZGV4T2YoY2gpICE9IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHsgY2hhbmdlQ2FzZTogY2gsIGxvY2FsOiBjaCA+IFwiYVwiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbF07XG4gICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICB7IHJlZ2V4OiBcIi9cXFxcdyp9XCIsIG9uTWF0Y2g6IGZ1bmN0aW9uICh2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5mbGFnID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHQgJiYgbmV4dC50YWJzdG9wSWQgPyBcInN0YXJ0XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXh0IHx8IHZhbF07XG4gICAgICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwic3RhcnRcIiB9LFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC9cXCQoPzpcXGQrfFxcdyspLywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3sgdGV4dDogdmFsLnNsaWNlKDEpIH1dO1xuICAgICAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgeyByZWdleDogL1xcJHtcXHcrLywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB7IHRleHQ6IHZhbC5zbGljZSgyKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbmV4dDogXCJmb3JtYXRTdHJpbmdWYXJcIiB9LFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC9cXG4vLCB0b2tlbjogXCJuZXdsaW5lXCIsIG1lcmdlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC99Lywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0ICYmIG5leHQudGFic3RvcElkID8gXCJzdGFydFwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV4dCB8fCB2YWxdO1xuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0OiBcInN0YXJ0XCIgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZ1ZhcjogW1xuICAgICAgICAgICAgICAgIHsgcmVnZXg6IC86XFwvXFx3K30vLCBvbk1hdGNoOiBmdW5jdGlvbiAodmFsLCBzdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cyA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHMuZm9ybWF0RnVuY3Rpb24gPSB2YWwuc2xpY2UoMiwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFjay5zaGlmdCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbmV4dDogXCJmb3JtYXRTdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIGZvcm1hdE1hdGNoZXIsXG4gICAgICAgICAgICAgICAgeyByZWdleDogLzpbXFw/XFwtK10/Lywgb25NYXRjaDogZnVuY3Rpb24gKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsWzFdID09IFwiK1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmlmRW5kID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsWzFdID09IFwiP1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmV4cGVjdEVsc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0OiBcImZvcm1hdFN0cmluZ1wiIH0sXG4gICAgICAgICAgICAgICAgeyByZWdleDogXCIoW146fVxcXFxcXFxcXXxcXFxcXFxcXC4pKjo/XCIsIHRva2VuOiBcIlwiLCBuZXh0OiBcImZvcm1hdFN0cmluZ1wiIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTbmlwcGV0TWFuYWdlcltcIiR0b2tlbml6ZXJcIl07XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUudG9rZW5pemVUbVNuaXBwZXQgPSBmdW5jdGlvbiAoc3RyLCBzdGFydFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuaXplcigpLmdldExpbmVUb2tlbnMoc3RyLCBzdGFydFN0YXRlKS50b2tlbnMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC52YWx1ZSB8fCB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYWJsZVZhbHVlID0gZnVuY3Rpb24gKGVkaXRvciwgbmFtZSwgaW5kZW50YXRpb24pIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFyaWFibGVzLl9fIHx8IHt9KVtuYW1lXSB8fCBcIlwiO1xuICAgICAgICBpZiAoL15bQS1aXVxcZCskLy50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhcmlhYmxlc1tuYW1lWzBdICsgXCJfX1wiXSB8fCB7fSlbbmFtZS5zdWJzdHIoMSldIHx8IFwiXCI7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL15UTV8vLCBcIlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhcmlhYmxlc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFyaWFibGVzW25hbWVdKGVkaXRvciwgbmFtZSwgaW5kZW50YXRpb24pO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS50bVN0ckZvcm1hdCA9IGZ1bmN0aW9uIChzdHIsIGNoLCBlZGl0b3IpIHtcbiAgICAgICAgaWYgKCFjaC5mbXQpXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB2YXIgZmxhZyA9IGNoLmZsYWcgfHwgXCJcIjtcbiAgICAgICAgdmFyIHJlID0gY2guZ3VhcmQ7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZSwgZmxhZy5yZXBsYWNlKC9bXmdpbV0vZywgXCJcIikpO1xuICAgICAgICB2YXIgZm10VG9rZW5zID0gdHlwZW9mIGNoLmZtdCA9PSBcInN0cmluZ1wiID8gdGhpcy50b2tlbml6ZVRtU25pcHBldChjaC5mbXQsIFwiZm9ybWF0U3RyaW5nXCIpIDogY2guZm10O1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZm9ybWF0dGVkID0gc3RyLnJlcGxhY2UocmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGRBcmdzID0gX3NlbGYudmFyaWFibGVzLl9fO1xuICAgICAgICAgICAgX3NlbGYudmFyaWFibGVzLl9fID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGZtdFBhcnRzID0gX3NlbGYucmVzb2x2ZVZhcmlhYmxlcyhmbXRUb2tlbnMsIGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgZ0NoYW5nZUNhc2UgPSBcIkVcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm10UGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBmbXRQYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2guY2hhbmdlQ2FzZSAmJiBjaC5sb2NhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmbXRQYXJ0c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoLmNoYW5nZUNhc2UgPT0gXCJ1XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdFBhcnRzW2ldID0gbmV4dFswXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaV0gPSBuZXh0WzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaSArIDFdID0gbmV4dC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2guY2hhbmdlQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ0NoYW5nZUNhc2UgPSBjaC5jaGFuZ2VDYXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdDaGFuZ2VDYXNlID09IFwiVVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdFBhcnRzW2ldID0gY2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ0NoYW5nZUNhc2UgPT0gXCJMXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaV0gPSBjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zZWxmLnZhcmlhYmxlcy5fXyA9IG9sZEFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gZm10UGFydHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUudG1Gb3JtYXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChzdHIsIGNoLCBlZGl0b3IpIHtcbiAgICAgICAgaWYgKGNoLmZvcm1hdEZ1bmN0aW9uID09IFwidXBjYXNlXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChjaC5mb3JtYXRGdW5jdGlvbiA9PSBcImRvd25jYXNlXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUucmVzb2x2ZVZhcmlhYmxlcyA9IGZ1bmN0aW9uIChzbmlwcGV0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgaW5kZW50YXRpb24gPSBcIlwiO1xuICAgICAgICB2YXIgYWZ0ZXJOZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbmlwcGV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBzbmlwcGV0W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2gpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyTmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uID0gL15cXHQqLy5leGVjKGNoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJOZXdMaW5lID0gL1xcUy8udGVzdChjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjaClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGFmdGVyTmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNoLmZtdFN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBqID0gc25pcHBldC5pbmRleE9mKGNoLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGogPSBzbmlwcGV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaC5mbXQgPSBzbmlwcGV0LnNsaWNlKGkgKyAxLCBqKTtcbiAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYXJpYWJsZVZhbHVlKGVkaXRvciwgY2gudGV4dCwgaW5kZW50YXRpb24pICsgXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoY2guZm10U3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG1TdHJGb3JtYXQodmFsdWUsIGNoLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChjaC5mb3JtYXRGdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRtRm9ybWF0RnVuY3Rpb24odmFsdWUsIGNoLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhY2guaWZFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBnb3RvTmV4dChjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF2YWx1ZSAmJiBjaC5pZkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBnb3RvTmV4dChjaC5pZkVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2guZWxzZUVuZCkge1xuICAgICAgICAgICAgICAgIGdvdG9OZXh0KGNoLmVsc2VFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gudGFic3RvcElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5jaGFuZ2VDYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ290b05leHQoY2gpIHtcbiAgICAgICAgICAgIHZhciBpMSA9IHNuaXBwZXQuaW5kZXhPZihjaCwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKGkxICE9IC0xKVxuICAgICAgICAgICAgICAgIGkgPSBpMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU25pcHBldE1hbmFnZXIucHJvdG90eXBlLmdldERpc3BsYXlUZXh0Rm9yU25pcHBldCA9IGZ1bmN0aW9uIChlZGl0b3IsIHNuaXBwZXRUZXh0KSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWRTbmlwcGV0ID0gcHJvY2Vzc1NuaXBwZXRUZXh0LmNhbGwodGhpcywgZWRpdG9yLCBzbmlwcGV0VGV4dCk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRTbmlwcGV0LnRleHQ7XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUuaW5zZXJ0U25pcHBldEZvclNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlZGl0b3IsIHNuaXBwZXRUZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwcm9jZXNzZWRTbmlwcGV0ID0gcHJvY2Vzc1NuaXBwZXRUZXh0LmNhbGwodGhpcywgZWRpdG9yLCBzbmlwcGV0VGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB2YXIgZW5kID0gZWRpdG9yLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgcHJvY2Vzc2VkU25pcHBldC50ZXh0KTtcbiAgICAgICAgdmFyIHRhYnN0b3BNYW5hZ2VyID0gbmV3IFRhYnN0b3BNYW5hZ2VyKGVkaXRvcik7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JZCA9IGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlICYmIGVkaXRvci5zZWxlY3Rpb24uaW5kZXg7XG4gICAgICAgIHRhYnN0b3BNYW5hZ2VyLmFkZFRhYnN0b3BzKHByb2Nlc3NlZFNuaXBwZXQudGFic3RvcHMsIHJhbmdlLnN0YXJ0LCBlbmQsIHNlbGVjdGlvbklkKTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS5pbnNlcnRTbmlwcGV0ID0gZnVuY3Rpb24gKGVkaXRvciwgc25pcHBldFRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnNlcnRTbmlwcGV0Rm9yU2VsZWN0aW9uKGVkaXRvciwgc25pcHBldFRleHQsIG9wdGlvbnMpO1xuICAgICAgICBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmluc2VydFNuaXBwZXRGb3JTZWxlY3Rpb24oZWRpdG9yLCBzbmlwcGV0VGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIH0sIG51bGwsIHsga2VlcE9yZGVyOiB0cnVlIH0pO1xuICAgICAgICBpZiAoZWRpdG9yLnRhYnN0b3BNYW5hZ2VyKVxuICAgICAgICAgICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyLnRhYk5leHQoKTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS4kZ2V0U2NvcGUgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGVkaXRvci5zZXNzaW9uLiRtb2RlLiRpZCB8fCBcIlwiO1xuICAgICAgICBzY29wZSA9IHNjb3BlLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgICAgaWYgKHNjb3BlID09PSBcImh0bWxcIiB8fCBzY29wZSA9PT0gXCJwaHBcIikge1xuICAgICAgICAgICAgaWYgKHNjb3BlID09PSBcInBocFwiICYmICFlZGl0b3Iuc2Vzc2lvbi4kbW9kZS5pbmxpbmVQaHApXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBcImh0bWxcIjtcbiAgICAgICAgICAgIHZhciBjID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRTdGF0ZShjLnJvdyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdWJzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3Vic3RyaW5nKDAsIDMpID09IFwianMtXCIpXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID0gXCJqYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuc3Vic3RyaW5nKDAsIDQpID09IFwiY3NzLVwiKVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IFwiY3NzXCI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuc3Vic3RyaW5nKDAsIDQpID09IFwicGhwLVwiKVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IFwicGhwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH07XG4gICAgU25pcHBldE1hbmFnZXIucHJvdG90eXBlLmdldEFjdGl2ZVNjb3BlcyA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy4kZ2V0U2NvcGUoZWRpdG9yKTtcbiAgICAgICAgdmFyIHNjb3BlcyA9IFtzY29wZV07XG4gICAgICAgIHZhciBzbmlwcGV0TWFwID0gdGhpcy5zbmlwcGV0TWFwO1xuICAgICAgICBpZiAoc25pcHBldE1hcFtzY29wZV0gJiYgc25pcHBldE1hcFtzY29wZV0uaW5jbHVkZVNjb3Blcykge1xuICAgICAgICAgICAgc2NvcGVzLnB1c2guYXBwbHkoc2NvcGVzLCBzbmlwcGV0TWFwW3Njb3BlXS5pbmNsdWRlU2NvcGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZXMucHVzaChcIl9cIik7XG4gICAgICAgIHJldHVybiBzY29wZXM7XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUuZXhwYW5kV2l0aFRhYiA9IGZ1bmN0aW9uIChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZvckVhY2hTZWxlY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZXhwYW5kU25pcHBldEZvclNlbGVjdGlvbihlZGl0b3IsIG9wdGlvbnMpO1xuICAgICAgICB9LCBudWxsLCB7IGtlZXBPcmRlcjogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBlZGl0b3IudGFic3RvcE1hbmFnZXIpXG4gICAgICAgICAgICBlZGl0b3IudGFic3RvcE1hbmFnZXIudGFiTmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU25pcHBldE1hbmFnZXIucHJvdG90eXBlLmV4cGFuZFNuaXBwZXRGb3JTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxpbmUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgYmVmb3JlID0gbGluZS5zdWJzdHJpbmcoMCwgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHZhciBhZnRlciA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB2YXIgc25pcHBldE1hcCA9IHRoaXMuc25pcHBldE1hcDtcbiAgICAgICAgdmFyIHNuaXBwZXQ7XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlU2NvcGVzKGVkaXRvcikuc29tZShmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBzbmlwcGV0cyA9IHNuaXBwZXRNYXBbc2NvcGVdO1xuICAgICAgICAgICAgaWYgKHNuaXBwZXRzKVxuICAgICAgICAgICAgICAgIHNuaXBwZXQgPSB0aGlzLmZpbmRNYXRjaGluZ1NuaXBwZXQoc25pcHBldHMsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuICEhc25pcHBldDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmICghc25pcHBldClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kcnlSdW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWRpdG9yLnNlc3Npb24uZG9jLnJlbW92ZUluTGluZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uIC0gc25pcHBldC5yZXBsYWNlQmVmb3JlLmxlbmd0aCwgY3Vyc29yLmNvbHVtbiArIHNuaXBwZXQucmVwbGFjZUFmdGVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLk1fXyA9IHNuaXBwZXQubWF0Y2hCZWZvcmU7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLlRfXyA9IHNuaXBwZXQubWF0Y2hBZnRlcjtcbiAgICAgICAgdGhpcy5pbnNlcnRTbmlwcGV0Rm9yU2VsZWN0aW9uKGVkaXRvciwgc25pcHBldC5jb250ZW50KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuTV9fID0gdGhpcy52YXJpYWJsZXMuVF9fID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUuZmluZE1hdGNoaW5nU25pcHBldCA9IGZ1bmN0aW9uIChzbmlwcGV0TGlzdCwgYmVmb3JlLCBhZnRlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gc25pcHBldExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNuaXBwZXRMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHMuc3RhcnRSZSAmJiAhcy5zdGFydFJlLnRlc3QoYmVmb3JlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChzLmVuZFJlICYmICFzLmVuZFJlLnRlc3QoYWZ0ZXIpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFzLnN0YXJ0UmUgJiYgIXMuZW5kUmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzLm1hdGNoQmVmb3JlID0gcy5zdGFydFJlID8gcy5zdGFydFJlLmV4ZWMoYmVmb3JlKSA6IFtcIlwiXTtcbiAgICAgICAgICAgIHMubWF0Y2hBZnRlciA9IHMuZW5kUmUgPyBzLmVuZFJlLmV4ZWMoYWZ0ZXIpIDogW1wiXCJdO1xuICAgICAgICAgICAgcy5yZXBsYWNlQmVmb3JlID0gcy50cmlnZ2VyUmUgPyBzLnRyaWdnZXJSZS5leGVjKGJlZm9yZSlbMF0gOiBcIlwiO1xuICAgICAgICAgICAgcy5yZXBsYWNlQWZ0ZXIgPSBzLmVuZFRyaWdnZXJSZSA/IHMuZW5kVHJpZ2dlclJlLmV4ZWMoYWZ0ZXIpWzBdIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc25pcHBldHMsIHNjb3BlKSB7XG4gICAgICAgIHZhciBzbmlwcGV0TWFwID0gdGhpcy5zbmlwcGV0TWFwO1xuICAgICAgICB2YXIgc25pcHBldE5hbWVNYXAgPSB0aGlzLnNuaXBwZXROYW1lTWFwO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc25pcHBldHMpXG4gICAgICAgICAgICBzbmlwcGV0cyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiB3cmFwUmVnZXhwKHNyYykge1xuICAgICAgICAgICAgaWYgKHNyYyAmJiAhL15cXF4/XFwoLipcXClcXCQ/JHxeXFxcXGIkLy50ZXN0KHNyYykpXG4gICAgICAgICAgICAgICAgc3JjID0gXCIoPzpcIiArIHNyYyArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIHNyYyB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGd1YXJkZWRSZWdleHAocmUsIGd1YXJkLCBvcGVuaW5nKSB7XG4gICAgICAgICAgICByZSA9IHdyYXBSZWdleHAocmUpO1xuICAgICAgICAgICAgZ3VhcmQgPSB3cmFwUmVnZXhwKGd1YXJkKTtcbiAgICAgICAgICAgIGlmIChvcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgcmUgPSBndWFyZCArIHJlO1xuICAgICAgICAgICAgICAgIGlmIChyZSAmJiByZVtyZS5sZW5ndGggLSAxXSAhPSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmUgPSByZSArIFwiJFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmUgPSByZSArIGd1YXJkO1xuICAgICAgICAgICAgICAgIGlmIChyZSAmJiByZVswXSAhPSBcIl5cIilcbiAgICAgICAgICAgICAgICAgICAgcmUgPSBcIl5cIiArIHJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNuaXBwZXQocykge1xuICAgICAgICAgICAgaWYgKCFzLnNjb3BlKVxuICAgICAgICAgICAgICAgIHMuc2NvcGUgPSBzY29wZSB8fCBcIl9cIjtcbiAgICAgICAgICAgIHNjb3BlID0gcy5zY29wZTtcbiAgICAgICAgICAgIGlmICghc25pcHBldE1hcFtzY29wZV0pIHtcbiAgICAgICAgICAgICAgICBzbmlwcGV0TWFwW3Njb3BlXSA9IFtdO1xuICAgICAgICAgICAgICAgIHNuaXBwZXROYW1lTWFwW3Njb3BlXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hcCA9IHNuaXBwZXROYW1lTWFwW3Njb3BlXTtcbiAgICAgICAgICAgIGlmIChzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gbWFwW3MubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9sZClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51bnJlZ2lzdGVyKG9sZCk7XG4gICAgICAgICAgICAgICAgbWFwW3MubmFtZV0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc25pcHBldE1hcFtzY29wZV0ucHVzaChzKTtcbiAgICAgICAgICAgIGlmIChzLnByZWZpeClcbiAgICAgICAgICAgICAgICBzLnRhYlRyaWdnZXIgPSBzLnByZWZpeDtcbiAgICAgICAgICAgIGlmICghcy5jb250ZW50ICYmIHMuYm9keSlcbiAgICAgICAgICAgICAgICBzLmNvbnRlbnQgPSBBcnJheS5pc0FycmF5KHMuYm9keSkgPyBzLmJvZHkuam9pbihcIlxcblwiKSA6IHMuYm9keTtcbiAgICAgICAgICAgIGlmIChzLnRhYlRyaWdnZXIgJiYgIXMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGlmICghcy5ndWFyZCAmJiAvXlxcdy8udGVzdChzLnRhYlRyaWdnZXIpKVxuICAgICAgICAgICAgICAgICAgICBzLmd1YXJkID0gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIHMudHJpZ2dlciA9IGxhbmcuZXNjYXBlUmVnRXhwKHMudGFiVHJpZ2dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXMudHJpZ2dlciAmJiAhcy5ndWFyZCAmJiAhcy5lbmRUcmlnZ2VyICYmICFzLmVuZEd1YXJkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHMuc3RhcnRSZSA9IGd1YXJkZWRSZWdleHAocy50cmlnZ2VyLCBzLmd1YXJkLCB0cnVlKTtcbiAgICAgICAgICAgIHMudHJpZ2dlclJlID0gbmV3IFJlZ0V4cChzLnRyaWdnZXIpO1xuICAgICAgICAgICAgcy5lbmRSZSA9IGd1YXJkZWRSZWdleHAocy5lbmRUcmlnZ2VyLCBzLmVuZEd1YXJkLCB0cnVlKTtcbiAgICAgICAgICAgIHMuZW5kVHJpZ2dlclJlID0gbmV3IFJlZ0V4cChzLmVuZFRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNuaXBwZXRzKSkge1xuICAgICAgICAgICAgc25pcHBldHMuZm9yRWFjaChhZGRTbmlwcGV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNuaXBwZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBhZGRTbmlwcGV0KHNuaXBwZXRzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2lnbmFsKFwicmVnaXN0ZXJTbmlwcGV0c1wiLCB7IHNjb3BlOiBzY29wZSB9KTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKHNuaXBwZXRzLCBzY29wZSkge1xuICAgICAgICB2YXIgc25pcHBldE1hcCA9IHRoaXMuc25pcHBldE1hcDtcbiAgICAgICAgdmFyIHNuaXBwZXROYW1lTWFwID0gdGhpcy5zbmlwcGV0TmFtZU1hcDtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlU25pcHBldChzKSB7XG4gICAgICAgICAgICB2YXIgbmFtZU1hcCA9IHNuaXBwZXROYW1lTWFwW3Muc2NvcGUgfHwgc2NvcGVdO1xuICAgICAgICAgICAgaWYgKG5hbWVNYXAgJiYgbmFtZU1hcFtzLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWVNYXBbcy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gc25pcHBldE1hcFtzLnNjb3BlIHx8IHNjb3BlXTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG1hcCAmJiBtYXAuaW5kZXhPZihzKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBtYXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzbmlwcGV0cy5jb250ZW50KVxuICAgICAgICAgICAgcmVtb3ZlU25pcHBldChzbmlwcGV0cyk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc25pcHBldHMpKVxuICAgICAgICAgICAgc25pcHBldHMuZm9yRWFjaChyZW1vdmVTbmlwcGV0KTtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS5wYXJzZVNuaXBwZXRGaWxlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyL2csIFwiXCIpO1xuICAgICAgICB2YXIgbGlzdCA9IFtdLCAvKipAdHlwZXtTbmlwcGV0fSovIHNuaXBwZXQgPSB7fTtcbiAgICAgICAgdmFyIHJlID0gL14jLip8Xih7W1xcc1xcU10qfSlcXHMqJHxeKFxcUyspICguKikkfF4oKD86XFxuKlxcdC4qKSspL2dtO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgd2hpbGUgKG0gPSByZS5leGVjKHN0cikpIHtcbiAgICAgICAgICAgIGlmIChtWzFdKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldCA9IEpTT04ucGFyc2UobVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChzbmlwcGV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bNF0pIHtcbiAgICAgICAgICAgICAgICBzbmlwcGV0LmNvbnRlbnQgPSBtWzRdLnJlcGxhY2UoL15cXHQvZ20sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChzbmlwcGV0KTtcbiAgICAgICAgICAgICAgICBzbmlwcGV0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbVsyXSwgdmFsID0gbVszXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3VhcmRSZSA9IC9cXC8oKD86W15cXC9cXFxcXXxcXFxcLikqKXwkL2c7XG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQuZ3VhcmQgPSBndWFyZFJlLmV4ZWModmFsKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldC50cmlnZ2VyID0gZ3VhcmRSZS5leGVjKHZhbClbMV07XG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQuZW5kVHJpZ2dlciA9IGd1YXJkUmUuZXhlYyh2YWwpWzFdO1xuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0LmVuZEd1YXJkID0gZ3VhcmRSZS5leGVjKHZhbClbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSBcInNuaXBwZXRcIikge1xuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0LnRhYlRyaWdnZXIgPSB2YWwubWF0Y2goL15cXFMqLylbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc25pcHBldC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgc25pcHBldC5uYW1lID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIFNuaXBwZXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRTbmlwcGV0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGVkaXRvcikge1xuICAgICAgICB2YXIgc25pcHBldE1hcCA9IHRoaXMuc25pcHBldE5hbWVNYXA7XG4gICAgICAgIHZhciBzbmlwcGV0O1xuICAgICAgICB0aGlzLmdldEFjdGl2ZVNjb3BlcyhlZGl0b3IpLnNvbWUoZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgc25pcHBldHMgPSBzbmlwcGV0TWFwW3Njb3BlXTtcbiAgICAgICAgICAgIGlmIChzbmlwcGV0cylcbiAgICAgICAgICAgICAgICBzbmlwcGV0ID0gc25pcHBldHNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gISFzbmlwcGV0O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNuaXBwZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gU25pcHBldE1hbmFnZXI7XG59KCkpO1xub29wLmltcGxlbWVudChTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlcik7XG52YXIgcHJvY2Vzc1NuaXBwZXRUZXh0ID0gZnVuY3Rpb24gKGVkaXRvciwgc25pcHBldFRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgbGluZSA9IGVkaXRvci5zZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgdmFyIHRhYlN0cmluZyA9IGVkaXRvci5zZXNzaW9uLmdldFRhYlN0cmluZygpO1xuICAgIHZhciBpbmRlbnRTdHJpbmcgPSBsaW5lLm1hdGNoKC9eXFxzKi8pWzBdO1xuICAgIGlmIChjdXJzb3IuY29sdW1uIDwgaW5kZW50U3RyaW5nLmxlbmd0aClcbiAgICAgICAgaW5kZW50U3RyaW5nID0gaW5kZW50U3RyaW5nLnNsaWNlKDAsIGN1cnNvci5jb2x1bW4pO1xuICAgIHNuaXBwZXRUZXh0ID0gc25pcHBldFRleHQucmVwbGFjZSgvXFxyL2csIFwiXCIpO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplVG1TbmlwcGV0KHNuaXBwZXRUZXh0KTtcbiAgICB0b2tlbnMgPSB0aGlzLnJlc29sdmVWYXJpYWJsZXModG9rZW5zLCBlZGl0b3IpO1xuICAgIHRva2VucyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHggPT0gXCJcXG5cIiAmJiAhb3B0aW9ucy5leGNsdWRlRXh0cmFJbmRlbnQpXG4gICAgICAgICAgICByZXR1cm4geCArIGluZGVudFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4geC5yZXBsYWNlKC9cXHQvZywgdGFiU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSk7XG4gICAgdmFyIHRhYnN0b3BzID0gW107XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHAudGFic3RvcElkO1xuICAgICAgICB2YXIgdHMgPSB0YWJzdG9wc1tpZF07XG4gICAgICAgIGlmICghdHMpIHtcbiAgICAgICAgICAgIHRzID0gdGFic3RvcHNbaWRdID0gW107XG4gICAgICAgICAgICB0cy5pbmRleCA9IGlkO1xuICAgICAgICAgICAgdHMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdHMucGFyZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cy5pbmRleE9mKHApICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHAuY2hvaWNlcyAmJiAhdHMuY2hvaWNlcylcbiAgICAgICAgICAgIHRzLmNob2ljZXMgPSBwLmNob2ljZXM7XG4gICAgICAgIHRzLnB1c2gocCk7XG4gICAgICAgIHZhciBpMSA9IHRva2Vucy5pbmRleE9mKHAsIGkgKyAxKTtcbiAgICAgICAgaWYgKGkxID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW5zLnNsaWNlKGkgKyAxLCBpMSk7XG4gICAgICAgIHZhciBpc05lc3RlZCA9IHZhbHVlLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHR5cGVvZiB0ID09PSBcIm9iamVjdFwiOyB9KTtcbiAgICAgICAgaWYgKGlzTmVzdGVkICYmICF0cy52YWx1ZSkge1xuICAgICAgICAgICAgdHMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggJiYgKCF0cy52YWx1ZSB8fCB0eXBlb2YgdHMudmFsdWUgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB0cy52YWx1ZSA9IHZhbHVlLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJzdG9wcy5mb3JFYWNoKGZ1bmN0aW9uICh0cykgeyB0cy5sZW5ndGggPSAwOyB9KTtcbiAgICB2YXIgZXhwYW5kaW5nID0ge307XG4gICAgZnVuY3Rpb24gY29weVZhbHVlKHZhbCkge1xuICAgICAgICB2YXIgY29weSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSB2YWxbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRpbmdbcC50YWJzdG9wSWRdKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IHZhbC5sYXN0SW5kZXhPZihwLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgcCA9IGNvcHlbal0gfHwgeyB0YWJzdG9wSWQ6IHAudGFic3RvcElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5W2ldID0gcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgcCAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBpZCA9IHAudGFic3RvcElkO1xuICAgICAgICB2YXIgdHMgPSB0YWJzdG9wc1tpZF07XG4gICAgICAgIHZhciBpMSA9IHRva2Vucy5pbmRleE9mKHAsIGkgKyAxKTtcbiAgICAgICAgaWYgKGV4cGFuZGluZ1tpZF0pIHtcbiAgICAgICAgICAgIGlmIChleHBhbmRpbmdbaWRdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV4cGFuZGluZ1tpZF07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXhwYW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICB0cy5wYXJlbnRzW3BhcmVudElkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBleHBhbmRpbmdbaWRdID0gcDtcbiAgICAgICAgdmFyIHZhbHVlID0gdHMudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IGNvcHlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHAuZm10KVxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRtU3RyRm9ybWF0KHZhbHVlLCBwLCBlZGl0b3IpO1xuICAgICAgICB0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucywgW2kgKyAxLCBNYXRoLm1heCgwLCBpMSAtIGkpXS5jb25jYXQodmFsdWUsIHApKTtcbiAgICAgICAgaWYgKHRzLmluZGV4T2YocCkgPT09IC0xKVxuICAgICAgICAgICAgdHMucHVzaChwKTtcbiAgICB9XG4gICAgdmFyIHJvdyA9IDAsIGNvbHVtbiA9IDA7XG4gICAgdmFyIHRleHQgPSBcIlwiO1xuICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJvdyArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbHVtbiArPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRleHQgKz0gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0KSB7XG4gICAgICAgICAgICBpZiAoIXQuc3RhcnQpXG4gICAgICAgICAgICAgICAgdC5zdGFydCA9IHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdC5lbmQgPSB7IHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGFic3RvcHM6IHRhYnN0b3BzLFxuICAgICAgICB0b2tlbnM6IHRva2Vuc1xuICAgIH07XG59O1xudmFyIFRhYnN0b3BNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYnN0b3BNYW5hZ2VyKGVkaXRvcikge1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy50YWJzdG9wcyA9IFtdO1xuICAgICAgICBpZiAoZWRpdG9yLnRhYnN0b3BNYW5hZ2VyKVxuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci50YWJzdG9wTWFuYWdlcjtcbiAgICAgICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy4kb25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuJG9uQ2hhbmdlU2VsZWN0aW9uID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLm9uQ2hhbmdlU2VsZWN0aW9uLmJpbmQodGhpcykpLnNjaGVkdWxlO1xuICAgICAgICB0aGlzLiRvbkNoYW5nZVNlc3Npb24gPSB0aGlzLm9uQ2hhbmdlU2Vzc2lvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiRvbkFmdGVyRXhlYyA9IHRoaXMub25BZnRlckV4ZWMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICB9XG4gICAgVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgdGhpcy4kb3BlblRhYnN0b3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhYnN0b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gZWRpdG9yLnNlc3Npb247XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuJG9uQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy4kb25DaGFuZ2VTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgdGhpcy4kb25DaGFuZ2VTZXNzaW9uKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMub24oXCJhZnRlckV4ZWNcIiwgdGhpcy4kb25BZnRlckV4ZWMpO1xuICAgICAgICB0aGlzLmVkaXRvci5rZXlCaW5kaW5nLmFkZEtleWJvYXJkSGFuZGxlcih0aGlzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRhYnN0b3BzLmZvckVhY2godGhpcy5yZW1vdmVUYWJzdG9wTWFya2VycywgdGhpcyk7XG4gICAgICAgIHRoaXMucmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudGFic3RvcHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhYnN0b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy4kb25DaGFuZ2VTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJjaGFuZ2VTZXNzaW9uXCIsIHRoaXMuJG9uQ2hhbmdlU2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLm9mZihcImFmdGVyRXhlY1wiLCB0aGlzLiRvbkFmdGVyRXhlYyk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKHRoaXMua2V5Ym9hcmRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3IudGFic3RvcE1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIGlzUmVtb3ZlID0gZGVsdGEuYWN0aW9uWzBdID09IFwiclwiO1xuICAgICAgICB2YXIgc2VsZWN0ZWRUYWJzdG9wID0gdGhpcy5zZWxlY3RlZFRhYnN0b3AgfHwge307XG4gICAgICAgIHZhciBwYXJlbnRzID0gc2VsZWN0ZWRUYWJzdG9wLnBhcmVudHMgfHwge307XG4gICAgICAgIHZhciB0YWJzdG9wcyA9IHRoaXMudGFic3RvcHMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRzID0gdGFic3RvcHNbaV07XG4gICAgICAgICAgICB2YXIgYWN0aXZlID0gdHMgPT0gc2VsZWN0ZWRUYWJzdG9wIHx8IHBhcmVudHNbdHMuaW5kZXhdO1xuICAgICAgICAgICAgdHMucmFuZ2VMaXN0LiRiaWFzID0gYWN0aXZlID8gMCA6IDE7XG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlXCIgJiYgdHMgIT09IHNlbGVjdGVkVGFic3RvcCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRBY3RpdmUgPSB0cy5wYXJlbnRzICYmIHRzLnBhcmVudHNbc2VsZWN0ZWRUYWJzdG9wLmluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRzLnJhbmdlTGlzdC5wb2ludEluZGV4KGRlbHRhLnN0YXJ0LCBwYXJlbnRBY3RpdmUpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4IDwgMCA/IC1zdGFydEluZGV4IC0gMSA6IHN0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRzLnJhbmdlTGlzdC5wb2ludEluZGV4KGRlbHRhLmVuZCwgcGFyZW50QWN0aXZlKTtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IGVuZEluZGV4IDwgMCA/IC1lbmRJbmRleCAtIDEgOiBlbmRJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHRvUmVtb3ZlID0gdHMucmFuZ2VMaXN0LnJhbmdlcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b1JlbW92ZS5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSYW5nZSh0b1JlbW92ZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cy5yYW5nZUxpc3QuJG9uQ2hhbmdlKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCF0aGlzLiRpbkNoYW5nZSAmJiBpc1JlbW92ZSAmJiBzZXNzaW9uLmdldExlbmd0aCgpID09IDEgJiYgIXNlc3Npb24uZ2V0VmFsdWUoKSlcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUudXBkYXRlTGlua2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnNlbGVjdGVkVGFic3RvcDtcbiAgICAgICAgaWYgKCF0cyB8fCAhdHMuaGFzTGlua2VkUmFuZ2VzIHx8ICF0cy5maXJzdE5vbkxpbmtlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaW5DaGFuZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHRleHQgPSBzZXNzaW9uLmdldFRleHRSYW5nZSh0cy5maXJzdE5vbkxpbmtlZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRzW2ldO1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5saW5rZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSByYW5nZS5vcmlnaW5hbDtcbiAgICAgICAgICAgIHZhciBmbXQgPSBleHBvcnRzLnNuaXBwZXRNYW5hZ2VyLnRtU3RyRm9ybWF0KHRleHQsIG9yaWdpbmFsLCB0aGlzLmVkaXRvcik7XG4gICAgICAgICAgICBzZXNzaW9uLnJlcGxhY2UocmFuZ2UsIGZtdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5DaGFuZ2UgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRhYnN0b3BNYW5hZ2VyLnByb3RvdHlwZS5vbkFmdGVyRXhlYyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmNvbW1hbmQgJiYgIWUuY29tbWFuZC5yZWFkT25seSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlua2VkRmllbGRzKCk7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUub25DaGFuZ2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5lZGl0b3Iuc2VsZWN0aW9uLmxlYWQ7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmVkaXRvci5zZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICB2YXIgaXNFbXB0eSA9IHRoaXMuZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlc1tpXS5saW5rZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgY29udGFpbnNMZWFkID0gdGhpcy5yYW5nZXNbaV0uY29udGFpbnMobGVhZC5yb3csIGxlYWQuY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBjb250YWluc0FuY2hvciA9IGlzRW1wdHkgfHwgdGhpcy5yYW5nZXNbaV0uY29udGFpbnMoYW5jaG9yLnJvdywgYW5jaG9yLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY29udGFpbnNMZWFkICYmIGNvbnRhaW5zQW5jaG9yKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgIH07XG4gICAgVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLm9uQ2hhbmdlU2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICB9O1xuICAgIFRhYnN0b3BNYW5hZ2VyLnByb3RvdHlwZS50YWJOZXh0ID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy50YWJzdG9wcy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXggKyAoZGlyIHx8IDEpO1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKE1hdGgubWF4KGluZGV4LCAxKSwgbWF4KTtcbiAgICAgICAgaWYgKGluZGV4ID09IG1heClcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3RUYWJzdG9wKGluZGV4KTtcbiAgICAgICAgdGhpcy51cGRhdGVUYWJzdG9wTWFya2VycygpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYnN0b3BNYW5hZ2VyLnByb3RvdHlwZS5zZWxlY3RUYWJzdG9wID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuJG9wZW5UYWJzdG9wcyA9IG51bGw7XG4gICAgICAgIHZhciB0cyA9IHRoaXMudGFic3RvcHNbdGhpcy5pbmRleF07XG4gICAgICAgIGlmICh0cylcbiAgICAgICAgICAgIHRoaXMuYWRkVGFic3RvcE1hcmtlcnModHMpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRzID0gdGhpcy50YWJzdG9wc1t0aGlzLmluZGV4XTtcbiAgICAgICAgaWYgKCF0cyB8fCAhdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVGFic3RvcCA9IHRzO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0cy5maXJzdE5vbkxpbmtlZCB8fCB0cztcbiAgICAgICAgaWYgKHRzLmNob2ljZXMpXG4gICAgICAgICAgICByYW5nZS5jdXJzb3IgPSByYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICB2YXIgc2VsID0gdGhpcy5lZGl0b3IubXVsdGlTZWxlY3Q7XG4gICAgICAgICAgICBzZWwudG9TaW5nbGVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRzLmhhc0xpbmtlZFJhbmdlcyAmJiB0c1tpXS5saW5rZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZSh0c1tpXS5jbG9uZSgpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdGlvbi5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iua2V5QmluZGluZy5hZGRLZXlib2FyZEhhbmRsZXIodGhpcy5rZXlib2FyZEhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFRhYnN0b3AgJiYgdGhpcy5zZWxlY3RlZFRhYnN0b3AuY2hvaWNlcylcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKFwic3RhcnRBdXRvY29tcGxldGVcIiwgeyBtYXRjaGVzOiB0aGlzLnNlbGVjdGVkVGFic3RvcC5jaG9pY2VzIH0pO1xuICAgIH07XG4gICAgVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLmFkZFRhYnN0b3BzID0gZnVuY3Rpb24gKHRhYnN0b3BzLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB1c2VMaW5rID0gdGhpcy51c2VMaW5rIHx8ICF0aGlzLmVkaXRvci5nZXRPcHRpb24oXCJlbmFibGVNdWx0aXNlbGVjdFwiKTtcbiAgICAgICAgaWYgKCF0aGlzLiRvcGVuVGFic3RvcHMpXG4gICAgICAgICAgICB0aGlzLiRvcGVuVGFic3RvcHMgPSBbXTtcbiAgICAgICAgaWYgKCF0YWJzdG9wc1swXSkge1xuICAgICAgICAgICAgdmFyIHAgPSBSYW5nZS5mcm9tUG9pbnRzKGVuZCwgZW5kKTtcbiAgICAgICAgICAgIG1vdmVSZWxhdGl2ZShwLnN0YXJ0LCBzdGFydCk7XG4gICAgICAgICAgICBtb3ZlUmVsYXRpdmUocC5lbmQsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRhYnN0b3BzWzBdID0gW3BdO1xuICAgICAgICAgICAgdGFic3RvcHNbMF0uaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIGFyZyA9IFtpICsgMSwgMF07XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgdmFyIHNuaXBwZXRJZCA9IHRoaXMuc25pcHBldElkID0gKHRoaXMuc25pcHBldElkIHx8IDApICsgMTtcbiAgICAgICAgdGFic3RvcHMuZm9yRWFjaChmdW5jdGlvbiAodHMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHRoaXMuJG9wZW5UYWJzdG9wc1tpbmRleF0gfHwgdHM7XG4gICAgICAgICAgICBkZXN0LnNuaXBwZXRJZCA9IHNuaXBwZXRJZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocC5zdGFydCwgcC5lbmQgfHwgcC5zdGFydCk7XG4gICAgICAgICAgICAgICAgbW92ZVBvaW50KHJhbmdlLnN0YXJ0LCBzdGFydCk7XG4gICAgICAgICAgICAgICAgbW92ZVBvaW50KHJhbmdlLmVuZCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm9yaWdpbmFsID0gcDtcbiAgICAgICAgICAgICAgICByYW5nZS50YWJzdG9wID0gZGVzdDtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3QgIT0gdHMpXG4gICAgICAgICAgICAgICAgICAgIGRlc3QudW5zaGlmdChyYW5nZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZXN0W2ldID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHAuZm10U3RyaW5nIHx8IChkZXN0LmZpcnN0Tm9uTGlua2VkICYmIHVzZUxpbmspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmxpbmtlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlc3QuaGFzTGlua2VkUmFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRlc3QuZmlyc3ROb25MaW5rZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlc3QuZmlyc3ROb25MaW5rZWQgPSByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzdC5maXJzdE5vbkxpbmtlZClcbiAgICAgICAgICAgICAgICBkZXN0Lmhhc0xpbmtlZFJhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRlc3QgPT09IHRzKSB7XG4gICAgICAgICAgICAgICAgYXJnLnB1c2goZGVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3BlblRhYnN0b3BzW2luZGV4XSA9IGRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZFRhYnN0b3BNYXJrZXJzKGRlc3QpO1xuICAgICAgICAgICAgZGVzdC5yYW5nZUxpc3QgPSBkZXN0LnJhbmdlTGlzdCB8fCBuZXcgUmFuZ2VMaXN0KCk7XG4gICAgICAgICAgICBkZXN0LnJhbmdlTGlzdC4kYmlhcyA9IDA7XG4gICAgICAgICAgICBkZXN0LnJhbmdlTGlzdC5hZGRMaXN0KGRlc3QpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJzdG9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYXJnLnB1c2goYXJnLnNwbGljZSgyLCAxKVswXSk7XG4gICAgICAgICAgICB0aGlzLnRhYnN0b3BzLnNwbGljZS5hcHBseSh0aGlzLnRhYnN0b3BzLCBhcmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUuYWRkVGFic3RvcE1hcmtlcnMgPSBmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHRzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLm1hcmtlcklkKVxuICAgICAgICAgICAgICAgIHJhbmdlLm1hcmtlcklkID0gc2Vzc2lvbi5hZGRNYXJrZXIocmFuZ2UsIFwiYWNlX3NuaXBwZXQtbWFya2VyXCIsIFwidGV4dFwiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlVGFic3RvcE1hcmtlcnMgPSBmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHRzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXJJZCk7XG4gICAgICAgICAgICByYW5nZS5tYXJrZXJJZCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVRhYnN0b3BNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRUYWJzdG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY3VycmVudFNuaXBwZXRJZCA9IHRoaXMuc2VsZWN0ZWRUYWJzdG9wLnNuaXBwZXRJZDtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRUYWJzdG9wLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50U25pcHBldElkLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWJzdG9wcy5mb3JFYWNoKGZ1bmN0aW9uICh0cykge1xuICAgICAgICAgICAgaWYgKHRzLnNuaXBwZXRJZCA9PT0gY3VycmVudFNuaXBwZXRJZClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhYnN0b3BNYXJrZXJzKHRzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhYnN0b3BNYXJrZXJzKHRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBUYWJzdG9wTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGkgPSByYW5nZS50YWJzdG9wLmluZGV4T2YocmFuZ2UpO1xuICAgICAgICBpZiAoaSAhPSAtMSlcbiAgICAgICAgICAgIHJhbmdlLnRhYnN0b3Auc3BsaWNlKGksIDEpO1xuICAgICAgICBpID0gdGhpcy5yYW5nZXMuaW5kZXhPZihyYW5nZSk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgdGhpcy5yYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpID0gcmFuZ2UudGFic3RvcC5yYW5nZUxpc3QucmFuZ2VzLmluZGV4T2YocmFuZ2UpO1xuICAgICAgICBpZiAoaSAhPSAtMSlcbiAgICAgICAgICAgIHJhbmdlLnRhYnN0b3Auc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlTWFya2VyKHJhbmdlLm1hcmtlcklkKTtcbiAgICAgICAgaWYgKCFyYW5nZS50YWJzdG9wLmxlbmd0aCkge1xuICAgICAgICAgICAgaSA9IHRoaXMudGFic3RvcHMuaW5kZXhPZihyYW5nZS50YWJzdG9wKTtcbiAgICAgICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMudGFic3RvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhYnN0b3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFic3RvcE1hbmFnZXI7XG59KCkpO1xuVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLmtleWJvYXJkSGFuZGxlciA9IG5ldyBIYXNoSGFuZGxlcigpO1xuVGFic3RvcE1hbmFnZXIucHJvdG90eXBlLmtleWJvYXJkSGFuZGxlci5iaW5kS2V5cyh7XG4gICAgXCJUYWJcIjogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBpZiAoZXhwb3J0cy5zbmlwcGV0TWFuYWdlciAmJiBleHBvcnRzLnNuaXBwZXRNYW5hZ2VyLmV4cGFuZFdpdGhUYWIoZWRpdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyLnRhYk5leHQoMSk7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgIH0sXG4gICAgXCJTaGlmdC1UYWJcIjogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3IudGFic3RvcE1hbmFnZXIudGFiTmV4dCgtMSk7XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgIH0sXG4gICAgXCJFc2NcIjogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3IudGFic3RvcE1hbmFnZXIuZGV0YWNoKCk7XG4gICAgfVxufSk7XG52YXIgbW92ZVBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCBkaWZmKSB7XG4gICAgaWYgKHBvaW50LnJvdyA9PSAwKVxuICAgICAgICBwb2ludC5jb2x1bW4gKz0gZGlmZi5jb2x1bW47XG4gICAgcG9pbnQucm93ICs9IGRpZmYucm93O1xufTtcbnZhciBtb3ZlUmVsYXRpdmUgPSBmdW5jdGlvbiAocG9pbnQsIHN0YXJ0KSB7XG4gICAgaWYgKHBvaW50LnJvdyA9PSBzdGFydC5yb3cpXG4gICAgICAgIHBvaW50LmNvbHVtbiAtPSBzdGFydC5jb2x1bW47XG4gICAgcG9pbnQucm93IC09IHN0YXJ0LnJvdztcbn07XG5kb20uaW1wb3J0Q3NzU3RyaW5nKFwiXFxuLmFjZV9zbmlwcGV0LW1hcmtlciB7XFxuICAgIC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgxOTQsIDE5MywgMjA4LCAwLjA5KTtcXG4gICAgYm9yZGVyOiAxcHggZG90dGVkIHJnYmEoMjExLCAyMDgsIDIzNSwgMC42Mik7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XCIsIFwic25pcHBldHMuY3NzXCIsIGZhbHNlKTtcbmV4cG9ydHMuc25pcHBldE1hbmFnZXIgPSBuZXcgU25pcHBldE1hbmFnZXIoKTtcbnZhciBFZGl0b3IgPSByZXF1aXJlKFwiLi9lZGl0b3JcIikuRWRpdG9yO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmluc2VydFNuaXBwZXQgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zbmlwcGV0TWFuYWdlci5pbnNlcnRTbmlwcGV0KHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdGhpcy5leHBhbmRTbmlwcGV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc25pcHBldE1hbmFnZXIuZXhwYW5kV2l0aFRhYih0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xufSkuY2FsbChFZGl0b3IucHJvdG90eXBlKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXV0b2NvbXBsZXRlL3BvcHVwXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFwiYWNlL2VkaXRvclwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoXCIuLi92aXJ0dWFsX3JlbmRlcmVyXCIpLlZpcnR1YWxSZW5kZXJlcjtcbnZhciBFZGl0b3IgPSByZXF1aXJlKFwiLi4vZWRpdG9yXCIpLkVkaXRvcjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBubHMgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpLm5scztcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKFwiLi8uLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIGdldEFyaWFJZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBcInN1Z2dlc3QtYXJpYS1pZDpcIi5jb25jYXQoaW5kZXgpO1xufTtcbnZhciBwb3B1cEFyaWFSb2xlID0gdXNlckFnZW50LmlzU2FmYXJpID8gXCJtZW51XCIgOiBcImxpc3Rib3hcIjtcbnZhciBvcHRpb25BcmlhUm9sZSA9IHVzZXJBZ2VudC5pc1NhZmFyaSA/IFwibWVudWl0ZW1cIiA6IFwib3B0aW9uXCI7XG52YXIgYXJpYUFjdGl2ZVN0YXRlID0gdXNlckFnZW50LmlzU2FmYXJpID8gXCJhcmlhLWN1cnJlbnRcIiA6IFwiYXJpYS1zZWxlY3RlZFwiO1xudmFyICRzaW5nbGVMaW5lRWRpdG9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKGVsKTtcbiAgICByZW5kZXJlci4kbWF4TGluZXMgPSA0O1xuICAgIHZhciBlZGl0b3IgPSBuZXcgRWRpdG9yKHJlbmRlcmVyKTtcbiAgICBlZGl0b3Iuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZShmYWxzZSk7XG4gICAgZWRpdG9yLnNldFNob3dQcmludE1hcmdpbihmYWxzZSk7XG4gICAgZWRpdG9yLnJlbmRlcmVyLnNldFNob3dHdXR0ZXIoZmFsc2UpO1xuICAgIGVkaXRvci5yZW5kZXJlci5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lKGZhbHNlKTtcbiAgICBlZGl0b3IuJG1vdXNlSGFuZGxlci4kZm9jdXNUaW1lb3V0ID0gMDtcbiAgICBlZGl0b3IuJGhpZ2hsaWdodFRhZ1BlbmRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBlZGl0b3I7XG59O1xudmFyIEFjZVBvcHVwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjZVBvcHVwKHBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBwb3B1cCA9ICRzaW5nbGVMaW5lRWRpdG9yKGVsKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIuY29udGVudC5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIuc2V0U3R5bGUoXCJhY2VfYXV0b2NvbXBsZXRlXCIpO1xuICAgICAgICBwb3B1cC5yZW5kZXJlci4kdGV4dExheWVyLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBwb3B1cEFyaWFSb2xlKTtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIuJHRleHRMYXllci5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIG5scyhcImF1dG9jb21wbGV0ZS5wb3B1cC5hcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcIkF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1wiKSk7XG4gICAgICAgIHBvcHVwLnJlbmRlcmVyLiR0ZXh0TGF5ZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG5scyhcImF1dG9jb21wbGV0ZS5wb3B1cC5hcmlhLWxhYmVsXCIsIFwiQXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXCIpKTtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIudGV4dGFyZWEuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBwb3B1cC5zZXRPcHRpb24oXCJkaXNwbGF5SW5kZW50R3VpZGVzXCIsIGZhbHNlKTtcbiAgICAgICAgcG9wdXAuc2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIsIDE1MCk7XG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBwb3B1cC5mb2N1cyA9IG5vb3A7XG4gICAgICAgIHBvcHVwLiRpc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBwb3B1cC5yZW5kZXJlci4kY3Vyc29yTGF5ZXIucmVzdGFydFRpbWVyID0gbm9vcDtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgICBwb3B1cC5yZW5kZXJlci4kbWF4TGluZXMgPSA4O1xuICAgICAgICBwb3B1cC5yZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgcG9wdXAuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZShmYWxzZSk7XG4gICAgICAgIHBvcHVwLnNlc3Npb24uaGlnaGxpZ2h0KFwiXCIpO1xuICAgICAgICBwb3B1cC5zZXNzaW9uLiRzZWFyY2hIaWdobGlnaHQuY2xhenogPSBcImFjZV9oaWdobGlnaHQtbWFya2VyXCI7XG4gICAgICAgIHBvcHVwLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBwb3B1cC5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hcmtlci5zdGFydC5yb3cgPSBzZWxlY3Rpb25NYXJrZXIuZW5kLnJvdyA9IHBvcy5yb3c7XG4gICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW91c2VFdmVudDtcbiAgICAgICAgdmFyIGhvdmVyTWFya2VyID0gbmV3IFJhbmdlKC0xLCAwLCAtMSwgSW5maW5pdHkpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTWFya2VyID0gbmV3IFJhbmdlKC0xLCAwLCAtMSwgSW5maW5pdHkpO1xuICAgICAgICBzZWxlY3Rpb25NYXJrZXIuaWQgPSBwb3B1cC5zZXNzaW9uLmFkZE1hcmtlcihzZWxlY3Rpb25NYXJrZXIsIFwiYWNlX2FjdGl2ZS1saW5lXCIsIFwiZnVsbExpbmVcIik7XG4gICAgICAgIHBvcHVwLnNldFNlbGVjdE9uSG92ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgICAgIGhvdmVyTWFya2VyLmlkID0gcG9wdXAuc2Vzc2lvbi5hZGRNYXJrZXIoaG92ZXJNYXJrZXIsIFwiYWNlX2xpbmUtaG92ZXJcIiwgXCJmdWxsTGluZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhvdmVyTWFya2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgcG9wdXAuc2Vzc2lvbi5yZW1vdmVNYXJrZXIoaG92ZXJNYXJrZXIuaWQpO1xuICAgICAgICAgICAgICAgIGhvdmVyTWFya2VyLmlkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcG9wdXAuc2V0U2VsZWN0T25Ib3ZlcihmYWxzZSk7XG4gICAgICAgIHBvcHVwLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxhc3RNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGFzdE1vdXNlRXZlbnQgPSBlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TW91c2VFdmVudC54ID09IGUueCAmJiBsYXN0TW91c2VFdmVudC55ID09IGUueSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb3VzZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIGxhc3RNb3VzZUV2ZW50LnNjcm9sbFRvcCA9IHBvcHVwLnJlbmRlcmVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHBvcHVwLmlzTW91c2VPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByb3cgPSBsYXN0TW91c2VFdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICAgICAgaWYgKGhvdmVyTWFya2VyLnN0YXJ0LnJvdyAhPSByb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhvdmVyTWFya2VyLmlkKVxuICAgICAgICAgICAgICAgICAgICBwb3B1cC5zZXRSb3cocm93KTtcbiAgICAgICAgICAgICAgICBzZXRIb3Zlck1hcmtlcihyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIub24oXCJiZWZvcmVSZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxhc3RNb3VzZUV2ZW50ICYmIGhvdmVyTWFya2VyLnN0YXJ0LnJvdyAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZUV2ZW50LiRwb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBsYXN0TW91c2VFdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICAgICAgICAgIGlmICghaG92ZXJNYXJrZXIuaWQpXG4gICAgICAgICAgICAgICAgICAgIHBvcHVwLnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgIHNldEhvdmVyTWFya2VyKHJvdywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwb3B1cC5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gcG9wdXAucmVuZGVyZXIuJHRleHRMYXllcjtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHQuY29uZmlnLmZpcnN0Um93LCBsID0gdC5jb25maWcubGFzdFJvdzsgcm93IDw9IGw7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwUm93RWxlbWVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH0gKi8gKHQuZWxlbWVudC5jaGlsZE5vZGVzW3JvdyAtIHQuY29uZmlnLmZpcnN0Um93XSk7XG4gICAgICAgICAgICAgICAgcG9wdXBSb3dFbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgb3B0aW9uQXJpYVJvbGUpO1xuICAgICAgICAgICAgICAgIHBvcHVwUm93RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBubHMoXCJhdXRvY29tcGxldGUucG9wdXAuaXRlbS5hcmlhLXJvbGVkZXNjcmlwdGlvblwiLCBcIml0ZW1cIikpO1xuICAgICAgICAgICAgICAgIHBvcHVwUm93RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNldHNpemVcIiwgcG9wdXAuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHBvcHVwUm93RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIFwiZG9jLXRvb2x0aXBcIik7XG4gICAgICAgICAgICAgICAgcG9wdXBSb3dFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcG9zaW5zZXRcIiwgcm93ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSBwb3B1cC5nZXREYXRhKHJvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyaWFMYWJlbCA9IFwiXCIuY29uY2F0KHJvd0RhdGEuY2FwdGlvbiB8fCByb3dEYXRhLnZhbHVlKS5jb25jYXQocm93RGF0YS5tZXRhID8gXCIsIFwiLmNvbmNhdChyb3dEYXRhLm1ldGEpIDogJycpO1xuICAgICAgICAgICAgICAgICAgICBwb3B1cFJvd0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ZWRTcGFucyA9IHBvcHVwUm93RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFjZV9jb21wbGV0aW9uLWhpZ2hsaWdodFwiKTtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZFNwYW5zLmZvckVhY2goZnVuY3Rpb24gKHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWFya1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHBvcHVwLmdldFJvdygpO1xuICAgICAgICAgICAgdmFyIHQgPSBwb3B1cC5yZW5kZXJlci4kdGV4dExheWVyO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfSAqLyAodC5lbGVtZW50LmNoaWxkTm9kZXNbcm93IC0gdC5jb25maWcuZmlyc3RSb3ddKTtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IC8vIEFjdGl2ZSBlbGVtZW50IGlzIHRleHRhcmVhIG9mIG1haW4gZWRpdG9yXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IHBvcHVwLnNlbGVjdGVkTm9kZSAmJiBwb3B1cC5zZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3MocG9wdXAuc2VsZWN0ZWROb2RlLCBcImFjZV9zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBwb3B1cC5zZWxlY3RlZE5vZGUucmVtb3ZlQXR0cmlidXRlKGFyaWFBY3RpdmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgcG9wdXAuc2VsZWN0ZWROb2RlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICAgICAgcG9wdXAuc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJpYUlkID0gZ2V0QXJpYUlkKHJvdyk7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHNlbGVjdGVkLCBcImFjZV9zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5pZCA9IGFyaWFJZDtcbiAgICAgICAgICAgICAgICB0LmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGFyaWFJZCk7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGFyaWFJZCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0QXR0cmlidXRlKGFyaWFBY3RpdmVTdGF0ZSwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhpZGVIb3Zlck1hcmtlciA9IGZ1bmN0aW9uICgpIHsgc2V0SG92ZXJNYXJrZXIoLTEpOyB9O1xuICAgICAgICB2YXIgc2V0SG92ZXJNYXJrZXIgPSBmdW5jdGlvbiAocm93LCBzdXBwcmVzc1JlZHJhdykge1xuICAgICAgICAgICAgaWYgKHJvdyAhPT0gaG92ZXJNYXJrZXIuc3RhcnQucm93KSB7XG4gICAgICAgICAgICAgICAgaG92ZXJNYXJrZXIuc3RhcnQucm93ID0gaG92ZXJNYXJrZXIuZW5kLnJvdyA9IHJvdztcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHByZXNzUmVkcmF3KVxuICAgICAgICAgICAgICAgICAgICBwb3B1cC5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgICAgICAgICBwb3B1cC5fZW1pdChcImNoYW5nZUhvdmVyTWFya2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwb3B1cC5nZXRIb3ZlcmVkUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvdmVyTWFya2VyLnN0YXJ0LnJvdztcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIocG9wdXAuY29udGFpbmVyLCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBvcHVwLmlzTW91c2VPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBoaWRlSG92ZXJNYXJrZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLm9uKFwiaGlkZVwiLCBoaWRlSG92ZXJNYXJrZXIpO1xuICAgICAgICBwb3B1cC5vbihcImNoYW5nZVNlbGVjdGlvblwiLCBoaWRlSG92ZXJNYXJrZXIpO1xuICAgICAgICBwb3B1cC5zZXNzaW9uLmRvYy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9wdXAuZGF0YS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIHBvcHVwLnNlc3Npb24uZG9jLmdldExpbmUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBwb3B1cC5kYXRhW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGEgJiYgZGF0YS52YWx1ZSkgfHwgXCJcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJnVG9rZW5pemVyID0gcG9wdXAuc2Vzc2lvbi5iZ1Rva2VuaXplcjtcbiAgICAgICAgYmdUb2tlbml6ZXIuJHRva2VuaXplUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBwb3B1cC5kYXRhW3Jvd107XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGRhdGEgPSB7IHZhbHVlOiBkYXRhIH07XG4gICAgICAgICAgICB2YXIgY2FwdGlvbiA9IGRhdGEuY2FwdGlvbiB8fCBkYXRhLnZhbHVlIHx8IGRhdGEubmFtZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFRva2VuKHZhbHVlLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IChkYXRhLmNsYXNzTmFtZSB8fCBcIlwiKSArIChjbGFzc05hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvd2VyID0gY2FwdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGZpbHRlclRleHQgPSAocG9wdXAuZmlsdGVyVGV4dCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbGFzdEkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZmlsdGVyVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9IGxhc3RJICYmIChkYXRhLm1hdGNoTWFzayAmICgxIDw8IGkpIHx8IGkgPT0gZmlsdGVyVGV4dC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWIgPSBmaWx0ZXJUZXh0LnNsaWNlKGxhc3RJLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEkgPSBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsb3dlci5pbmRleE9mKHN1YiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRva2VuKGNhcHRpb24uc2xpY2UobGFzdEluZGV4LCBpbmRleCksIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIHN1Yi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRva2VuKGNhcHRpb24uc2xpY2UoaW5kZXgsIGxhc3RJbmRleCksIFwiY29tcGxldGlvbi1oaWdobGlnaHRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVG9rZW4oY2FwdGlvbi5zbGljZShsYXN0SW5kZXgsIGNhcHRpb24ubGVuZ3RoKSwgXCJcIik7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiY29tcGxldGlvbi1zcGFjZXJcIiwgdmFsdWU6IFwiIFwiIH0pO1xuICAgICAgICAgICAgaWYgKGRhdGEubWV0YSlcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiY29tcGxldGlvbi1tZXRhXCIsIHZhbHVlOiBkYXRhLm1ldGEgfSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJjb21wbGV0aW9uLW1lc3NhZ2VcIiwgdmFsdWU6IGRhdGEubWVzc2FnZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH07XG4gICAgICAgIGJnVG9rZW5pemVyLiR1cGRhdGVPbkNoYW5nZSA9IG5vb3A7XG4gICAgICAgIGJnVG9rZW5pemVyLnN0YXJ0ID0gbm9vcDtcbiAgICAgICAgcG9wdXAuc2Vzc2lvbi4kY29tcHV0ZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuV2lkdGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICBwb3B1cC5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgcG9wdXAuaXNUb3Bkb3duID0gZmFsc2U7XG4gICAgICAgIHBvcHVwLmF1dG9TZWxlY3QgPSB0cnVlO1xuICAgICAgICBwb3B1cC5maWx0ZXJUZXh0ID0gXCJcIjtcbiAgICAgICAgcG9wdXAuaXNNb3VzZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgcG9wdXAuZGF0YSA9IFtdO1xuICAgICAgICBwb3B1cC5zZXREYXRhID0gZnVuY3Rpb24gKGxpc3QsIGZpbHRlclRleHQpIHtcbiAgICAgICAgICAgIHBvcHVwLmZpbHRlclRleHQgPSBmaWx0ZXJUZXh0IHx8IFwiXCI7XG4gICAgICAgICAgICBwb3B1cC5zZXRWYWx1ZShsYW5nLnN0cmluZ1JlcGVhdChcIlxcblwiLCBsaXN0Lmxlbmd0aCksIC0xKTtcbiAgICAgICAgICAgIHBvcHVwLmRhdGEgPSBsaXN0IHx8IFtdO1xuICAgICAgICAgICAgcG9wdXAuc2V0Um93KDApO1xuICAgICAgICB9O1xuICAgICAgICBwb3B1cC5nZXREYXRhID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHBvcHVwLmRhdGFbcm93XTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9wdXAuZ2V0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbk1hcmtlci5zdGFydC5yb3c7XG4gICAgICAgIH07XG4gICAgICAgIHBvcHVwLnNldFJvdyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBsaW5lID0gTWF0aC5tYXgodGhpcy5hdXRvU2VsZWN0ID8gMCA6IC0xLCBNYXRoLm1pbih0aGlzLmRhdGEubGVuZ3RoIC0gMSwgbGluZSkpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1hcmtlci5zdGFydC5yb3cgIT0gbGluZSkge1xuICAgICAgICAgICAgICAgIHBvcHVwLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1hcmtlci5zdGFydC5yb3cgPSBzZWxlY3Rpb25NYXJrZXIuZW5kLnJvdyA9IGxpbmUgfHwgMDtcbiAgICAgICAgICAgICAgICBwb3B1cC5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgICAgICAgICBwb3B1cC5tb3ZlQ3Vyc29yVG8obGluZSB8fCAwLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAuaXNPcGVuKVxuICAgICAgICAgICAgICAgICAgICBwb3B1cC5fc2lnbmFsKFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwb3B1cC5vbihcImNoYW5nZVNlbGVjdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocG9wdXAuaXNPcGVuKVxuICAgICAgICAgICAgICAgIHBvcHVwLnNldFJvdyhwb3B1cC5zZWxlY3Rpb24ubGVhZC5yb3cpO1xuICAgICAgICAgICAgcG9wdXAucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBwb3B1cC5hbmNob3JQb3MgPSBudWxsO1xuICAgICAgICAgICAgcG9wdXAuYW5jaG9yID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3B1cC5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBwb3B1cC5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJoaWRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwb3B1cC50cnlTaG93ID0gZnVuY3Rpb24gKHBvcywgbGluZUhlaWdodCwgYW5jaG9yLCBmb3JjZVNob3cpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2VTaG93ICYmIHBvcHVwLmlzT3BlbiAmJiBwb3B1cC5hbmNob3JQb3MgJiYgcG9wdXAuYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgcG9wdXAuYW5jaG9yUG9zLnRvcCA9PT0gcG9zLnRvcCAmJiBwb3B1cC5hbmNob3JQb3MubGVmdCA9PT0gcG9zLmxlZnQgJiZcbiAgICAgICAgICAgICAgICBwb3B1cC5hbmNob3IgPT09IGFuY2hvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc2NyZWVuSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjcmVlbldpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICAgICAgdmFyIG1heEggPSByZW5kZXJlci4kbWF4TGluZXMgKiBsaW5lSGVpZ2h0ICogMS40O1xuICAgICAgICAgICAgdmFyIGRpbXMgPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICB2YXIgc3BhY2VCZWxvdyA9IHNjcmVlbkhlaWdodCAtIHBvcy50b3AgLSAzICogdGhpcy4kYm9yZGVyU2l6ZSAtIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc3BhY2VBYm92ZSA9IHBvcy50b3AgLSAzICogdGhpcy4kYm9yZGVyU2l6ZTtcbiAgICAgICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlQWJvdmUgPD0gc3BhY2VCZWxvdyB8fCBzcGFjZUJlbG93ID49IG1heEgpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IFwidG9wXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuY2hvciA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIGRpbXMuYm90dG9tID0gcG9zLnRvcCAtIHRoaXMuJGJvcmRlclNpemU7XG4gICAgICAgICAgICAgICAgZGltcy50b3AgPSBkaW1zLmJvdHRvbSAtIG1heEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbmNob3IgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgICAgICBkaW1zLnRvcCA9IHBvcy50b3AgKyBsaW5lSGVpZ2h0ICsgdGhpcy4kYm9yZGVyU2l6ZTtcbiAgICAgICAgICAgICAgICBkaW1zLmJvdHRvbSA9IGRpbXMudG9wICsgbWF4SDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXRzWCA9IGRpbXMudG9wID49IDAgJiYgZGltcy5ib3R0b20gPD0gc2NyZWVuSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFmb3JjZVNob3cgJiYgIWZpdHNYKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaXRzWCkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuJG1heFBpeGVsSGVpZ2h0ID0gc3BhY2VBYm92ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLiRtYXhQaXhlbEhlaWdodCA9IHNwYWNlQmVsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuJG1heFBpeGVsSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmNob3IgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmJvdHRvbSA9IChzY3JlZW5IZWlnaHQgLSBkaW1zLmJvdHRvbSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgcG9wdXAuaXNUb3Bkb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBkaW1zLnRvcCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5ib3R0b20gPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBvcHVwLmlzVG9wZG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgICAgICBpZiAobGVmdCArIGVsLm9mZnNldFdpZHRoID4gc2NyZWVuV2lkdGgpXG4gICAgICAgICAgICAgICAgbGVmdCA9IHNjcmVlbldpZHRoIC0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIGVsLnN0eWxlLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghcG9wdXAuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgcG9wdXAuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJzaG93XCIpO1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcHVwLmFuY2hvclBvcyA9IHBvcztcbiAgICAgICAgICAgIHBvcHVwLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBwb3B1cC5zaG93ID0gZnVuY3Rpb24gKHBvcywgbGluZUhlaWdodCwgdG9wZG93bk9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5U2hvdyhwb3MsIGxpbmVIZWlnaHQsIHRvcGRvd25Pbmx5ID8gXCJib3R0b21cIiA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcHVwLmdvVG8gPSBmdW5jdGlvbiAod2hlcmUpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdygpO1xuICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHdoZXJlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvdyA8PSAwID8gbWF4IDogcm93IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93ID49IG1heCA/IC0xIDogcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Um93KHJvdyk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcHVwLmdldFRleHRMZWZ0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGJvcmRlclNpemUgKyB0aGlzLnJlbmRlcmVyLiRwYWRkaW5nICsgdGhpcy4kaW1hZ2VTaXplO1xuICAgICAgICB9O1xuICAgICAgICBwb3B1cC4kaW1hZ2VTaXplID0gMDtcbiAgICAgICAgcG9wdXAuJGJvcmRlclNpemUgPSAxO1xuICAgICAgICByZXR1cm4gcG9wdXA7XG4gICAgfVxuICAgIHJldHVybiBBY2VQb3B1cDtcbn0oKSk7XG5kb20uaW1wb3J0Q3NzU3RyaW5nKFwiXFxuLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0NBRDZGQTtcXG4gICAgei1pbmRleDogMTtcXG59XFxuLmFjZV9kYXJrLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNhNjc0ZTtcXG59XFxuLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX2xpbmUtaG92ZXIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYWJiZmZlO1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIzMywyMzMsMjUzLDAuNCk7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuLmFjZV9kYXJrLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX2xpbmUtaG92ZXIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwOSwgMTUwLCAxMywgMC44KTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSg1OCwgMTAzLCA3OCwgMC42Mik7XFxufVxcbi5hY2VfY29tcGxldGlvbi1tZXRhIHtcXG4gICAgb3BhY2l0eTogMC41O1xcbiAgICBtYXJnaW4tbGVmdDogMC45ZW07XFxufVxcbi5hY2VfY29tcGxldGlvbi1tZXNzYWdlIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuOWVtO1xcbiAgICBjb2xvcjogYmx1ZTtcXG59XFxuLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX2NvbXBsZXRpb24taGlnaGxpZ2h0e1xcbiAgICBjb2xvcjogIzJkNjljNztcXG59XFxuLmFjZV9kYXJrLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX2NvbXBsZXRpb24taGlnaGxpZ2h0e1xcbiAgICBjb2xvcjogIzkzY2ExMjtcXG59XFxuLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSB7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgei1pbmRleDogMjAwMDAwO1xcbiAgICBib3JkZXI6IDFweCBsaWdodGdyYXkgc29saWQ7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm94LXNoYWRvdzogMnB4IDNweCA1cHggcmdiYSgwLDAsMCwuMik7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XFxuICAgIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICAgIGNvbG9yOiAjMTExO1xcbn1cXG4uYWNlX2RhcmsuYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIHtcXG4gICAgYm9yZGVyOiAxcHggIzQ4NDc0NyBzb2xpZDtcXG4gICAgYm94LXNoYWRvdzogMnB4IDNweCA1cHggcmdiYSgwLCAwLCAwLCAwLjUxKTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG4gICAgYmFja2dyb3VuZDogIzI1MjgyYztcXG4gICAgY29sb3I6ICNjMWMxYzE7XFxufVxcbi5hY2VfYXV0b2NvbXBsZXRlIC5hY2VfdGV4dC1sYXllciAge1xcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gOHB4KTtcXG59XFxuLmFjZV9hdXRvY29tcGxldGUgLmFjZV9saW5lIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLmFjZV9hdXRvY29tcGxldGUgLmFjZV9saW5lID4gKiB7XFxuICAgIG1pbi13aWR0aDogMDtcXG4gICAgZmxleDogMCAwIGF1dG87XFxufVxcbi5hY2VfYXV0b2NvbXBsZXRlIC5hY2VfbGluZSAuYWNlXyB7XFxuICAgIGZsZXg6IDAgMSBhdXRvO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG59XFxuLmFjZV9hdXRvY29tcGxldGUgLmFjZV9jb21wbGV0aW9uLXNwYWNlciB7XFxuICAgIGZsZXg6IDE7XFxufVxcbi5hY2VfYXV0b2NvbXBsZXRlLmFjZV9sb2FkaW5nOmFmdGVyICB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMHB4O1xcbiAgICBoZWlnaHQ6IDJweDtcXG4gICAgd2lkdGg6IDglO1xcbiAgICBiYWNrZ3JvdW5kOiBibHVlO1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIGFuaW1hdGlvbjogYWNlX3Byb2dyZXNzIDNzIGluZmluaXRlIGxpbmVhcjtcXG4gICAgYW5pbWF0aW9uLWRlbGF5OiAzMDBtcztcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDAlKSBzY2FsZVgoMSk7XFxufVxcbkBrZXlmcmFtZXMgYWNlX3Byb2dyZXNzIHtcXG4gICAgMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMCUpIHNjYWxlWCgxKSB9XFxuICAgIDUwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCg2MjUlKSBzY2FsZVgoMikgfSBcXG4gICAgMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNTAwJSkgc2NhbGVYKDMpIH0gXFxufVxcbkBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbikge1xcbiAgICAuYWNlX2F1dG9jb21wbGV0ZS5hY2VfbG9hZGluZzphZnRlciB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNjI1JSkgc2NhbGVYKDIpO1xcbiAgICAgICAgYW5pbWF0aW9uOiBub25lO1xcbiAgICAgfVxcbn1cXG5cIiwgXCJhdXRvY29tcGxldGlvbi5jc3NcIiwgZmFsc2UpO1xuZXhwb3J0cy5BY2VQb3B1cCA9IEFjZVBvcHVwO1xuZXhwb3J0cy4kc2luZ2xlTGluZUVkaXRvciA9ICRzaW5nbGVMaW5lRWRpdG9yO1xuZXhwb3J0cy5nZXRBcmlhSWQgPSBnZXRBcmlhSWQ7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2F1dG9jb21wbGV0ZS9pbmxpbmVfc2NyZWVucmVhZGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xudmFyIEFjZUlubGluZVNjcmVlblJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBY2VJbmxpbmVTY3JlZW5SZWFkZXIoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLnNjcmVlblJlYWRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2NyZWVuUmVhZGVyRGl2LmNsYXNzTGlzdC5hZGQoXCJhY2Vfc2NyZWVucmVhZGVyLW9ubHlcIik7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNjcmVlblJlYWRlckRpdik7XG4gICAgfVxuICAgIEFjZUlubGluZVNjcmVlblJlYWRlci5wcm90b3R5cGUuc2V0U2NyZWVuUmVhZGVyQ29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5wb3B1cCAmJiB0aGlzLmVkaXRvci5jb21wbGV0ZXIgJiYgLyoqQHR5cGV7aW1wb3J0KFwiLi4vYXV0b2NvbXBsZXRlXCIpLkF1dG9jb21wbGV0ZX0qLyAodGhpcy5lZGl0b3IuY29tcGxldGVyKS5wb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IC8qKkB0eXBle2ltcG9ydChcIi4uL2F1dG9jb21wbGV0ZVwiKS5BdXRvY29tcGxldGV9Ki8gKHRoaXMuZWRpdG9yLmNvbXBsZXRlcikucG9wdXA7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnBvcHVwLmdldFJvdygpO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5wb3B1cC5yZW5kZXJlci4kdGV4dExheWVyO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHQuZWxlbWVudC5jaGlsZE5vZGVzW3JvdyAtIHQuY29uZmlnLmZpcnN0Um93XTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkU3RyaW5nID0gXCJkb2MtdG9vbHRpcCBcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgdGhpcy5fbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRTdHJpbmcgKz0gXCJhY2UtaW5saW5lLXNjcmVlbnJlYWRlci1saW5lLVwiLmNvbmNhdChsaW5lSW5kZXgsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGlkU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnNjcmVlblJlYWRlckRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmVlblJlYWRlckRpdi5yZW1vdmVDaGlsZCh0aGlzLnNjcmVlblJlYWRlckRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5lcyA9IGNvbnRlbnQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgICAgIHZhciBjb2RlRWxlbWVudCA9IHRoaXMuY3JlYXRlQ29kZUJsb2NrKCk7XG4gICAgICAgIHRoaXMuc2NyZWVuUmVhZGVyRGl2LmFwcGVuZENoaWxkKGNvZGVFbGVtZW50KTtcbiAgICB9O1xuICAgIEFjZUlubGluZVNjcmVlblJlYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JlZW5SZWFkZXJEaXYucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBBY2VJbmxpbmVTY3JlZW5SZWFkZXIucHJvdG90eXBlLmNyZWF0ZUNvZGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImFjZS1pbmxpbmUtc2NyZWVucmVhZGVyXCIpO1xuICAgICAgICBmb3IgKHZhciBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCB0aGlzLl9saW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY29kZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29kZVwiKTtcbiAgICAgICAgICAgIGNvZGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIFwiYWNlLWlubGluZS1zY3JlZW5yZWFkZXItbGluZS1cIi5jb25jYXQobGluZUluZGV4KSk7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX2xpbmVzW2xpbmVJbmRleF0pO1xuICAgICAgICAgICAgY29kZUVsZW1lbnQuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29kZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gQWNlSW5saW5lU2NyZWVuUmVhZGVyO1xufSgpKTtcbmV4cG9ydHMuQWNlSW5saW5lU2NyZWVuUmVhZGVyID0gQWNlSW5saW5lU2NyZWVuUmVhZGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9hdXRvY29tcGxldGUvaW5saW5lXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2Uvc25pcHBldHNcIixcImFjZS9hdXRvY29tcGxldGUvaW5saW5lX3NjcmVlbnJlYWRlclwiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcInVzZSBzdHJpY3RcIjtcbnZhciBzbmlwcGV0TWFuYWdlciA9IHJlcXVpcmUoXCIuLi9zbmlwcGV0c1wiKS5zbmlwcGV0TWFuYWdlcjtcbnZhciBBY2VJbmxpbmVTY3JlZW5SZWFkZXIgPSByZXF1aXJlKFwiLi9pbmxpbmVfc2NyZWVucmVhZGVyXCIpLkFjZUlubGluZVNjcmVlblJlYWRlcjtcbnZhciBBY2VJbmxpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNlSW5saW5lKCkge1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgfVxuICAgIEFjZUlubGluZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChlZGl0b3IsIGNvbXBsZXRpb24sIHByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJcIjtcbiAgICAgICAgaWYgKGVkaXRvciAmJiB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lU2NyZWVuUmVhZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVkaXRvciB8fCAhY29tcGxldGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pbmxpbmVTY3JlZW5SZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lU2NyZWVuUmVhZGVyID0gbmV3IEFjZUlubGluZVNjcmVlblJlYWRlcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXNwbGF5VGV4dCA9IGNvbXBsZXRpb24uc25pcHBldCA/IHNuaXBwZXRNYW5hZ2VyLmdldERpc3BsYXlUZXh0Rm9yU25pcHBldChlZGl0b3IsIGNvbXBsZXRpb24uc25pcHBldCkgOiBjb21wbGV0aW9uLnZhbHVlO1xuICAgICAgICBpZiAoY29tcGxldGlvbi5oaWRlSW5saW5lUHJldmlldyB8fCAhZGlzcGxheVRleHQgfHwgIWRpc3BsYXlUZXh0LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLmlubGluZVNjcmVlblJlYWRlci5zZXRTY3JlZW5SZWFkZXJDb250ZW50KGRpc3BsYXlUZXh0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBkaXNwbGF5VGV4dC5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKGRpc3BsYXlUZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBlZGl0b3IucmVtb3ZlR2hvc3RUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0R2hvc3RUZXh0KGRpc3BsYXlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEFjZUlubGluZS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5lZGl0b3IucmVuZGVyZXIuJGdob3N0VGV4dDtcbiAgICB9O1xuICAgIEFjZUlubGluZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbW92ZUdob3N0VGV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEFjZUlubGluZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaW5saW5lU2NyZWVuUmVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubGluZVNjcmVlblJlYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlubGluZVNjcmVlblJlYWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBY2VJbmxpbmU7XG59KCkpO1xuZXhwb3J0cy5BY2VJbmxpbmUgPSBBY2VJbmxpbmU7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2F1dG9jb21wbGV0ZS91dGlsXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1widXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wYXJGb3JFYWNoID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICB2YXIgYXJMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyTGVuZ3RoID09PSAwKVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJMZW5ndGg7IGkrKykge1xuICAgICAgICBmbihhcnJheVtpXSwgZnVuY3Rpb24gKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQrKztcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT09IGFyTGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBJRF9SRUdFWCA9IC9bYS16QS1aXzAtOVxcJFxcLVxcdTAwQTItXFx1MjAwMFxcdTIwNzAtXFx1RkZGRl0vO1xuZXhwb3J0cy5yZXRyaWV2ZVByZWNlZGluZ0lkZW50aWZpZXIgPSBmdW5jdGlvbiAodGV4dCwgcG9zLCByZWdleCkge1xuICAgIHJlZ2V4ID0gcmVnZXggfHwgSURfUkVHRVg7XG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBwb3MgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocmVnZXgudGVzdCh0ZXh0W2ldKSlcbiAgICAgICAgICAgIGJ1Zi5wdXNoKHRleHRbaV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn07XG5leHBvcnRzLnJldHJpZXZlRm9sbG93aW5nSWRlbnRpZmllciA9IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHJlZ2V4KSB7XG4gICAgcmVnZXggPSByZWdleCB8fCBJRF9SRUdFWDtcbiAgICB2YXIgYnVmID0gW107XG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2V4LnRlc3QodGV4dFtpXSkpXG4gICAgICAgICAgICBidWYucHVzaCh0ZXh0W2ldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5nZXRDb21wbGV0aW9uUHJlZml4ID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgIHZhciBwb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgbGluZSA9IGVkaXRvci5zZXNzaW9uLmdldExpbmUocG9zLnJvdyk7XG4gICAgdmFyIHByZWZpeDtcbiAgICBlZGl0b3IuY29tcGxldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wbGV0ZXIpIHtcbiAgICAgICAgaWYgKGNvbXBsZXRlci5pZGVudGlmaWVyUmVnZXhwcykge1xuICAgICAgICAgICAgY29tcGxldGVyLmlkZW50aWZpZXJSZWdleHBzLmZvckVhY2goZnVuY3Rpb24gKGlkZW50aWZpZXJSZWdleCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJlZml4ICYmIGlkZW50aWZpZXJSZWdleClcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5yZXRyaWV2ZVByZWNlZGluZ0lkZW50aWZpZXIobGluZSwgcG9zLmNvbHVtbiwgaWRlbnRpZmllclJlZ2V4KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHJldHVybiBwcmVmaXggfHwgdGhpcy5yZXRyaWV2ZVByZWNlZGluZ0lkZW50aWZpZXIobGluZSwgcG9zLmNvbHVtbik7XG59O1xuZXhwb3J0cy50cmlnZ2VyQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gKGVkaXRvciwgcHJldmlvdXNDaGFyKSB7XG4gICAgdmFyIHByZXZpb3VzQ2hhciA9IHByZXZpb3VzQ2hhciA9PSBudWxsXG4gICAgICAgID8gZWRpdG9yLnNlc3Npb24uZ2V0UHJlY2VkaW5nQ2hhcmFjdGVyKClcbiAgICAgICAgOiBwcmV2aW91c0NoYXI7XG4gICAgcmV0dXJuIGVkaXRvci5jb21wbGV0ZXJzLnNvbWUoZnVuY3Rpb24gKGNvbXBsZXRlcikge1xuICAgICAgICBpZiAoY29tcGxldGVyLnRyaWdnZXJDaGFyYWN0ZXJzICYmIEFycmF5LmlzQXJyYXkoY29tcGxldGVyLnRyaWdnZXJDaGFyYWN0ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlci50cmlnZ2VyQ2hhcmFjdGVycy5pbmNsdWRlcyhwcmV2aW91c0NoYXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9hdXRvY29tcGxldGVcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIixcImFjZS9hdXRvY29tcGxldGUvcG9wdXBcIixcImFjZS9hdXRvY29tcGxldGUvaW5saW5lXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3BvcHVwXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9kb21cIixcImFjZS9zbmlwcGV0c1wiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi9zY3JvbGxcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgSGFzaEhhbmRsZXIgPSByZXF1aXJlKFwiLi9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIikuSGFzaEhhbmRsZXI7XG52YXIgQWNlUG9wdXAgPSByZXF1aXJlKFwiLi9hdXRvY29tcGxldGUvcG9wdXBcIikuQWNlUG9wdXA7XG52YXIgQWNlSW5saW5lID0gcmVxdWlyZShcIi4vYXV0b2NvbXBsZXRlL2lubGluZVwiKS5BY2VJbmxpbmU7XG52YXIgZ2V0QXJpYUlkID0gcmVxdWlyZShcIi4vYXV0b2NvbXBsZXRlL3BvcHVwXCIpLmdldEFyaWFJZDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vYXV0b2NvbXBsZXRlL3V0aWxcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIGRvbSA9IHJlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgc25pcHBldE1hbmFnZXIgPSByZXF1aXJlKFwiLi9zbmlwcGV0c1wiKS5zbmlwcGV0TWFuYWdlcjtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgZXZlbnQgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRcIik7XG52YXIgcHJldmVudFBhcmVudFNjcm9sbCA9IHJlcXVpcmUoXCIuL2xpYi9zY3JvbGxcIikucHJldmVudFBhcmVudFNjcm9sbDtcbnZhciBkZXN0cm95Q29tcGxldGVyID0gZnVuY3Rpb24gKGUsIGVkaXRvcikge1xuICAgIGVkaXRvci5jb21wbGV0ZXIgJiYgZWRpdG9yLmNvbXBsZXRlci5kZXN0cm95KCk7XG59O1xudmFyIEF1dG9jb21wbGV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuYXV0b0luc2VydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9TZWxlY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9TaG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4YWN0TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmxpbmVFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRIYW5kbGVyID0gbmV3IEhhc2hIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRIYW5kbGVyLmJpbmRLZXlzKHRoaXMuY29tbWFuZHMpO1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNldFNlbGVjdE9uSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTZWVuID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnNob3dMb2FkaW5nU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGlja3lTZWxlY3Rpb25EZWxheSA9IDUwMDtcbiAgICAgICAgdGhpcy5ibHVyTGlzdGVuZXIgPSB0aGlzLmJsdXJMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gdGhpcy5jaGFuZ2VMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdXNlZG93bkxpc3RlbmVyID0gdGhpcy5tb3VzZWRvd25MaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1vdXNld2hlZWxMaXN0ZW5lciA9IHRoaXMubW91c2V3aGVlbExpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MYXlvdXRDaGFuZ2UgPSB0aGlzLm9uTGF5b3V0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlVGltZXIgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29tcGxldGlvbnModHJ1ZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLnVwZGF0ZURvY1Rvb2x0aXAuYmluZCh0aGlzKSwgNTApO1xuICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBsYW5nLmRlbGF5ZWRDYWxsKHRoaXMuJHVwZGF0ZVBvcHVwUG9zaXRpb24uYmluZCh0aGlzKSwgNTApO1xuICAgICAgICB0aGlzLnN0aWNreVNlbGVjdGlvblRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0aWNreVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5zdGlja3lTZWxlY3Rpb25EZWxheSk7XG4gICAgICAgIHRoaXMuJGZpcnN0T3BlblRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbCgvKipAdGhpc3tBdXRvY29tcGxldGV9Ki8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuY29tcGxldGlvblByb3ZpZGVyICYmIHRoaXMuY29tcGxldGlvblByb3ZpZGVyLmluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TaG93biB8fCAodGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLmlzT3BlbikgfHwgIWluaXRpYWxQb3NpdGlvbiB8fCB0aGlzLmVkaXRvci5jb21wbGV0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25zID0gbmV3IEZpbHRlcmVkTGlzdChBdXRvY29tcGxldGUuY29tcGxldGlvbnNGb3JMb2FkaW5nKTtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKHRoaXMuZWRpdG9yLCBpbml0aWFsUG9zaXRpb24ucHJlZml4LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnJlbmRlcmVyLnNldFN0eWxlKFwiYWNlX2xvYWRpbmdcIiwgdHJ1ZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5zdGlja3lTZWxlY3Rpb25EZWxheSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvY29tcGxldGUsIFwiY29tcGxldGlvbnNGb3JMb2FkaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgY2FwdGlvbjogY29uZmlnLm5scyhcImF1dG9jb21wbGV0ZS5sb2FkaW5nXCIsIFwiTG9hZGluZy4uLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuJGluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucG9wdXAgPSBuZXcgQWNlUG9wdXAodGhpcy5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5wb3B1cC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydE1hdGNoKCk7XG4gICAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5wb3B1cC5mb2N1cyA9IHRoaXMuZWRpdG9yLmZvY3VzLmJpbmQodGhpcy5lZGl0b3IpO1xuICAgICAgICB0aGlzLnBvcHVwLm9uKFwic2hvd1wiLCB0aGlzLiRvblBvcHVwU2hvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5wb3B1cC5vbihcImhpZGVcIiwgdGhpcy4kb25IaWRlUG9wdXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucG9wdXAub24oXCJzZWxlY3RcIiwgdGhpcy4kb25Qb3B1cENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5wb3B1cC5jb250YWluZXIsIFwibW91c2VvdXRcIiwgdGhpcy5tb3VzZU91dExpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnBvcHVwLm9uKFwiY2hhbmdlSG92ZXJNYXJrZXJcIiwgdGhpcy50b29sdGlwVGltZXIuYmluZChudWxsLCBudWxsKSk7XG4gICAgICAgIHRoaXMucG9wdXAucmVuZGVyZXIub24oXCJhZnRlclJlbmRlclwiLCB0aGlzLiRvblBvcHVwUmVuZGVyLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1cDtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuJGluaXRJbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmxpbmVFbmFibGVkIHx8IHRoaXMuaW5saW5lUmVuZGVyZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5saW5lUmVuZGVyZXIgPSBuZXcgQWNlSW5saW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlubGluZVJlbmRlcmVyO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5nZXRQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXAgfHwgdGhpcy4kaW5pdCgpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS4kb25IaWRlUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlubGluZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubGluZVJlbmRlcmVyLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpZGVEb2NUb29sdGlwKCk7XG4gICAgICAgIHRoaXMuc3RpY2t5U2VsZWN0aW9uVGltZXIuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMucG9wdXBUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5zdGlja3lTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuJHNlZW4gPSBmdW5jdGlvbiAoY29tcGxldGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2Vlbi5oYXMoY29tcGxldGlvbikgJiYgY29tcGxldGlvbiAmJiBjb21wbGV0aW9uLmNvbXBsZXRlciAmJiBjb21wbGV0aW9uLmNvbXBsZXRlci5vblNlZW4gJiYgdHlwZW9mIGNvbXBsZXRpb24uY29tcGxldGVyLm9uU2VlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9uLmNvbXBsZXRlci5vblNlZW4odGhpcy5lZGl0b3IsIGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgdGhpcy5oYXNTZWVuLmFkZChjb21wbGV0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS4kb25Qb3B1cENoYW5nZSA9IGZ1bmN0aW9uIChoaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmlubGluZVJlbmRlcmVyICYmIHRoaXMuaW5saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRpb24gPSBoaWRlID8gbnVsbCA6IHRoaXMucG9wdXAuZ2V0RGF0YSh0aGlzLnBvcHVwLmdldFJvdygpKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUdob3N0VGV4dChjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwLmlzTW91c2VPdmVyICYmIHRoaXMuc2V0U2VsZWN0T25Ib3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcFRpbWVyLmNhbGwobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3B1cFRpbWVyLnNjaGVkdWxlKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBUaW1lci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFRpbWVyLmNhbGwobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBUaW1lci5jYWxsKG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLiR1cGRhdGVHaG9zdFRleHQgPSBmdW5jdGlvbiAoY29tcGxldGlvbikge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5iYXNlLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuYmFzZS5jb2x1bW47XG4gICAgICAgIHZhciBjdXJzb3JDb2x1bW4gPSB0aGlzLmVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLmNvbHVtbjtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuZWRpdG9yLnNlc3Npb24uZ2V0TGluZShyb3cpLnNsaWNlKGNvbHVtbiwgY3Vyc29yQ29sdW1uKTtcbiAgICAgICAgaWYgKCF0aGlzLmlubGluZVJlbmRlcmVyLnNob3codGhpcy5lZGl0b3IsIGNvbXBsZXRpb24sIHByZWZpeCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lUmVuZGVyZXIuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kc2Vlbihjb21wbGV0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS4kb25Qb3B1cFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubGluZUVuYWJsZWQgPSB0aGlzLmlubGluZVJlbmRlcmVyICYmIHRoaXMuaW5saW5lRW5hYmxlZDtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGlvbnMgJiYgdGhpcy5jb21wbGV0aW9ucy5maWx0ZXJlZCAmJiB0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcHVwLmdldEZpcnN0VmlzaWJsZVJvdygpOyBpIDw9IHRoaXMucG9wdXAuZ2V0TGFzdFZpc2libGVSb3coKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRpb24gPSB0aGlzLnBvcHVwLmdldERhdGEoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24gJiYgKCFpbmxpbmVFbmFibGVkIHx8IGNvbXBsZXRpb24uaGlkZUlubGluZVByZXZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHNlZW4oY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLiRvblBvcHVwU2hvdyA9IGZ1bmN0aW9uIChoaWRlKSB7XG4gICAgICAgIHRoaXMuJG9uUG9wdXBDaGFuZ2UoaGlkZSk7XG4gICAgICAgIHRoaXMuc3RpY2t5U2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0aWNreVNlbGVjdGlvbkRlbGF5ID49IDApXG4gICAgICAgICAgICB0aGlzLnN0aWNreVNlbGVjdGlvblRpbWVyLnNjaGVkdWxlKHRoaXMuc3RpY2t5U2VsZWN0aW9uRGVsYXkpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5vYnNlcnZlTGF5b3V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRzIHx8ICF0aGlzLmVkaXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbkxheW91dENoYW5nZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lZGl0b3IuY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uTGF5b3V0Q2hhbmdlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUudW5PYnNlcnZlTGF5b3V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbkxheW91dENoYW5nZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudHMgJiYgdGhpcy4kZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX3RoaXMub25MYXlvdXRDaGFuZ2UsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnRzID0gbnVsbDtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUub25MYXlvdXRDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wb3B1cC5pc09wZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bk9ic2VydmVMYXlvdXRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZVBvcHVwUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVEb2NUb29sdGlwKCk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLiR1cGRhdGVQb3B1cFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSByZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgcG9zID0gcmVuZGVyZXIuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24odGhpcy5iYXNlLCB0cnVlKTtcbiAgICAgICAgcG9zLmxlZnQgLT0gdGhpcy5wb3B1cC5nZXRUZXh0TGVmdE9mZnNldCgpO1xuICAgICAgICB2YXIgcmVjdCA9IGVkaXRvci5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHBvcy50b3AgKz0gcmVjdC50b3AgLSByZW5kZXJlci5sYXllckNvbmZpZy5vZmZzZXQ7XG4gICAgICAgIHBvcy5sZWZ0ICs9IHJlY3QubGVmdCAtIGVkaXRvci5yZW5kZXJlci5zY3JvbGxMZWZ0O1xuICAgICAgICBwb3MubGVmdCArPSByZW5kZXJlci5ndXR0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBvc0dob3N0VGV4dCA9IHtcbiAgICAgICAgICAgIHRvcDogcG9zLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHBvcy5sZWZ0XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZW5kZXJlci4kZ2hvc3RUZXh0ICYmIHJlbmRlcmVyLiRnaG9zdFRleHRXaWRnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2Uucm93ID09PSByZW5kZXJlci4kZ2hvc3RUZXh0LnBvc2l0aW9uLnJvdykge1xuICAgICAgICAgICAgICAgIHBvc0dob3N0VGV4dC50b3AgKz0gcmVuZGVyZXIuJGdob3N0VGV4dFdpZGdldC5lbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRvckNvbnRhaW5lckJvdHRvbSA9IGVkaXRvci5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gbGluZUhlaWdodDtcbiAgICAgICAgdmFyIGxvd2VzdFBvc2l0aW9uID0gZWRpdG9yQ29udGFpbmVyQm90dG9tIDwgcG9zR2hvc3RUZXh0LnRvcCA/XG4gICAgICAgICAgICB7IHRvcDogZWRpdG9yQ29udGFpbmVyQm90dG9tLCBsZWZ0OiBwb3NHaG9zdFRleHQubGVmdCB9IDpcbiAgICAgICAgICAgIHBvc0dob3N0VGV4dDtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAudHJ5U2hvdyhsb3dlc3RQb3NpdGlvbiwgbGluZUhlaWdodCwgXCJib3R0b21cIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3B1cC50cnlTaG93KHBvcywgbGluZUhlaWdodCwgXCJ0b3BcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcHVwLnNob3cocG9zLCBsaW5lSGVpZ2h0KTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUub3BlblBvcHVwID0gZnVuY3Rpb24gKGVkaXRvciwgcHJlZml4LCBrZWVwUG9wdXBQb3NpdGlvbikge1xuICAgICAgICB0aGlzLiRmaXJzdE9wZW5UaW1lci5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCF0aGlzLnBvcHVwKVxuICAgICAgICAgICAgdGhpcy4kaW5pdCgpO1xuICAgICAgICBpZiAodGhpcy5pbmxpbmVFbmFibGVkICYmICF0aGlzLmlubGluZVJlbmRlcmVyKVxuICAgICAgICAgICAgdGhpcy4kaW5pdElubGluZSgpO1xuICAgICAgICB0aGlzLnBvcHVwLmF1dG9TZWxlY3QgPSB0aGlzLmF1dG9TZWxlY3Q7XG4gICAgICAgIHRoaXMucG9wdXAuc2V0U2VsZWN0T25Ib3Zlcih0aGlzLnNldFNlbGVjdE9uSG92ZXIpO1xuICAgICAgICB2YXIgb2xkUm93ID0gdGhpcy5wb3B1cC5nZXRSb3coKTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VsZWN0ZWRJdGVtID0gdGhpcy5wb3B1cC5kYXRhW29sZFJvd107XG4gICAgICAgIHRoaXMucG9wdXAuc2V0RGF0YSh0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLCB0aGlzLmNvbXBsZXRpb25zLmZpbHRlclRleHQpO1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IudGV4dElucHV0LnNldEFyaWFPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci50ZXh0SW5wdXQuc2V0QXJpYU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZURlc2NlbmRhbnQ6IGdldEFyaWFJZCh0aGlzLnBvcHVwLmdldFJvdygpKSxcbiAgICAgICAgICAgICAgICBpbmxpbmU6IHRoaXMuaW5saW5lRW5hYmxlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKHRoaXMua2V5Ym9hcmRIYW5kbGVyKTtcbiAgICAgICAgdmFyIG5ld1JvdztcbiAgICAgICAgaWYgKHRoaXMuc3RpY2t5U2VsZWN0aW9uKVxuICAgICAgICAgICAgbmV3Um93ID0gdGhpcy5wb3B1cC5kYXRhLmluZGV4T2YocHJldmlvdXNTZWxlY3RlZEl0ZW0pO1xuICAgICAgICBpZiAoIW5ld1JvdyB8fCBuZXdSb3cgPT09IC0xKVxuICAgICAgICAgICAgbmV3Um93ID0gMDtcbiAgICAgICAgdGhpcy5wb3B1cC5zZXRSb3codGhpcy5hdXRvU2VsZWN0ID8gbmV3Um93IDogLTEpO1xuICAgICAgICBpZiAobmV3Um93ID09PSBvbGRSb3cgJiYgcHJldmlvdXNTZWxlY3RlZEl0ZW0gIT09IHRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWRbbmV3Um93XSlcbiAgICAgICAgICAgIHRoaXMuJG9uUG9wdXBDaGFuZ2UoKTtcbiAgICAgICAgdmFyIGlubGluZUVuYWJsZWQgPSB0aGlzLmlubGluZVJlbmRlcmVyICYmIHRoaXMuaW5saW5lRW5hYmxlZDtcbiAgICAgICAgaWYgKG5ld1JvdyA9PT0gb2xkUm93ICYmIGlubGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0aW9uID0gdGhpcy5wb3B1cC5nZXREYXRhKHRoaXMucG9wdXAuZ2V0Um93KCkpO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlR2hvc3RUZXh0KGNvbXBsZXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcFBvcHVwUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2V0VGhlbWUoZWRpdG9yLmdldFRoZW1lKCkpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zZXRGb250U2l6ZShlZGl0b3IuZ2V0Rm9udFNpemUoKSk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sdGlwTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRG9jVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlVGltZXIuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUxheW91dENoYW5nZXMoKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKHRoaXMua2V5Ym9hcmRIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLmNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZihcImJsdXJcIiwgdGhpcy5ibHVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwibW91c2V3aGVlbFwiLCB0aGlzLm1vdXNld2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZmlyc3RPcGVuVGltZXIuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlVGltZXIuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuaGlkZURvY1Rvb2x0aXAoKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGlvblByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm92aWRlci5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLmlzT3BlbilcbiAgICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICBpZiAodGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnJlbmRlcmVyLm9mZihcImFmdGVyUmVuZGVyXCIsIHRoaXMuJG9uUG9wdXBSZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2UuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGxldGlvblByb3ZpZGVyID0gdGhpcy5jb21wbGV0aW9ucyA9IHRoaXMuYmFzZSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5PYnNlcnZlTGF5b3V0Q2hhbmdlcygpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmVkaXRvci5zZWxlY3Rpb24ubGVhZDtcbiAgICAgICAgaWYgKGN1cnNvci5yb3cgIT0gdGhpcy5iYXNlLnJvdyB8fCBjdXJzb3IuY29sdW1uIDwgdGhpcy5iYXNlLmNvbHVtbikge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQpXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVRpbWVyLnNjaGVkdWxlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLmJsdXJMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5lZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKTtcbiAgICAgICAgdmFyIGZyb21Ub29sdGlwID0gZS5yZWxhdGVkVGFyZ2V0ICYmIHRoaXMudG9vbHRpcE5vZGUgJiYgdGhpcy50b29sdGlwTm9kZS5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGVsICE9IHRleHQgJiYgZWwucGFyZW50Tm9kZSAhPSBjb250YWluZXIgJiYgIWZyb21Ub29sdGlwXG4gICAgICAgICAgICAmJiBlbCAhPSB0aGlzLnRvb2x0aXBOb2RlICYmIGUucmVsYXRlZFRhcmdldCAhPSB0ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLm1vdXNlZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUubW91c2V3aGVlbExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgJiYgIXRoaXMucG9wdXAuaXNNb3VzZU92ZXIpXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5tb3VzZU91dExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaXNPcGVuKVxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlUG9wdXBQb3NpdGlvbigpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24gKHdoZXJlKSB7XG4gICAgICAgIHRoaXMucG9wdXAuZ29Ubyh3aGVyZSk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLmluc2VydE1hdGNoID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucG9wdXAuZ2V0RGF0YSh0aGlzLnBvcHVwLmdldFJvdygpKTtcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGF0YS52YWx1ZSA9PT0gXCJcIikgLy8gRXhwbGljaXRseSBnaXZlbiBub3RoaW5nIHRvIGluc2VydCwgZS5nLiBcIk5vIHN1Z2dlc3Rpb24gc3RhdGVcIlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIHZhciBjb21wbGV0aW9ucyA9IHRoaXMuY29tcGxldGlvbnM7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldENvbXBsZXRpb25Qcm92aWRlcigpLmluc2VydE1hdGNoKHRoaXMuZWRpdG9yLCBkYXRhLCBjb21wbGV0aW9ucy5maWx0ZXJUZXh0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGlvbnMgPT0gY29tcGxldGlvbnMpXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5zaG93UG9wdXAgPSBmdW5jdGlvbiAoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcilcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGlmIChlZGl0b3IuY29tcGxldGVyICE9IHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuY29tcGxldGVyKVxuICAgICAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIuZGV0YWNoKCk7XG4gICAgICAgICAgICBlZGl0b3IuY29tcGxldGVyID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgdGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIGVkaXRvci5vbihcImJsdXJcIiwgdGhpcy5ibHVyTGlzdGVuZXIpO1xuICAgICAgICBlZGl0b3Iub24oXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNld2hlZWxcIiwgdGhpcy5tb3VzZXdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbXBsZXRpb25zKGZhbHNlLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuZ2V0Q29tcGxldGlvblByb3ZpZGVyID0gZnVuY3Rpb24gKGluaXRpYWxQb3NpdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGxldGlvblByb3ZpZGVyKVxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uUHJvdmlkZXIgPSBuZXcgQ29tcGxldGlvblByb3ZpZGVyKGluaXRpYWxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRpb25Qcm92aWRlcjtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuZ2F0aGVyQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZWRpdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV0aW9uUHJvdmlkZXIoKS5nYXRoZXJDb21wbGV0aW9ucyhlZGl0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUudXBkYXRlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoa2VlcFBvcHVwUG9zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtlZXBQb3B1cFBvc2l0aW9uICYmIHRoaXMuYmFzZSAmJiB0aGlzLmNvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmVkaXRvci5zZXNzaW9uLmdldFRleHRSYW5nZSh7IHN0YXJ0OiB0aGlzLmJhc2UsIGVuZDogcG9zIH0pO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PSB0aGlzLmNvbXBsZXRpb25zLmZpbHRlclRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucy5zZXRGaWx0ZXIocHJlZml4KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9ucy5maWx0ZXJlZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wbGV0aW9ucy5maWx0ZXJlZC5sZW5ndGggPT0gMVxuICAgICAgICAgICAgICAgICYmIHRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWRbMF0udmFsdWUgPT0gcHJlZml4XG4gICAgICAgICAgICAgICAgJiYgIXRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWRbMF0uc25pcHBldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKHRoaXMuZWRpdG9yLCBwcmVmaXgsIGtlZXBQb3B1cFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbi5kb2MuY3JlYXRlQW5jaG9yKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgdGhpcy5iYXNlLiRpbnNlcnRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25zID0gbmV3IEZpbHRlcmVkTGlzdChvcHRpb25zLm1hdGNoZXMpO1xuICAgICAgICAgICAgdGhpcy5nZXRDb21wbGV0aW9uUHJvdmlkZXIoKS5jb21wbGV0aW9ucyA9IHRoaXMuY29tcGxldGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuUG9wdXAodGhpcy5lZGl0b3IsIFwiXCIsIGtlZXBQb3B1cFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBwcmVmaXggPSB1dGlsLmdldENvbXBsZXRpb25QcmVmaXgodGhpcy5lZGl0b3IpO1xuICAgICAgICB0aGlzLmJhc2UgPSBzZXNzaW9uLmRvYy5jcmVhdGVBbmNob3IocG9zLnJvdywgcG9zLmNvbHVtbiAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICB0aGlzLmJhc2UuJGluc2VydFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNvbXBsZXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgZXhhY3RNYXRjaDogdGhpcy5leGFjdE1hdGNoLFxuICAgICAgICAgICAgaWdub3JlQ2FwdGlvbjogdGhpcy5pZ25vcmVDYXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29tcGxldGlvblByb3ZpZGVyKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgcG9zOiBwb3NcbiAgICAgICAgfSkucHJvdmlkZUNvbXBsZXRpb25zKHRoaXMuZWRpdG9yLCBjb21wbGV0aW9uT3B0aW9ucywgXG4gICAgICAgIGZ1bmN0aW9uIChlcnIsIGNvbXBsZXRpb25zLCBmaW5pc2hlZCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gY29tcGxldGlvbnMuZmlsdGVyZWQ7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gdXRpbC5nZXRDb21wbGV0aW9uUHJlZml4KHRoaXMuZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuJGZpcnN0T3BlblRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5TWVzc2FnZSA9ICF0aGlzLmF1dG9TaG93biAmJiB0aGlzLmVtcHR5TWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbXB0eU1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHlNZXNzYWdlID0gdGhpcy5lbXB0eU1lc3NhZ2UocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRpb25zRm9yRW1wdHkgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiBlbXB0eU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSBuZXcgRmlsdGVyZWRMaXN0KGNvbXBsZXRpb25zRm9yRW1wdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAodGhpcy5lZGl0b3IsIHByZWZpeCwga2VlcFBvcHVwUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cC5yZW5kZXJlci5zZXRTdHlsZShcImFjZV9sb2FkaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXAucmVuZGVyZXIuc2V0U3R5bGUoXCJhY2VfZW1wdHktbWVzc2FnZVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PSAxICYmIGZpbHRlcmVkWzBdLnZhbHVlID09IHByZWZpeFxuICAgICAgICAgICAgICAgICAgICAmJiAhZmlsdGVyZWRbMF0uc25pcHBldClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0luc2VydCAmJiAhdGhpcy5hdXRvU2hvd24gJiYgZmlsdGVyZWQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydE1hdGNoKGZpbHRlcmVkWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSAhZmluaXNoZWQgJiYgdGhpcy5zaG93TG9hZGluZ1N0YXRlID9cbiAgICAgICAgICAgICAgICBuZXcgRmlsdGVyZWRMaXN0KEF1dG9jb21wbGV0ZS5jb21wbGV0aW9uc0ZvckxvYWRpbmcuY29uY2F0KGZpbHRlcmVkKSwgY29tcGxldGlvbnMuZmlsdGVyVGV4dCkgOlxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zO1xuICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAodGhpcy5lZGl0b3IsIHByZWZpeCwga2VlcFBvcHVwUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5yZW5kZXJlci5zZXRTdHlsZShcImFjZV9lbXB0eS1tZXNzYWdlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAucmVuZGVyZXIuc2V0U3R5bGUoXCJhY2VfbG9hZGluZ1wiLCAhZmluaXNoZWQpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5zaG93TG9hZGluZ1N0YXRlICYmICF0aGlzLmF1dG9TaG93biAmJiAhKHRoaXMucG9wdXAgJiYgdGhpcy5wb3B1cC5pc09wZW4pKSB7XG4gICAgICAgICAgICB0aGlzLiRmaXJzdE9wZW5UaW1lci5kZWxheSh0aGlzLnN0aWNreVNlbGVjdGlvbkRlbGF5IC8gMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY2FuY2VsQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLiRtb3VzZUhhbmRsZXIuY2FuY2VsQ29udGV4dE1lbnUoKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUudXBkYXRlRG9jVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcHVwID0gdGhpcy5wb3B1cDtcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWQ7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGFsbCAmJiAoYWxsW3BvcHVwLmdldEhvdmVyZWRSb3coKV0gfHwgYWxsW3BvcHVwLmdldFJvdygpXSk7XG4gICAgICAgIHZhciBkb2MgPSBudWxsO1xuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8ICF0aGlzLmVkaXRvciB8fCAhdGhpcy5wb3B1cC5pc09wZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlRG9jVG9vbHRpcCgpO1xuICAgICAgICB2YXIgY29tcGxldGVyc0xlbmd0aCA9IHRoaXMuZWRpdG9yLmNvbXBsZXRlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBsZXRlcnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlciA9IHRoaXMuZWRpdG9yLmNvbXBsZXRlcnNbaV07XG4gICAgICAgICAgICBpZiAoY29tcGxldGVyLmdldERvY1Rvb2x0aXAgJiYgc2VsZWN0ZWQuY29tcGxldGVySWQgPT09IGNvbXBsZXRlci5pZCkge1xuICAgICAgICAgICAgICAgIGRvYyA9IGNvbXBsZXRlci5nZXREb2NUb29sdGlwKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvYyAmJiB0eXBlb2Ygc2VsZWN0ZWQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGRvYyA9IHNlbGVjdGVkO1xuICAgICAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZG9jID0geyBkb2NUZXh0OiBkb2MgfTtcbiAgICAgICAgaWYgKCFkb2MgfHwgIShkb2MuZG9jSFRNTCB8fCBkb2MuZG9jVGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlRG9jVG9vbHRpcCgpO1xuICAgICAgICB0aGlzLnNob3dEb2NUb29sdGlwKGRvYyk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLnNob3dEb2NUb29sdGlwID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLnN0eWxlLm1hcmdpbiA9IFwiMFwiO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLnN0eWxlLm92ZXJzY3JvbGxCZWhhdmlvciA9IFwiY29udGFpblwiO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5vbmJsdXIgPSB0aGlzLmJsdXJMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5vbmNsaWNrID0gdGhpcy5vblRvb2x0aXBDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5pZCA9IFwiZG9jLXRvb2x0aXBcIjtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcE5vZGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBwcmV2ZW50UGFyZW50U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLmVkaXRvci5yZW5kZXJlci50aGVtZTtcbiAgICAgICAgdGhpcy50b29sdGlwTm9kZS5jbGFzc05hbWUgPSBcImFjZV90b29sdGlwIGFjZV9kb2MtdG9vbHRpcCBcIiArXG4gICAgICAgICAgICAodGhlbWUuaXNEYXJrID8gXCJhY2VfZGFyayBcIiA6IFwiXCIpICsgKHRoZW1lLmNzc0NsYXNzIHx8IFwiXCIpO1xuICAgICAgICB2YXIgdG9vbHRpcE5vZGUgPSB0aGlzLnRvb2x0aXBOb2RlO1xuICAgICAgICBpZiAoaXRlbS5kb2NIVE1MKSB7XG4gICAgICAgICAgICB0b29sdGlwTm9kZS5pbm5lckhUTUwgPSBpdGVtLmRvY0hUTUw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbS5kb2NUZXh0KSB7XG4gICAgICAgICAgICB0b29sdGlwTm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uZG9jVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvb2x0aXBOb2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0aGlzLnBvcHVwLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBOb2RlKTtcbiAgICAgICAgdmFyIHBvcHVwID0gdGhpcy5wb3B1cDtcbiAgICAgICAgdmFyIHJlY3QgPSBwb3B1cC5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLnRvcCA9IHBvcHVwLmNvbnRhaW5lci5zdHlsZS50b3A7XG4gICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmJvdHRvbSA9IHBvcHVwLmNvbnRhaW5lci5zdHlsZS5ib3R0b207XG4gICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAtIHJlY3QucmlnaHQgPCAzMjApIHtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCAzMjApIHtcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAuaXNUb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLnRvcCA9IHJlY3QuYm90dG9tICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS50b3AgPSBwb3B1cC5jb250YWluZXIub2Zmc2V0VG9wIC0gdG9vbHRpcE5vZGUub2Zmc2V0SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUucmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmxlZnQgPSAocmVjdC5yaWdodCArIDEpICsgXCJweFwiO1xuICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLmhpZGVEb2NUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBOb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLnRvb2x0aXBOb2RlO1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmlzRm9jdXNlZCgpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gZWwpXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xuICAgICAgICB0aGlzLnRvb2x0aXBOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUub25Ub29sdGlwQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYSA9IGUudGFyZ2V0O1xuICAgICAgICB3aGlsZSAoYSAmJiBhICE9IHRoaXMudG9vbHRpcE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChhLm5vZGVOYW1lID09IFwiQVwiICYmIGEuaHJlZikge1xuICAgICAgICAgICAgICAgIGEucmVsID0gXCJub3JlZmVycmVyXCI7XG4gICAgICAgICAgICAgICAgYS50YXJnZXQgPSBcIl9ibGFua1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICBpZiAodGhpcy5wb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5kZXN0cm95KCk7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnBvcHVwLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5jb21wbGV0ZXIgPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwiZGVzdHJveVwiLCBkZXN0cm95Q29tcGxldGVyKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbXBsZXRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmxpbmVSZW5kZXJlciA9IHRoaXMucG9wdXAgPSB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUuZm9yID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBpZiAoZWRpdG9yLmNvbXBsZXRlciBpbnN0YW5jZW9mIEF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5jb21wbGV0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvci5jb21wbGV0ZXIpIHtcbiAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgZWRpdG9yLmNvbXBsZXRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5nZXQoXCJzaGFyZWRQb3B1cHNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXV0b2NvbXBsZXRlW1wiJHNoYXJlZEluc3RhbmNlXCJdKVxuICAgICAgICAgICAgICAgIEF1dG9jb21wbGV0ZVtcIiRzaGFyZWRJbnN0YW5jZVwiXSA9IG5ldyBBdXRvY29tcGxldGUoKTtcbiAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIgPSBBdXRvY29tcGxldGVbXCIkc2hhcmVkSW5zdGFuY2VcIl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuY29tcGxldGVyID0gbmV3IEF1dG9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgZWRpdG9yLm9uY2UoXCJkZXN0cm95XCIsIGRlc3Ryb3lDb21wbGV0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuY29tcGxldGVyO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZTtcbn0oKSk7XG5BdXRvY29tcGxldGUucHJvdG90eXBlLmNvbW1hbmRzID0ge1xuICAgIFwiVXBcIjogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29tcGxldGVyLmdvVG8oXCJ1cFwiKTsgfSxcbiAgICBcIkRvd25cIjogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29tcGxldGVyLmdvVG8oXCJkb3duXCIpOyB9LFxuICAgIFwiQ3RybC1VcHxDdHJsLUhvbWVcIjogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29tcGxldGVyLmdvVG8oXCJzdGFydFwiKTsgfSxcbiAgICBcIkN0cmwtRG93bnxDdHJsLUVuZFwiOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuZ29UbyhcImVuZFwiKTsgfSxcbiAgICBcIkVzY1wiOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuZGV0YWNoKCk7IH0sXG4gICAgXCJSZXR1cm5cIjogZnVuY3Rpb24gKGVkaXRvcikgeyByZXR1cm4gZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaCgpOyB9LFxuICAgIFwiU2hpZnQtUmV0dXJuXCI6IGZ1bmN0aW9uIChlZGl0b3IpIHsgZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaChudWxsLCB7IGRlbGV0ZVN1ZmZpeDogdHJ1ZSB9KTsgfSxcbiAgICBcIlRhYlwiOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoKCk7XG4gICAgICAgIGlmICghcmVzdWx0ICYmICFlZGl0b3IudGFic3RvcE1hbmFnZXIpXG4gICAgICAgICAgICBlZGl0b3IuY29tcGxldGVyLmdvVG8oXCJkb3duXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgXCJCYWNrc3BhY2VcIjogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoXCJiYWNrc3BhY2VcIik7XG4gICAgICAgIHZhciBwcmVmaXggPSB1dGlsLmdldENvbXBsZXRpb25QcmVmaXgoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFwcmVmaXggJiYgZWRpdG9yLmNvbXBsZXRlcilcbiAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIuZGV0YWNoKCk7XG4gICAgfSxcbiAgICBcIlBhZ2VVcFwiOiBmdW5jdGlvbiAoZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIucG9wdXAuZ290b1BhZ2VVcCgpOyB9LFxuICAgIFwiUGFnZURvd25cIjogZnVuY3Rpb24gKGVkaXRvcikgeyBlZGl0b3IuY29tcGxldGVyLnBvcHVwLmdvdG9QYWdlRG93bigpOyB9XG59O1xuQXV0b2NvbXBsZXRlLnN0YXJ0Q29tbWFuZCA9IHtcbiAgICBuYW1lOiBcInN0YXJ0QXV0b2NvbXBsZXRlXCIsXG4gICAgZXhlYzogZnVuY3Rpb24gKGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcGxldGVyID0gQXV0b2NvbXBsZXRlLmZvcihlZGl0b3IpO1xuICAgICAgICBjb21wbGV0ZXIuYXV0b0luc2VydCA9IGZhbHNlO1xuICAgICAgICBjb21wbGV0ZXIuYXV0b1NlbGVjdCA9IHRydWU7XG4gICAgICAgIGNvbXBsZXRlci5hdXRvU2hvd24gPSBmYWxzZTtcbiAgICAgICAgY29tcGxldGVyLnNob3dQb3B1cChlZGl0b3IsIG9wdGlvbnMpO1xuICAgICAgICBjb21wbGV0ZXIuY2FuY2VsQ29udGV4dE1lbnUoKTtcbiAgICB9LFxuICAgIGJpbmRLZXk6IFwiQ3RybC1TcGFjZXxDdHJsLVNoaWZ0LVNwYWNlfEFsdC1TcGFjZVwiXG59O1xudmFyIENvbXBsZXRpb25Qcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wbGV0aW9uUHJvdmlkZXIoaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIENvbXBsZXRpb25Qcm92aWRlci5wcm90b3R5cGUuaW5zZXJ0QnlJbmRleCA9IGZ1bmN0aW9uIChlZGl0b3IsIGluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9ucyB8fCAhdGhpcy5jb21wbGV0aW9ucy5maWx0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydE1hdGNoKGVkaXRvciwgdGhpcy5jb21wbGV0aW9ucy5maWx0ZXJlZFtpbmRleF0sIG9wdGlvbnMpO1xuICAgIH07XG4gICAgQ29tcGxldGlvblByb3ZpZGVyLnByb3RvdHlwZS5pbnNlcnRNYXRjaCA9IGZ1bmN0aW9uIChlZGl0b3IsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlZGl0b3Iuc3RhcnRPcGVyYXRpb24oeyBjb21tYW5kOiB7IG5hbWU6IFwiaW5zZXJ0TWF0Y2hcIiB9IH0pO1xuICAgICAgICBpZiAoZGF0YS5jb21wbGV0ZXIgJiYgZGF0YS5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2gpIHtcbiAgICAgICAgICAgIGRhdGEuY29tcGxldGVyLmluc2VydE1hdGNoKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCZWZvcmUgPSB0aGlzLmNvbXBsZXRpb25zLmZpbHRlclRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VBZnRlciA9IDA7XG4gICAgICAgICAgICBpZiAoZGF0YS5yYW5nZSAmJiBkYXRhLnJhbmdlLnN0YXJ0LnJvdyA9PT0gZGF0YS5yYW5nZS5lbmQucm93KSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUJlZm9yZSAtPSB0aGlzLmluaXRpYWxQb3NpdGlvbi5wcmVmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VCZWZvcmUgKz0gdGhpcy5pbml0aWFsUG9zaXRpb24ucG9zLmNvbHVtbiAtIGRhdGEucmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VBZnRlciArPSBkYXRhLnJhbmdlLmVuZC5jb2x1bW4gLSB0aGlzLmluaXRpYWxQb3NpdGlvbi5wb3MuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcGxhY2VCZWZvcmUgfHwgcmVwbGFjZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlcztcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5nZXRBbGxSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IFtlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByYW5nZTsgcmFuZ2UgPSByYW5nZXNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gLT0gcmVwbGFjZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiArPSByZXBsYWNlQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc25pcHBldCkge1xuICAgICAgICAgICAgICAgIHNuaXBwZXRNYW5hZ2VyLmluc2VydFNuaXBwZXQoZWRpdG9yLCBkYXRhLnNuaXBwZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5zZXJ0U3RyaW5nKGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5jb21wbGV0ZXIgJiYgZGF0YS5jb21wbGV0ZXIub25JbnNlcnQgJiYgdHlwZW9mIGRhdGEuY29tcGxldGVyLm9uSW5zZXJ0ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRhdGEuY29tcGxldGVyLm9uSW5zZXJ0KGVkaXRvciwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5jb21tYW5kICYmIGRhdGEuY29tbWFuZCA9PT0gXCJzdGFydEF1dG9jb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKGRhdGEuY29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmVuZE9wZXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvbXBsZXRpb25Qcm92aWRlci5wcm90b3R5cGUuJGluc2VydFN0cmluZyA9IGZ1bmN0aW9uIChlZGl0b3IsIGRhdGEpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRhLnZhbHVlIHx8IGRhdGE7XG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChcImluc2VydHN0cmluZ1wiLCB0ZXh0KTtcbiAgICB9O1xuICAgIENvbXBsZXRpb25Qcm92aWRlci5wcm90b3R5cGUuZ2F0aGVyQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZWRpdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5nZXRTZXNzaW9uKCk7XG4gICAgICAgIHZhciBwb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IHV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBsZXRlcnMgPSBlZGl0b3IuY29tcGxldGVycztcbiAgICAgICAgdmFyIHRvdGFsID0gZWRpdG9yLmNvbXBsZXRlcnMubGVuZ3RoO1xuICAgICAgICBlZGl0b3IuY29tcGxldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wbGV0ZXIsIGkpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlci5nZXRDb21wbGV0aW9ucyhlZGl0b3IsIHNlc3Npb24sIHBvcywgcHJlZml4LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlci5oaWRlSW5saW5lUHJldmlldylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBoaWRlSW5saW5lUHJldmlldzogY29tcGxldGVyLmhpZGVJbmxpbmVQcmV2aWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiByZXN1bHRzKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5jb25jYXQocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZDogKC0tdG90YWwgPT09IDApXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ29tcGxldGlvblByb3ZpZGVyLnByb3RvdHlwZS5wcm92aWRlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZWRpdG9yLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcHJvY2Vzc1Jlc3VsdHMgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHJlc3VsdHMucHJlZml4O1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSByZXN1bHRzLm1hdGNoZXM7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25zID0gbmV3IEZpbHRlcmVkTGlzdChtYXRjaGVzKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4YWN0TWF0Y2gpXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucy5leGFjdE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUNhcHRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucy5pZ25vcmVDYXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbnMuc2V0RmlsdGVyKHByZWZpeCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5maW5pc2hlZCB8fCB0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0aGlzLmNvbXBsZXRpb25zLCByZXN1bHRzLmZpbmlzaGVkKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgaXNJbW1lZGlhdGUgPSB0cnVlO1xuICAgICAgICB2YXIgaW1tZWRpYXRlUmVzdWx0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2F0aGVyQ29tcGxldGlvbnMoZWRpdG9yLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgW10sIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gcmVzdWx0cy5wcmVmaXg7XG4gICAgICAgICAgICBpZiAocHJlZml4LmluZGV4T2YocmVzdWx0cy5wcmVmaXgpICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpc0ltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZVJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBpc0ltbWVkaWF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaW1tZWRpYXRlUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBpbW1lZGlhdGVSZXN1bHRzO1xuICAgICAgICAgICAgaW1tZWRpYXRlUmVzdWx0cyA9IG51bGw7XG4gICAgICAgICAgICBwcm9jZXNzUmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGxldGlvblByb3ZpZGVyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGxldGVycyAmJiB0aGlzLmNvbXBsZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGxldGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBsZXRlci5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGxldGlvblByb3ZpZGVyO1xufSgpKTtcbnZhciBGaWx0ZXJlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyZWRMaXN0KGFycmF5LCBmaWx0ZXJUZXh0KSB7XG4gICAgICAgIHRoaXMuYWxsID0gYXJyYXk7XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSBhcnJheTtcbiAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gZmlsdGVyVGV4dCB8fCBcIlwiO1xuICAgICAgICB0aGlzLmV4YWN0TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZ25vcmVDYXB0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIEZpbHRlcmVkTGlzdC5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IHRoaXMuZmlsdGVyVGV4dCAmJiBzdHIubGFzdEluZGV4T2YodGhpcy5maWx0ZXJUZXh0LCAwKSA9PT0gMClcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5maWx0ZXJlZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLmFsbDtcbiAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gc3RyO1xuICAgICAgICBtYXRjaGVzID0gdGhpcy5maWx0ZXJDb21wbGV0aW9ucyhtYXRjaGVzLCB0aGlzLmZpbHRlclRleHQpO1xuICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5leGFjdE1hdGNoIC0gYS5leGFjdE1hdGNoIHx8IGIuJHNjb3JlIC0gYS4kc2NvcmVcbiAgICAgICAgICAgICAgICB8fCAoYS5jYXB0aW9uIHx8IGEudmFsdWUpLmxvY2FsZUNvbXBhcmUoYi5jYXB0aW9uIHx8IGIudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByZXYgPSBudWxsO1xuICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBjYXB0aW9uID0gaXRlbS5zbmlwcGV0IHx8IGl0ZW0uY2FwdGlvbiB8fCBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGNhcHRpb24gPT09IHByZXYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcHJldiA9IGNhcHRpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSBtYXRjaGVzO1xuICAgIH07XG4gICAgRmlsdGVyZWRMaXN0LnByb3RvdHlwZS5maWx0ZXJDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChpdGVtcywgbmVlZGxlKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciB1cHBlciA9IG5lZWRsZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgbG93ZXIgPSBuZWVkbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IDAsIGl0ZW07IGl0ZW0gPSBpdGVtc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5za2lwRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbS4kc2NvcmUgPSBpdGVtLnNjb3JlO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYXB0aW9uID0gKCF0aGlzLmlnbm9yZUNhcHRpb24gJiYgaXRlbS5jYXB0aW9uKSB8fCBpdGVtLnZhbHVlIHx8IGl0ZW0uc25pcHBldDtcbiAgICAgICAgICAgIGlmICghY2FwdGlvbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBtYXRjaE1hc2sgPSAwO1xuICAgICAgICAgICAgdmFyIHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgdmFyIGluZGV4LCBkaXN0YW5jZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZGxlICE9PSBjYXB0aW9uLnN1YnN0cigwLCBuZWVkbGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmdWxsTWF0Y2hJbmRleCA9IGNhcHRpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKGxvd2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbE1hdGNoSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5hbHR5ID0gZnVsbE1hdGNoSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lZWRsZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkxID0gY2FwdGlvbi5pbmRleE9mKGxvd2VyW2pdLCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpMiA9IGNhcHRpb24uaW5kZXhPZih1cHBlcltqXSwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IChpMSA+PSAwKSA/ICgoaTIgPCAwIHx8IGkxIDwgaTIpID8gaTEgOiBpMikgOiBpMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gaW5kZXggLSBsYXN0SW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5ICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hNYXNrID0gbWF0Y2hNYXNrIHwgKDEgPDwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubWF0Y2hNYXNrID0gbWF0Y2hNYXNrO1xuICAgICAgICAgICAgaXRlbS5leGFjdE1hdGNoID0gcGVuYWx0eSA/IDAgOiAxO1xuICAgICAgICAgICAgaXRlbS4kc2NvcmUgPSAoaXRlbS5zY29yZSB8fCAwKSAtIHBlbmFsdHk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuQXV0b2NvbXBsZXRlID0gQXV0b2NvbXBsZXRlO1xuZXhwb3J0cy5Db21wbGV0aW9uUHJvdmlkZXIgPSBDb21wbGV0aW9uUHJvdmlkZXI7XG5leHBvcnRzLkZpbHRlcmVkTGlzdCA9IEZpbHRlcmVkTGlzdDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXV0b2NvbXBsZXRlL3RleHRfY29tcGxldGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7dmFyIFJhbmdlID0gcmVxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIHNwbGl0UmVnZXggPSAvW15hLXpBLVpfMC05XFwkXFwtXFx1MDBDMC1cXHUxRkZGXFx1MkMwMC1cXHVEN0ZGXFx3XSsvO1xuZnVuY3Rpb24gZ2V0V29yZEluZGV4KGRvYywgcG9zKSB7XG4gICAgdmFyIHRleHRCZWZvcmUgPSBkb2MuZ2V0VGV4dFJhbmdlKFJhbmdlLmZyb21Qb2ludHMoe1xuICAgICAgICByb3c6IDAsXG4gICAgICAgIGNvbHVtbjogMFxuICAgIH0sIHBvcykpO1xuICAgIHJldHVybiB0ZXh0QmVmb3JlLnNwbGl0KHNwbGl0UmVnZXgpLmxlbmd0aCAtIDE7XG59XG5mdW5jdGlvbiB3b3JkRGlzdGFuY2UoZG9jLCBwb3MpIHtcbiAgICB2YXIgcHJlZml4UG9zID0gZ2V0V29yZEluZGV4KGRvYywgcG9zKTtcbiAgICB2YXIgd29yZHMgPSBkb2MuZ2V0VmFsdWUoKS5zcGxpdChzcGxpdFJlZ2V4KTtcbiAgICB2YXIgd29yZFNjb3JlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGN1cnJlbnRXb3JkID0gd29yZHNbcHJlZml4UG9zXTtcbiAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkLCBpZHgpIHtcbiAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQgPT09IGN1cnJlbnRXb3JkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhwcmVmaXhQb3MgLSBpZHgpO1xuICAgICAgICB2YXIgc2NvcmUgPSB3b3Jkcy5sZW5ndGggLSBkaXN0YW5jZTtcbiAgICAgICAgaWYgKHdvcmRTY29yZXNbd29yZF0pIHtcbiAgICAgICAgICAgIHdvcmRTY29yZXNbd29yZF0gPSBNYXRoLm1heChzY29yZSwgd29yZFNjb3Jlc1t3b3JkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3b3JkU2NvcmVzW3dvcmRdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gd29yZFNjb3Jlcztcbn1cbmV4cG9ydHMuZ2V0Q29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZWRpdG9yLCBzZXNzaW9uLCBwb3MsIHByZWZpeCwgY2FsbGJhY2spIHtcbiAgICB2YXIgd29yZFNjb3JlID0gd29yZERpc3RhbmNlKHNlc3Npb24sIHBvcyk7XG4gICAgdmFyIHdvcmRMaXN0ID0gT2JqZWN0LmtleXMod29yZFNjb3JlKTtcbiAgICBjYWxsYmFjayhudWxsLCB3b3JkTGlzdC5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhcHRpb246IHdvcmQsXG4gICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgIHNjb3JlOiB3b3JkU2NvcmVbd29yZF0sXG4gICAgICAgICAgICBtZXRhOiBcImxvY2FsXCJcbiAgICAgICAgfTtcbiAgICB9KSk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9leHQvbGFuZ3VhZ2VfdG9vbHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9zbmlwcGV0c1wiLFwiYWNlL2F1dG9jb21wbGV0ZVwiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIixcImFjZS9hdXRvY29tcGxldGUvdGV4dF9jb21wbGV0ZXJcIixcImFjZS9lZGl0b3JcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XCJ1c2Ugc3RyaWN0XCI7XG52YXIgc25pcHBldE1hbmFnZXIgPSByZXF1aXJlKFwiLi4vc25pcHBldHNcIikuc25pcHBldE1hbmFnZXI7XG52YXIgQXV0b2NvbXBsZXRlID0gcmVxdWlyZShcIi4uL2F1dG9jb21wbGV0ZVwiKS5BdXRvY29tcGxldGU7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vYXV0b2NvbXBsZXRlL3V0aWxcIik7XG52YXIgdGV4dENvbXBsZXRlciA9IHJlcXVpcmUoXCIuLi9hdXRvY29tcGxldGUvdGV4dF9jb21wbGV0ZXJcIik7XG52YXIga2V5V29yZENvbXBsZXRlciA9IHtcbiAgICBnZXRDb21wbGV0aW9uczogZnVuY3Rpb24gKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChzZXNzaW9uLiRtb2RlLmNvbXBsZXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uJG1vZGUuY29tcGxldGVyLmdldENvbXBsZXRpb25zKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRTdGF0ZShwb3Mucm93KTtcbiAgICAgICAgdmFyIGNvbXBsZXRpb25zID0gc2Vzc2lvbi4kbW9kZS5nZXRDb21wbGV0aW9ucyhzdGF0ZSwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgpO1xuICAgICAgICBjb21wbGV0aW9ucyA9IGNvbXBsZXRpb25zLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLmNvbXBsZXRlcklkID0ga2V5V29yZENvbXBsZXRlci5pZDtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbXBsZXRpb25zKTtcbiAgICB9LFxuICAgIGlkOiBcImtleXdvcmRDb21wbGV0ZXJcIlxufTtcbnZhciB0cmFuc2Zvcm1TbmlwcGV0VG9vbHRpcCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgcmVjb3JkID0ge307XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXCR7KFxcZCspKDooLio/KSk/fS9nLCBmdW5jdGlvbiAoXywgcDEsIHAyLCBwMykge1xuICAgICAgICByZXR1cm4gKHJlY29yZFtwMV0gPSBwMyB8fCAnJyk7XG4gICAgfSkucmVwbGFjZSgvXFwkKFxcZCs/KS9nLCBmdW5jdGlvbiAoXywgcDEpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZFtwMV07XG4gICAgfSk7XG59O1xudmFyIHNuaXBwZXRDb21wbGV0ZXIgPSB7XG4gICAgZ2V0Q29tcGxldGlvbnM6IGZ1bmN0aW9uIChlZGl0b3IsIHNlc3Npb24sIHBvcywgcHJlZml4LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NvcGVzID0gW107XG4gICAgICAgIHZhciB0b2tlbiA9IHNlc3Npb24uZ2V0VG9rZW5BdChwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUubWF0Y2goLyh0YWctbmFtZXx0YWctb3Blbnx0YWctd2hpdGVzcGFjZXxhdHRyaWJ1dGUtbmFtZXxhdHRyaWJ1dGUtdmFsdWUpXFwueG1sJC8pKVxuICAgICAgICAgICAgc2NvcGVzLnB1c2goJ2h0bWwtdGFnJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNjb3BlcyA9IHNuaXBwZXRNYW5hZ2VyLmdldEFjdGl2ZVNjb3BlcyhlZGl0b3IpO1xuICAgICAgICB2YXIgc25pcHBldE1hcCA9IHNuaXBwZXRNYW5hZ2VyLnNuaXBwZXRNYXA7XG4gICAgICAgIHZhciBjb21wbGV0aW9ucyA9IFtdO1xuICAgICAgICBzY29wZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBzbmlwcGV0cyA9IHNuaXBwZXRNYXBbc2NvcGVdIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNuaXBwZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gc25pcHBldHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNhcHRpb24gPSBzLm5hbWUgfHwgcy50YWJUcmlnZ2VyO1xuICAgICAgICAgICAgICAgIGlmICghY2FwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQ6IHMuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogcy50YWJUcmlnZ2VyICYmICFzLm5hbWUgPyBzLnRhYlRyaWdnZXIgKyBcIlxcdTIxRTUgXCIgOiBcInNuaXBwZXRcIixcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVySWQ6IHNuaXBwZXRDb21wbGV0ZXIuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbXBsZXRpb25zKTtcbiAgICB9LFxuICAgIGdldERvY1Rvb2x0aXA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnNuaXBwZXQgJiYgIWl0ZW0uZG9jSFRNTCkge1xuICAgICAgICAgICAgaXRlbS5kb2NIVE1MID0gW1xuICAgICAgICAgICAgICAgIFwiPGI+XCIsIGxhbmcuZXNjYXBlSFRNTChpdGVtLmNhcHRpb24pLCBcIjwvYj5cIiwgXCI8aHI+PC9ocj5cIixcbiAgICAgICAgICAgICAgICBsYW5nLmVzY2FwZUhUTUwodHJhbnNmb3JtU25pcHBldFRvb2x0aXAoaXRlbS5zbmlwcGV0KSlcbiAgICAgICAgICAgIF0uam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaWQ6IFwic25pcHBldENvbXBsZXRlclwiXG59O1xudmFyIGNvbXBsZXRlcnMgPSBbc25pcHBldENvbXBsZXRlciwgdGV4dENvbXBsZXRlciwga2V5V29yZENvbXBsZXRlcl07XG5leHBvcnRzLnNldENvbXBsZXRlcnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgY29tcGxldGVycy5sZW5ndGggPSAwO1xuICAgIGlmICh2YWwpXG4gICAgICAgIGNvbXBsZXRlcnMucHVzaC5hcHBseShjb21wbGV0ZXJzLCB2YWwpO1xufTtcbmV4cG9ydHMuYWRkQ29tcGxldGVyID0gZnVuY3Rpb24gKGNvbXBsZXRlcikge1xuICAgIGNvbXBsZXRlcnMucHVzaChjb21wbGV0ZXIpO1xufTtcbmV4cG9ydHMudGV4dENvbXBsZXRlciA9IHRleHRDb21wbGV0ZXI7XG5leHBvcnRzLmtleVdvcmRDb21wbGV0ZXIgPSBrZXlXb3JkQ29tcGxldGVyO1xuZXhwb3J0cy5zbmlwcGV0Q29tcGxldGVyID0gc25pcHBldENvbXBsZXRlcjtcbnZhciBleHBhbmRTbmlwcGV0ID0ge1xuICAgIG5hbWU6IFwiZXhwYW5kU25pcHBldFwiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNuaXBwZXRNYW5hZ2VyLmV4cGFuZFdpdGhUYWIoZWRpdG9yKTtcbiAgICB9LFxuICAgIGJpbmRLZXk6IFwiVGFiXCJcbn07XG52YXIgb25DaGFuZ2VNb2RlID0gZnVuY3Rpb24gKGUsIGVkaXRvcikge1xuICAgIGxvYWRTbmlwcGV0c0Zvck1vZGUoZWRpdG9yLnNlc3Npb24uJG1vZGUpO1xufTtcbnZhciBsb2FkU25pcHBldHNGb3JNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgbW9kZSA9IGNvbmZpZy4kbW9kZXNbbW9kZV07XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzbmlwcGV0TWFuYWdlci5maWxlcylcbiAgICAgICAgc25pcHBldE1hbmFnZXIuZmlsZXMgPSB7fTtcbiAgICBsb2FkU25pcHBldEZpbGUobW9kZS4kaWQsIG1vZGUuc25pcHBldEZpbGVJZCk7XG4gICAgaWYgKG1vZGUubW9kZXMpXG4gICAgICAgIG1vZGUubW9kZXMuZm9yRWFjaChsb2FkU25pcHBldHNGb3JNb2RlKTtcbn07XG52YXIgbG9hZFNuaXBwZXRGaWxlID0gZnVuY3Rpb24gKGlkLCBzbmlwcGV0RmlsZVBhdGgpIHtcbiAgICBpZiAoIXNuaXBwZXRGaWxlUGF0aCB8fCAhaWQgfHwgc25pcHBldE1hbmFnZXIuZmlsZXNbaWRdKVxuICAgICAgICByZXR1cm47XG4gICAgc25pcHBldE1hbmFnZXIuZmlsZXNbaWRdID0ge307XG4gICAgY29uZmlnLmxvYWRNb2R1bGUoc25pcHBldEZpbGVQYXRoLCBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNuaXBwZXRNYW5hZ2VyLmZpbGVzW2lkXSA9IG07XG4gICAgICAgIGlmICghbS5zbmlwcGV0cyAmJiBtLnNuaXBwZXRUZXh0KVxuICAgICAgICAgICAgbS5zbmlwcGV0cyA9IHNuaXBwZXRNYW5hZ2VyLnBhcnNlU25pcHBldEZpbGUobS5zbmlwcGV0VGV4dCk7XG4gICAgICAgIHNuaXBwZXRNYW5hZ2VyLnJlZ2lzdGVyKG0uc25pcHBldHMgfHwgW10sIG0uc2NvcGUpO1xuICAgICAgICBpZiAobS5pbmNsdWRlU2NvcGVzKSB7XG4gICAgICAgICAgICBzbmlwcGV0TWFuYWdlci5zbmlwcGV0TWFwW20uc2NvcGVdLmluY2x1ZGVTY29wZXMgPSBtLmluY2x1ZGVTY29wZXM7XG4gICAgICAgICAgICBtLmluY2x1ZGVTY29wZXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGxvYWRTbmlwcGV0c0Zvck1vZGUoXCJhY2UvbW9kZS9cIiArIHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG52YXIgZG9MaXZlQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgdmFyIGhhc0NvbXBsZXRlciA9IGVkaXRvci5jb21wbGV0ZXIgJiYgZWRpdG9yLmNvbXBsZXRlci5hY3RpdmF0ZWQ7XG4gICAgaWYgKGUuY29tbWFuZC5uYW1lID09PSBcImJhY2tzcGFjZVwiKSB7XG4gICAgICAgIGlmIChoYXNDb21wbGV0ZXIgJiYgIXV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpKVxuICAgICAgICAgICAgZWRpdG9yLmNvbXBsZXRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5jb21tYW5kLm5hbWUgPT09IFwiaW5zZXJ0c3RyaW5nXCIgJiYgIWhhc0NvbXBsZXRlcikge1xuICAgICAgICBsYXN0RXhlY0V2ZW50ID0gZTtcbiAgICAgICAgdmFyIGRlbGF5ID0gZS5lZGl0b3IuJGxpdmVBdXRvY29tcGxldGlvbkRlbGF5O1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIGxpdmVBdXRvY29tcGxldGVUaW1lci5kZWxheShkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaG93TGl2ZUF1dG9jb21wbGV0ZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgbGFzdEV4ZWNFdmVudDtcbnZhciBsaXZlQXV0b2NvbXBsZXRlVGltZXIgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uICgpIHtcbiAgICBzaG93TGl2ZUF1dG9jb21wbGV0ZShsYXN0RXhlY0V2ZW50KTtcbn0sIDApO1xudmFyIHNob3dMaXZlQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgdmFyIHByZWZpeCA9IHV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpO1xuICAgIHZhciBwcmV2aW91c0NoYXIgPSBlLmFyZ3M7XG4gICAgdmFyIHRyaWdnZXJBdXRvY29tcGxldGUgPSB1dGlsLnRyaWdnZXJBdXRvY29tcGxldGUoZWRpdG9yLCBwcmV2aW91c0NoYXIpO1xuICAgIGlmIChwcmVmaXggJiYgcHJlZml4Lmxlbmd0aCA+PSBlZGl0b3IuJGxpdmVBdXRvY29tcGxldGlvblRocmVzaG9sZCB8fCB0cmlnZ2VyQXV0b2NvbXBsZXRlKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZXIgPSBBdXRvY29tcGxldGUuZm9yKGVkaXRvcik7XG4gICAgICAgIGNvbXBsZXRlci5hdXRvU2hvd24gPSB0cnVlO1xuICAgICAgICBjb21wbGV0ZXIuc2hvd1BvcHVwKGVkaXRvcik7XG4gICAgfVxufTtcbnZhciBFZGl0b3IgPSByZXF1aXJlKFwiLi4vZWRpdG9yXCIpLkVkaXRvcjtcbnJlcXVpcmUoXCIuLi9jb25maWdcIikuZGVmaW5lT3B0aW9ucyhFZGl0b3IucHJvdG90eXBlLCBcImVkaXRvclwiLCB7XG4gICAgZW5hYmxlQmFzaWNBdXRvY29tcGxldGlvbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZXJzID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogY29tcGxldGVycztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmFkZENvbW1hbmQoQXV0b2NvbXBsZXRlLnN0YXJ0Q29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnJlbW92ZUNvbW1hbmQoQXV0b2NvbXBsZXRlLnN0YXJ0Q29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlTGl2ZUF1dG9jb21wbGV0aW9uOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21wbGV0ZXJzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlcnMgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBjb21wbGV0ZXJzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMub24oJ2FmdGVyRXhlYycsIGRvTGl2ZUF1dG9jb21wbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLm9mZignYWZ0ZXJFeGVjJywgZG9MaXZlQXV0b2NvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBsaXZlQXV0b2NvbXBsZXRpb25EZWxheToge1xuICAgICAgICBpbml0aWFsVmFsdWU6IDBcbiAgICB9LFxuICAgIGxpdmVBdXRvY29tcGxldGlvblRocmVzaG9sZDoge1xuICAgICAgICBpbml0aWFsVmFsdWU6IDBcbiAgICB9LFxuICAgIGVuYWJsZVNuaXBwZXRzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMuYWRkQ29tbWFuZChleHBhbmRTbmlwcGV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKFwiY2hhbmdlTW9kZVwiLCBvbkNoYW5nZU1vZGUpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlTW9kZShudWxsLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlQ29tbWFuZChleHBhbmRTbmlwcGV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihcImNoYW5nZU1vZGVcIiwgb25DaGFuZ2VNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxufSk7XG5cbn0pOyAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjZS5yZXF1aXJlKFtcImFjZS9leHQvbGFuZ3VhZ2VfdG9vbHNcIl0sIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ace-builds/src-noconflict/ext-language_tools.js\n"));

/***/ })

}]);